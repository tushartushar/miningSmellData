Implementation smell,Namespace,Class,File,Method,Description
Long Method,de4dot.code.deobfuscators.Agile_NET.vm,CilOperandInstructionRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CilOperandInstructionRestorer.cs,Restore,The method has 143 lines of code.
Long Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,OpCodeHandlerInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\OpCodeHandlerInfo.cs,GetHandlerName,The method has 162 lines of code.
Long Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,OpCodeHandlerInfoReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\OpCodeHandlerInfoReader.cs,OpCodeHandlerInfoReader,The method has 318 lines of code.
Long Method,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The method has 158 lines of code.
Long Method,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The method has 157 lines of code.
Long Method,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The method has 104 lines of code.
Long Method,de4dot.code.deobfuscators,MethodStack,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodStack.cs,GetLoadedType,The method has 121 lines of code.
Long Method,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,The method has 145 lines of code.
Long Method,de4dot.code.deobfuscators.Babel_NET,BabelMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelMethodCallInliner.cs,GetNewValue,The method has 104 lines of code.
Long Method,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The method has 100 lines of code.
Long Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The method has 102 lines of code.
Long Method,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,EmulateInstructions,The method has 125 lines of code.
Long Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The method has 131 lines of code.
Long Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The method has 130 lines of code.
Long Method,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The method has 316 lines of code.
Long Method,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The method has 107 lines of code.
Long Method,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindFirstBlocks,The method has 113 lines of code.
Long Method,de4dot.code.renamer.asmmodules,MTypeDef,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,InitializeInterfaceMethods,The method has 126 lines of code.
Long Method,de4dot.code.renamer,VariableNameCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeNames.cs,VariableNameCreator,The method has 134 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The method has 109 lines of code.
Complex Method,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,Code,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,GetServerName,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code,Logger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Logger.cs,Log,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code,MethodPrinter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodPrinter.cs,InitTargets,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code,MethodPrinter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodPrinter.cs,PrintExInfo,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,Initialize,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,Cyclomatic complexity of the method is 35
Complex Method,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,FixIntArg,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,Cyclomatic complexity of the method is 68
Complex Method,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,CreateOperations,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,DetectObfuscator2,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,DeobfuscateBegin,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,FindMethodTokens,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,SplitMethodDesc,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,DeobfuscateMethods,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,Deobfuscate,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,DeobfuscateStrings,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code,PrintNewTokens,F:\newReposMay17\0xd4d_de4dot\de4dot.code\PrintNewTokens.cs,PrintTokens,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code,StringInlinerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\StringInliner.cs,InlineReturnValues,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code,DynamicStringInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\StringInliner.cs,InlineAllCalls,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code,Utils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Utils.cs,ToCsharpString,Cyclomatic complexity of the method is 27
Complex Method,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DeobfuscateBegin,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DeobfuscateEnd,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,FindStringDecrypters,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,Deobfuscate,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm,CilOperandInstructionRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CilOperandInstructionRestorer.cs,Restore,Cyclomatic complexity of the method is 110
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm,CilOperandInstructionRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CilOperandInstructionRestorer.cs,IsValidType,Cyclomatic complexity of the method is 48
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,Cyclomatic complexity of the method is 25
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,Cyclomatic complexity of the method is 21
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,ReadTypeRef,Cyclomatic complexity of the method is 36
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,box_read,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,call_read,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,cast_read,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,Cyclomatic complexity of the method is 57
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,logical_read,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v1,UnknownHandlerInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\UnknownHandlerInfo.cs,GetFields,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v1,UnknownHandlerInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\UnknownHandlerInfo.cs,FindOverrideMethods,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CompositeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CompositeHandlerDetector.cs,Matches,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareMethod,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,OpCodeHandlerInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\OpCodeHandlerInfo.cs,GetHandlerName,Cyclomatic complexity of the method is 80
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,OpCodeHandlerInfos,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\OpCodeHandlerInfos.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,Cyclomatic complexity of the method is 55
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,Hash,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,Hash,Cyclomatic complexity of the method is 69
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,GetReadAndExecMethods,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators,ArrayFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,GetInitializedArray,Cyclomatic complexity of the method is 23
Complex Method,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,Cyclomatic complexity of the method is 136
Complex Method,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,Cyclomatic complexity of the method is 135
Complex Method,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,Cyclomatic complexity of the method is 82
Complex Method,de4dot.code.deobfuscators,DeobfuscatorBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,IsTypeCalled,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,GetInitCctors,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,ExceptionLoggerRemover,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ExceptionLoggerRemover.cs,Find,Cyclomatic complexity of the method is 18
Complex Method,de4dot.code.deobfuscators,InlinedMethodsFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,Find,Cyclomatic complexity of the method is 47
Complex Method,de4dot.code.deobfuscators,InlinedMethodsFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,IsCallMethod,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,MethodStack,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodStack.cs,GetPushedArgInstructions,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators,MethodStack,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodStack.cs,GetLoadedType,Cyclomatic complexity of the method is 100
Complex Method,de4dot.code.deobfuscators,NullStream,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\NullStream.cs,Seek,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators,ProxyCallFixer1,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,ProxyCallFixer2,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,Find2,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,HasVowel,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,GetTypeWords,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,Cyclomatic complexity of the method is 117
Complex Method,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateFields,Cyclomatic complexity of the method is 47
Complex Method,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,IsValidType,Cyclomatic complexity of the method is 44
Complex Method,de4dot.code.deobfuscators,UnusedMethodsFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\UnusedMethodsFinder.cs,Check,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Babel_NET,BabelInflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,ReadHeader,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Babel_NET,BabelMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelMethodCallInliner.cs,GetNewValue,Cyclomatic complexity of the method is 82
Complex Method,de4dot.code.deobfuscators.Babel_NET,BabelUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelUtils.cs,FindRegisterMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,Deobfuscate,Cyclomatic complexity of the method is 17
Complex Method,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,Restore,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,InitializeTypeRefs,Cyclomatic complexity of the method is 25
Complex Method,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,GetCallInfo,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,FindDelegateCreator,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceResolver.cs,InitXorKeys,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckDecryptMethodBabel2x,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,GetOffsetMagic,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindBundleType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindAssemblyManagerType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindXmlParserType,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindStreamProviderType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DetectVersion,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DeobfuscateEnd,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,Find,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,Cyclomatic complexity of the method is 66
Complex Method,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindResourceEnumerator,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindEncryptedResourceStreamType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,ResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,Cyclomatic complexity of the method is 40
Complex Method,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,Cyclomatic complexity of the method is 25
Complex Method,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicLocal_v17_r73740,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r73740,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,Find,Cyclomatic complexity of the method is 17
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,InitializeFields,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,DecryptConstant,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,Cyclomatic complexity of the method is 34
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,DecryptConstant,Cyclomatic complexity of the method is 17
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,Cyclomatic complexity of the method is 29
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKeys,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,DecryptResource,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,Cyclomatic complexity of the method is 34
Complex Method,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,Cyclomatic complexity of the method is 37
Complex Method,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,GetDecryptedModule,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,GetStringDecrypterMethods,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,Cyclomatic complexity of the method is 19
Complex Method,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindCompileMethod,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,InitializeKeys,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,InitializeMethodDataIndexes,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,Cyclomatic complexity of the method is 34
Complex Method,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,InitializeKeys,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey5,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,Decrypt,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,Cyclomatic complexity of the method is 34
Complex Method,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindKey0_v16_r71742,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindKey0_v14_r58564,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindKey1,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindKey6,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCctor,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetCallInfo,Cyclomatic complexity of the method is 47
Complex Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Extract_v17_r73740,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,Cyclomatic complexity of the method is 32
Complex Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,IsMethodCreator_v14_r58802,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Find,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CreateDelegateInitInfos_v10_r42915,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,Cyclomatic complexity of the method is 72
Complex Method,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetHandler,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v18_r75369,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0Key1_v14_r55802,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,DecryptResource,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,Cyclomatic complexity of the method is 22
Complex Method,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,Find,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic1,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic2,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,Initialize,Cyclomatic complexity of the method is 17
Complex Method,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Find,Cyclomatic complexity of the method is 28
Complex Method,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,Cyclomatic complexity of the method is 46
Complex Method,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,Emulate,Cyclomatic complexity of the method is 27
Complex Method,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,Decode,Cyclomatic complexity of the method is 32
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,Deobfuscate,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,DecryptResourceName,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,LdnullFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\LdnullFixer.cs,FindFieldTypes,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,LdnullFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\LdnullFixer.cs,FindFieldTypes,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,LdnullFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\LdnullFixer.cs,Restore,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,MethodBodyReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodBodyReader.cs,ReadExceptionHandler,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,GetTokens,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,GetCallInfo,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,GetProxyCreatorType,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Find,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,FindDesktopOrCompactFrameworkV1,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,Cyclomatic complexity of the method is 21
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,GetDecrypterMethods,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Decrypt,Cyclomatic complexity of the method is 21
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,GetResourceNames,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,FindStringDecrypterType,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,Find,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,IsLdelem,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,IsStelem,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,FindFieldsToKeep,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckHandlerV404_41,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,GetAssemblyInfos,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,CastDeobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\CastDeobfuscator.cs,Deobfuscate,Cyclomatic complexity of the method is 22
Complex Method,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,EmulateInstructions,Cyclomatic complexity of the method is 85
Complex Method,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,Cyclomatic complexity of the method is 45
Complex Method,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,GetMovedTypes,Cyclomatic complexity of the method is 22
Complex Method,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,GetPossibleFields,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Retail,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV40,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindKey,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,Find,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,CheckFields,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v3,LibAssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\LibAssemblyResolver.cs,CheckInitMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,CheckType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,CheckMethod,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,Cyclomatic complexity of the method is 18
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DeobfuscateBegin,Cyclomatic complexity of the method is 17
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,OnWriterEvent,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MetadataTokenObfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MetadataTokenObfuscator.cs,Find,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MetadataTokenObfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MetadataTokenObfuscator.cs,Deobfuscate,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Find,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,FindInitMethod,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Find,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CheckCalledMethods,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindMethodInts,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,DynocodeService,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DynocodeService.cs,HandleMessage,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,EfUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\EfUtils.cs,GetNextStore,Cyclomatic complexity of the method is 30
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,ResourceMethodsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\ResourceMethodsRestorer.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindFlags2,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInts,Cyclomatic complexity of the method is 37
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInitIntsIndex,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInt3New,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,Cyclomatic complexity of the method is 24
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,GetNestedType,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Initialize,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DeobfuscateBegin,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Goliath_NET,LocalsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\LocalsRestorer.cs,Deobfuscate,Cyclomatic complexity of the method is 17
Complex Method,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.ILProtector,MethodReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,ReadType,Cyclomatic complexity of the method is 45
Complex Method,de4dot.code.deobfuscators.ILProtector,MethodReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,ReadExceptionHandler,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.MaxtoCode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Deobfuscator.cs,RemoveDuplicateEmbeddedResources,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.MaxtoCode,PeHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\PeHeader.cs,PeHeader,Cyclomatic complexity of the method is 22
Complex Method,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,ScanForObfuscator,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,Cyclomatic complexity of the method is 23
Complex Method,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,Cyclomatic complexity of the method is 29
Complex Method,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Rummage,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Rummage\Deobfuscator.cs,DetectVersion,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Deobfuscate,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GetTypeIdAttribute,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitStringDecrypterInfos,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,CheckAttachAppMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,GetResolverHandlers,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,Cyclomatic complexity of the method is 22
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindSimpleZipTypeMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,RemoveTamperProtection,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,RenameResources,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,RestoreMethodBodies,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Find,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Initialize,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Xenocode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,FindXenocodeAttribute,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Find,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.renamer.asmmodules,Module,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\Module.cs,FindAllMemberRefs,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer.asmmodules,Module,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\Module.cs,ResolveAllRefs,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.renamer.asmmodules,Modules,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\Modules.cs,InitAllTypes,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.renamer.asmmodules,MTypeDef,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,AddMembers,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.renamer.asmmodules,MTypeDef,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,InitializeInterfaceMethods,Cyclomatic complexity of the method is 33
Complex Method,de4dot.code.renamer.asmmodules,MTypeDef,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,InstantiateVirtualMembers,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,MemberInfos,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\MemberInfos.cs,Initialize,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.renamer,TypeNameCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\NameCreators.cs,GetNameCreator,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RemoveUselessOverrides,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RemoveOneClassNamespaces,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RenameMethods2,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RenameMemberRefs,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,ResetVirtualPropertyNames,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,ResetVirtualEventNames,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,PrepareRenameMemberDefs,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreMethodArgs,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,GetValidArgNames,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,PrepareRenameEvent,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,PrepareRenameProperty,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,PrepareRenameProperty,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,PrepareRenameVirtualMethods,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,ResourceKeysRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,GetResourceName,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,ResourceKeysRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,Cyclomatic complexity of the method is 24
Complex Method,de4dot.code.renamer,ResourceRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceRenamer.cs,RenameResourceNamesInCode,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,PrepareRenameTypes,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,PrepareRenameMembers,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,PrepareRenameFields,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,PrepareRenameMethodArgs,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitializeWindowsFormsFieldsAndProps,Cyclomatic complexity of the method is 21
Complex Method,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitFieldEventHandlers,Cyclomatic complexity of the method is 21
Complex Method,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitTypeEventHandlers,Cyclomatic complexity of the method is 18
Complex Method,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,FindWindowsFormsClassName,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Checksums,Adler32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,Cyclomatic complexity of the method is 32
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,Decode,Cyclomatic complexity of the method is 33
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,Inflate,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,Cyclomatic complexity of the method is 53
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 12
Long Parameter List,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZip,ICoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\ICoder.cs,Code,The method has 5 parameters.
Long Parameter List,de4dot.code,DumpedMethodsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\DumpedMethodsRestorer.cs,GetMethodBody,The method has 5 parameters.
Long Parameter List,de4dot.code,Logger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Logger.cs,Log,The method has 5 parameters.
Long Parameter List,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,Deobfuscate,The method has 5 parameters.
Long Parameter List,de4dot.code,OneArgOption,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Option.cs,OneArgOption,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,DesDecrypt,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators,InitializedDataCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,AddInitializeArrayCode,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators,MemberRefBuilder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MemberReferenceBuilder.cs,Method,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators,MethodStack,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodStack.cs,GetLoadedType,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators,ProxyCallFixer1,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,FindProxyCall,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Copy,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,GetLoadedType,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.CodeFort,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyData.cs,TypeInfo,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,Compare,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,DecryptCompressedInt32Data,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,DecryptConstant_v17_r73740_dynamic,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,DecryptConstant_v17_r73764_native,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Extract_v17_r73740,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetCallInfo_v18_r75367,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,GetTheOnlyMethod,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,GetIndexOfCall,The method has 5 parameters.
Long Parameter List,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The method has 6 parameters.
Long Parameter List,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,CreateProperty,The method has 5 parameters.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindEncryptedResourceStreamType,The length of the parameter getManifestResourceStreamMethodTmp1 is 35.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindEncryptedResourceStreamType,The length of the parameter getManifestResourceStreamMethodTmp2 is 35.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindManifestResourceStreamMethods,The length of the parameter getManifestResourceStreamMethodTmp1 is 35.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindManifestResourceStreamMethods,The length of the parameter getManifestResourceStreamMethodTmp2 is 35.
Long Identifier,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The length of the parameter compileMethodHasConstant_0x70000000 is 35.
Long Identifier,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the parameter CompileAssemblyFromSourceBatch2 is 31.
Long Statement,de4dot.code,DumpedMethodsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\DumpedMethodsRestorer.cs,GetMethodBody,The length of the statement  "	methodBody = MethodBodyReader.CreateCilBody (module' dm.code' dm.extraSections' parameters' dm.mhFlags' dm.mhMaxStack' dm.mhCodeSize' dm.mhLocalVarSigTok' gpContext); " is 166.
Long Statement,de4dot.code,MethodPrinter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodPrinter.cs,Print,The length of the statement  "			Logger.Log (loggerEvent' "{0'-9} {1} // {2:X8}"' instrString' Utils.RemoveNewlines (operandString)' memberRef.MDToken.ToUInt32 ()); " is 131.
Long Statement,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The length of the statement  "			Logger.w ("Could not find all arguments to method {0} ({1:X8})"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()); " is 123.
Long Statement,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The length of the statement  "				Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr); " is 142.
Long Statement,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,GetDefaultNewFilename,The length of the statement  "	string newFilename = Path.GetFileNameWithoutExtension (options.Filename) + "-cleaned" + Path.GetExtension (options.Filename); " is 125.
Long Statement,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,UnpackNativeImage,The length of the statement  "				Logger.w ("Could not load unpacked data. File: {0}' deobfuscator: {0}"' peImage.FileName ?? "(unknown filename)"' deob.TypeLong); " is 129.
Long Statement,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,GetMetaDataFlags,The length of the statement  "		mdFlags |= MetaDataFlags.PreserveRids | MetaDataFlags.PreserveUSOffsets | MetaDataFlags.PreserveBlobOffsets | MetaDataFlags.PreserveExtraSignatureData; " is 151.
Long Statement,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,CheckSupportedStringDecrypter,The length of the statement  "	throw new UserException (string.Format ("Deobfuscator {0} does not support this string decryption type"' deob.TypeLong)); " is 121.
Long Statement,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,FindMethodTokens,The length of the statement  "			if (method.MethodSig.GetRetType ().GetElementType () != ElementType.String && method.MethodSig.GetRetType ().GetElementType () != ElementType.Object) " is 149.
Long Statement,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,FindMethodTokens,The length of the statement  "			Logger.v ("Adding string decrypter; token: {0:X8}' method: {1}"' method.MDToken.ToInt32 ()' Utils.RemoveNewlines (method.FullName)); " is 132.
Long Statement,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,GetMethodImplOptions,The length of the statement  "	if (cattr.ConstructorArguments [0].Type.ElementType != ElementType.I2 && cattr.ConstructorArguments [0].Type.FullName != "System.Runtime.CompilerServices.MethodImplOptions") " is 173.
Long Statement,de4dot.code,BoolOption,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Option.cs,Set,The length of the statement  "	if (string.Equals (newVal' "false"' StringComparison.OrdinalIgnoreCase) || string.Equals (newVal' "off"' StringComparison.OrdinalIgnoreCase) || string.Equals (newVal' "0"' StringComparison.OrdinalIgnoreCase)) { " is 210.
Long Statement,de4dot.code,PrintNewTokens,F:\newReposMay17\0xd4d_de4dot\de4dot.code\PrintNewTokens.cs,PrintTokens,The length of the statement  "		Logger.v ("{0:X8} -> {1:X8} Type: {2}"' type.MDToken.ToUInt32 ()' new MDToken (Table.TypeDef' newRid).ToUInt32 ()' Utils.RemoveNewlines (type)); " is 144.
Long Statement,de4dot.code,PrintNewTokens,F:\newReposMay17\0xd4d_de4dot\de4dot.code\PrintNewTokens.cs,PrintTokens,The length of the statement  "			Logger.v ("{0:X8} -> {1:X8} Method: {2}"' method.MDToken.ToUInt32 ()' new MDToken (Table.Method' newRid).ToUInt32 ()' Utils.RemoveNewlines (method)); " is 149.
Long Statement,de4dot.code,PrintNewTokens,F:\newReposMay17\0xd4d_de4dot\de4dot.code\PrintNewTokens.cs,PrintTokens,The length of the statement  "			Logger.v ("{0:X8} -> {1:X8} Field: {2}"' field.MDToken.ToUInt32 ()' new MDToken (Table.Field' newRid).ToUInt32 ()' Utils.RemoveNewlines (field)); " is 145.
Long Statement,de4dot.code,PrintNewTokens,F:\newReposMay17\0xd4d_de4dot\de4dot.code\PrintNewTokens.cs,PrintTokens,The length of the statement  "			Logger.v ("{0:X8} -> {1:X8} Property: {2}"' prop.MDToken.ToUInt32 ()' new MDToken (Table.Property' newRid).ToUInt32 ()' Utils.RemoveNewlines (prop)); " is 149.
Long Statement,de4dot.code,PrintNewTokens,F:\newReposMay17\0xd4d_de4dot\de4dot.code\PrintNewTokens.cs,PrintTokens,The length of the statement  "			Logger.v ("{0:X8} -> {1:X8} Event: {2}"' evt.MDToken.ToUInt32 ()' new MDToken (Table.Event' newRid).ToUInt32 ()' Utils.RemoveNewlines (evt)); " is 141.
Long Statement,de4dot.code,DynamicStringInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\StringInliner.cs,InlineAllCalls,The length of the statement  "		var decryptedStrings = assemblyClient.StringDecrypterService.DecryptStrings (methodId' args' Method.MDToken.ToInt32 ()); " is 120.
Long Statement,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DetectInternal,The length of the statement  "	int sum = ToInt32 (cliSecureRtType.Detected) + ToInt32 (stringDecrypter.Detected) + ToInt32 (proxyCallFixer.Detected) + ToInt32 (resourceDecrypter.Detected) + ToInt32 (csvmV1.Detected || csvmV2.Detected); " is 204.
Long Statement,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,FindCliSecureAttribute,The length of the statement  "		if (Utils.StartsWith (type.FullName' "SecureTeam.Attributes.ObfuscatedByCliSecureAttribute"' StringComparison.Ordinal)) { " is 121.
Long Statement,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,FindCliSecureAttribute,The length of the statement  "		} else if (Utils.StartsWith (type.FullName' "SecureTeam.Attributes.ObfuscatedByAgileDotNetAttribute"' StringComparison.Ordinal)) { " is 130.
Long Statement,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,IsOldHeader,The length of the statement  "	if ((uint)methodDefTable.StartOffset - peImage.RvaToOffset ((uint)peImage.Cor20Header.MetaData.VirtualAddress) != codeHeader.methodDefTableOffset) " is 146.
Long Statement,de4dot.code.deobfuscators.Agile_NET,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\ResourceDecrypter.cs,FindResourceType,The length of the statement  "		var resolveHandler = DotNetUtils.GetMethod (type' "System.Reflection.Assembly"' "(System.Object'System.ResolveEventArgs)"); " is 123.
Long Statement,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,The length of the statement  "			if (sig != null && method.IsStatic && method.HasBody && sig.Params.Count == 2 && !method.HasGenericParameters && !DotNetUtils.HasReturnValue (method) && sig.Params [0].GetFullName () == "System.Exception" && sig.Params [1].GetFullName () == "System.Object[]") { " is 261.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,Csvm,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\Csvm.cs,GetVmOpCodeHandlerDetector,The length of the statement  "		deobfuscatorContext.SetData (dataKey' dict = new Dictionary<string' VmOpCodeHandlerDetector> (StringComparer.OrdinalIgnoreCase)); " is 129.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,endfinally_check,The length of the statement  "	return DotNetUtils.CallsMethod (info.ExecuteMethod' "System.Reflection.MethodInfo System.Type::GetMethod(System.String'System.Reflection.BindingFlags)"); " is 153.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,ldtoken_check,The length of the statement  "	return DotNetUtils.CallsMethod (info.ExecuteMethod' "System.Reflection.MemberInfo System.Reflection.Module::ResolveMember(System.Int32)"); " is 138.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,leave_check,The length of the statement  "	return !DotNetUtils.CallsMethod (info.ExecuteMethod' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)") && !DotNetUtils.CallsMethod (info.ExecuteMethod' "System.Type System.Reflection.Module::ResolveType(System.Int32)") && !DotNetUtils.CallsMethod (info.ExecuteMethod' "System.Reflection.MemberInfo System.Reflection.Module::ResolveMember(System.Int32)"); " is 390.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,ret_check,The length of the statement  "	return DotNetUtils.CallsMethod (info.ExecuteMethod' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)"); " is 138.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,throw_check,The length of the statement  "	return !DotNetUtils.CallsMethod (info.ExecuteMethod' "System.Reflection.MethodInfo System.Type::GetMethod(System.String'System.Reflection.BindingFlags)"); " is 154.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,CompositeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CompositeHandlerDetector.cs,Matches,The length of the statement  "		if (findState.CompositeState.BlockIndex == nextState.Value.BlockIndex && findState.CompositeState.HashIndex == nextState.Value.HashIndex) " is 137.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,Csvm,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\Csvm.cs,GetVmOpCodeHandlerDetector,The length of the statement  "		deobfuscatorContext.SetData (dataKey' dict = new Dictionary<string' VmOpCodeHandlerDetector> (StringComparer.OrdinalIgnoreCase)); " is 129.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,Initialize,The length of the statement  "	return FindVmHandlerBase () && FindLocalOpsMethods () && FindComparerMethods () && FindArithmeticMethods () && FindUnaryOpsMethods () && FindArgsLocals (); " is 155.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLocalOpsMethods,The length of the statement  "		if (LogicalOpShrUn != null && LogicalOpShl != null && LogicalOpShr != null && LogicalOpAnd != null && LogicalOpXor != null && LogicalOpOr != null) " is 146.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckLogicalMethodSig,The length of the statement  "	return method != null && method.IsStatic && method.MethodSig.GetParamCount () == 2 && method.MethodSig.RetType.GetElementType () == ElementType.Object && method.MethodSig.Params [0].GetElementType () == ElementType.Object && method.MethodSig.Params [1].GetElementType () == ElementType.Object; " is 293.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindComparerMethods,The length of the statement  "		if (CompareLt != null && CompareLte != null && CompareGt != null && CompareGte != null && CompareEq != null && CompareEqz != null) " is 130.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckCompareEqMethodSig,The length of the statement  "	return method != null && method.IsStatic && method.MethodSig.GetParamCount () == 2 && method.MethodSig.RetType.GetElementType () == ElementType.Boolean && method.MethodSig.Params [0].GetElementType () == ElementType.Object && method.MethodSig.Params [1].GetElementType () == ElementType.Object; " is 294.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckCompareEqzMethodSig,The length of the statement  "	return method != null && method.IsStatic && method.MethodSig.GetParamCount () == 1 && method.MethodSig.RetType.GetElementType () == ElementType.Boolean && method.MethodSig.Params [0].GetElementType () == ElementType.Object; " is 223.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticMethods,The length of the statement  "		if (ArithmeticSubOvfUn != null && ArithmeticMulOvfUn != null && ArithmeticRemUn != null && ArithmeticRem != null && ArithmeticDivUn != null && ArithmeticDiv != null && ArithmeticMul != null && ArithmeticMulOvf != null && ArithmeticSub != null && ArithmeticSubOvf != null && ArithmeticAddOvfUn != null && ArithmeticAddOvf != null && ArithmeticAdd != null) " is 354.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckArithmeticUnMethodSig,The length of the statement  "	return method != null && method.IsStatic && method.MethodSig.GetParamCount () == 2 && method.MethodSig.RetType.GetElementType () == ElementType.Object && method.MethodSig.Params [0].GetElementType () == ElementType.Class && method.MethodSig.Params [1].GetElementType () == ElementType.Class; " is 291.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckArithmeticOtherMethodSig,The length of the statement  "	return method != null && method.IsStatic && method.MethodSig.GetParamCount () == 2 && method.MethodSig.RetType.GetElementType () == ElementType.Object && method.MethodSig.Params [0].GetElementType () == ElementType.Object && method.MethodSig.Params [1].GetElementType () == ElementType.Object; " is 293.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,Hash,The length of the statement  "	var attrMask1 = MethodImplAttributes.CodeTypeMask | MethodImplAttributes.ManagedMask | MethodImplAttributes.ForwardRef | MethodImplAttributes.PreserveSig | MethodImplAttributes.InternalCall; " is 190.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,Hash,The length of the statement  "	var attrMask2 = MethodAttributes.Static | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.VtableLayoutMask | MethodAttributes.CheckAccessOnOverride | MethodAttributes.Abstract | MethodAttributes.SpecialName | MethodAttributes.PinvokeImpl | MethodAttributes.UnmanagedExport | MethodAttributes.RTSpecialName; " is 331.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,Hash,The length of the statement  "	var attrMask = TypeAttributes.LayoutMask | TypeAttributes.ClassSemanticsMask | TypeAttributes.Abstract | TypeAttributes.SpecialName | TypeAttributes.Import | TypeAttributes.WindowsRuntime | TypeAttributes.StringFormatMask | TypeAttributes.RTSpecialName; " is 253.
Long Statement,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The length of the statement  "		P [i] = Pboxes [i] ^ (((uint)key [ki++ % kl] << 24) | ((uint)key [ki++ % kl] << 16) | ((uint)key [ki++ % kl] << 8) | key [ki++ % kl]); " is 134.
Long Statement,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The length of the statement  "		xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl]; " is 125.
Long Statement,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The length of the statement  "		xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl]; " is 125.
Long Statement,de4dot.code.deobfuscators,DeobfuscatorBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,PreserveTokensAndTypes,The length of the statement  "	mdFlags |= MetaDataFlags.PreserveRids | MetaDataFlags.PreserveUSOffsets | MetaDataFlags.PreserveBlobOffsets | MetaDataFlags.PreserveExtraSignatureData; " is 151.
Long Statement,de4dot.code.deobfuscators,DeobfuscatorBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,DeleteEmptyCctors,The length of the statement  "			Logger.v ("{0:X8}' type: {1} ({2:X8})"' cctor.MDToken.ToUInt32 ()' Utils.RemoveNewlines (type)' type.MDToken.ToUInt32 ()); " is 122.
Long Statement,de4dot.code.deobfuscators,DeobfuscatorBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,DeleteMethods,The length of the statement  "			Logger.v ("Removed method {0} ({1:X8}) (Type: {2}) (reason: {3})"' Utils.RemoveNewlines (method)' method.MDToken.ToUInt32 ()' Utils.RemoveNewlines (type)' info.reason); " is 168.
Long Statement,de4dot.code.deobfuscators,DeobfuscatorBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,DeleteFields,The length of the statement  "			Logger.v ("Removed field {0} ({1:X8}) (Type: {2}) (reason: {3})"' Utils.RemoveNewlines (field)' field.MDToken.ToUInt32 ()' Utils.RemoveNewlines (type)' info.reason); " is 165.
Long Statement,de4dot.code.deobfuscators,DeobfuscatorBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,DeleteTypes,The length of the statement  "			Logger.v ("Removed type {0} ({1:X8}) (reason: {2})"' Utils.RemoveNewlines (typeDef)' typeDef.MDToken.ToUInt32 ()' info.reason); " is 127.
Long Statement,de4dot.code.deobfuscators,DeobfuscatorBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,DeleteCustomAttributes,The length of the statement  "				Logger.v ("Removed custom attribute {0} ({1:X8}) (reason: {2})"' Utils.RemoveNewlines (typeDef)' typeDef.MDToken.ToUInt32 ()' info.reason); " is 139.
Long Statement,de4dot.code.deobfuscators,DeobfuscatorBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,RemoveInlinedMethods,The length of the statement  "	AddMethodsToBeRemoved (new UnusedMethodsFinder (module' inlinedMethods' GetRemovedMethods ()).Find ()' "Inlined method"); " is 121.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateInitializeArrayMethod,The length of the statement  "		var runtimeHelpersType = DotNetUtils.FindOrCreateTypeRef (module' module.CorLibTypes.AssemblyRef' "System.Runtime.CompilerServices"' "RuntimeHelpers"' false); " is 158.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateInitializeArrayMethod,The length of the statement  "		var systemArrayType = DotNetUtils.FindOrCreateTypeRef (module' module.CorLibTypes.AssemblyRef' "System"' "Array"' false); " is 121.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateInitializeArrayMethod,The length of the statement  "		var runtimeFieldHandleType = DotNetUtils.FindOrCreateTypeRef (module' module.CorLibTypes.AssemblyRef' "System"' "RuntimeFieldHandle"' true); " is 140.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateInitializeArrayMethod,The length of the statement  "		initializeArrayMethod = module.UpdateRowId (new MemberRefUser (module' "InitializeArray"' methodSig' runtimeHelpersType.TypeDefOrRef)); " is 135.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,AddInitializeArrayCode,The length of the statement  "	block.Replace (index++' numToRemove' Instruction.CreateLdcI4 (data.Length / elementType.ToTypeSig ().ElementType.GetPrimitiveSize ())); " is 135.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateOurType,The length of the statement  "	ourType = new TypeDefUser (""' string.Format ("<PrivateImplementationDetails>{0}"' GetModuleId ())' module.CorLibTypes.Object.TypeDefOrRef); " is 140.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,CreateOurType,The length of the statement  "	ourType.Attributes = TypeAttributes.NotPublic | TypeAttributes.AutoLayout | TypeAttributes.Class | TypeAttributes.AnsiClass; " is 124.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetModuleId,The length of the statement  "	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]); " is 203.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,GetArrayType,The length of the statement  "	arrayType.Attributes = TypeAttributes.NestedPrivate | TypeAttributes.ExplicitLayout | TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.AnsiClass; " is 158.
Long Statement,de4dot.code.deobfuscators,MethodCallRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodCallRestorerBase.cs,CreateGetManifestResourceStream1,The length of the statement  "	var newMethod = builder.InstanceMethod ("GetManifestResourceStream"' assemblyType.TypeDefOrRef' streamType' builder.String); " is 124.
Long Statement,de4dot.code.deobfuscators,MethodCallRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodCallRestorerBase.cs,CreateGetManifestResourceStream2,The length of the statement  "	var newMethod = builder.InstanceMethod ("GetManifestResourceStream"' assemblyType.TypeDefOrRef' streamType' typeType' builder.String); " is 134.
Long Statement,de4dot.code.deobfuscators,MyPEImage,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MyPEImage.cs,FindSection,The length of the statement  "		if (section.VirtualAddress <= rva && rva < section.VirtualAddress + Math.Max (section.VirtualSize' section.SizeOfRawData)) " is 122.
Long Statement,de4dot.code.deobfuscators,ProxyCallFixer1,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,Find,The length of the statement  "			Logger.v ("Field: {0}' Opcode: {1}' Method: {2} ({3:X8})"' Utils.RemoveNewlines (field.Name)' callOpcode' Utils.RemoveNewlines (calledMethod)' calledMethod.MDToken.Raw); " is 169.
Long Statement,de4dot.code.deobfuscators,ProxyCallFixer1,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,Deobfuscate,The length of the statement  "				Logger.w ("Could not fix proxy call. Method: {0} ({1:X8})' Proxy type: {2} ({3:X8})"' Utils.RemoveNewlines (blocks.Method)' blocks.Method.MDToken.ToInt32 ()' Utils.RemoveNewlines (di.field.DeclaringType)' di.field.DeclaringType.MDToken.ToInt32 ()); " is 248.
Long Statement,de4dot.code.deobfuscators,ProxyCallFixer1,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,FixBrokenCalls,The length of the statement  "			Logger.w ("Holy obfuscator bugs' Batman! Found a proxy delegate call with no instance push in {0:X8}. Replacing it with a throw..."' obfuscatedMethod.MDToken.ToInt32 ()); " is 170.
Long Statement,de4dot.code.deobfuscators,ProxyCallFixer2,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,Find2,The length of the statement  "			Logger.v ("Field: {0}' Opcode: {1}' Method: {2} ({3:X8})"' Utils.RemoveNewlines (field.Name)' callOpcode' Utils.RemoveNewlines (calledMethod)' calledMethod.MDToken.ToUInt32 ()); " is 177.
Long Statement,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,RestoreFieldTypes,The length of the statement  "		Logger.v ("Field {0:X8}: type {1} ({2:X8})"' updatedField.token' Utils.RemoveNewlines (updatedField.newFieldType.FullName)' updatedField.newFieldType.MDToken.ToInt32 ()); " is 170.
Long Statement,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,RestoreMethodTypes,The length of the statement  "			Logger.v ("ret: {0} ({1:X8})"' Utils.RemoveNewlines (updatedMethod.newReturnType.FullName)' updatedMethod.newReturnType.MDToken.ToInt32 ()); " is 140.
Long Statement,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,The length of the statement  "					AddMethodArgType (method' GetParameter (methodParams' ldInstr)' DotNetUtils.GetArg (calledMethodParams' calledMethodParamIndex)); " is 129.
Long Statement,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateFields,The length of the statement  "				calledMethodArgs = DotNetUtils.ReplaceGenericParameters (calledMethodDefOrRef.DeclaringType.TryGetGenericInstSig ()' calledMethodSpec' calledMethodArgs); " is 153.
Long Statement,de4dot.code.deobfuscators,ValueInlinerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ValueInlinerBase.cs,Add,The length of the statement  "		throw new ApplicationException (string.Format ("Handler for method {0:X8} has already been added"' method.MDToken.ToInt32 ())); " is 127.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,Deobfuscate,The length of the statement  "			initializedDataCreator.AddInitializeArrayCode (block' info.start' info.len' info.arrayType.Next.ToTypeDefOrRef ()' decrypted); " is 126.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DetectInternal,The length of the statement  "	int sum = ToInt32 (resourceResolver.Detected) + ToInt32 (assemblyResolver.Detected) + ToInt32 (stringDecrypter.Detected) + ToInt32 (constantsDecrypter.Detected) + ToInt32 (proxyCallFixer.Detected) + ToInt32 (methodsDecrypter.Detected) + ToInt32 (HasMetadataStream ("Babel")); " is 275.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,ScanForObfuscator,The length of the statement  "	methodsDecrypter = new MethodsDecrypter (module' resourceDecrypterCreator.Create ()' DeobfuscatedFile.DeobfuscatorContext); " is 123.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,CheckVersion,The length of the statement  "	if (versionField != null && versionField.IsLiteral && versionField.Constant != null && versionField.Constant.Value is string) { " is 127.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "		int32ValueInliner.Add (constantsDecrypter.Int32Decrypter' (method' gim' args) => constantsDecrypter.DecryptInt32 ((int)args [0])); " is 130.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "		int64ValueInliner.Add (constantsDecrypter.Int64Decrypter' (method' gim' args) => constantsDecrypter.DecryptInt64 ((int)args [0])); " is 130.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "		singleValueInliner.Add (constantsDecrypter.SingleDecrypter' (method' gim' args) => constantsDecrypter.DecryptSingle ((int)args [0])); " is 133.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "		doubleValueInliner.Add (constantsDecrypter.DoubleDecrypter' (method' gim' args) => constantsDecrypter.DecryptDouble ((int)args [0])); " is 133.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,ReadFieldRef,The length of the statement  "		throw new ApplicationException (string.Format ("Couldn't find one field named '{0}' in type {1}"' name' Utils.RemoveNewlines (declaringType))); " is 143.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,ReadMethodRef,The length of the statement  "		throw new ApplicationException (string.Format ("Could not find method '{0}' in type '{1}'"' Utils.RemoveNewlines (babelMethodRef.Name)' Utils.RemoveNewlines (babelMethodRef.DeclaringType))); " is 190.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,ReadMethodRef,The length of the statement  "	var mr = new MemberRefUser (module' method.Name' method.MethodSig.Clone ()' babelMethodRef.DeclaringType.ToTypeDefOrRef ()); " is 124.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMethodRef,The length of the statement  "		throw new ApplicationException (string.Format ("Couldn't find one method named '{0}' in type {1}"' babelMethodRef.Name' Utils.RemoveNewlines (declaringType))); " is 159.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The length of the statement  "		var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call); " is 139.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The length of the statement  "		} else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) { " is 142.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "			if (!DotNetUtils.IsMethod (method' "System.Void"' "(System.RuntimeTypeHandle'System.Int32'System.RuntimeFieldHandle)") && !DotNetUtils.IsMethod (method' "System.Void"' "(System.RuntimeTypeHandle'System.Int32'System.Int32'System.RuntimeFieldHandle)")) " is 250.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,GetProxyCreatorType,The length of the statement  "		if (DotNetUtils.IsMethod (calledMethod' "System.Void"' "(System.Reflection.FieldInfo'System.Type'System.Reflection.MethodInfo)")) " is 129.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,GetProxyCreatorType,The length of the statement  "		if (DotNetUtils.IsMethod (calledMethod' "System.Void"' "(System.Reflection.FieldInfo'System.Type'System.Reflection.ConstructorInfo)")) " is 134.
Long Statement,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckNested,The length of the statement  "		var decrypterBuilderMethod = DotNetUtils.GetMethod (nested' "System.Reflection.Emit.MethodBuilder"' "(System.Reflection.Emit.TypeBuilder)"); " is 140.
Long Statement,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,GetOffsetMagic,The length of the statement  "		if (calledMethod.FullName != "System.Void System.Reflection.Emit.ILGenerator::Emit(System.Reflection.Emit.OpCode'System.Int32)") " is 128.
Long Statement,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckFields,The length of the statement  "	if (type.Fields [0].FieldSig.GetFieldType ().GetFullName () != fieldType1 && type.Fields [1].FieldSig.GetFieldType ().GetFullName () != fieldType1) " is 147.
Long Statement,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckFields,The length of the statement  "	if (!new SigComparer ().Equals (type.Fields [0].FieldSig.GetFieldType ()' fieldType2) && !new SigComparer ().Equals (type.Fields [1].FieldSig.GetFieldType ()' fieldType2)) " is 171.
Long Statement,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,CheckType,The length of the statement  "	if (DotNetUtils.GetMethod (type' "System.Byte[]"' "(System.Byte[]'System.String'System.String'System.Int32'System.String'System.Int32)") == null) " is 145.
Long Statement,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,Decrypt,The length of the statement  "	var key = new Rfc2898DeriveBytes (password.passphrase' Encoding.UTF8.GetBytes (password.salt)' iterations).GetBytes (numBits / 8); " is 130.
Long Statement,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,GetAssemblyInfos,The length of the statement  "		infos.Add (new AssemblyInfo (asmData' resource' mod.Assembly.FullName' mod.Assembly.Name.String' DeobUtils.GetExtension (mod.Kind))); " is 133.
Long Statement,de4dot.code.deobfuscators.CodeFort,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\Deobfuscator.cs,DetectInternal,The length of the statement  "	int sum = ToInt32 (proxyCallFixer.Detected) + ToInt32 (stringDecrypter.Detected) + ToInt32 (assemblyDecrypter.Detected); " is 120.
Long Statement,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,CheckMethods,The length of the statement  "		if (DotNetUtils.IsMethod (method' "System.MulticastDelegate"' "(System.Type'System.Reflection.MethodInfo'System.Int32)")) " is 121.
Long Statement,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DetectInternal,The length of the statement  "	int sum = ToInt32 (mainType.Detected) + ToInt32 (methodsDecrypter.Detected) + ToInt32 (stringDecrypter.Detected) + ToInt32 (proxyCallFixer.Detected); " is 149.
Long Statement,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The length of the statement  "		resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length)); " is 153.
Long Statement,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The length of the statement  "		resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length)); " is 143.
Long Statement,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The length of the statement  "		resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length)); " is 145.
Long Statement,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindEncryptedResourceStreamType,The length of the statement  "		if (!FindManifestResourceStreamMethods (type' out getManifestResourceStreamMethodTmp1' out getManifestResourceStreamMethodTmp2)) " is 128.
Long Statement,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindXxteaMethod,The length of the statement  "		} else if (DotNetUtils.IsMethod (method' "System.Void"' "(System.UInt32[]'System.UInt32[]'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32)")) { " is 221.
Long Statement,de4dot.code.deobfuscators.CodeVeil,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,CallsMainTypeTamperCheckMethod,The length of the statement  "		var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Call' OpCodes.Ldc_I8' OpCodes.Call); " is 134.
Long Statement,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,GetMainResourceKey,The length of the statement  "		return BitConverter.ToString (new MD5CryptoServiceProvider ().ComputeHash (new ASCIIEncoding ().GetBytes (keyInfo))).Replace ("-"' ""); " is 135.
Long Statement,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,DecryptAllAssemblies,The length of the statement  "		assemblyInfos.Add (new AssemblyInfo (assemblyData' DeobUtils.GetExtension (theModule.Kind)' theModule.Assembly.FullName' theModule.Assembly.Name.String' isMain)); " is 162.
Long Statement,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,Decrypt,The length of the statement  "	return DeobUtils.Inflate (DeobUtils.AesDecrypt (encrypted' keyGenerator.GetBytes (32)' keyGenerator.GetBytes (16))' false); " is 123.
Long Statement,de4dot.code.deobfuscators.CodeWall,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,InitializeStringDecrypter,The length of the statement  "		staticStringInliner.Add (info.Method' (method' gim' args) => stringDecrypter.Decrypt (method' (int)args [0]' (int)args [1]' (int)args [2])); " is 140.
Long Statement,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The length of the statement  "	sum = (ulong)2111111111UL * (ulong)x [3] + (ulong)1492 * (ulong)(x [2]) + (ulong)1776 * (ulong)(x [1]) + (ulong)5115 * (ulong)(x [0]) + (ulong)x [4]; " is 149.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetAntiDebugMethod,The length of the statement  "		if (!DotNetUtils.IsMethod (method' "System.Void"' "()") && !DotNetUtils.IsMethod (method' "System.Void"' "(System.Object)")) " is 124.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The length of the statement  "	if (DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) { " is 132.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The length of the statement  "		int failFastCalls = ConfuserUtils.CountCalls (antiDebugMethod' "System.Void System.Environment::FailFast(System.String)"); " is 122.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The length of the statement  "		if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) { " is 138.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The length of the statement  "	} else if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.ThreadStart::.ctor(System.Object'System.IntPtr)")) { " is 131.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_safe,The length of the statement  "		bool hasDebuggerStrings = DotNetUtils.HasString (antiDebugMethod' "Debugger detected (Managed)") || DotNetUtils.HasString (antiDebugMethod' "Debugger is detected (Managed)"); " is 174.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_safe,The length of the statement  "		if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) " is 131.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_safe,The length of the statement  "		int failFastCalls = ConfuserUtils.CountCalls (antiDebugMethod' "System.Void System.Environment::FailFast(System.String)"); " is 122.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_safe,The length of the statement  "			if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) " is 136.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckMethod,The length of the statement  "		simpleDeobfuscator.Deobfuscate (calledMethod' SimpleDeobfuscatorFlags.Force | SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs); " is 137.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58564,The length of the statement  "	if (!DotNetUtils.CallsMethod (initMethod' "System.IntPtr System.Runtime.InteropServices.Marshal::GetHINSTANCE(System.Reflection.Module)")) " is 138.
Long Statement,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The length of the statement  "	if (!DotNetUtils.CallsMethod (initMethod' "System.IntPtr System.Runtime.InteropServices.Marshal::GetHINSTANCE(System.Reflection.Module)")) " is 138.
Long Statement,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResourceHookCode,The length of the statement  "	return RemoveResolveHandlerCode (blocks' handler' "System.Void System.AppDomain::add_ResourceResolve(System.ResolveEventHandler)"); " is 131.
Long Statement,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveAssemblyHookCode,The length of the statement  "	return RemoveResolveHandlerCode (blocks' handler' "System.Void System.AppDomain::add_AssemblyResolve(System.ResolveEventHandler)"); " is 131.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,DecryptConstant_v17_r73764_native,The length of the statement  "		return Decrypt (encrypted' key1' (magic' i) => (byte)(x86Emu.Emulate ((uint)nativeMethod.RVA' magic) ^ key2 [i % key2.Length])); " is 128.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterUtils.cs,FindDictField,The length of the statement  "		if (ctor == null || ctor.FullName != "System.Void System.Collections.Generic.Dictionary`2<System.UInt32'System.Object>::.ctor()") " is 129.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,Find,The length of the statement  "			else if (DeobUtils.HasInteger (method' 0x100) && DeobUtils.HasInteger (method' 0x10000) && DeobUtils.HasInteger (method' 0xFFFF)) " is 129.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,Find,The length of the statement  "			} else if (DotNetUtils.CallsMethod (method' "System.String System.Text.Encoding::GetString(System.Byte[]'System.Int32'System.Int32)")) { " is 136.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,Find,The length of the statement  "			if (DeobUtils.HasInteger (method' 0x100) && DeobUtils.HasInteger (method' 0x10000) && DeobUtils.HasInteger (method' 0xFFFF)) " is 124.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,DecryptData,The length of the statement  "	if (typeCode != info.int32Type && typeCode != info.int64Type && typeCode != info.singleType && typeCode != info.doubleType && typeCode != info.stringType) " is 154.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The length of the statement  "	simpleDeobfuscator.Deobfuscate (cctor' SimpleDeobfuscatorFlags.Force | SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs); " is 130.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The length of the statement  "			InitVersion (method' ConfuserVersion.v17_r75056_normal' ConfuserVersion.v17_r75056_dynamic' ConfuserVersion.v17_r75056_native); " is 127.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The length of the statement  "			InitVersion (method' ConfuserVersion.v18_r75257_normal' ConfuserVersion.v18_r75257_dynamic' ConfuserVersion.v18_r75257_native); " is 127.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The length of the statement  "		InitVersion (method' ConfuserVersion.v17_r74816_normal' ConfuserVersion.v17_r74816_dynamic' ConfuserVersion.v17_r74816_native); " is 127.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The length of the statement  "	else if (DotNetUtils.CallsMethod (method' "System.Reflection.Module System.Reflection.Assembly::GetModule(System.String)")) " is 123.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The length of the statement  "		InitVersion (method' ConfuserVersion.v17_r74788_normal' ConfuserVersion.v17_r74788_dynamic' ConfuserVersion.v17_r74788_native); " is 127.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The length of the statement  "		InitVersion (method' ConfuserVersion.v17_r74708_normal' ConfuserVersion.v17_r74708_dynamic' ConfuserVersion.v17_r74708_native); " is 127.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,InitVersion,The length of the statement  "	if (DeobUtils.HasInteger (method' 0x100) && DeobUtils.HasInteger (method' 0x10000) && DeobUtils.HasInteger (method' 0xFFFF)) " is 124.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,DecryptData,The length of the statement  "	uint offs = info.CalcHash (info2.decryptMethod.MDToken.ToUInt32 () ^ (info2.decryptMethod.DeclaringType.MDToken.ToUInt32 () * (uint)args [0])) ^ (uint)args [1]; " is 160.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,DecryptData,The length of the statement  "	if (typeCode != info.int32Type && typeCode != info.int64Type && typeCode != info.singleType && typeCode != info.doubleType && typeCode != info.stringType) " is 154.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The length of the statement  "	simpleDeobfuscator.Deobfuscate (cctor' SimpleDeobfuscatorFlags.Force | SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs); " is 130.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The length of the statement  "	if ((dataField = ConstantsDecrypterUtils.FindDataField_v18_r75367 (cctor' cctor.DeclaringType)) == null && (dataField = ConstantsDecrypterUtils.FindDataField_v19_r77172 (cctor' cctor.DeclaringType)) == null) " is 207.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The length of the statement  "		InitVersion (cctor' ConfuserVersion.v18_r75367_normal' ConfuserVersion.v18_r75367_dynamic' ConfuserVersion.v18_r75367_native); " is 126.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The length of the statement  "			InitVersion (cctor' ConfuserVersion.v18_r75369_normal' ConfuserVersion.v18_r75369_dynamic' ConfuserVersion.v18_r75369_native); " is 126.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The length of the statement  "			InitVersion (cctor' ConfuserVersion.v19_r77172_normal' ConfuserVersion.v19_r77172_dynamic' ConfuserVersion.v19_r77172_native); " is 126.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The length of the statement  "			InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native); " is 126.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The length of the statement  "			int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"); " is 157.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The length of the statement  "			int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()"); " is 152.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The length of the statement  "				InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native); " is 126.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The length of the statement  "				InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native); " is 126.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0,The length of the statement  "		int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Text.Encoding System.Text.Encoding::get_UTF8()"); " is 121.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0,The length of the statement  "		int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Byte[] System.BitConverter::GetBytes(System.Int32)"); " is 126.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d,The length of the statement  "		int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"); " is 139.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d,The length of the statement  "		int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()"); " is 135.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d_v18_r75367,The length of the statement  "		int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()"); " is 134.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d_v18_r75367,The length of the statement  "		int index2 = ConfuserUtils.FindCallMethod (instrs' index' Code.Call' "System.Byte[] System.BitConverter::GetBytes(System.Int32)"); " is 130.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The length of the statement  "					ulong valu64 = instr.OpCode.Code == Code.Ldc_R4 ? (ulong)(float)instr.Operand : (ulong)(double)instr.Operand;*/switch (conv.OpCode.Code) { " is 138.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The length of the statement  "				newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (sbyte)(float)instr.Operand : (sbyte)(double)instr.Operand); " is 131.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The length of the statement  "				newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (byte)(float)instr.Operand : (byte)(double)instr.Operand); " is 129.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The length of the statement  "				newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (short)(float)instr.Operand : (short)(double)instr.Operand); " is 131.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The length of the statement  "				newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (ushort)(float)instr.Operand : (ushort)(double)instr.Operand); " is 133.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The length of the statement  "				newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (int)(float)instr.Operand : (int)(double)instr.Operand); " is 127.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The length of the statement  "				newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (int)(uint)(float)instr.Operand : (int)(uint)(double)instr.Operand); " is 139.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The length of the statement  "				newInstr = Instruction.Create (OpCodes.Ldc_I8' instr.OpCode.Code == Code.Ldc_R4 ? (long)(float)instr.Operand : (long)(double)instr.Operand); " is 140.
Long Statement,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The length of the statement  "				newInstr = Instruction.Create (OpCodes.Ldc_I8' instr.OpCode.Code == Code.Ldc_R4 ? (ulong)(float)instr.Operand : (ulong)(double)instr.Operand); " is 142.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,DetectInternal,The length of the statement  "	int sum = ToInt32 (jitMethodsDecrypter != null ? jitMethodsDecrypter.Detected : false) + ToInt32 (memoryMethodsDecrypter != null ? memoryMethodsDecrypter.Detected : false) + ToInt32 (proxyCallFixer != null ? proxyCallFixer.Detected : false) + ToInt32 (antiDebugger != null ? antiDebugger.Detected : false) + ToInt32 (antiDumping != null ? antiDumping.Detected : false) + ToInt32 (resourceDecrypter != null ? resourceDecrypter.Detected : false) + ToInt32 (constantsDecrypterV18 != null ? constantsDecrypterV18.Detected : false) + ToInt32 (constantsDecrypterV15 != null ? constantsDecrypterV15.Detected : false) + ToInt32 (constantsDecrypterV17 != null ? constantsDecrypterV17.Detected : false) + ToInt32 (stringDecrypter != null ? stringDecrypter.Detected : false) + ToInt32 (unpacker != null ? unpacker.Detected : false); " is 821.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,ModuleReloaded,The length of the statement  "	newOne.jitMethodsDecrypter = hasUnpacked ? new JitMethodsDecrypter (module' DeobfuscatedFile) : new JitMethodsDecrypter (module' DeobfuscatedFile' jitMethodsDecrypter); " is 168.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,ModuleReloaded,The length of the statement  "	newOne.memoryMethodsDecrypter = hasUnpacked ? new MemoryMethodsDecrypter (module' DeobfuscatedFile) : new MemoryMethodsDecrypter (module' DeobfuscatedFile' memoryMethodsDecrypter); " is 180.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,InitializeStringDecrypter,The length of the statement  "	staticStringInliner.Add (stringDecrypter.Method' (method' gim' args) => stringDecrypter.Decrypt (staticStringInliner.Method' (int)args [0])); " is 141.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,InitializeConstantsDecrypterV18,The length of the statement  "		staticStringInliner.Add (info.method' (method' gim' args) => constantsDecrypterV18.DecryptString (method' gim' (uint)args [0]' (ulong)args [1])); " is 145.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,InitializeConstantsDecrypterV18,The length of the statement  "		int32ValueInliner.Add (info.method' (method' gim' args) => constantsDecrypterV18.DecryptInt32 (method' gim' (uint)args [0]' (ulong)args [1])); " is 142.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,InitializeConstantsDecrypterV18,The length of the statement  "		int64ValueInliner.Add (info.method' (method' gim' args) => constantsDecrypterV18.DecryptInt64 (method' gim' (uint)args [0]' (ulong)args [1])); " is 142.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,InitializeConstantsDecrypterV18,The length of the statement  "		singleValueInliner.Add (info.method' (method' gim' args) => constantsDecrypterV18.DecryptSingle (method' gim' (uint)args [0]' (ulong)args [1])); " is 144.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,InitializeConstantsDecrypterV18,The length of the statement  "		doubleValueInliner.Add (info.method' (method' gim' args) => constantsDecrypterV18.DecryptDouble (method' gim' (uint)args [0]' (ulong)args [1])); " is 144.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,Initialize,The length of the statement  "		staticStringInliner.Add (info.decryptMethod' (method' gim' args) => constDecrypter.DecryptString (staticStringInliner.Method' method' args)); " is 141.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,Initialize,The length of the statement  "		int32ValueInliner.Add (info.decryptMethod' (method' gim' args) => constDecrypter.DecryptInt32 (int32ValueInliner.Method' method' args)); " is 136.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,Initialize,The length of the statement  "		int64ValueInliner.Add (info.decryptMethod' (method' gim' args) => constDecrypter.DecryptInt64 (int64ValueInliner.Method' method' args)); " is 136.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,Initialize,The length of the statement  "		singleValueInliner.Add (info.decryptMethod' (method' gim' args) => constDecrypter.DecryptSingle (singleValueInliner.Method' method' args)); " is 139.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,Initialize,The length of the statement  "		doubleValueInliner.Add (info.decryptMethod' (method' gim' args) => constDecrypter.DecryptDouble (doubleValueInliner.Method' method' args)); " is 139.
Long Statement,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,SetConfuserVersion,The length of the statement  "	approxVersion = new Version (int.Parse (val.Groups [1].ToString ())' int.Parse (val.Groups [2].ToString ())' int.Parse (val.Groups [3].ToString ())' int.Parse (val.Groups [4].ToString ())); " is 189.
Long Statement,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The length of the statement  "			if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()")) " is 133.
Long Statement,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The length of the statement  "		} else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()")) " is 140.
Long Statement,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindKey4,The length of the statement  "		index = ConfuserUtils.FindCallMethod (instrs' index' Code.Call' "System.Void System.Runtime.InteropServices.Marshal::Copy(System.Byte[]'System.Int32'System.IntPtr'System.Int32)"); " is 179.
Long Statement,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,InitializeMethodDataIndexes_v17_r73477,The length of the statement  "	var methodDataType = FindFirstThreeIndexes (method' out methodDataIndexes.maxStack' out methodDataIndexes.ehs' out methodDataIndexes.options); " is 142.
Long Statement,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,IsEncryptedMethod,The length of the statement  "	return fileData [offset] == 0x46 && fileData [offset + 1] == 0x21 && fileData [offset + 10] == 0x20 && fileData [offset + 15] == 0x26; " is 134.
Long Statement,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The length of the statement  "	bool callsFileStreamCtor = DotNetUtils.CallsMethod (initMethod' "System.Void System.IO.FileStream::.ctor(System.String'System.IO.FileMode'System.IO.FileAccess'System.IO.FileShare)"); " is 182.
Long Statement,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The length of the statement  "		int calls = ConfuserUtils.CountCalls (initMethod' "System.Void System.Buffer::BlockCopy(System.Array'System.Int32'System.Array'System.Int32'System.Int32)"); " is 156.
Long Statement,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The length of the statement  "	} else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()")) " is 140.
Long Statement,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey5,The length of the statement  "		int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.BinaryReader::ReadInt32()"); " is 121.
Long Statement,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,DecryptMethodsData_v14_r57884,The length of the statement  "			if (peImage.RvaToOffset ((uint)peImage.Cor20Header.StrongNameSignature.VirtualAddress) != sn || peImage.Cor20Header.StrongNameSignature.Size != snLen) " is 150.
Long Statement,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,CheckCallvirtReadUInt32,The length of the statement  "	if (!ConfuserUtils.IsCallMethod (instrs [index + 1]' Code.Callvirt' "System.UInt32 System.IO.BinaryReader::ReadUInt32()")) " is 122.
Long Statement,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindKey2OrKey3,The length of the statement  "	if (!ConfuserUtils.IsCallMethod (instrs [i++]' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)")) " is 127.
Long Statement,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindCallvirtReadUInt32,The length of the statement  "	return ConfuserUtils.FindCallMethod (instrs' index' Code.Callvirt' "System.UInt32 System.IO.BinaryReader::ReadUInt32()"); " is 121.
Long Statement,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindCallvirtReadUInt64,The length of the statement  "	return ConfuserUtils.FindCallMethod (instrs' index' Code.Callvirt' "System.UInt64 System.IO.BinaryReader::ReadUInt64()"); " is 121.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetCallInfo_v10_r48717,The length of the statement  "	uint token = BitConverter.ToUInt32 (Encoding.Unicode.GetBytes (info.field.Name.String.ToCharArray ()' offs' 2)' 0) ^ creatorInfo.magic; " is 135.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetCallInfo_v18_r75367_normal,The length of the statement  "	GetCallInfo_v18_r75367 (info' creatorInfo' out calledMethod' out callOpcode' (creatorInfo2' magic) => creatorInfo2.magic ^ magic); " is 130.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,ReadAssemblyNameReference,The length of the statement  "	return module.UpdateRowId (new AssemblyRefUser (name' version' pkt == null ? null : new PublicKeyToken (pkt)' culture)); " is 120.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "			else if (proxyType != ProxyCreatorType.CallOrCallvirt || !HasFieldReference (method' "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Castclass")) " is 160.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "			else if (proxyType == ProxyCreatorType.CallOrCallvirt && DotNetUtils.CallsMethod (method' "System.Void System.Reflection.Emit.DynamicMethod::.ctor(System.String'System.Type'System.Type[]'System.Boolean)")) " is 205.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "		} else if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)") && DotNetUtils.CallsMethod (method' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) { " is 234.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "				theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native; " is 151.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "				theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal; " is 151.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "				if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()")) " is 130.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "				int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)"); " is 138.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "				if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)")) " is 133.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The length of the statement  "				if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)")) " is 146.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetFieldNameIndex,The length of the statement  "		i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)"); " is 149.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v18_r75367,The length of the statement  "		i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"); " is 131.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v18_r75367,The length of the statement  "		i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"); " is 131.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v17_r73740,The length of the statement  "		int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Int32 System.BitConverter::ToInt32(System.Byte[]'System.Int32)"); " is 137.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v17_r73740,The length of the statement  "		int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Int32 System.BitConverter::ToInt32(System.Byte[]'System.Int32)"); " is 137.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Is_v17_r73740,The length of the statement  "		int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)"); " is 154.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v14_r58564,The length of the statement  "		int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Int32 System.BitConverter::ToInt32(System.Byte[]'System.Int32)"); " is 137.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v14_r58564,The length of the statement  "		int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)"); " is 155.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Find,The length of the statement  "				Logger.v ("Field: {0}' Opcode: {1}' Method: {2} ({3:X8})"' Utils.RemoveNewlines (field.Name)' callOpcode' Utils.RemoveNewlines (calledMethod)' calledMethod.MDToken.ToUInt32 ()); " is 177.
Long Statement,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindCallvirtChar,The length of the statement  "		index = ConfuserUtils.FindCallMethod (instrs' index' Code.Callvirt' "System.Char System.String::get_Chars(System.Int32)"); " is 122.
Long Statement,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,CheckMethod,The length of the statement  "	simpleDeobfuscator.Deobfuscate (method' SimpleDeobfuscatorFlags.Force | SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs); " is 131.
Long Statement,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,CheckMethod,The length of the statement  "	simpleDeobfuscator.Deobfuscate (tmpHandler' SimpleDeobfuscatorFlags.Force | SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs); " is 135.
Long Statement,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,CheckMethod,The length of the statement  "		if (!DotNetUtils.CallsMethod (tmpHandler' "System.Void System.Buffer::BlockCopy(System.Array'System.Int32'System.Array'System.Int32'System.Int32)")) { " is 150.
Long Statement,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v18_r75367,The length of the statement  "		i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.Stream::Read(System.Byte[]'System.Int32'System.Int32)"); " is 140.
Long Statement,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v18_r75369,The length of the statement  "		index = ConfuserUtils.FindCallMethod (instrs' index' Code.Callvirt' "System.Int32 System.IO.Stream::Read(System.Byte[]'System.Int32'System.Int32)"); " is 148.
Long Statement,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v17_r73404,The length of the statement  "		int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)"); " is 133.
Long Statement,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic1,The length of the statement  "		int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)"); " is 133.
Long Statement,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic2,The length of the statement  "		int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.UInt32 System.IO.BinaryReader::ReadUInt32()"); " is 122.
Long Statement,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindEntryPointToken,The length of the statement  "	var modPowMethod = DotNetUtils.GetMethod (cctor.DeclaringType' "System.UInt64"' "(System.UInt64'System.UInt64'System.UInt64)"); " is 127.
Long Statement,de4dot.code.deobfuscators.Confuser,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\VersionDetector.cs,GetVersionString,The length of the statement  "	return string.Format ("v{0}.{1} - v{2}.{3} (r{4}-r{5})"' minVersion.Major' minVersion.Minor' maxVersion.Major' maxVersion.Minor' minRev' maxRev); " is 145.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AntiDebugger.cs,Find,The length of the statement  "		if (!ContainsString (method' "debugger is activ") && !ContainsString (method' "debugger is running") && !ContainsString (method' "Debugger detected") && !ContainsString (method' "Debugger was detected") && !ContainsString (method' "{0} was detected") && !ContainsString (method' "run under") && !ContainsString (method' "run with") && !ContainsString (method' "started under") && !ContainsString (method' "{0} detected") && !ContainsString (method' "{0} found")) " is 462.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,CheckInitMethod,The length of the statement  "		if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)") " is 124.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,Deobfuscate,The length of the statement  "			initializedDataCreator.AddInitializeArrayCode (block' info.start' info.len' info.arrayType.ToTypeDefOrRef ()' decrypted); " is 121.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,GetResource,The length of the statement  "			resource = DotNetUtils.GetResource (module' Encoding.UTF8.GetString (Convert.FromBase64String (name))) as EmbeddedResource; " is 123.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DetectInternal,The length of the statement  "	int sum = ToInt32 (methodsDecrypter.Detected) + ToInt32 (stringDecrypter.Detected) + ToInt32 (tamperDetection.Detected) + ToInt32 (proxyCallFixer.Detected) + ToInt32 (constantsDecrypter.Detected); " is 196.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,ScanForObfuscator,The length of the statement  "	foundObfuscatorUserString = Utils.StartsWith (module.ReadUserString (0x70000001)' "\u0011\"3D9B94A98B-76A8-4810-B1A0-4BE7C4F9C98D"' StringComparison.Ordinal); " is 158.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "		int32ValueInliner.Add (constantsDecrypter.Int32Decrypter' (method' gim' args) => constantsDecrypter.DecryptInt32 ((int)args [0])); " is 130.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "		int64ValueInliner.Add (constantsDecrypter.Int64Decrypter' (method' gim' args) => constantsDecrypter.DecryptInt64 ((int)args [0])); " is 130.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "		singleValueInliner.Add (constantsDecrypter.SingleDecrypter' (method' gim' args) => constantsDecrypter.DecryptSingle ((int)args [0])); " is 133.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "		doubleValueInliner.Add (constantsDecrypter.DoubleDecrypter' (method' gim' args) => constantsDecrypter.DecryptDouble ((int)args [0])); " is 133.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DumpEmbeddedAssemblies,The length of the statement  "		DumpEmbeddedFile (info.resource' info.assemblyName' ".dll"' string.Format ("Embedded assembly: {0}"' info.assemblyName)); " is 121.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DumpEmbeddedAssemblies,The length of the statement  "			DumpEmbeddedFile (info.symbolsResource' info.assemblyName' ".pdb"' string.Format ("Embedded pdb: {0}"' info.assemblyName)); " is 123.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DumpEmbeddedFile,The length of the statement  "	DeobfuscatedFile.CreateAssemblyFile (resourceDecrypter.Decrypt (resource.GetResourceStream ())' Utils.GetAssemblySimpleName (assemblyName)' extension); " is 151.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,InlinedMethodTypes,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\InlinedMethodTypes.cs,IsValidType,The length of the statement  "	if (type.Attributes != (TypeAttributes.NotPublic | TypeAttributes.AutoLayout | TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.AnsiClass)) " is 152.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,Decrypt,The length of the statement  "	Logger.v ("Restored method {0} ({1:X8}). Instrs:{2}' Locals:{3}' Exceptions:{4}"' Utils.RemoveNewlines (encMethod.FullName)' encMethod.MDToken.ToInt32 ()' encMethod.Body.Instructions.Count' encMethod.Body.Variables.Count' encMethod.Body.ExceptionHandlers.Count); " is 262.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,CheckCctor,The length of the statement  "		var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Call); " is 121.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,FindDesktopOrCompactFrameworkV1,The length of the statement  "			if (!DotNetUtils.CallsMethod (method' "System.Void"' "(System.Array'System.Int32'System.Array'System.Int32'System.Int32)")) " is 123.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,MergeResources,The length of the statement  "	DeobUtils.DecryptAndAddResources (module' resource.Name.String' () => resourceDecrypter.Decrypt (resource.Data.CreateStream ())); " is 129.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,CheckSetupMethod,The length of the statement  "		if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)") " is 124.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindCompactFramework,The length of the statement  "	if (DotNetUtils.CallsMethod (method' "System.Byte[]"' "(System.Reflection.Assembly)") && DotNetUtils.CallsMethod (method' "System.String"' "(System.Reflection.Assembly)")) { " is 173.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindCompactFramework,The length of the statement  "	} else if (DotNetUtils.CallsMethod (method' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()") && DotNetUtils.CallsMethod (method' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()")) { " is 223.
Long Statement,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,The length of the statement  "		var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld); " is 135.
Long Statement,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,The length of the statement  "		if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)") " is 171.
Long Statement,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The length of the statement  "			if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)") " is 171.
Long Statement,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV3Old,The length of the statement  "	return DotNetUtils.CallsMethod (method' "System.Int32 System.IO.Stream::Read(System.Byte[]'System.Int32'System.Int32)") && !DotNetUtils.CallsMethod (method' "System.Int32 System.IO.Stream::ReadByte()") && // Obfuscated System.Int32 System.IO.Stream::ReadByte() " is 260.
Long Statement,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckResolverInitMethodInternal,The length of the statement  "	return DotNetUtils.CallsMethod (resolverInitMethod' "System.Void System.AppDomain::add_AssemblyResolve(System.ResolveEventHandler)"); " is 133.
Long Statement,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckHandlerV4,The length of the statement  "		if (!DotNetUtils.IsMethod (decryptMethodTmp' "System.Reflection.Assembly"' "(System.RuntimeFieldHandle'System.Int32'System.Int32)")) " is 132.
Long Statement,de4dot.code.deobfuscators.DeepSea,CastDeobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\CastDeobfuscator.cs,Deobfuscate,The length of the statement  "					AddCast (block' castIndex' i + 1' instr.Instruction.GetArgumentType (blocks.Method.MethodSig' blocks.Method.DeclaringType)); " is 124.
Long Statement,de4dot.code.deobfuscators.DeepSea,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectInternal,The length of the statement  "	int sum = ToInt32 (stringDecrypter.Detected) + ToInt32 (resourceResolver.Detected) + ToInt32 (assemblyResolver.Detected); " is 121.
Long Statement,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,InlineMethod,The length of the statement  "	var patcher = TryInlineOtherMethod (instrIndex' methodToInline' methodToInline.Body.Instructions [index]' index + 1' 2); " is 120.
Long Statement,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,EmulateInstructions,The length of the statement  "		if (!foundOpCodes.ContainsKey (Code.Brtrue) && !foundOpCodes.ContainsKey (Code.Brtrue_S) && !foundOpCodes.ContainsKey (Code.Brfalse) && !foundOpCodes.ContainsKey (Code.Brfalse_S)) " is 179.
Long Statement,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,Initialize,The length of the statement  "				var newField = module.UpdateRowId (new FieldDefUser (structField.Name' structField.FieldSig.Clone ()' structField.Attributes)); " is 127.
Long Statement,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,CheckMethods,The length of the statement  "		if (type.BaseType != null && type.BaseType.FullName == "System.Object" && method.Name == ".ctor" && method.MethodSig.GetParamCount () == 0) " is 139.
Long Statement,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckResolverInitMethodInternal,The length of the statement  "	return DotNetUtils.CallsMethod (resolverInitMethod' "System.Void System.AppDomain::add_ResourceResolve(System.ResolveEventHandler)"); " is 133.
Long Statement,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,DecryptResource,The length of the statement  "	string name = string.Format ("Embedded data field {0:X8} RVA {1:X8}"' resourceField.MDToken.ToInt32 ()' (uint)resourceField.RVA); " is 129.
Long Statement,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,RemoveInitializeArrayCall,The length of the statement  "		if (calledMethod.ToString () != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)") " is 150.
Long Statement,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "		staticStringInliner.Add (info.method' (method' gim' args) => stringDecrypter.Decrypt (method' (string)args [0]' (int)args [1])); " is 128.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecryptMethod,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecryptMethod.cs,CouldBeDecryptMethod,The length of the statement  "	if (!localTypes.Exists ("System.Security.Cryptography.RijndaelManaged") && !localTypes.Exists ("System.Security.Cryptography.AesManaged")) " is 138.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v3,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\Deobfuscator.cs,DumpUnpackedFiles,The length of the statement  "		DeobfuscatedFile.CreateAssemblyFile (unpackedFile.data' Win32Path.GetFileNameWithoutExtension (unpackedFile.filename)' Win32Path.GetExtension (unpackedFile.filename)); " is 167.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v3,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\Deobfuscator.cs,DumpResourceFiles,The length of the statement  "		DeobfuscatedFile.CreateAssemblyFile (resource.GetResourceData ()' Utils.GetAssemblySimpleName (mod.Assembly.FullName)' DeobUtils.GetExtension (mod.Kind)); " is 154.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,CheckFields,The length of the statement  "	return fieldTypes.Count ("System.Boolean") == 1 && (fieldTypes.Count ("System.Collections.Hashtable") == 1 || fieldTypes.Count ("System.Object") == 1); " is 151.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The length of the statement  "	int sum = ToInt32 (methodsDecrypter.Detected) + ToInt32 (stringDecrypter.Detected) + ToInt32 (booleanDecrypter.Detected) + ToInt32 (assemblyResolver.Detected) + ToInt32 (resourceResolver.Detected); " is 197.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The length of the statement  "		bool callsReverse = DotNetUtils.CallsMethod (methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)"); " is 121.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The length of the statement  "		bool hasSymmetricAlgorithm = new LocalTypes (methodsDecrypter.Method).Exists ("System.Security.Cryptography.SymmetricAlgorithm"); " is 129.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,MetadataTokenObfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MetadataTokenObfuscator.cs,Deobfuscate,The length of the statement  "			instrs [i + 1] = new Instr (new Instruction (OpCodes.Ldtoken' module.ResolveToken (token' gpContext) as ITokenOperand)); " is 120.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,EncryptNativeMethods,The length of the statement  "		Logger.v ("Native method {0:X8}' code RVA {1:X8}"' new MDToken (Table.Method' moduleWriter.MetaData.GetRid (method)).Raw' codeRva); " is 131.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,GetCompileMethodType,The length of the statement  "	if (DotNetUtils.IsMethod (method' "System.UInt32"' "(System.UInt64&'System.IntPtr'System.IntPtr'System.UInt32'System.IntPtr&'System.UInt32&)")) " is 143.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,GetCompileMethodType,The length of the statement  "	if (DotNetUtils.IsMethod (method' "System.UInt32"' "(System.IntPtr'System.IntPtr'System.IntPtr'System.UInt32'System.IntPtr'System.UInt32&)")) " is 141.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,Find,The length of the statement  "			if (!DotNetUtils.IsMethod (method' "System.Reflection.Assembly"' "(System.Object'System.ResolveEventArgs)") && !DotNetUtils.IsMethod (method' "System.Reflection.Assembly"' "(System.Object'System.Object)")) " is 205.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,InitializeEmbeddedFiles,The length of the statement  "			throw new ApplicationException (string.Format ("Could not find resource {0}"' Utils.ToCsharpString (info.ResourceName))); " is 121.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "		var CompileAssemblyFromDom1 = GetTheOnlyMethod (nestedType' "System.CodeDom.Compiler.CodeDomProvider"' "CompileAssemblyFromDom"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.CodeDom.CodeCompileUnit[]"); " is 251.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "		var CompileAssemblyFromFile1 = GetTheOnlyMethod (nestedType' "System.CodeDom.Compiler.CodeDomProvider"' "CompileAssemblyFromFile"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 236.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "		var CompileAssemblyFromSource1 = GetTheOnlyMethod (nestedType' "System.CodeDom.Compiler.CodeDomProvider"' "CompileAssemblyFromSource"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 240.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "		var CompileAssemblyFromDom2 = GetTheOnlyMethod (nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromDom"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.CodeDom.CodeCompileUnit"); " is 247.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "		var CompileAssemblyFromDomBatch2 = GetTheOnlyMethod (nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromDomBatch"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.CodeDom.CodeCompileUnit[]"); " is 259.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "		var CompileAssemblyFromFile2 = GetTheOnlyMethod (nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromFile"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String"); " is 232.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "		var CompileAssemblyFromFileBatch2 = GetTheOnlyMethod (nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromFileBatch"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 244.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "		var CompileAssemblyFromSource2 = GetTheOnlyMethod (nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromSource"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String"); " is 236.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "		var CompileAssemblyFromSourceBatch2 = GetTheOnlyMethod (nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromSourceBatch"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 248.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The length of the statement  "		if (CompileAssemblyFromDom1 == null && CompileAssemblyFromFile1 == null && CompileAssemblyFromSource1 == null && CompileAssemblyFromDom2 == null && CompileAssemblyFromDomBatch2 == null && CompileAssemblyFromFile2 == null && CompileAssemblyFromFileBatch2 == null && CompileAssemblyFromSource2 == null && CompileAssemblyFromSourceBatch2 == null) { " is 345.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_CodeDomProvider_CompileAssemblyFromDom,The length of the statement  "	Add (oldMethod' builder.InstanceMethod ("CompileAssemblyFromDom"' CodeDomProvider' CompilerResults' CompilerParameters' CodeCompileUnitArray)); " is 143.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_CodeDomProvider_CompileAssemblyFromFile,The length of the statement  "	Add (oldMethod' builder.InstanceMethod ("CompileAssemblyFromFile"' CodeDomProvider' CompilerResults' CompilerParameters' StringArray)); " is 135.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_CodeDomProvider_CompileAssemblyFromSource,The length of the statement  "	Add (oldMethod' builder.InstanceMethod ("CompileAssemblyFromSource"' CodeDomProvider' CompilerResults' CompilerParameters' StringArray)); " is 137.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromDom,The length of the statement  "	Add (oldMethod' builder.InstanceMethod ("CompileAssemblyFromDom"' ICodeCompiler' CompilerResults' CompilerParameters' CodeCompileUnit)); " is 136.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromDomBatch,The length of the statement  "	Add (oldMethod' builder.InstanceMethod ("CompileAssemblyFromDomBatch"' ICodeCompiler' CompilerResults' CompilerParameters' CodeCompileUnitArray)); " is 146.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromFile,The length of the statement  "	Add (oldMethod' builder.InstanceMethod ("CompileAssemblyFromFile"' ICodeCompiler' CompilerResults' CompilerParameters' builder.String)); " is 136.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromFileBatch,The length of the statement  "	Add (oldMethod' builder.InstanceMethod ("CompileAssemblyFromFileBatch"' ICodeCompiler' CompilerResults' CompilerParameters' StringArray)); " is 138.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromSource,The length of the statement  "	Add (oldMethod' builder.InstanceMethod ("CompileAssemblyFromSource"' ICodeCompiler' CompilerResults' CompilerParameters' builder.String)); " is 138.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,Add_ICodeCompiler_CompileAssemblyFromSourceBatch,The length of the statement  "	Add (oldMethod' builder.InstanceMethod ("CompileAssemblyFromSourceBatch"' ICodeCompiler' CompilerResults' CompilerParameters' StringArray)); " is 140.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod1,The length of the statement  "	return BinOp3 (BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [0].DeclaringType.MDToken.ToInt32 ()' efConstMethods [4].DeclaringType.MDToken.ToInt32 ()))' ConstMethod6 ()); " is 209.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod2,The length of the statement  "	return BinOp1 (efConstMethods [2].DeclaringType.MDToken.ToInt32 ()' efConstMethods [3].DeclaringType.MDToken.ToInt32 () ^ BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' ConstMethod4 ()))); " is 263.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod3,The length of the statement  "	return BinOp3 (BinOp1 (ConstMethod2 () ^ i1' efConstMethods [3].DeclaringType.MDToken.ToInt32 ())' BinOp2 (efConstMethods [0].DeclaringType.MDToken.ToInt32 () ^ efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' i2)); " is 219.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod4,The length of the statement  "	return BinOp3 (efConstMethods [3].DeclaringType.MDToken.ToInt32 ()' BinOp1 (efConstMethods [0].DeclaringType.MDToken.ToInt32 ()' BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [2].DeclaringType.MDToken.ToInt32 ()' BinOp1 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' efConstMethods [5].DeclaringType.MDToken.ToInt32 ()))))); " is 369.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod5,The length of the statement  "	return BinOp2 (BinOp2 (ConstMethod3 ()' BinOp1 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' ConstMethod2 ()))' efConstMethods [5].DeclaringType.MDToken.ToInt32 ()); " is 173.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod6,The length of the statement  "	return BinOp1 (efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' BinOp3 (BinOp2 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' efConstMethods [0].DeclaringType.MDToken.ToInt32 ())' BinOp3 (efConstMethods [2].DeclaringType.MDToken.ToInt32 () ^ i3' ConstMethod5 ()))); " is 276.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,DetectInternal,The length of the statement  "	int sum = ToInt32 (stringDecrypter.Detected) + ToInt32 (assemblyResolver.Detected) + ToInt32 (resourceResolver.Detected); " is 121.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,StringDecrypterBugWorkaround,The length of the statement  "	if (!Operations.KeepObfuscatorTypes || Operations.DecryptStrings == OpDecryptString.None || (Operations.RenamerFlags & (RenamerFlags.RenameNamespaces | RenamerFlags.RenameTypes)) != 0) " is 184.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,StringDecrypterBugWorkaround,The length of the statement  "	var newType = module.UpdateRowId (new TypeDefUser (Guid.NewGuid ().ToString ("B")' module.CorLibTypes.Object.TypeDefOrRef)); " is 124.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,StringDecrypterBugWorkaround,The length of the statement  "	var newMethod = module.UpdateRowId (new MethodDefUser ("x"' MethodSig.CreateStatic (module.CorLibTypes.Void)' 0' MethodAttributes.Static | MethodAttributes.HideBySig)); " is 168.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DynocodeService,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DynocodeService.cs,CreateEnumerator,The length of the statement  "	foreach (var method in ienumerable.GetType ().GetMethods (BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) { " is 158.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DynocodeService,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DynocodeService.cs,FindEnumeratorMethods,The length of the statement  "	foreach (var method in ienumerable.GetType ().GetMethods (BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) { " is 158.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\ResourceResolver.cs,MergeResources,The length of the statement  "			throw new ApplicationException (string.Format ("Could not find resource assembly {0}"' Utils.ToCsharpString (asmName))); " is 120.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,CheckType,The length of the statement  "		return DotNetUtils.FindFieldType (type' "System.IO.BinaryReader"' true) != null && DotNetUtils.FindFieldType (type' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' true) != null; " is 201.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,CheckDecrypterMethod,The length of the statement  "		if (calledMethod != null && calledMethod.FullName == "System.IO.Stream System.Reflection.Assembly::GetManifestResourceStream(System.String)") " is 141.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindResourceFromStringBuilder,The length of the statement  "	int endIndex = EfUtils.FindOpCodeIndex (method' startIndex' Code.Call' "System.String System.Text.StringBuilder::ToString()"); " is 126.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindResourceFromStringBuilder,The length of the statement  "		if (instr.OpCode.Code == Code.Call && instr.Operand.ToString () == "System.Text.StringBuilder System.Text.StringBuilder::Append(System.Char)") { " is 144.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInts,The length of the statement  "			if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType () != ElementType.I4) " is 126.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInts,The length of the statement  "			if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType () != ElementType.I4) " is 126.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindCallReadInt16,The length of the statement  "	return FindCall (stringMethod' ref index' streamHelperType == null ? "System.Int16 System.IO.BinaryReader::ReadInt16()" : streamHelperType.readInt16Method.FullName); " is 165.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindCallReadInt32,The length of the statement  "	return FindCall (stringMethod' ref index' streamHelperType == null ? "System.Int32 System.IO.BinaryReader::ReadInt32()" : streamHelperType.readInt32Method.FullName); " is 165.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindCallReadBytes,The length of the statement  "	return FindCall (stringMethod' ref index' streamHelperType == null ? "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)" : streamHelperType.readBytesMethod.FullName); " is 178.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindCallGetFrame,The length of the statement  "	return FindCall (method' ref index' "System.Diagnostics.StackFrame System.Diagnostics.StackTrace::GetFrame(System.Int32)"); " is 123.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals11 = CreateLocalsArray ("System.Boolean"' "System.Byte[]"' "System.Char[]"' "System.Int16"' "System.Int32"' "System.Reflection.Assembly"' "System.String"); " is 165.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 35 && decryptStringMethod.Body.MaxStack <= 50 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals11) && CheckTypeFields (fields11)) { " is 431.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals13 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Int16"' "System.Int32"' "System.Reflection.Assembly"' "System.String"); " is 180.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 35 && decryptStringMethod.Body.MaxStack <= 50 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals13) && CheckTypeFields (fields13)) { " is 431.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals14 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Int16"' "System.Int32"' "System.Reflection.Assembly"' "System.String"); " is 180.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 150 && decryptStringMethod.Body.MaxStack <= 200 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals14) && CheckTypeFields (fields14)) { " is 433.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals24 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Int16"' "System.Int32"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.String"); " is 214.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals24) && CheckTypeFields (fields24)) { " is 429.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals26 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' "System.Int16"' "System.Int32"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.String"); " is 285.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).Exactly (locals26) && CheckTypeFields (fields26)) { " is 430.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals27 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' "System.Int16"' "System.Int32"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.String"); " is 285.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).Exactly (locals27) && CheckTypeFields (fields27)) { " is 429.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals28 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' "System.Int16"' "System.Int32"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.String"); " is 285.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).Exactly (locals28) && CheckTypeFields (fields28)) { " is 431.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals29 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type"); " is 418.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals29) && CheckTypeFields (fields29)) { " is 490.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals30 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type"); " is 418.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals30) && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals30) && CheckTypeFields (fields30)) { " is 711.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals31 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type"); " is 418.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals31) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals31) && CheckTypeFields (fields31)) { " is 710.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	var locals32 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type"); " is 434.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals32) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals32) && CheckTypeFields (fields32)) { " is 709.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type"); " is 434.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 1 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) { " is 709.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type"); " is 386.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) { " is 692.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type"); " is 419.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) { " is 705.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type"); " is 473.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) { " is 630.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type"); " is 457.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) { " is 630.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The length of the statement  "		if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) { " is 521.
Long Statement,de4dot.code.deobfuscators.Goliath_NET,ArrayValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\ArrayValueInliner.cs,InlineReturnValues,The length of the statement  "		initializedDataCreator.AddInitializeArrayCode (block' callResult.callStartIndex' num' module.CorLibTypes.Byte.TypeDefOrRef' arrayData); " is 135.
Long Statement,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Decrypt,The length of the statement  "		decryptedData [i] = (byte)(encryptedData [KEY_LEN + i] ^ encryptedData [(encryptedData [j] + encryptedData [ki]) % (KEY_LEN - 1)]); " is 131.
Long Statement,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DetectInternal,The length of the statement  "	int sum = ToInt32 (stringDecrypter.Detected) + ToInt32 (integerDecrypter.Detected) + ToInt32 (arrayDecrypter.Detected) + ToInt32 (strongNameChecker.Detected) + ToInt32 (HasMetadataStream ("#GOLIATH")); " is 201.
Long Statement,de4dot.code.deobfuscators.Goliath_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\ProxyCallFixer.cs,Find,The length of the statement  "			Logger.v ("Field: {0}' Opcode: {1}' Method: {2} ({3:X8})"' Utils.RemoveNewlines (di.field.Name)' di.callOpcode' Utils.RemoveNewlines (di.methodRef)' di.methodRef.MDToken.ToUInt32 ()); " is 183.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,Decrypt,The length of the statement  "		throw new ApplicationException (string.Format ("Probably a new version. Could not decrypt method. ID:{0}' RID:{1:X4}"' methodId' rid)); " is 135.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The length of the statement  "		return CreateDecrypterV1_0_7_0 () ?? CreateDecrypterV2_0_0_0 () ?? CreateDecrypterV2_0_8_0 () ?? CreateDecrypterV2_0_8_5 () ?? CreateDecrypterV2_0_9_0 (); " is 154.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,FindDelegateFieldV1_0_7_0,The length of the statement  "	return FindDelegateField (mainType' "System.Boolean"' "(System.Int32'System.Int32'System.Int32'System.Byte*&'System.Int32&)"); " is 126.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,FindDelegateFieldV2_0_0_0,The length of the statement  "	return FindDelegateField (mainType' "System.Boolean"' "(System.Int32'System.Int32'System.Int32'System.Int32'System.Byte*&'System.Int32&)"); " is 139.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,FindDelegateFieldV2_0_8_0,The length of the statement  "	return FindDelegateField (mainType' "System.Boolean"' string.Format ("(System.Int32'System.Int32'System.Int32'System.Int32'{0}'System.Delegate&)"' type.FullName)); " is 163.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,FindDelegateFieldV2_0_8_5,The length of the statement  "	return FindDelegateField (mainType' "System.Boolean"' string.Format ("(System.Int32'System.Int32'System.Int32'System.Int32'System.Diagnostics.StackTrace'{0}'System.Delegate&)"' type.FullName)); " is 193.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,FindDelegateFieldV2_0_9_0,The length of the statement  "	return FindDelegateField (mainType' "System.Boolean"' string.Format ("(System.Int32'System.Int32'System.Int32'System.Int32'System.Diagnostics.StackTrace'{0})"' type.FullName)); " is 176.
Long Statement,de4dot.code.deobfuscators.ILProtector,DynamicMethodsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsRestorer.cs,DecryptInternal,The length of the statement  "		MethodReaderHasDelegateTypeFlag = (bool)client.GenericService.SendMessage (DynamicMethodsDecrypterService.MSG_HAS_DELEGATE_TYPE_FLAG' new object[0]); " is 149.
Long Statement,de4dot.code.deobfuscators.ILProtector,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodsDecrypterBase.cs,RestoreMethods,The length of the statement  "				Logger.v ("Restored method {0} ({1:X8}). Instrs:{2}' Locals:{3}' Exceptions:{4}"' Utils.RemoveNewlines (method.FullName)' method.MDToken.ToInt32 ()' method.Body.Instructions.Count' method.Body.Variables.Count' method.Body.ExceptionHandlers.Count); " is 247.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The length of the statement  "		int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64; " is 150.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The length of the statement  "	uint x = (uint)((gen1 [(byte)(val >> 24)] << 24) | (gen2 [(byte)(val >> 16)] << 16) | (gen3 [(byte)(val >> 8)] << 8) | gen4 [(byte)val]); " is 137.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptMethods,The length of the statement  "	var methodInfos = new MethodInfos (module' decrypterInfo.mainType' peImage' decrypterInfo.peHeader' decrypterInfo.mcKey); " is 121.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptMethods,The length of the statement  "		var mbHeader = MethodBodyParser.ParseMethodBody (MemoryImageStream.Create (info.body)' out dm.code' out dm.extraSections); " is 122.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptResources,The length of the statement  "	if (resourceRva != (uint)peImage.Cor20Header.Resources.VirtualAddress || resourceSize != peImage.Cor20Header.Resources.Size) { " is 126.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptStrings,The length of the statement  "	peImage.RvaToOffset (usHeapRva) != (uint)usHeap.StartOffset || usHeapSize != (uint)(usHeap.EndOffset - usHeap.StartOffset)) { " is 125.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptStrings,The length of the statement  "			Logger.v ("Decrypted string: {0}"' Utils.ToCsharpString (Encoding.Unicode.GetString (fileData' usHeapOffsetString' stringDataLength - 1))); " is 139.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,FindDecryptMethod,The length of the statement  "		if (!DotNetUtils.CallsMethod (method' "System.String System.Runtime.InteropServices.Marshal::PtrToStringAnsi(System.IntPtr)")) " is 126.
Long Statement,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The length of the statement  "		var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]); " is 203.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolver.cs,RemoveDecryptedResource,The length of the statement  "		throw new ApplicationException (string.Format ("Could not remove resource {0}"' Utils.ToCsharpString (info.resourceName))); " is 123.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolverInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolverInfo.cs,CheckResolverType,The length of the statement  "	if (DotNetUtils.FindFieldType (type' "System.Collections.Hashtable"' true) != null || DotNetUtils.FindFieldType (type' "System.Collections.Generic.Dictionary`2<System.String'System.Reflection.Assembly>"' true) != null) " is 218.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The length of the statement  "	approxVersion = new Version (int.Parse (val.Groups [2].ToString ())' int.Parse (val.Groups [3].ToString ())' int.Parse (val.Groups [4].ToString ())' int.Parse (val.Groups [5].ToString ())); " is 189.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,GetResolverHandlers,The length of the statement  "		var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt); " is 138.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The length of the statement  "		resourceDecrypter = new ResourceDecrypter (new ResourceDecrypterInfo (module' simpleZipTypeMethod' simpleDeobfuscator)); " is 120.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindStringsResource,The length of the statement  "		stringsResource = DotNetUtils.GetResource (module' (module.Mvid ?? Guid.NewGuid ()).ToString ("B")) as EmbeddedResource; " is 120.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindDecrypterMethod,The length of the statement  "	var methods = new List<MethodDef> (DotNetUtils.FindMethods (stringsEncodingClass.Methods' "System.String"' new string[] { " is 121.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,StringEncoderClassFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringEncoderClassFinder.cs,CouldBeStringDecrypterClass,The length of the statement  "	if (fields.Exists ("System.Collections.Hashtable") || fields.Exists ("System.Collections.Generic.Dictionary`2<System.Int32'System.String>") || fields.Exactly (fields3x)) { " is 171.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindFirstBlocks,The length of the statement  "	int start = FindCallMethod (block' index' true' calledMethod => calledMethod.ToString () == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()"); " is 173.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindFirstBlocks,The length of the statement  "	index = FindCallMethod (block' index' false' calledMethod => calledMethod.ToString () == "System.String System.Reflection.Assembly::get_Location()"); " is 149.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,RemoveTamperProtection,The length of the statement  "			Logger.w ("Could not remove tamper protection code: {0} ({1:X8})"' Utils.RemoveNewlines (blocks.Method)' blocks.Method.MDToken.ToUInt32 ()); " is 140.
Long Statement,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,RemoveInlinedMethods,The length of the statement  "	var unusedMethods = new UnusedMethodsFinder (module' methodCallInliner.GetInlinedMethods ()' GetRemovedMethods ()).Find (); " is 123.
Long Statement,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,IsWinFormType,The length of the statement  "		if (baseType.FullName == "System.Windows.Forms.Control" || baseType.FullName == "System.Windows.Forms.Form" || baseType.FullName == "System.Windows.Forms.UserControl") " is 167.
Long Statement,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,Rename,The length of the statement  "	Logger.v ("Restoring resource name: '{0}' => '{1}'"' Utils.RemoveNewlines (resource.Name)' Utils.RemoveNewlines (newName)); " is 123.
Long Statement,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,RestoreMethodBodies,The length of the statement  "		Logger.v ("Restored method body {0:X8} from method {1:X8}"' method.MDToken.ToInt32 ()' calledMethod.MDToken.ToInt32 ()); " is 120.
Long Statement,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CheckCctor,The length of the statement  "		var instrs = DotNetUtils.GetInstructions (instructions' i + 1' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call); " is 123.
Long Statement,de4dot.code.deobfuscators.Xenocode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,DeobfuscateBegin,The length of the statement  "	staticStringInliner.Add (stringDecrypter.Method' (method' gim' args) => stringDecrypter.Decrypt ((string)args [0]' (int)args [1])); " is 131.
Long Statement,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The length of the statement  "		char c = (char)((es [i] - 'a') + ((es [i + 1] - 'a') << 4) + ((es [i + 2] - 'a') << 8) + ((es [i + 3] - 'a') << 12) - magic); " is 125.
Long Statement,de4dot.code.renamer.asmmodules,Module,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\Module.cs,ResolveAllRefs,The length of the statement  "					Logger.w ("Could not find field {0} in attribute {1} ({2:X8})"' Utils.ToCsharpString (namedArg.Name)' Utils.ToCsharpString (typeDef.TypeDef.Name)' typeDef.TypeDef.MDToken.ToInt32 ()); " is 183.
Long Statement,de4dot.code.renamer.asmmodules,Module,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\Module.cs,ResolveAllRefs,The length of the statement  "					Logger.w ("Could not find property {0} in attribute {1} ({2:X8})"' Utils.ToCsharpString (namedArg.Name)' Utils.ToCsharpString (typeDef.TypeDef.Name)' typeDef.TypeDef.MDToken.ToInt32 ()); " is 186.
Long Statement,de4dot.code.renamer.asmmodules,Modules,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\Modules.cs,ResolveType,The length of the statement  "	Logger.e ("Could not resolve TypeRef {0} ({1:X8}) (from {2} -> {3})"' Utils.RemoveNewlines (typeRef)' typeRef.MDToken.ToInt32 ()' typeRef.Module' typeRef.Scope); " is 161.
Long Statement,de4dot.code.renamer.asmmodules,Modules,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\Modules.cs,ResolveMethod,The length of the statement  "	Logger.e ("Could not resolve MethodRef {0} ({1:X8}) (from {2} -> {3})"' Utils.RemoveNewlines (methodRef)' methodRef.MDToken.ToInt32 ()' methodRef.DeclaringType.Module' methodRef.DeclaringType.Scope); " is 199.
Long Statement,de4dot.code.renamer.asmmodules,Modules,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\Modules.cs,ResolveField,The length of the statement  "	Logger.e ("Could not resolve FieldRef {0} ({1:X8}) (from {2} -> {3})"' Utils.RemoveNewlines (fieldRef)' fieldRef.MDToken.ToInt32 ()' fieldRef.DeclaringType.Module' fieldRef.DeclaringType.Scope); " is 194.
Long Statement,de4dot.code.renamer.asmmodules,MTypeDef,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,InitializeInterfaceMethods,The length of the statement  "			if (!TypeDef.IsImport && !HasAttribute ("System.Runtime.InteropServices.ComImportAttribute") && !HasAttribute ("System.Runtime.InteropServices.TypeLibTypeAttribute")) { " is 168.
Long Statement,de4dot.code.renamer.asmmodules,MTypeDef,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,InitializeInterfaceMethods,The length of the statement  "				Logger.w ("Could not find interface method {0} ({1:X8}). Type: {2} ({3:X8})"' Utils.RemoveNewlines (pair.Key.methodDef.MethodDef)' pair.Key.methodDef.MethodDef.MDToken.ToInt32 ()' Utils.RemoveNewlines (TypeDef)' TypeDef.MDToken.ToInt32 ()); " is 240.
Long Statement,de4dot.code.renamer.asmmodules,MTypeDef,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,InstantiateVirtualMembers,The length of the statement  "			virtualMethodInstances.InitializeFrom (baseType.typeDef.virtualMethodInstances' baseType.typeRef.TryGetGenericInstSig ()); " is 122.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RemoveUselessOverrides,The length of the statement  "					Logger.v ("Removed useless override from method {0} ({1:X8})' override: {2:X8}"' Utils.RemoveNewlines (method.MethodDef)' method.MethodDef.MDToken.ToInt32 ()' overrideMethod.MDToken.ToInt32 ()); " is 194.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,renameGenericParams2,The length of the statement  "			Logger.v ("GenParam: {0} => {1}"' Utils.RemoveNewlines (info.oldFullName)' Utils.RemoveNewlines (param.GenericParam.FullName)); " is 127.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RenameFields2,The length of the statement  "			Logger.v ("Field: {0} ({1:X8}) => {2}"' Utils.RemoveNewlines (fieldInfo.oldFullName)' fieldDef.FieldDef.MDToken.ToUInt32 ()' Utils.RemoveNewlines (fieldDef.FieldDef.FullName)); " is 176.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RenameProperties2,The length of the statement  "			Logger.v ("Property: {0} ({1:X8}) => {2}"' Utils.RemoveNewlines (propInfo.oldFullName)' propDef.PropertyDef.MDToken.ToUInt32 ()' Utils.RemoveNewlines (propDef.PropertyDef.FullName)); " is 182.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RenameEvents2,The length of the statement  "			Logger.v ("Event: {0} ({1:X8}) => {2}"' Utils.RemoveNewlines (eventInfo.oldFullName)' eventDef.EventDef.MDToken.ToUInt32 ()' Utils.RemoveNewlines (eventDef.EventDef.FullName)); " is 176.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RenameMethods2,The length of the statement  "			Logger.v ("Method {0} ({1:X8})"' Utils.RemoveNewlines (methodInfo.oldFullName)' methodDef.MethodDef.MDToken.ToUInt32 ()); " is 121.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RenameMethods2,The length of the statement  "				Logger.v ("Name: {0} => {1}"' Utils.RemoveNewlines (methodInfo.oldFullName)' Utils.RemoveNewlines (methodDef.MethodDef.FullName)); " is 130.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RenameMethods2,The length of the statement  "						Logger.v ("Param ({0}/{1}): {2} => {3}"' param.ParameterDef.MethodSigIndex + 1' methodDef.MethodDef.MethodSig.GetParamCount ()' Utils.RemoveNewlines (paramInfo.oldName)' Utils.RemoveNewlines (paramInfo.newName)); " is 212.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,CreatePropertyGetter,The length of the statement  "		Logger.v ("Restoring property getter {0} ({1:X8})' Property: {2} ({3:X8})"' Utils.RemoveNewlines (propMethod)' propMethod.MethodDef.MDToken.ToInt32 ()' Utils.RemoveNewlines (propDef.PropertyDef)' propDef.PropertyDef.MDToken.ToInt32 ()); " is 236.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,CreatePropertySetter,The length of the statement  "		Logger.v ("Restoring property setter {0} ({1:X8})' Property: {2} ({3:X8})"' Utils.RemoveNewlines (propMethod)' propMethod.MethodDef.MDToken.ToInt32 ()' Utils.RemoveNewlines (propDef.PropertyDef)' propDef.PropertyDef.MDToken.ToInt32 ()); " is 236.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,CreateEventAdder,The length of the statement  "		Logger.v ("Restoring event adder {0} ({1:X8})' Event: {2} ({3:X8})"' Utils.RemoveNewlines (eventMethod)' eventMethod.MethodDef.MDToken.ToInt32 ()' Utils.RemoveNewlines (eventDef.EventDef)' eventDef.EventDef.MDToken.ToInt32 ()); " is 227.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,CreateEventRemover,The length of the statement  "		Logger.v ("Restoring event remover {0} ({1:X8})' Event: {2} ({3:X8})"' Utils.RemoveNewlines (eventMethod)' eventMethod.MethodDef.MDToken.ToInt32 ()' Utils.RemoveNewlines (eventDef.EventDef)' eventDef.EventDef.MDToken.ToInt32 ()); " is 229.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,PrepareRenameMemberDefs,The length of the statement  "		else if (group.HasGetterOrSetterPropertyMethod () && GetPropertyMethodType (group.Methods [0]) != PropertyMethodType.Other) " is 123.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,PrepareRenameProperty,The length of the statement  "		newPropName = GetAvailableName (propPrefix' trySameName' group' (group2' newName) => IsPropertyAvailable (group2' newName)); " is 124.
Long Statement,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,PrepareRenameEntryPoints,The length of the statement  "			Logger.w (string.Format ("Could not find entry point. Module: {0}' Method: {1}"' module.ModuleDefMD.Location' Utils.RemoveNewlines (entryPoint))); " is 146.
Long Statement,de4dot.code.renamer,ResourceKeysRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,The length of the statement  "			case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String'System.Globalization.CultureInfo)": " is 131.
Long Statement,de4dot.code.renamer,ResourceKeysRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,The length of the statement  "			Logger.v ("Renamed resource key {0} => {1}"' Utils.ToCsharpString (info.element.Name)' Utils.ToCsharpString (info.newName)); " is 124.
Long Statement,de4dot.code.renamer,ResourceRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceRenamer.cs,RenameResourceNamesInCode,The length of the statement  "			bool renameCodeString = module.ObfuscatedFile.RenameResourcesInCode || IsCallingResourceManagerCtor (instrs' i' typeInfo); " is 122.
Long Statement,de4dot.code.renamer,ResourceRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceRenamer.cs,RenameResourceNamesInCode,The length of the statement  "				Logger.v ("Possible resource name in code: '{0}' => '{1}' in method {2}"' Utils.RemoveNewlines (codeString)' newName' Utils.RemoveNewlines (method)); " is 149.
Long Statement,de4dot.code.renamer,ResourceRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceRenamer.cs,RenameResourceNamesInCode,The length of the statement  "				Logger.v ("Renamed resource string in code: '{0}' => '{1}' ({2})"' Utils.RemoveNewlines (codeString)' newName' Utils.RemoveNewlines (method)); " is 142.
Long Statement,de4dot.code.renamer,ResourceRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceRenamer.cs,IsCallingResourceManagerCtor,The length of the statement  "		if (newobj.Operand.ToString () != "System.Void System.Resources.ResourceManager::.ctor(System.String'System.Reflection.Assembly)") " is 130.
Long Statement,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,PrepareRenameMethods2,The length of the statement  "		PrepareRenameGenericParams (methodDef.GenericParams' checker' methodDef.Owner == null ? null : methodDef.Owner.GenericParams); " is 126.
Long Statement,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,PrepareRenameMethodArgs,The length of the statement  "	if ((methodDef.Property != null && methodDef == methodDef.Property.SetMethod) || (methodDef.Event != null && (methodDef == methodDef.Event.AddMethod || methodDef == methodDef.Event.RemoveMethod))) { " is 198.
Long Statement,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitVbEventHandlers,The length of the statement  "		memberInfos.Method (handlerDef).suggestedName = string.Format ("{0}_{1}"' memberInfos.Property (propDef).newName' eventName); " is 125.
Long Statement,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitFieldEventHandlers,The length of the statement  "			memberInfos.Method (handlerMethod).suggestedName = string.Format ("{0}_{1}"' memberInfos.Field (fieldDef).newName' eventName); " is 126.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The length of the statement  "	return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]); " is 172.
Complex Conditional,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,The conditional expression  "sig != null && method.IsStatic && method.HasBody && sig.Params.Count == 2 && !method.HasGenericParameters && !DotNetUtils.HasReturnValue (method) && sig.Params [0].GetFullName () == "System.Exception" && sig.Params [1].GetFullName () == "System.Object[]""  is complex.
Complex Conditional,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLocalOpsMethods,The conditional expression  "LogicalOpShrUn != null && LogicalOpShl != null && LogicalOpShr != null && LogicalOpAnd != null && LogicalOpXor != null && LogicalOpOr != null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindComparerMethods,The conditional expression  "CompareLt != null && CompareLte != null && CompareGt != null && CompareGte != null && CompareEq != null && CompareEqz != null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticMethods,The conditional expression  "ArithmeticSubOvfUn != null && ArithmeticMulOvfUn != null && ArithmeticRemUn != null && ArithmeticRem != null && ArithmeticDivUn != null && ArithmeticDiv != null && ArithmeticMul != null && ArithmeticMulOvf != null && ArithmeticSub != null && ArithmeticSubOvf != null && ArithmeticAddOvfUn != null && ArithmeticAddOvf != null && ArithmeticAdd != null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,CheckVersion,The conditional expression  "versionField != null && versionField.IsLiteral && versionField.Constant != null && versionField.Constant.Value is string"  is complex.
Complex Conditional,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DeobfuscateEnd,The conditional expression  "!type.HasNestedTypes && !type.HasProperties && !type.HasEvents && !type.HasFields"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,DecryptData,The conditional expression  "typeCode != info.int32Type && typeCode != info.int64Type && typeCode != info.singleType && typeCode != info.doubleType && typeCode != info.stringType"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,DecryptData,The conditional expression  "typeCode != info.int32Type && typeCode != info.int64Type && typeCode != info.singleType && typeCode != info.doubleType && typeCode != info.stringType"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetCallInfo_v10_r48717,The conditional expression  "table != 0 && table != 6 && table != 0x0A && table != 0x2B"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,UnpackMainAssembly,The conditional expression  "createAssembly && asm != null && entryPointToken != 0 && info.kind == ModuleKind.NetModule"  is complex.
Complex Conditional,de4dot.code.deobfuscators.CryptoObfuscator,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AntiDebugger.cs,Find,The conditional expression  "!ContainsString (method' "debugger is activ") && !ContainsString (method' "debugger is running") && !ContainsString (method' "Debugger detected") && !ContainsString (method' "Debugger was detected") && !ContainsString (method' "{0} was detected") && !ContainsString (method' "run under") && !ContainsString (method' "run with") && !ContainsString (method' "started under") && !ContainsString (method' "{0} detected") && !ContainsString (method' "{0} found")"  is complex.
Complex Conditional,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,EmulateInstructions,The conditional expression  "!foundOpCodes.ContainsKey (Code.Brtrue) && !foundOpCodes.ContainsKey (Code.Brtrue_S) && !foundOpCodes.ContainsKey (Code.Brfalse) && !foundOpCodes.ContainsKey (Code.Brfalse_S)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,CheckMethods,The conditional expression  "type.BaseType != null && type.BaseType.FullName == "System.Object" && method.Name == ".ctor" && method.MethodSig.GetParamCount () == 0"  is complex.
Complex Conditional,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The conditional expression  "clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,FindCodeDomMethods,The conditional expression  "CompileAssemblyFromDom1 == null && CompileAssemblyFromFile1 == null && CompileAssemblyFromSource1 == null && CompileAssemblyFromDom2 == null && CompileAssemblyFromDomBatch2 == null && CompileAssemblyFromFile2 == null && CompileAssemblyFromFileBatch2 == null && CompileAssemblyFromSource2 == null && CompileAssemblyFromSourceBatch2 == null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,ResourceMethodsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\ResourceMethodsRestorer.cs,Find,The conditional expression  "getStream2 == null && getNames == null && getRefAsms == null && bitmapCtor == null && iconCtor == null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 35 && decryptStringMethod.Body.MaxStack <= 50 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals11) && CheckTypeFields (fields11)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 35 && decryptStringMethod.Body.MaxStack <= 50 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals13) && CheckTypeFields (fields13)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 150 && decryptStringMethod.Body.MaxStack <= 200 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals14) && CheckTypeFields (fields14)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals24) && CheckTypeFields (fields24)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).Exactly (locals26) && CheckTypeFields (fields26)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).Exactly (locals27) && CheckTypeFields (fields27)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).Exactly (locals28) && CheckTypeFields (fields28)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals29) && CheckTypeFields (fields29)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals30) && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals30) && CheckTypeFields (fields30)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals31) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals31) && CheckTypeFields (fields31)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals32) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals32) && CheckTypeFields (fields32)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 1 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The conditional expression  "stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,HasEmptyClassesInEveryNamespace,The conditional expression  "type.Name != "" || type.IsPublic || type.HasFields || type.HasMethods || type.HasProperties || type.HasEvents"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,CheckMethodsType,The conditional expression  "type.HasProperties || type.HasEvents || type.HasFields || type.HasNestedTypes"  is complex.
Complex Conditional,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,PrepareRenameMethodArgs,The conditional expression  "(methodDef.Property != null && methodDef == methodDef.Property.SetMethod) || (methodDef.Event != null && (methodDef == methodDef.Event.AddMethod || methodDef == methodDef.Event.RemoveMethod))"  is complex.
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "CreateNameCreator".
Empty Catch Block,de4dot.code.AssemblyClient,AssemblyClient,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\AssemblyClient.cs,WaitConnected,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,AssemblyClient,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\AssemblyClient.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,AssemblyClient,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\AssemblyClient.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,LoadServer,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,LoadServer,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,UnloadAppDomain,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,UnloadAppDomain,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewProcessAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewProcessAssemblyServerLoader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,UnpackNativeImage,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Decrypt2,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Detect,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Detect,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators,MethodStack,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodStack.cs,GetPushedArgInstructions,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Babel_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\MethodsDecrypter.cs,GetFile,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,ScanForObfuscator,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,ModuleReloaded,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetEmbeddedAssemblyInfos,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,GetResource,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,GetResourceName,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,InitializeNameAndExtension,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.ILProtector,RuntimeFileInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\RuntimeFileInfo.cs,GetVersion2,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.ILProtector,RuntimeFileInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\RuntimeFileInfo.cs,GetHash,The method has an empty catch block.
Empty Catch Block,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,HasXamlFiles,The method has an empty catch block.
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize) {  	m_DictionarySize = dictionarySize;  	m_DictionarySizeCheck = Math.Max (m_DictionarySize' 1);  	uint blockSize = Math.Max (m_DictionarySizeCheck' (1 << 12));  	m_OutWindow.Create (blockSize);  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64) {  	// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  	// while(nowPos64 < next)  	{  		uint posState = (uint)nowPos64 & m_PosStateMask;  		if (m_IsMatchDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  			byte b;  			byte prevByte = m_OutWindow.GetByte (0);  			if (!state.IsCharState ())  				b = m_LiteralDecoder.DecodeWithMatchByte (m_RangeDecoder' (uint)nowPos64' prevByte' m_OutWindow.GetByte (rep0));  			else  				b = m_LiteralDecoder.DecodeNormal (m_RangeDecoder' (uint)nowPos64' prevByte);  			m_OutWindow.PutByte (b);  			state.UpdateChar ();  			nowPos64++;  		} else {  			uint len;  			if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  				if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  					if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  						state.UpdateShortRep ();  						m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  						nowPos64++;  						continue;  					}  				} else {  					UInt32 distance;  					if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  						distance = rep1;  					} else {  						if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  							distance = rep2;  						else {  							distance = rep3;  							rep3 = rep2;  						}  						rep2 = rep1;  					}  					rep1 = rep0;  					rep0 = distance;  				}  				len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  				state.UpdateRep ();  			} else {  				rep3 = rep2;  				rep2 = rep1;  				rep1 = rep0;  				len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  				state.UpdateMatch ();  				uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  				if (posSlot >= Base.kStartPosModelIndex) {  					int numDirectBits = (int)((posSlot >> 1) - 1);  					rep0 = ((2 | (posSlot & 1)) << numDirectBits);  					if (posSlot < Base.kEndPosModelIndex)  						rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  					else {  						rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  						rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  					}  				} else  					rep0 = posSlot;  			}  			if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  				if (rep0 == 0xFFFFFFFF)  					break;  				throw new DataErrorException ();  			}  			m_OutWindow.CopyBlock (rep0' len);  			nowPos64 += len;  		}  	}  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: if (m_IsMatchDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  	byte b;  	byte prevByte = m_OutWindow.GetByte (0);  	if (!state.IsCharState ())  		b = m_LiteralDecoder.DecodeWithMatchByte (m_RangeDecoder' (uint)nowPos64' prevByte' m_OutWindow.GetByte (rep0));  	else  		b = m_LiteralDecoder.DecodeNormal (m_RangeDecoder' (uint)nowPos64' prevByte);  	m_OutWindow.PutByte (b);  	state.UpdateChar ();  	nowPos64++;  } else {  	uint len;  	if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  		if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  			if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  				state.UpdateShortRep ();  				m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  				nowPos64++;  				continue;  			}  		} else {  			UInt32 distance;  			if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  				distance = rep1;  			} else {  				if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  					distance = rep2;  				else {  					distance = rep3;  					rep3 = rep2;  				}  				rep2 = rep1;  			}  			rep1 = rep0;  			rep0 = distance;  		}  		len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  		state.UpdateRep ();  	} else {  		rep3 = rep2;  		rep2 = rep1;  		rep1 = rep0;  		len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  		state.UpdateMatch ();  		uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  		if (posSlot >= Base.kStartPosModelIndex) {  			int numDirectBits = (int)((posSlot >> 1) - 1);  			rep0 = ((2 | (posSlot & 1)) << numDirectBits);  			if (posSlot < Base.kEndPosModelIndex)  				rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  			else {  				rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  				rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  			}  		} else  			rep0 = posSlot;  	}  	if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  		if (rep0 == 0xFFFFFFFF)  			break;  		throw new DataErrorException ();  	}  	m_OutWindow.CopyBlock (rep0' len);  	nowPos64 += len;  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  	if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  		if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  			state.UpdateShortRep ();  			m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  			nowPos64++;  			continue;  		}  	} else {  		UInt32 distance;  		if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  			distance = rep1;  		} else {  			if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  				distance = rep2;  			else {  				distance = rep3;  				rep3 = rep2;  			}  			rep2 = rep1;  		}  		rep1 = rep0;  		rep0 = distance;  	}  	len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  	state.UpdateRep ();  } else {  	rep3 = rep2;  	rep2 = rep1;  	rep1 = rep0;  	len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  	state.UpdateMatch ();  	uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  	if (posSlot >= Base.kStartPosModelIndex) {  		int numDirectBits = (int)((posSlot >> 1) - 1);  		rep0 = ((2 | (posSlot & 1)) << numDirectBits);  		if (posSlot < Base.kEndPosModelIndex)  			rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  		else {  			rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  			rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  		}  	} else  		rep0 = posSlot;  }  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: if (posSlot >= Base.kStartPosModelIndex) {  	int numDirectBits = (int)((posSlot >> 1) - 1);  	rep0 = ((2 | (posSlot & 1)) << numDirectBits);  	if (posSlot < Base.kEndPosModelIndex)  		rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  	else {  		rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  		rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  	}  } else  	rep0 = posSlot;  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: rep0 = ((2 | (posSlot & 1)) << numDirectBits);  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  	throw new InvalidParamException ();  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.LZMA,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: if (range < kTopValue) {  	code = (code << 8) | (byte)Stream.ReadByte ();  	range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: if (range < kTopValue) {  	code = (code << 8) | (byte)Stream.ReadByte ();  	range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,Decoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  } else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  } else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  } else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  } else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;  
Magic Number,de4dot.code.AssemblyClient,AssemblyClient,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\AssemblyClient.cs,WaitConnected,The following statement contains a magic number: while (true) {  	try {  		service.DoNothing ();  		break;  	} catch (RemotingException) {  		// Couldn't connect  	}  	var elapsedTime = DateTime.UtcNow - startTime;  	if (elapsedTime.TotalMilliseconds >= MAX_CONNECT_WAIT_TIME_MS)  		throw new ApplicationException ("Could not connect to server");  	Thread.Sleep (20);  }  
Magic Number,de4dot.code.AssemblyClient,AssemblyClient,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\AssemblyClient.cs,WaitConnected,The following statement contains a magic number: Thread.Sleep (20);  
Magic Number,de4dot.code.AssemblyClient,NewProcessAssemblyClientFactory,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\AssemblyClientFactory.cs,GetServerClrVersion,The following statement contains a magic number: switch (module.GetPointerSize ()) {  default:  case 4:  	if (module.IsClr40)  		return ServerClrVersion.CLR_v40_x86;  	return ServerClrVersion.CLR_v20_x86;  case 8:  	if (module.IsClr40)  		return ServerClrVersion.CLR_v40_x64;  	return ServerClrVersion.CLR_v20_x64;  }  
Magic Number,de4dot.code.AssemblyClient,NewProcessAssemblyClientFactory,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\AssemblyClientFactory.cs,GetServerClrVersion,The following statement contains a magic number: switch (module.GetPointerSize ()) {  default:  case 4:  	if (module.IsClr40)  		return ServerClrVersion.CLR_v40_x86;  	return ServerClrVersion.CLR_v20_x86;  case 8:  	if (module.IsClr40)  		return ServerClrVersion.CLR_v40_x64;  	return ServerClrVersion.CLR_v20_x64;  }  
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcName = Utils.RandomName (15' 20);  
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcName = Utils.RandomName (15' 20);  
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcUri = Utils.RandomName (15' 20);  
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcUri = Utils.RandomName (15' 20);  
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,GetServerName,The following statement contains a magic number: if (serverVersion == ServerClrVersion.CLR_ANY_ANYCPU)  	serverVersion = IntPtr.Size == 4 ? ServerClrVersion.CLR_ANY_x86 : ServerClrVersion.CLR_ANY_x64;  
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,GetServerName,The following statement contains a magic number: serverVersion = IntPtr.Size == 4 ? ServerClrVersion.CLR_ANY_x86 : ServerClrVersion.CLR_ANY_x64;  
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,LoadServer,The following statement contains a magic number: appDomain = AppDomain.CreateDomain (Utils.RandomName (15' 20));  
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,LoadServer,The following statement contains a magic number: appDomain = AppDomain.CreateDomain (Utils.RandomName (15' 20));  
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,Dispose,The following statement contains a magic number: if (thread != null) {  	try {  		if (!thread.Join (100))  			thread.Abort ();  	} catch (ThreadStateException) {  		// Here if eg. the thread wasn't started  	}  	thread = null;  }  
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,Dispose,The following statement contains a magic number: try {  	if (!thread.Join (100))  		thread.Abort ();  } catch (ThreadStateException) {  	// Here if eg. the thread wasn't started  }  
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,Dispose,The following statement contains a magic number: if (!thread.Join (100))  	thread.Abort ();  
Magic Number,de4dot.code.AssemblyClient,NewProcessAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewProcessAssemblyServerLoader.cs,Dispose,The following statement contains a magic number: if (process != null) {  	if (!process.WaitForExit (300)) {  		try {  			process.Kill ();  		} catch (InvalidOperationException) {  			// Here if process has already exited.  		}  	}  	process = null;  }  
Magic Number,de4dot.code.AssemblyClient,NewProcessAssemblyServerLoader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\AssemblyClient\NewProcessAssemblyServerLoader.cs,Dispose,The following statement contains a magic number: if (!process.WaitForExit (300)) {  	try {  		process.Kill ();  	} catch (InvalidOperationException) {  		// Here if process has already exited.  	}  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  	if (index <= 0) {  		obj = null;  		return false;  	}  	var instr = block.Instructions [--index];  	if (instr.OpCode == OpCodes.Nop)  		continue;  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		obj = instr.Operand;  		return true;  	case Code.Ldc_I4_S:  		obj = (int)(sbyte)instr.Operand;  		return true;  	case Code.Ldc_I4_0:  		obj = 0;  		return true;  	case Code.Ldc_I4_1:  		obj = 1;  		return true;  	case Code.Ldc_I4_2:  		obj = 2;  		return true;  	case Code.Ldc_I4_3:  		obj = 3;  		return true;  	case Code.Ldc_I4_4:  		obj = 4;  		return true;  	case Code.Ldc_I4_5:  		obj = 5;  		return true;  	case Code.Ldc_I4_6:  		obj = 6;  		return true;  	case Code.Ldc_I4_7:  		obj = 7;  		return true;  	case Code.Ldc_I4_8:  		obj = 8;  		return true;  	case Code.Ldc_I4_M1:  		obj = -1;  		return true;  	case Code.Ldnull:  		obj = null;  		return true;  	default:  		obj = null;  		return false;  	}  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  	if (index <= 0) {  		obj = null;  		return false;  	}  	var instr = block.Instructions [--index];  	if (instr.OpCode == OpCodes.Nop)  		continue;  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		obj = instr.Operand;  		return true;  	case Code.Ldc_I4_S:  		obj = (int)(sbyte)instr.Operand;  		return true;  	case Code.Ldc_I4_0:  		obj = 0;  		return true;  	case Code.Ldc_I4_1:  		obj = 1;  		return true;  	case Code.Ldc_I4_2:  		obj = 2;  		return true;  	case Code.Ldc_I4_3:  		obj = 3;  		return true;  	case Code.Ldc_I4_4:  		obj = 4;  		return true;  	case Code.Ldc_I4_5:  		obj = 5;  		return true;  	case Code.Ldc_I4_6:  		obj = 6;  		return true;  	case Code.Ldc_I4_7:  		obj = 7;  		return true;  	case Code.Ldc_I4_8:  		obj = 8;  		return true;  	case Code.Ldc_I4_M1:  		obj = -1;  		return true;  	case Code.Ldnull:  		obj = null;  		return true;  	default:  		obj = null;  		return false;  	}  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  	if (index <= 0) {  		obj = null;  		return false;  	}  	var instr = block.Instructions [--index];  	if (instr.OpCode == OpCodes.Nop)  		continue;  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		obj = instr.Operand;  		return true;  	case Code.Ldc_I4_S:  		obj = (int)(sbyte)instr.Operand;  		return true;  	case Code.Ldc_I4_0:  		obj = 0;  		return true;  	case Code.Ldc_I4_1:  		obj = 1;  		return true;  	case Code.Ldc_I4_2:  		obj = 2;  		return true;  	case Code.Ldc_I4_3:  		obj = 3;  		return true;  	case Code.Ldc_I4_4:  		obj = 4;  		return true;  	case Code.Ldc_I4_5:  		obj = 5;  		return true;  	case Code.Ldc_I4_6:  		obj = 6;  		return true;  	case Code.Ldc_I4_7:  		obj = 7;  		return true;  	case Code.Ldc_I4_8:  		obj = 8;  		return true;  	case Code.Ldc_I4_M1:  		obj = -1;  		return true;  	case Code.Ldnull:  		obj = null;  		return true;  	default:  		obj = null;  		return false;  	}  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  	if (index <= 0) {  		obj = null;  		return false;  	}  	var instr = block.Instructions [--index];  	if (instr.OpCode == OpCodes.Nop)  		continue;  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		obj = instr.Operand;  		return true;  	case Code.Ldc_I4_S:  		obj = (int)(sbyte)instr.Operand;  		return true;  	case Code.Ldc_I4_0:  		obj = 0;  		return true;  	case Code.Ldc_I4_1:  		obj = 1;  		return true;  	case Code.Ldc_I4_2:  		obj = 2;  		return true;  	case Code.Ldc_I4_3:  		obj = 3;  		return true;  	case Code.Ldc_I4_4:  		obj = 4;  		return true;  	case Code.Ldc_I4_5:  		obj = 5;  		return true;  	case Code.Ldc_I4_6:  		obj = 6;  		return true;  	case Code.Ldc_I4_7:  		obj = 7;  		return true;  	case Code.Ldc_I4_8:  		obj = 8;  		return true;  	case Code.Ldc_I4_M1:  		obj = -1;  		return true;  	case Code.Ldnull:  		obj = null;  		return true;  	default:  		obj = null;  		return false;  	}  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  	if (index <= 0) {  		obj = null;  		return false;  	}  	var instr = block.Instructions [--index];  	if (instr.OpCode == OpCodes.Nop)  		continue;  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		obj = instr.Operand;  		return true;  	case Code.Ldc_I4_S:  		obj = (int)(sbyte)instr.Operand;  		return true;  	case Code.Ldc_I4_0:  		obj = 0;  		return true;  	case Code.Ldc_I4_1:  		obj = 1;  		return true;  	case Code.Ldc_I4_2:  		obj = 2;  		return true;  	case Code.Ldc_I4_3:  		obj = 3;  		return true;  	case Code.Ldc_I4_4:  		obj = 4;  		return true;  	case Code.Ldc_I4_5:  		obj = 5;  		return true;  	case Code.Ldc_I4_6:  		obj = 6;  		return true;  	case Code.Ldc_I4_7:  		obj = 7;  		return true;  	case Code.Ldc_I4_8:  		obj = 8;  		return true;  	case Code.Ldc_I4_M1:  		obj = -1;  		return true;  	case Code.Ldnull:  		obj = null;  		return true;  	default:  		obj = null;  		return false;  	}  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  	if (index <= 0) {  		obj = null;  		return false;  	}  	var instr = block.Instructions [--index];  	if (instr.OpCode == OpCodes.Nop)  		continue;  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		obj = instr.Operand;  		return true;  	case Code.Ldc_I4_S:  		obj = (int)(sbyte)instr.Operand;  		return true;  	case Code.Ldc_I4_0:  		obj = 0;  		return true;  	case Code.Ldc_I4_1:  		obj = 1;  		return true;  	case Code.Ldc_I4_2:  		obj = 2;  		return true;  	case Code.Ldc_I4_3:  		obj = 3;  		return true;  	case Code.Ldc_I4_4:  		obj = 4;  		return true;  	case Code.Ldc_I4_5:  		obj = 5;  		return true;  	case Code.Ldc_I4_6:  		obj = 6;  		return true;  	case Code.Ldc_I4_7:  		obj = 7;  		return true;  	case Code.Ldc_I4_8:  		obj = 8;  		return true;  	case Code.Ldc_I4_M1:  		obj = -1;  		return true;  	case Code.Ldnull:  		obj = null;  		return true;  	default:  		obj = null;  		return false;  	}  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: while (true) {  	if (index <= 0) {  		obj = null;  		return false;  	}  	var instr = block.Instructions [--index];  	if (instr.OpCode == OpCodes.Nop)  		continue;  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		obj = instr.Operand;  		return true;  	case Code.Ldc_I4_S:  		obj = (int)(sbyte)instr.Operand;  		return true;  	case Code.Ldc_I4_0:  		obj = 0;  		return true;  	case Code.Ldc_I4_1:  		obj = 1;  		return true;  	case Code.Ldc_I4_2:  		obj = 2;  		return true;  	case Code.Ldc_I4_3:  		obj = 3;  		return true;  	case Code.Ldc_I4_4:  		obj = 4;  		return true;  	case Code.Ldc_I4_5:  		obj = 5;  		return true;  	case Code.Ldc_I4_6:  		obj = 6;  		return true;  	case Code.Ldc_I4_7:  		obj = 7;  		return true;  	case Code.Ldc_I4_8:  		obj = 8;  		return true;  	case Code.Ldc_I4_M1:  		obj = -1;  		return true;  	case Code.Ldnull:  		obj = null;  		return true;  	default:  		obj = null;  		return false;  	}  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	obj = instr.Operand;  	return true;  case Code.Ldc_I4_S:  	obj = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_0:  	obj = 0;  	return true;  case Code.Ldc_I4_1:  	obj = 1;  	return true;  case Code.Ldc_I4_2:  	obj = 2;  	return true;  case Code.Ldc_I4_3:  	obj = 3;  	return true;  case Code.Ldc_I4_4:  	obj = 4;  	return true;  case Code.Ldc_I4_5:  	obj = 5;  	return true;  case Code.Ldc_I4_6:  	obj = 6;  	return true;  case Code.Ldc_I4_7:  	obj = 7;  	return true;  case Code.Ldc_I4_8:  	obj = 8;  	return true;  case Code.Ldc_I4_M1:  	obj = -1;  	return true;  case Code.Ldnull:  	obj = null;  	return true;  default:  	obj = null;  	return false;  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	obj = instr.Operand;  	return true;  case Code.Ldc_I4_S:  	obj = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_0:  	obj = 0;  	return true;  case Code.Ldc_I4_1:  	obj = 1;  	return true;  case Code.Ldc_I4_2:  	obj = 2;  	return true;  case Code.Ldc_I4_3:  	obj = 3;  	return true;  case Code.Ldc_I4_4:  	obj = 4;  	return true;  case Code.Ldc_I4_5:  	obj = 5;  	return true;  case Code.Ldc_I4_6:  	obj = 6;  	return true;  case Code.Ldc_I4_7:  	obj = 7;  	return true;  case Code.Ldc_I4_8:  	obj = 8;  	return true;  case Code.Ldc_I4_M1:  	obj = -1;  	return true;  case Code.Ldnull:  	obj = null;  	return true;  default:  	obj = null;  	return false;  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	obj = instr.Operand;  	return true;  case Code.Ldc_I4_S:  	obj = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_0:  	obj = 0;  	return true;  case Code.Ldc_I4_1:  	obj = 1;  	return true;  case Code.Ldc_I4_2:  	obj = 2;  	return true;  case Code.Ldc_I4_3:  	obj = 3;  	return true;  case Code.Ldc_I4_4:  	obj = 4;  	return true;  case Code.Ldc_I4_5:  	obj = 5;  	return true;  case Code.Ldc_I4_6:  	obj = 6;  	return true;  case Code.Ldc_I4_7:  	obj = 7;  	return true;  case Code.Ldc_I4_8:  	obj = 8;  	return true;  case Code.Ldc_I4_M1:  	obj = -1;  	return true;  case Code.Ldnull:  	obj = null;  	return true;  default:  	obj = null;  	return false;  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	obj = instr.Operand;  	return true;  case Code.Ldc_I4_S:  	obj = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_0:  	obj = 0;  	return true;  case Code.Ldc_I4_1:  	obj = 1;  	return true;  case Code.Ldc_I4_2:  	obj = 2;  	return true;  case Code.Ldc_I4_3:  	obj = 3;  	return true;  case Code.Ldc_I4_4:  	obj = 4;  	return true;  case Code.Ldc_I4_5:  	obj = 5;  	return true;  case Code.Ldc_I4_6:  	obj = 6;  	return true;  case Code.Ldc_I4_7:  	obj = 7;  	return true;  case Code.Ldc_I4_8:  	obj = 8;  	return true;  case Code.Ldc_I4_M1:  	obj = -1;  	return true;  case Code.Ldnull:  	obj = null;  	return true;  default:  	obj = null;  	return false;  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	obj = instr.Operand;  	return true;  case Code.Ldc_I4_S:  	obj = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_0:  	obj = 0;  	return true;  case Code.Ldc_I4_1:  	obj = 1;  	return true;  case Code.Ldc_I4_2:  	obj = 2;  	return true;  case Code.Ldc_I4_3:  	obj = 3;  	return true;  case Code.Ldc_I4_4:  	obj = 4;  	return true;  case Code.Ldc_I4_5:  	obj = 5;  	return true;  case Code.Ldc_I4_6:  	obj = 6;  	return true;  case Code.Ldc_I4_7:  	obj = 7;  	return true;  case Code.Ldc_I4_8:  	obj = 8;  	return true;  case Code.Ldc_I4_M1:  	obj = -1;  	return true;  case Code.Ldnull:  	obj = null;  	return true;  default:  	obj = null;  	return false;  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	obj = instr.Operand;  	return true;  case Code.Ldc_I4_S:  	obj = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_0:  	obj = 0;  	return true;  case Code.Ldc_I4_1:  	obj = 1;  	return true;  case Code.Ldc_I4_2:  	obj = 2;  	return true;  case Code.Ldc_I4_3:  	obj = 3;  	return true;  case Code.Ldc_I4_4:  	obj = 4;  	return true;  case Code.Ldc_I4_5:  	obj = 5;  	return true;  case Code.Ldc_I4_6:  	obj = 6;  	return true;  case Code.Ldc_I4_7:  	obj = 7;  	return true;  case Code.Ldc_I4_8:  	obj = 8;  	return true;  case Code.Ldc_I4_M1:  	obj = -1;  	return true;  case Code.Ldnull:  	obj = null;  	return true;  default:  	obj = null;  	return false;  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	obj = instr.Operand;  	return true;  case Code.Ldc_I4_S:  	obj = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_0:  	obj = 0;  	return true;  case Code.Ldc_I4_1:  	obj = 1;  	return true;  case Code.Ldc_I4_2:  	obj = 2;  	return true;  case Code.Ldc_I4_3:  	obj = 3;  	return true;  case Code.Ldc_I4_4:  	obj = 4;  	return true;  case Code.Ldc_I4_5:  	obj = 5;  	return true;  case Code.Ldc_I4_6:  	obj = 6;  	return true;  case Code.Ldc_I4_7:  	obj = 7;  	return true;  case Code.Ldc_I4_8:  	obj = 8;  	return true;  case Code.Ldc_I4_M1:  	obj = -1;  	return true;  case Code.Ldnull:  	obj = null;  	return true;  default:  	obj = null;  	return false;  }  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: obj = 2;  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: obj = 3;  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: obj = 4;  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: obj = 5;  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: obj = 6;  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: obj = 7;  
Magic Number,de4dot.code,VariableValues,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetValue,The following statement contains a magic number: obj = 8;  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  	if (instrIndex < 0) {  		// We're here if there were no cflow deobfuscation' or if there are two or  		// more blocks branching to the decrypter method' or the two blocks can't be  		// merged because one is outside the exception handler (eg. buggy obfuscator).  		Logger.w ("Could not find all arguments to method {0} ({1:X8})"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ());  		errors++;  		return false;  	}  	var instr = block.Instructions [instrIndex--];  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		arg = instr.Operand;  		break;  	case Code.Ldc_I4_S:  		arg = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldc_I4_0:  		arg = 0;  		break;  	case Code.Ldc_I4_1:  		arg = 1;  		break;  	case Code.Ldc_I4_2:  		arg = 2;  		break;  	case Code.Ldc_I4_3:  		arg = 3;  		break;  	case Code.Ldc_I4_4:  		arg = 4;  		break;  	case Code.Ldc_I4_5:  		arg = 5;  		break;  	case Code.Ldc_I4_6:  		arg = 6;  		break;  	case Code.Ldc_I4_7:  		arg = 7;  		break;  	case Code.Ldc_I4_8:  		arg = 8;  		break;  	case Code.Ldc_I4_M1:  		arg = -1;  		break;  	case Code.Ldnull:  		arg = null;  		break;  	case Code.Nop:  		continue;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  		break;  	case Code.Ldfld:  	case Code.Ldsfld:  		arg = instr.Operand;  		break;  	default:  		int pushes' pops;  		instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  		if (!useUnknownArgs || pushes != 1) {  			Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  			errors++;  			return false;  		}  		for (int i = 0; i < pops; i++) {  			if (!GetArg (method' block' ref arg' ref instrIndex))  				return false;  		}  		arg = null;  		break;  	}  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  	if (instrIndex < 0) {  		// We're here if there were no cflow deobfuscation' or if there are two or  		// more blocks branching to the decrypter method' or the two blocks can't be  		// merged because one is outside the exception handler (eg. buggy obfuscator).  		Logger.w ("Could not find all arguments to method {0} ({1:X8})"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ());  		errors++;  		return false;  	}  	var instr = block.Instructions [instrIndex--];  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		arg = instr.Operand;  		break;  	case Code.Ldc_I4_S:  		arg = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldc_I4_0:  		arg = 0;  		break;  	case Code.Ldc_I4_1:  		arg = 1;  		break;  	case Code.Ldc_I4_2:  		arg = 2;  		break;  	case Code.Ldc_I4_3:  		arg = 3;  		break;  	case Code.Ldc_I4_4:  		arg = 4;  		break;  	case Code.Ldc_I4_5:  		arg = 5;  		break;  	case Code.Ldc_I4_6:  		arg = 6;  		break;  	case Code.Ldc_I4_7:  		arg = 7;  		break;  	case Code.Ldc_I4_8:  		arg = 8;  		break;  	case Code.Ldc_I4_M1:  		arg = -1;  		break;  	case Code.Ldnull:  		arg = null;  		break;  	case Code.Nop:  		continue;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  		break;  	case Code.Ldfld:  	case Code.Ldsfld:  		arg = instr.Operand;  		break;  	default:  		int pushes' pops;  		instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  		if (!useUnknownArgs || pushes != 1) {  			Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  			errors++;  			return false;  		}  		for (int i = 0; i < pops; i++) {  			if (!GetArg (method' block' ref arg' ref instrIndex))  				return false;  		}  		arg = null;  		break;  	}  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  	if (instrIndex < 0) {  		// We're here if there were no cflow deobfuscation' or if there are two or  		// more blocks branching to the decrypter method' or the two blocks can't be  		// merged because one is outside the exception handler (eg. buggy obfuscator).  		Logger.w ("Could not find all arguments to method {0} ({1:X8})"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ());  		errors++;  		return false;  	}  	var instr = block.Instructions [instrIndex--];  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		arg = instr.Operand;  		break;  	case Code.Ldc_I4_S:  		arg = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldc_I4_0:  		arg = 0;  		break;  	case Code.Ldc_I4_1:  		arg = 1;  		break;  	case Code.Ldc_I4_2:  		arg = 2;  		break;  	case Code.Ldc_I4_3:  		arg = 3;  		break;  	case Code.Ldc_I4_4:  		arg = 4;  		break;  	case Code.Ldc_I4_5:  		arg = 5;  		break;  	case Code.Ldc_I4_6:  		arg = 6;  		break;  	case Code.Ldc_I4_7:  		arg = 7;  		break;  	case Code.Ldc_I4_8:  		arg = 8;  		break;  	case Code.Ldc_I4_M1:  		arg = -1;  		break;  	case Code.Ldnull:  		arg = null;  		break;  	case Code.Nop:  		continue;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  		break;  	case Code.Ldfld:  	case Code.Ldsfld:  		arg = instr.Operand;  		break;  	default:  		int pushes' pops;  		instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  		if (!useUnknownArgs || pushes != 1) {  			Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  			errors++;  			return false;  		}  		for (int i = 0; i < pops; i++) {  			if (!GetArg (method' block' ref arg' ref instrIndex))  				return false;  		}  		arg = null;  		break;  	}  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  	if (instrIndex < 0) {  		// We're here if there were no cflow deobfuscation' or if there are two or  		// more blocks branching to the decrypter method' or the two blocks can't be  		// merged because one is outside the exception handler (eg. buggy obfuscator).  		Logger.w ("Could not find all arguments to method {0} ({1:X8})"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ());  		errors++;  		return false;  	}  	var instr = block.Instructions [instrIndex--];  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		arg = instr.Operand;  		break;  	case Code.Ldc_I4_S:  		arg = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldc_I4_0:  		arg = 0;  		break;  	case Code.Ldc_I4_1:  		arg = 1;  		break;  	case Code.Ldc_I4_2:  		arg = 2;  		break;  	case Code.Ldc_I4_3:  		arg = 3;  		break;  	case Code.Ldc_I4_4:  		arg = 4;  		break;  	case Code.Ldc_I4_5:  		arg = 5;  		break;  	case Code.Ldc_I4_6:  		arg = 6;  		break;  	case Code.Ldc_I4_7:  		arg = 7;  		break;  	case Code.Ldc_I4_8:  		arg = 8;  		break;  	case Code.Ldc_I4_M1:  		arg = -1;  		break;  	case Code.Ldnull:  		arg = null;  		break;  	case Code.Nop:  		continue;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  		break;  	case Code.Ldfld:  	case Code.Ldsfld:  		arg = instr.Operand;  		break;  	default:  		int pushes' pops;  		instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  		if (!useUnknownArgs || pushes != 1) {  			Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  			errors++;  			return false;  		}  		for (int i = 0; i < pops; i++) {  			if (!GetArg (method' block' ref arg' ref instrIndex))  				return false;  		}  		arg = null;  		break;  	}  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  	if (instrIndex < 0) {  		// We're here if there were no cflow deobfuscation' or if there are two or  		// more blocks branching to the decrypter method' or the two blocks can't be  		// merged because one is outside the exception handler (eg. buggy obfuscator).  		Logger.w ("Could not find all arguments to method {0} ({1:X8})"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ());  		errors++;  		return false;  	}  	var instr = block.Instructions [instrIndex--];  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		arg = instr.Operand;  		break;  	case Code.Ldc_I4_S:  		arg = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldc_I4_0:  		arg = 0;  		break;  	case Code.Ldc_I4_1:  		arg = 1;  		break;  	case Code.Ldc_I4_2:  		arg = 2;  		break;  	case Code.Ldc_I4_3:  		arg = 3;  		break;  	case Code.Ldc_I4_4:  		arg = 4;  		break;  	case Code.Ldc_I4_5:  		arg = 5;  		break;  	case Code.Ldc_I4_6:  		arg = 6;  		break;  	case Code.Ldc_I4_7:  		arg = 7;  		break;  	case Code.Ldc_I4_8:  		arg = 8;  		break;  	case Code.Ldc_I4_M1:  		arg = -1;  		break;  	case Code.Ldnull:  		arg = null;  		break;  	case Code.Nop:  		continue;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  		break;  	case Code.Ldfld:  	case Code.Ldsfld:  		arg = instr.Operand;  		break;  	default:  		int pushes' pops;  		instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  		if (!useUnknownArgs || pushes != 1) {  			Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  			errors++;  			return false;  		}  		for (int i = 0; i < pops; i++) {  			if (!GetArg (method' block' ref arg' ref instrIndex))  				return false;  		}  		arg = null;  		break;  	}  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  	if (instrIndex < 0) {  		// We're here if there were no cflow deobfuscation' or if there are two or  		// more blocks branching to the decrypter method' or the two blocks can't be  		// merged because one is outside the exception handler (eg. buggy obfuscator).  		Logger.w ("Could not find all arguments to method {0} ({1:X8})"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ());  		errors++;  		return false;  	}  	var instr = block.Instructions [instrIndex--];  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		arg = instr.Operand;  		break;  	case Code.Ldc_I4_S:  		arg = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldc_I4_0:  		arg = 0;  		break;  	case Code.Ldc_I4_1:  		arg = 1;  		break;  	case Code.Ldc_I4_2:  		arg = 2;  		break;  	case Code.Ldc_I4_3:  		arg = 3;  		break;  	case Code.Ldc_I4_4:  		arg = 4;  		break;  	case Code.Ldc_I4_5:  		arg = 5;  		break;  	case Code.Ldc_I4_6:  		arg = 6;  		break;  	case Code.Ldc_I4_7:  		arg = 7;  		break;  	case Code.Ldc_I4_8:  		arg = 8;  		break;  	case Code.Ldc_I4_M1:  		arg = -1;  		break;  	case Code.Ldnull:  		arg = null;  		break;  	case Code.Nop:  		continue;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  		break;  	case Code.Ldfld:  	case Code.Ldsfld:  		arg = instr.Operand;  		break;  	default:  		int pushes' pops;  		instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  		if (!useUnknownArgs || pushes != 1) {  			Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  			errors++;  			return false;  		}  		for (int i = 0; i < pops; i++) {  			if (!GetArg (method' block' ref arg' ref instrIndex))  				return false;  		}  		arg = null;  		break;  	}  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: while (true) {  	if (instrIndex < 0) {  		// We're here if there were no cflow deobfuscation' or if there are two or  		// more blocks branching to the decrypter method' or the two blocks can't be  		// merged because one is outside the exception handler (eg. buggy obfuscator).  		Logger.w ("Could not find all arguments to method {0} ({1:X8})"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ());  		errors++;  		return false;  	}  	var instr = block.Instructions [instrIndex--];  	switch (instr.OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldstr:  		arg = instr.Operand;  		break;  	case Code.Ldc_I4_S:  		arg = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldc_I4_0:  		arg = 0;  		break;  	case Code.Ldc_I4_1:  		arg = 1;  		break;  	case Code.Ldc_I4_2:  		arg = 2;  		break;  	case Code.Ldc_I4_3:  		arg = 3;  		break;  	case Code.Ldc_I4_4:  		arg = 4;  		break;  	case Code.Ldc_I4_5:  		arg = 5;  		break;  	case Code.Ldc_I4_6:  		arg = 6;  		break;  	case Code.Ldc_I4_7:  		arg = 7;  		break;  	case Code.Ldc_I4_8:  		arg = 8;  		break;  	case Code.Ldc_I4_M1:  		arg = -1;  		break;  	case Code.Ldnull:  		arg = null;  		break;  	case Code.Nop:  		continue;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  		break;  	case Code.Ldfld:  	case Code.Ldsfld:  		arg = instr.Operand;  		break;  	default:  		int pushes' pops;  		instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  		if (!useUnknownArgs || pushes != 1) {  			Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  			errors++;  			return false;  		}  		for (int i = 0; i < pops; i++) {  			if (!GetArg (method' block' ref arg' ref instrIndex))  				return false;  		}  		arg = null;  		break;  	}  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	arg = instr.Operand;  	break;  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	break;  case Code.Ldc_I4_0:  	arg = 0;  	break;  case Code.Ldc_I4_1:  	arg = 1;  	break;  case Code.Ldc_I4_2:  	arg = 2;  	break;  case Code.Ldc_I4_3:  	arg = 3;  	break;  case Code.Ldc_I4_4:  	arg = 4;  	break;  case Code.Ldc_I4_5:  	arg = 5;  	break;  case Code.Ldc_I4_6:  	arg = 6;  	break;  case Code.Ldc_I4_7:  	arg = 7;  	break;  case Code.Ldc_I4_8:  	arg = 8;  	break;  case Code.Ldc_I4_M1:  	arg = -1;  	break;  case Code.Ldnull:  	arg = null;  	break;  case Code.Nop:  	continue;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  	break;  case Code.Ldfld:  case Code.Ldsfld:  	arg = instr.Operand;  	break;  default:  	int pushes' pops;  	instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  	if (!useUnknownArgs || pushes != 1) {  		Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  		errors++;  		return false;  	}  	for (int i = 0; i < pops; i++) {  		if (!GetArg (method' block' ref arg' ref instrIndex))  			return false;  	}  	arg = null;  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	arg = instr.Operand;  	break;  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	break;  case Code.Ldc_I4_0:  	arg = 0;  	break;  case Code.Ldc_I4_1:  	arg = 1;  	break;  case Code.Ldc_I4_2:  	arg = 2;  	break;  case Code.Ldc_I4_3:  	arg = 3;  	break;  case Code.Ldc_I4_4:  	arg = 4;  	break;  case Code.Ldc_I4_5:  	arg = 5;  	break;  case Code.Ldc_I4_6:  	arg = 6;  	break;  case Code.Ldc_I4_7:  	arg = 7;  	break;  case Code.Ldc_I4_8:  	arg = 8;  	break;  case Code.Ldc_I4_M1:  	arg = -1;  	break;  case Code.Ldnull:  	arg = null;  	break;  case Code.Nop:  	continue;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  	break;  case Code.Ldfld:  case Code.Ldsfld:  	arg = instr.Operand;  	break;  default:  	int pushes' pops;  	instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  	if (!useUnknownArgs || pushes != 1) {  		Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  		errors++;  		return false;  	}  	for (int i = 0; i < pops; i++) {  		if (!GetArg (method' block' ref arg' ref instrIndex))  			return false;  	}  	arg = null;  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	arg = instr.Operand;  	break;  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	break;  case Code.Ldc_I4_0:  	arg = 0;  	break;  case Code.Ldc_I4_1:  	arg = 1;  	break;  case Code.Ldc_I4_2:  	arg = 2;  	break;  case Code.Ldc_I4_3:  	arg = 3;  	break;  case Code.Ldc_I4_4:  	arg = 4;  	break;  case Code.Ldc_I4_5:  	arg = 5;  	break;  case Code.Ldc_I4_6:  	arg = 6;  	break;  case Code.Ldc_I4_7:  	arg = 7;  	break;  case Code.Ldc_I4_8:  	arg = 8;  	break;  case Code.Ldc_I4_M1:  	arg = -1;  	break;  case Code.Ldnull:  	arg = null;  	break;  case Code.Nop:  	continue;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  	break;  case Code.Ldfld:  case Code.Ldsfld:  	arg = instr.Operand;  	break;  default:  	int pushes' pops;  	instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  	if (!useUnknownArgs || pushes != 1) {  		Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  		errors++;  		return false;  	}  	for (int i = 0; i < pops; i++) {  		if (!GetArg (method' block' ref arg' ref instrIndex))  			return false;  	}  	arg = null;  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	arg = instr.Operand;  	break;  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	break;  case Code.Ldc_I4_0:  	arg = 0;  	break;  case Code.Ldc_I4_1:  	arg = 1;  	break;  case Code.Ldc_I4_2:  	arg = 2;  	break;  case Code.Ldc_I4_3:  	arg = 3;  	break;  case Code.Ldc_I4_4:  	arg = 4;  	break;  case Code.Ldc_I4_5:  	arg = 5;  	break;  case Code.Ldc_I4_6:  	arg = 6;  	break;  case Code.Ldc_I4_7:  	arg = 7;  	break;  case Code.Ldc_I4_8:  	arg = 8;  	break;  case Code.Ldc_I4_M1:  	arg = -1;  	break;  case Code.Ldnull:  	arg = null;  	break;  case Code.Nop:  	continue;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  	break;  case Code.Ldfld:  case Code.Ldsfld:  	arg = instr.Operand;  	break;  default:  	int pushes' pops;  	instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  	if (!useUnknownArgs || pushes != 1) {  		Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  		errors++;  		return false;  	}  	for (int i = 0; i < pops; i++) {  		if (!GetArg (method' block' ref arg' ref instrIndex))  			return false;  	}  	arg = null;  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	arg = instr.Operand;  	break;  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	break;  case Code.Ldc_I4_0:  	arg = 0;  	break;  case Code.Ldc_I4_1:  	arg = 1;  	break;  case Code.Ldc_I4_2:  	arg = 2;  	break;  case Code.Ldc_I4_3:  	arg = 3;  	break;  case Code.Ldc_I4_4:  	arg = 4;  	break;  case Code.Ldc_I4_5:  	arg = 5;  	break;  case Code.Ldc_I4_6:  	arg = 6;  	break;  case Code.Ldc_I4_7:  	arg = 7;  	break;  case Code.Ldc_I4_8:  	arg = 8;  	break;  case Code.Ldc_I4_M1:  	arg = -1;  	break;  case Code.Ldnull:  	arg = null;  	break;  case Code.Nop:  	continue;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  	break;  case Code.Ldfld:  case Code.Ldsfld:  	arg = instr.Operand;  	break;  default:  	int pushes' pops;  	instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  	if (!useUnknownArgs || pushes != 1) {  		Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  		errors++;  		return false;  	}  	for (int i = 0; i < pops; i++) {  		if (!GetArg (method' block' ref arg' ref instrIndex))  			return false;  	}  	arg = null;  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	arg = instr.Operand;  	break;  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	break;  case Code.Ldc_I4_0:  	arg = 0;  	break;  case Code.Ldc_I4_1:  	arg = 1;  	break;  case Code.Ldc_I4_2:  	arg = 2;  	break;  case Code.Ldc_I4_3:  	arg = 3;  	break;  case Code.Ldc_I4_4:  	arg = 4;  	break;  case Code.Ldc_I4_5:  	arg = 5;  	break;  case Code.Ldc_I4_6:  	arg = 6;  	break;  case Code.Ldc_I4_7:  	arg = 7;  	break;  case Code.Ldc_I4_8:  	arg = 8;  	break;  case Code.Ldc_I4_M1:  	arg = -1;  	break;  case Code.Ldnull:  	arg = null;  	break;  case Code.Nop:  	continue;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  	break;  case Code.Ldfld:  case Code.Ldsfld:  	arg = instr.Operand;  	break;  default:  	int pushes' pops;  	instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  	if (!useUnknownArgs || pushes != 1) {  		Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  		errors++;  		return false;  	}  	for (int i = 0; i < pops; i++) {  		if (!GetArg (method' block' ref arg' ref instrIndex))  			return false;  	}  	arg = null;  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  case Code.Ldstr:  	arg = instr.Operand;  	break;  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	break;  case Code.Ldc_I4_0:  	arg = 0;  	break;  case Code.Ldc_I4_1:  	arg = 1;  	break;  case Code.Ldc_I4_2:  	arg = 2;  	break;  case Code.Ldc_I4_3:  	arg = 3;  	break;  case Code.Ldc_I4_4:  	arg = 4;  	break;  case Code.Ldc_I4_5:  	arg = 5;  	break;  case Code.Ldc_I4_6:  	arg = 6;  	break;  case Code.Ldc_I4_7:  	arg = 7;  	break;  case Code.Ldc_I4_8:  	arg = 8;  	break;  case Code.Ldc_I4_M1:  	arg = -1;  	break;  case Code.Ldnull:  	arg = null;  	break;  case Code.Nop:  	continue;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	GetLocalVariableValue (instr.Instruction.GetLocal (theMethod.Body.Variables)' out arg);  	break;  case Code.Ldfld:  case Code.Ldsfld:  	arg = instr.Operand;  	break;  default:  	int pushes' pops;  	instr.Instruction.CalculateStackUsage (false' out pushes' out pops);  	if (!useUnknownArgs || pushes != 1) {  		Logger.w ("Could not find all arguments to method {0} ({1:X8})' instr: {2}"' Utils.RemoveNewlines (method)' method.MDToken.ToInt32 ()' instr);  		errors++;  		return false;  	}  	for (int i = 0; i < pops; i++) {  		if (!GetArg (method' block' ref arg' ref instrIndex))  			return false;  	}  	arg = null;  	break;  }  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: arg = 2;  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: arg = 3;  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: arg = 4;  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: arg = 5;  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: arg = 6;  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: arg = 7;  
Magic Number,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,GetArg,The following statement contains a magic number: arg = 8;  
Magic Number,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,GetMethodTokens,The following statement contains a magic number: foreach (var val in options.StringDecrypterMethods) {  	var tokenStr = val.Trim ();  	if (Utils.StartsWith (tokenStr' "0x"' StringComparison.OrdinalIgnoreCase))  		tokenStr = tokenStr.Substring (2);  	int methodToken;  	if (int.TryParse (tokenStr' NumberStyles.HexNumber' null' out methodToken))  		tokens.Add (methodToken);  	else  		tokens.AddRange (FindMethodTokens (val));  }  
Magic Number,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,GetMethodTokens,The following statement contains a magic number: if (Utils.StartsWith (tokenStr' "0x"' StringComparison.OrdinalIgnoreCase))  	tokenStr = tokenStr.Substring (2);  
Magic Number,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,GetMethodTokens,The following statement contains a magic number: tokenStr = tokenStr.Substring (2);  
Magic Number,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,SplitMethodDesc,The following statement contains a magic number: if (index >= 0) {  	type = remaining.Substring (0' index);  	remaining = remaining.Substring (index + 2);  }  
Magic Number,de4dot.code,ObfuscatedFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\ObfuscatedFile.cs,SplitMethodDesc,The following statement contains a magic number: remaining = remaining.Substring (index + 2);  
Magic Number,de4dot.code,Utils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  	if (numLower == 0)  		sb.Append ((char)((int)'A' + random.Next (26)));  	else  		sb.Append ((char)((int)'a' + random.Next (26)));  	if (numLower == 0) {  		numLower = random.Next (1' 5);  	} else {  		numLower--;  	}  }  
Magic Number,de4dot.code,Utils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  	if (numLower == 0)  		sb.Append ((char)((int)'A' + random.Next (26)));  	else  		sb.Append ((char)((int)'a' + random.Next (26)));  	if (numLower == 0) {  		numLower = random.Next (1' 5);  	} else {  		numLower--;  	}  }  
Magic Number,de4dot.code,Utils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  	if (numLower == 0)  		sb.Append ((char)((int)'A' + random.Next (26)));  	else  		sb.Append ((char)((int)'a' + random.Next (26)));  	if (numLower == 0) {  		numLower = random.Next (1' 5);  	} else {  		numLower--;  	}  }  
Magic Number,de4dot.code,Utils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: if (numLower == 0)  	sb.Append ((char)((int)'A' + random.Next (26)));  else  	sb.Append ((char)((int)'a' + random.Next (26)));  
Magic Number,de4dot.code,Utils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: if (numLower == 0)  	sb.Append ((char)((int)'A' + random.Next (26)));  else  	sb.Append ((char)((int)'a' + random.Next (26)));  
Magic Number,de4dot.code,Utils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: sb.Append ((char)((int)'A' + random.Next (26)));  
Magic Number,de4dot.code,Utils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: sb.Append ((char)((int)'a' + random.Next (26)));  
Magic Number,de4dot.code,Utils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: if (numLower == 0) {  	numLower = random.Next (1' 5);  } else {  	numLower--;  }  
Magic Number,de4dot.code,Utils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\Utils.cs,RandomName,The following statement contains a magic number: numLower = random.Next (1' 5);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,Find2,The following statement contains a magic number: foreach (var cctor in DeobUtils.GetInitCctors (module' 3)) {  	foreach (var calledMethod in DotNetUtils.GetCalledMethods (module' cctor)) {  		var type = calledMethod.DeclaringType;  		if (type.IsPublic)  			continue;  		var fieldTypes = new FieldTypes (type);  		if (!fieldTypes.All (requiredFields1))  			continue;  		if (!HasInitializeMethod (type' "_Initialize") && !HasInitializeMethod (type' "_Initialize64"))  			continue;  		initializeMethod = calledMethod;  		postInitializeMethod = FindMethod (type' "System.Void"' "PostInitialize"' "()");  		loadMethod = FindMethod (type' "System.IntPtr"' "Load"' "()");  		cliSecureRtType = type;  		FindStringDecrypters ();  		return true;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,Find3,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.Fields.Count < 1 || type.Fields.Count > 2)  		continue;  	var fieldTypes = new FieldTypes (type);  	if (!fieldTypes.Exactly (requiredFields6) && !fieldTypes.Exactly (requiredFields7))  		continue;  	if (type.Methods.Count != 2)  		continue;  	if (type.FindStaticConstructor () == null)  		continue;  	var cs = type.FindMethod ("cs");  	if (cs == null)  		continue;  	AddStringDecrypterMethod (cs);  	cliSecureRtType = type;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,Find3,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.Fields.Count < 1 || type.Fields.Count > 2)  		continue;  	var fieldTypes = new FieldTypes (type);  	if (!fieldTypes.Exactly (requiredFields6) && !fieldTypes.Exactly (requiredFields7))  		continue;  	if (type.Methods.Count != 2)  		continue;  	if (type.FindStaticConstructor () == null)  		continue;  	var cs = type.FindMethod ("cs");  	if (cs == null)  		continue;  	AddStringDecrypterMethod (cs);  	cliSecureRtType = type;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,Find3,The following statement contains a magic number: if (type.Fields.Count < 1 || type.Fields.Count > 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,Find3,The following statement contains a magic number: if (type.Methods.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	uint t = xl;  	xl = (xl >> 24) ^ xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	uint t = xl;  	xl = (xl >> 24) ^ xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Encrypt,The following statement contains a magic number: xl = (xl >> 24) ^ xr;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Encrypt,The following statement contains a magic number: rxr = xl ^ P [16];  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Encrypt,The following statement contains a magic number: rxl = xr ^ P [17];  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	uint t = xl;  	xl = (xl >> 24) ^ xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	uint t = xl;  	xl = (xl >> 24) ^ xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	uint t = xl;  	xl = (xl >> 24) ^ xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,Decrypt,The following statement contains a magic number: xl = (xl >> 24) ^ xr;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile1,The following statement contains a magic number: WriteUInt32 (fileData' dotNetDir + 4' BitConverter.ToUInt32 (fileData' dataDir + 4));  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile1,The following statement contains a magic number: WriteUInt32 (fileData' dotNetDir + 4' BitConverter.ToUInt32 (fileData' dataDir + 4));  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,UnpackNativeFile1,The following statement contains a magic number: WriteUInt32 (fileData' dataDir + 4' 0);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,WriteUInt32,The following statement contains a magic number: data [offset + 1] = (byte)(value >> 8);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,WriteUInt32,The following statement contains a magic number: data [offset + 2] = (byte)(value >> 16);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,WriteUInt32,The following statement contains a magic number: data [offset + 2] = (byte)(value >> 16);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,WriteUInt32,The following statement contains a magic number: data [offset + 3] = (byte)(value >> 24);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,WriteUInt32,The following statement contains a magic number: data [offset + 3] = (byte)(value >> 24);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (cliSecureAttributes.Count != 0)  	val += 10;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 10;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,IsCsHeader40,The following statement contains a magic number: try {  	uint offset = codeHeaderOffset + codeHeader.totalCodeSize + 0x28;  	uint prevCodeOffs = 0;  	for (int i = 0; i < (int)codeHeader.numMethods; i++' offset += 4) {  		uint codeOffs = peImage.OffsetReadUInt32 (offset);  		if (prevCodeOffs != 0 && codeOffs != 0 && codeOffs < prevCodeOffs)  			return false;  		if (codeOffs != 0)  			prevCodeOffs = codeOffs;  	}  	return true;  } catch (IOException) {  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,IsCsHeader40,The following statement contains a magic number: for (int i = 0; i < (int)codeHeader.numMethods; i++' offset += 4) {  	uint codeOffs = peImage.OffsetReadUInt32 (offset);  	if (prevCodeOffs != 0 && codeOffs != 0 && codeOffs < prevCodeOffs)  		return false;  	if (codeOffs != 0)  		prevCodeOffs = codeOffs;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,IsCsHeader40,The following statement contains a magic number: offset += 4
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes [2] = (byte)(initToken >> 8);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes [2] = (byte)(initToken >> 8);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes [3] = (byte)(initToken >> 16);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes [3] = (byte)(initToken >> 16);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes [4] = (byte)(initToken >> 24);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes [4] = (byte)(initToken >> 24);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,GetModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes [5] = 0x2A;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ReadCodeHeader,The following statement contains a magic number: codeHeader.signature = peImage.OffsetReadBytes (offset' 16);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ReadCodeHeader,The following statement contains a magic number: codeHeader.decryptionKey = peImage.OffsetReadBytes (offset + 0x10' 16);  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Detect,The following statement contains a magic number: try {  	uint codeHeaderOffset = GetCodeHeaderOffset (peImage);  	if (IsValidSignature (peImage.OffsetReadBytes (codeHeaderOffset' 16)))  		return true;  } catch {  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Detect,The following statement contains a magic number: if (IsValidSignature (peImage.OffsetReadBytes (codeHeaderOffset' 16)))  	return true;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Detect,The following statement contains a magic number: try {  	uint codeHeaderOffset = GetOldCodeHeaderOffset (peImage);  	if (codeHeaderOffset != 0 && IsValidSignature (peImage.OffsetReadBytes (codeHeaderOffset' 16)))  		return true;  } catch {  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,Detect,The following statement contains a magic number: if (codeHeaderOffset != 0 && IsValidSignature (peImage.OffsetReadBytes (codeHeaderOffset' 16)))  	return true;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs.Count != 3)  	return null;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs [2].OpCode != OpCodes.Ret)  	return null;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,The following statement contains a magic number: foreach (var type in module.Types) {  	if (!type.HasMethods)  		continue;  	if (type.Methods.Count > 3)  		continue;  	MethodDef errorMethod = null;  	foreach (var method in type.Methods) {  		if (method.Name == ".ctor")  			continue;  		// .ctor is allowed  		if (method.Name == ".cctor")  			continue;  		// .cctor is allowed  		var sig = method.MethodSig;  		if (sig != null && method.IsStatic && method.HasBody && sig.Params.Count == 2 && !method.HasGenericParameters && !DotNetUtils.HasReturnValue (method) && sig.Params [0].GetFullName () == "System.Exception" && sig.Params [1].GetFullName () == "System.Object[]") {  			errorMethod = method;  		} else  			break;  	}  	if (errorMethod != null) {  		stackFrameHelperType = type;  		exceptionLoggerRemover.Add (errorMethod);  		return;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,The following statement contains a magic number: foreach (var type in module.Types) {  	if (!type.HasMethods)  		continue;  	if (type.Methods.Count > 3)  		continue;  	MethodDef errorMethod = null;  	foreach (var method in type.Methods) {  		if (method.Name == ".ctor")  			continue;  		// .ctor is allowed  		if (method.Name == ".cctor")  			continue;  		// .cctor is allowed  		var sig = method.MethodSig;  		if (sig != null && method.IsStatic && method.HasBody && sig.Params.Count == 2 && !method.HasGenericParameters && !DotNetUtils.HasReturnValue (method) && sig.Params [0].GetFullName () == "System.Exception" && sig.Params [1].GetFullName () == "System.Object[]") {  			errorMethod = method;  		} else  			break;  	}  	if (errorMethod != null) {  		stackFrameHelperType = type;  		exceptionLoggerRemover.Add (errorMethod);  		return;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,The following statement contains a magic number: if (type.Methods.Count > 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (method.Name == ".ctor")  		continue;  	// .ctor is allowed  	if (method.Name == ".cctor")  		continue;  	// .cctor is allowed  	var sig = method.MethodSig;  	if (sig != null && method.IsStatic && method.HasBody && sig.Params.Count == 2 && !method.HasGenericParameters && !DotNetUtils.HasReturnValue (method) && sig.Params [0].GetFullName () == "System.Exception" && sig.Params [1].GetFullName () == "System.Object[]") {  		errorMethod = method;  	} else  		break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,Find,The following statement contains a magic number: if (sig != null && method.IsStatic && method.HasBody && sig.Params.Count == 2 && !method.HasGenericParameters && !DotNetUtils.HasReturnValue (method) && sig.Params [0].GetFullName () == "System.Exception" && sig.Params [1].GetFullName () == "System.Object[]") {  	errorMethod = method;  } else  	break;  
Magic Number,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = instrs.Count - 2; i >= 0; i--) {  		var newobj = instrs [i];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		var ctor = newobj.Operand as IMethod;  		if (ctor == null || ctor.FullName != "System.Void System.Collections.Hashtable::.ctor()")  			continue;  		var stsfld = instrs [i + 1];  		if (stsfld.OpCode.Code != Code.Stsfld)  			continue;  		var field = stsfld.Operand as FieldDef;  		if (field == null || !decrypterFields.ContainsKey (field))  			continue;  		block.Remove (i' 2);  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = instrs.Count - 2; i >= 0; i--) {  		var newobj = instrs [i];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		var ctor = newobj.Operand as IMethod;  		if (ctor == null || ctor.FullName != "System.Void System.Collections.Hashtable::.ctor()")  			continue;  		var stsfld = instrs [i + 1];  		if (stsfld.OpCode.Code != Code.Stsfld)  			continue;  		var field = stsfld.Operand as FieldDef;  		if (field == null || !decrypterFields.ContainsKey (field))  			continue;  		block.Remove (i' 2);  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,Deobfuscate,The following statement contains a magic number: for (int i = instrs.Count - 2; i >= 0; i--) {  	var newobj = instrs [i];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	var ctor = newobj.Operand as IMethod;  	if (ctor == null || ctor.FullName != "System.Void System.Collections.Hashtable::.ctor()")  		continue;  	var stsfld = instrs [i + 1];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	var field = stsfld.Operand as FieldDef;  	if (field == null || !decrypterFields.ContainsKey (field))  		continue;  	block.Remove (i' 2);  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,Deobfuscate,The following statement contains a magic number: for (int i = instrs.Count - 2; i >= 0; i--) {  	var newobj = instrs [i];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	var ctor = newobj.Operand as IMethod;  	if (ctor == null || ctor.FullName != "System.Void System.Collections.Hashtable::.ctor()")  		continue;  	var stsfld = instrs [i + 1];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	var field = stsfld.Operand as FieldDef;  	if (field == null || !decrypterFields.ContainsKey (field))  		continue;  	block.Remove (i' 2);  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\StringDecrypter.cs,Deobfuscate,The following statement contains a magic number: block.Remove (i' 2);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CilOperandInstructionRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CilOperandInstructionRestorer.cs,Restore,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	var instr = instrs [i];  	if (instr.Operand != null)  		continue;  	TypeSig operandType = null' operandTypeTmp;  	OpCode newOpCode = null;  	SZArraySig arrayType;  	switch (instr.OpCode.Code) {  	case Code.Ldelem:  		arrayType = MethodStack.GetLoadedType (method' instrs' i' 1) as SZArraySig;  		if (arrayType == null)  			break;  		operandTypeTmp = arrayType.Next;  		if (operandTypeTmp == null)  			newOpCode = OpCodes.Ldelem_Ref;  		else {  			switch (operandTypeTmp.ElementType) {  			case ElementType.Boolean:  				newOpCode = OpCodes.Ldelem_I1;  				break;  			case ElementType.Char:  				newOpCode = OpCodes.Ldelem_U2;  				break;  			case ElementType.I:  				newOpCode = OpCodes.Ldelem_I;  				break;  			case ElementType.I1:  				newOpCode = OpCodes.Ldelem_I1;  				break;  			case ElementType.I2:  				newOpCode = OpCodes.Ldelem_I2;  				break;  			case ElementType.I4:  				newOpCode = OpCodes.Ldelem_I4;  				break;  			case ElementType.I8:  				newOpCode = OpCodes.Ldelem_I8;  				break;  			case ElementType.U:  				newOpCode = OpCodes.Ldelem_I;  				break;  			case ElementType.U1:  				newOpCode = OpCodes.Ldelem_U1;  				break;  			case ElementType.U2:  				newOpCode = OpCodes.Ldelem_U2;  				break;  			case ElementType.U4:  				newOpCode = OpCodes.Ldelem_U4;  				break;  			case ElementType.U8:  				newOpCode = OpCodes.Ldelem_I8;  				break;  			case ElementType.R4:  				newOpCode = OpCodes.Ldelem_R4;  				break;  			case ElementType.R8:  				newOpCode = OpCodes.Ldelem_R8;  				break;  			default:  				newOpCode = OpCodes.Ldelem_Ref;  				break;  			//TODO: Ldelem  			}  		}  		break;  	case Code.Stelem:  		arrayType = MethodStack.GetLoadedType (method' instrs' i' 2) as SZArraySig;  		if (arrayType == null)  			break;  		operandTypeTmp = arrayType.Next;  		if (operandTypeTmp == null)  			newOpCode = OpCodes.Stelem_Ref;  		else {  			switch (operandTypeTmp.ElementType) {  			case ElementType.U:  			case ElementType.I:  				newOpCode = OpCodes.Stelem_I;  				break;  			case ElementType.Boolean:  			case ElementType.U1:  			case ElementType.I1:  				newOpCode = OpCodes.Stelem_I1;  				break;  			case ElementType.Char:  			case ElementType.U2:  			case ElementType.I2:  				newOpCode = OpCodes.Stelem_I2;  				break;  			case ElementType.U4:  			case ElementType.I4:  				newOpCode = OpCodes.Stelem_I4;  				break;  			case ElementType.U8:  			case ElementType.I8:  				newOpCode = OpCodes.Stelem_I8;  				break;  			case ElementType.R4:  				newOpCode = OpCodes.Stelem_R4;  				break;  			case ElementType.R8:  				newOpCode = OpCodes.Stelem_R8;  				break;  			default:  				newOpCode = OpCodes.Stelem_Ref;  				break;  			//TODO: Stelem  			}  		}  		break;  	case Code.Ldelema:  		arrayType = MethodStack.GetLoadedType (method' instrs' i' 1) as SZArraySig;  		if (arrayType == null)  			break;  		operandType = arrayType.Next;  		break;  	case Code.Ldobj:  		operandType = GetPtrElementType (MethodStack.GetLoadedType (method' instrs' i' 0));  		break;  	case Code.Stobj:  		operandType = MethodStack.GetLoadedType (method' instrs' i' 0);  		if (!IsValidType (operandType))  			operandType = GetPtrElementType (MethodStack.GetLoadedType (method' instrs' i' 1));  		break;  	default:  		continue;  	}  	if (newOpCode == null && !IsValidType (operandType)) {  		atLeastOneFailed = true;  		continue;  	}  	instr.Operand = operandType.ToTypeDefOrRef ();  	if (newOpCode != null)  		instr.OpCode = newOpCode;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CilOperandInstructionRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CilOperandInstructionRestorer.cs,Restore,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldelem:  	arrayType = MethodStack.GetLoadedType (method' instrs' i' 1) as SZArraySig;  	if (arrayType == null)  		break;  	operandTypeTmp = arrayType.Next;  	if (operandTypeTmp == null)  		newOpCode = OpCodes.Ldelem_Ref;  	else {  		switch (operandTypeTmp.ElementType) {  		case ElementType.Boolean:  			newOpCode = OpCodes.Ldelem_I1;  			break;  		case ElementType.Char:  			newOpCode = OpCodes.Ldelem_U2;  			break;  		case ElementType.I:  			newOpCode = OpCodes.Ldelem_I;  			break;  		case ElementType.I1:  			newOpCode = OpCodes.Ldelem_I1;  			break;  		case ElementType.I2:  			newOpCode = OpCodes.Ldelem_I2;  			break;  		case ElementType.I4:  			newOpCode = OpCodes.Ldelem_I4;  			break;  		case ElementType.I8:  			newOpCode = OpCodes.Ldelem_I8;  			break;  		case ElementType.U:  			newOpCode = OpCodes.Ldelem_I;  			break;  		case ElementType.U1:  			newOpCode = OpCodes.Ldelem_U1;  			break;  		case ElementType.U2:  			newOpCode = OpCodes.Ldelem_U2;  			break;  		case ElementType.U4:  			newOpCode = OpCodes.Ldelem_U4;  			break;  		case ElementType.U8:  			newOpCode = OpCodes.Ldelem_I8;  			break;  		case ElementType.R4:  			newOpCode = OpCodes.Ldelem_R4;  			break;  		case ElementType.R8:  			newOpCode = OpCodes.Ldelem_R8;  			break;  		default:  			newOpCode = OpCodes.Ldelem_Ref;  			break;  		//TODO: Ldelem  		}  	}  	break;  case Code.Stelem:  	arrayType = MethodStack.GetLoadedType (method' instrs' i' 2) as SZArraySig;  	if (arrayType == null)  		break;  	operandTypeTmp = arrayType.Next;  	if (operandTypeTmp == null)  		newOpCode = OpCodes.Stelem_Ref;  	else {  		switch (operandTypeTmp.ElementType) {  		case ElementType.U:  		case ElementType.I:  			newOpCode = OpCodes.Stelem_I;  			break;  		case ElementType.Boolean:  		case ElementType.U1:  		case ElementType.I1:  			newOpCode = OpCodes.Stelem_I1;  			break;  		case ElementType.Char:  		case ElementType.U2:  		case ElementType.I2:  			newOpCode = OpCodes.Stelem_I2;  			break;  		case ElementType.U4:  		case ElementType.I4:  			newOpCode = OpCodes.Stelem_I4;  			break;  		case ElementType.U8:  		case ElementType.I8:  			newOpCode = OpCodes.Stelem_I8;  			break;  		case ElementType.R4:  			newOpCode = OpCodes.Stelem_R4;  			break;  		case ElementType.R8:  			newOpCode = OpCodes.Stelem_R8;  			break;  		default:  			newOpCode = OpCodes.Stelem_Ref;  			break;  		//TODO: Stelem  		}  	}  	break;  case Code.Ldelema:  	arrayType = MethodStack.GetLoadedType (method' instrs' i' 1) as SZArraySig;  	if (arrayType == null)  		break;  	operandType = arrayType.Next;  	break;  case Code.Ldobj:  	operandType = GetPtrElementType (MethodStack.GetLoadedType (method' instrs' i' 0));  	break;  case Code.Stobj:  	operandType = MethodStack.GetLoadedType (method' instrs' i' 0);  	if (!IsValidType (operandType))  		operandType = GetPtrElementType (MethodStack.GetLoadedType (method' instrs' i' 1));  	break;  default:  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CilOperandInstructionRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CilOperandInstructionRestorer.cs,Restore,The following statement contains a magic number: arrayType = MethodStack.GetLoadedType (method' instrs' i' 2) as SZArraySig;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmDataReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmDataReader.cs,Read,The following statement contains a magic number: for (int i = 0; i < numMethods; i++) {  	var csvmMethod = new CsvmMethodData ();  	csvmMethod.Guid = new Guid (reader.ReadBytes (16));  	csvmMethod.Token = reader.ReadInt32 ();  	csvmMethod.Locals = reader.ReadBytes (reader.ReadInt32 ());  	csvmMethod.Instructions = reader.ReadBytes (reader.ReadInt32 ());  	csvmMethod.Exceptions = reader.ReadBytes (reader.ReadInt32 ());  	methods.Add (csvmMethod);  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmDataReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmDataReader.cs,Read,The following statement contains a magic number: csvmMethod.Guid = new Guid (reader.ReadBytes (16));  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldloc_S:  case Code.Ldloc:  	if (index == 0)  		opcode = OpCodes.Ldloc_0;  	else if (index == 1)  		opcode = OpCodes.Ldloc_1;  	else if (index == 2)  		opcode = OpCodes.Ldloc_2;  	else if (index == 3)  		opcode = OpCodes.Ldloc_3;  	else if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Ldloc_S;  		operand = local;  	} else {  		opcode = OpCodes.Ldloc;  		operand = local;  	}  	break;  case Code.Stloc:  case Code.Stloc_S:  	if (index == 0)  		opcode = OpCodes.Stloc_0;  	else if (index == 1)  		opcode = OpCodes.Stloc_1;  	else if (index == 2)  		opcode = OpCodes.Stloc_2;  	else if (index == 3)  		opcode = OpCodes.Stloc_3;  	else if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Stloc_S;  		operand = local;  	} else {  		opcode = OpCodes.Stloc;  		operand = local;  	}  	break;  case Code.Ldloca:  case Code.Ldloca_S:  	if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Ldloca_S;  		operand = local;  	} else {  		opcode = OpCodes.Ldloca;  		operand = local;  	}  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldloc_S:  case Code.Ldloc:  	if (index == 0)  		opcode = OpCodes.Ldloc_0;  	else if (index == 1)  		opcode = OpCodes.Ldloc_1;  	else if (index == 2)  		opcode = OpCodes.Ldloc_2;  	else if (index == 3)  		opcode = OpCodes.Ldloc_3;  	else if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Ldloc_S;  		operand = local;  	} else {  		opcode = OpCodes.Ldloc;  		operand = local;  	}  	break;  case Code.Stloc:  case Code.Stloc_S:  	if (index == 0)  		opcode = OpCodes.Stloc_0;  	else if (index == 1)  		opcode = OpCodes.Stloc_1;  	else if (index == 2)  		opcode = OpCodes.Stloc_2;  	else if (index == 3)  		opcode = OpCodes.Stloc_3;  	else if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Stloc_S;  		operand = local;  	} else {  		opcode = OpCodes.Stloc;  		operand = local;  	}  	break;  case Code.Ldloca:  case Code.Ldloca_S:  	if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Ldloca_S;  		operand = local;  	} else {  		opcode = OpCodes.Ldloca;  		operand = local;  	}  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldloc_S:  case Code.Ldloc:  	if (index == 0)  		opcode = OpCodes.Ldloc_0;  	else if (index == 1)  		opcode = OpCodes.Ldloc_1;  	else if (index == 2)  		opcode = OpCodes.Ldloc_2;  	else if (index == 3)  		opcode = OpCodes.Ldloc_3;  	else if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Ldloc_S;  		operand = local;  	} else {  		opcode = OpCodes.Ldloc;  		operand = local;  	}  	break;  case Code.Stloc:  case Code.Stloc_S:  	if (index == 0)  		opcode = OpCodes.Stloc_0;  	else if (index == 1)  		opcode = OpCodes.Stloc_1;  	else if (index == 2)  		opcode = OpCodes.Stloc_2;  	else if (index == 3)  		opcode = OpCodes.Stloc_3;  	else if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Stloc_S;  		operand = local;  	} else {  		opcode = OpCodes.Stloc;  		operand = local;  	}  	break;  case Code.Ldloca:  case Code.Ldloca_S:  	if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Ldloca_S;  		operand = local;  	} else {  		opcode = OpCodes.Ldloca;  		operand = local;  	}  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldloc_S:  case Code.Ldloc:  	if (index == 0)  		opcode = OpCodes.Ldloc_0;  	else if (index == 1)  		opcode = OpCodes.Ldloc_1;  	else if (index == 2)  		opcode = OpCodes.Ldloc_2;  	else if (index == 3)  		opcode = OpCodes.Ldloc_3;  	else if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Ldloc_S;  		operand = local;  	} else {  		opcode = OpCodes.Ldloc;  		operand = local;  	}  	break;  case Code.Stloc:  case Code.Stloc_S:  	if (index == 0)  		opcode = OpCodes.Stloc_0;  	else if (index == 1)  		opcode = OpCodes.Stloc_1;  	else if (index == 2)  		opcode = OpCodes.Stloc_2;  	else if (index == 3)  		opcode = OpCodes.Stloc_3;  	else if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Stloc_S;  		operand = local;  	} else {  		opcode = OpCodes.Stloc;  		operand = local;  	}  	break;  case Code.Ldloca:  case Code.Ldloca_S:  	if (byte.MinValue <= index && index <= byte.MaxValue) {  		opcode = OpCodes.Ldloca_S;  		operand = local;  	} else {  		opcode = OpCodes.Ldloca;  		operand = local;  	}  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 0)  	opcode = OpCodes.Ldloc_0;  else if (index == 1)  	opcode = OpCodes.Ldloc_1;  else if (index == 2)  	opcode = OpCodes.Ldloc_2;  else if (index == 3)  	opcode = OpCodes.Ldloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Ldloc_S;  	operand = local;  } else {  	opcode = OpCodes.Ldloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 0)  	opcode = OpCodes.Ldloc_0;  else if (index == 1)  	opcode = OpCodes.Ldloc_1;  else if (index == 2)  	opcode = OpCodes.Ldloc_2;  else if (index == 3)  	opcode = OpCodes.Ldloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Ldloc_S;  	operand = local;  } else {  	opcode = OpCodes.Ldloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 1)  	opcode = OpCodes.Ldloc_1;  else if (index == 2)  	opcode = OpCodes.Ldloc_2;  else if (index == 3)  	opcode = OpCodes.Ldloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Ldloc_S;  	operand = local;  } else {  	opcode = OpCodes.Ldloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 1)  	opcode = OpCodes.Ldloc_1;  else if (index == 2)  	opcode = OpCodes.Ldloc_2;  else if (index == 3)  	opcode = OpCodes.Ldloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Ldloc_S;  	operand = local;  } else {  	opcode = OpCodes.Ldloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 2)  	opcode = OpCodes.Ldloc_2;  else if (index == 3)  	opcode = OpCodes.Ldloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Ldloc_S;  	operand = local;  } else {  	opcode = OpCodes.Ldloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 2)  	opcode = OpCodes.Ldloc_2;  else if (index == 3)  	opcode = OpCodes.Ldloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Ldloc_S;  	operand = local;  } else {  	opcode = OpCodes.Ldloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 3)  	opcode = OpCodes.Ldloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Ldloc_S;  	operand = local;  } else {  	opcode = OpCodes.Ldloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 0)  	opcode = OpCodes.Stloc_0;  else if (index == 1)  	opcode = OpCodes.Stloc_1;  else if (index == 2)  	opcode = OpCodes.Stloc_2;  else if (index == 3)  	opcode = OpCodes.Stloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Stloc_S;  	operand = local;  } else {  	opcode = OpCodes.Stloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 0)  	opcode = OpCodes.Stloc_0;  else if (index == 1)  	opcode = OpCodes.Stloc_1;  else if (index == 2)  	opcode = OpCodes.Stloc_2;  else if (index == 3)  	opcode = OpCodes.Stloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Stloc_S;  	operand = local;  } else {  	opcode = OpCodes.Stloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 1)  	opcode = OpCodes.Stloc_1;  else if (index == 2)  	opcode = OpCodes.Stloc_2;  else if (index == 3)  	opcode = OpCodes.Stloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Stloc_S;  	operand = local;  } else {  	opcode = OpCodes.Stloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 1)  	opcode = OpCodes.Stloc_1;  else if (index == 2)  	opcode = OpCodes.Stloc_2;  else if (index == 3)  	opcode = OpCodes.Stloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Stloc_S;  	operand = local;  } else {  	opcode = OpCodes.Stloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 2)  	opcode = OpCodes.Stloc_2;  else if (index == 3)  	opcode = OpCodes.Stloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Stloc_S;  	operand = local;  } else {  	opcode = OpCodes.Stloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 2)  	opcode = OpCodes.Stloc_2;  else if (index == 3)  	opcode = OpCodes.Stloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Stloc_S;  	operand = local;  } else {  	opcode = OpCodes.Stloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateLocalInstruction,The following statement contains a magic number: if (index == 3)  	opcode = OpCodes.Stloc_3;  else if (byte.MinValue <= index && index <= byte.MaxValue) {  	opcode = OpCodes.Stloc_S;  	operand = local;  } else {  	opcode = OpCodes.Stloc;  	operand = local;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  case Code.Ldarg_S:  	if (index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	} else if (index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	} else if (index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	} else if (index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	} else if (byte.MinValue <= index && index <= byte.MaxValue) {  		instr.OpCode = OpCodes.Ldarg_S;  		instr.Operand = arg;  	} else {  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = arg;  	}  	break;  case Code.Starg:  case Code.Starg_S:  	if (byte.MinValue <= index && index <= byte.MaxValue) {  		instr.OpCode = OpCodes.Starg_S;  		instr.Operand = arg;  	} else {  		instr.OpCode = OpCodes.Starg;  		instr.Operand = arg;  	}  	break;  case Code.Ldarga:  case Code.Ldarga_S:  	if (byte.MinValue <= index && index <= byte.MaxValue) {  		instr.OpCode = OpCodes.Ldarga_S;  		instr.Operand = arg;  	} else {  		instr.OpCode = OpCodes.Ldarga;  		instr.Operand = arg;  	}  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  case Code.Ldarg_S:  	if (index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	} else if (index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	} else if (index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	} else if (index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	} else if (byte.MinValue <= index && index <= byte.MaxValue) {  		instr.OpCode = OpCodes.Ldarg_S;  		instr.Operand = arg;  	} else {  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = arg;  	}  	break;  case Code.Starg:  case Code.Starg_S:  	if (byte.MinValue <= index && index <= byte.MaxValue) {  		instr.OpCode = OpCodes.Starg_S;  		instr.Operand = arg;  	} else {  		instr.OpCode = OpCodes.Starg;  		instr.Operand = arg;  	}  	break;  case Code.Ldarga:  case Code.Ldarga_S:  	if (byte.MinValue <= index && index <= byte.MaxValue) {  		instr.OpCode = OpCodes.Ldarga_S;  		instr.Operand = arg;  	} else {  		instr.OpCode = OpCodes.Ldarga;  		instr.Operand = arg;  	}  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: if (index == 0) {  	instr.OpCode = OpCodes.Ldarg_0;  	instr.Operand = null;  } else if (index == 1) {  	instr.OpCode = OpCodes.Ldarg_1;  	instr.Operand = null;  } else if (index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  } else if (index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  } else if (byte.MinValue <= index && index <= byte.MaxValue) {  	instr.OpCode = OpCodes.Ldarg_S;  	instr.Operand = arg;  } else {  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = arg;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: if (index == 0) {  	instr.OpCode = OpCodes.Ldarg_0;  	instr.Operand = null;  } else if (index == 1) {  	instr.OpCode = OpCodes.Ldarg_1;  	instr.Operand = null;  } else if (index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  } else if (index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  } else if (byte.MinValue <= index && index <= byte.MaxValue) {  	instr.OpCode = OpCodes.Ldarg_S;  	instr.Operand = arg;  } else {  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = arg;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: if (index == 1) {  	instr.OpCode = OpCodes.Ldarg_1;  	instr.Operand = null;  } else if (index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  } else if (index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  } else if (byte.MinValue <= index && index <= byte.MaxValue) {  	instr.OpCode = OpCodes.Ldarg_S;  	instr.Operand = arg;  } else {  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = arg;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: if (index == 1) {  	instr.OpCode = OpCodes.Ldarg_1;  	instr.Operand = null;  } else if (index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  } else if (index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  } else if (byte.MinValue <= index && index <= byte.MaxValue) {  	instr.OpCode = OpCodes.Ldarg_S;  	instr.Operand = arg;  } else {  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = arg;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: if (index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  } else if (index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  } else if (byte.MinValue <= index && index <= byte.MaxValue) {  	instr.OpCode = OpCodes.Ldarg_S;  	instr.Operand = arg;  } else {  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = arg;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: if (index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  } else if (index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  } else if (byte.MinValue <= index && index <= byte.MaxValue) {  	instr.OpCode = OpCodes.Ldarg_S;  	instr.Operand = arg;  } else {  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = arg;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,UpdateArgInstruction,The following statement contains a magic number: if (index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  } else if (byte.MinValue <= index && index <= byte.MaxValue) {  	instr.OpCode = OpCodes.Ldarg_S;  	instr.Operand = arg;  } else {  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = arg;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,GetInstructionSize,The following statement contains a magic number: if (opcode == null)  	return 5;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,GetInstructionSize,The following statement contains a magic number: return 5;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverterBase.cs,GetInstructionSize,The following statement contains a magic number: return instr.OpCode.Size + (op.TargetDisplacements.Length + 1) * 4;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,Csvm,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\Csvm.cs,FindVmAssemblyRef,The following statement contains a magic number: foreach (var memberRef in module.GetMemberRefs ()) {  	var sig = memberRef.MethodSig;  	if (sig == null)  		continue;  	if (sig.RetType.GetElementType () != ElementType.Object)  		continue;  	if (sig.Params.Count != 2)  		continue;  	if (memberRef.Name != "RunMethod")  		continue;  	if (memberRef.FullName == "System.Object VMRuntime.Libraries.CSVMRuntime::RunMethod(System.String'System.Object[])")  		return memberRef.DeclaringType.Scope as AssemblyRef;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,Csvm,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\Csvm.cs,FindVmAssemblyRef,The following statement contains a magic number: if (sig.Params.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.Add.ToInstruction ();  case 1:  	return OpCodes.Add_Ovf.ToInstruction ();  case 2:  	return OpCodes.Add_Ovf_Un.ToInstruction ();  case 3:  	return OpCodes.Sub.ToInstruction ();  case 4:  	return OpCodes.Sub_Ovf.ToInstruction ();  case 5:  	return OpCodes.Sub_Ovf_Un.ToInstruction ();  case 6:  	return OpCodes.Mul.ToInstruction ();  case 7:  	return OpCodes.Mul_Ovf.ToInstruction ();  case 8:  	return OpCodes.Mul_Ovf_Un.ToInstruction ();  case 9:  	return OpCodes.Div.ToInstruction ();  case 10:  	return OpCodes.Div_Un.ToInstruction ();  case 11:  	return OpCodes.Rem.ToInstruction ();  case 12:  	return OpCodes.Rem_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,call_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	instr.OpCode = OpCodes.Newobj;  	break;  case 1:  	instr.OpCode = OpCodes.Call;  	break;  case 2:  	instr.OpCode = OpCodes.Callvirt;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  case 0:  	instr.OpCode = OpCodes.Br;  	break;  case 1:  	instr.OpCode = OpCodes.Brtrue;  	break;  case 2:  	instr.OpCode = OpCodes.Brfalse;  	break;  case 3:  	instr.OpCode = OpCodes.Beq;  	break;  case 4:  	instr.OpCode = OpCodes.Bge;  	break;  case 5:  	instr.OpCode = OpCodes.Bgt;  	break;  case 6:  	instr.OpCode = OpCodes.Ble;  	break;  case 7:  	instr.OpCode = OpCodes.Blt;  	break;  case 8:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case 9:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case 10:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case 11:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case 12:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case 13:  	instr.OpCode = OpCodes.Ceq;  	break;  case 14:  	instr.OpCode = OpCodes.Cgt;  	break;  case 15:  	instr.OpCode = OpCodes.Clt;  	break;  case 16:  	instr.OpCode = OpCodes.Cgt_Un;  	break;  case 17:  	instr.OpCode = OpCodes.Clt_Un;  	break;  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,compare_read,The following statement contains a magic number: if (type < 13)  	instr.Operand = new TargetDisplOperand (reader.ReadInt32 ());  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,ldfld_read,The following statement contains a magic number: switch (b) {  case 0:  	return new Instruction (null' new FieldInstructionOperand (OpCodes.Ldsfld' OpCodes.Ldfld' field));  case 1:  	return new Instruction (null' new FieldInstructionOperand (OpCodes.Ldsflda' OpCodes.Ldflda' field));  case 2:  	return new Instruction (null' new FieldInstructionOperand (OpCodes.Stsfld' OpCodes.Stfld' field));  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.And.ToInstruction ();  case 1:  	return OpCodes.Or.ToInstruction ();  case 2:  	return OpCodes.Xor.ToInstruction ();  case 3:  	return OpCodes.Shl.ToInstruction ();  case 4:  	return OpCodes.Shr.ToInstruction ();  case 5:  	return OpCodes.Shr_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.And.ToInstruction ();  case 1:  	return OpCodes.Or.ToInstruction ();  case 2:  	return OpCodes.Xor.ToInstruction ();  case 3:  	return OpCodes.Shl.ToInstruction ();  case 4:  	return OpCodes.Shr.ToInstruction ();  case 5:  	return OpCodes.Shr_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.And.ToInstruction ();  case 1:  	return OpCodes.Or.ToInstruction ();  case 2:  	return OpCodes.Xor.ToInstruction ();  case 3:  	return OpCodes.Shl.ToInstruction ();  case 4:  	return OpCodes.Shr.ToInstruction ();  case 5:  	return OpCodes.Shr_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,OpCodeHandlers,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return OpCodes.And.ToInstruction ();  case 1:  	return OpCodes.Or.ToInstruction ();  case 2:  	return OpCodes.Xor.ToInstruction ();  case 3:  	return OpCodes.Shl.ToInstruction ();  case 4:  	return OpCodes.Shr.ToInstruction ();  case 5:  	return OpCodes.Shr_Un.ToInstruction ();  default:  	throw new ApplicationException ("Invalid opcode");  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,IsStackType,The following statement contains a magic number: if (type.Fields.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,IsStackType,The following statement contains a magic number: if (type.Interfaces.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,IsStackType,The following statement contains a magic number: if (stackValueTypes != 2 || int32Types != 2 || objectTypes != 1)  	return false;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,IsStackType,The following statement contains a magic number: if (stackValueTypes != 2 || int32Types != 2 || objectTypes != 1)  	return false;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,FindVmHandlerTypes,The following statement contains a magic number: foreach (var type in module.Types) {  	var cctor = type.FindStaticConstructor ();  	if (cctor == null)  		continue;  	requiredFields [0] = type.FullName;  	if (!new FieldTypes (type).Exactly (requiredFields))  		continue;  	cflowDeobfuscator.Deobfuscate (cctor);  	var handlers = FindVmHandlerTypes (cctor);  	if (handlers.Count != 31)  		continue;  	return handlers;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v1,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v1\VmOpCodeHandlerDetector.cs,FindVmHandlerTypes,The following statement contains a magic number: if (handlers.Count != 31)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,Csvm,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\Csvm.cs,FindVmAssemblyRef,The following statement contains a magic number: foreach (var memberRef in module.GetMemberRefs ()) {  	var sig = memberRef.MethodSig;  	if (sig == null)  		continue;  	if (sig.RetType.GetElementType () != ElementType.Object)  		continue;  	if (sig.Params.Count != 2)  		continue;  	if (memberRef.Name != "RunMethod")  		continue;  	if (memberRef.FullName == "System.Object VMRuntime.Libraries.CSVMRuntime::RunMethod(System.String'System.Object[])")  		return memberRef.DeclaringType.Scope as AssemblyRef;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,Csvm,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\Csvm.cs,FindVmAssemblyRef,The following statement contains a magic number: if (sig.Params.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindVmHandlerBase,The following statement contains a magic number: foreach (var type in module.Types) {  	if (!type.IsPublic || !type.IsAbstract)  		continue;  	if (type.HasProperties || type.HasEvents)  		continue;  	if (type.BaseType == null || type.BaseType.FullName != "System.Object")  		continue;  	if (CountVirtual (type) != 2)  		continue;  	VmHandlerBaseType = type;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindVmHandlerBase,The following statement contains a magic number: if (CountVirtual (type) != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLocalOpsMethods,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.BaseType == null || type.BaseType.FullName != "System.Object")  		continue;  	if (type.Methods.Count != 6 && type.Methods.Count != 7)  		continue;  	LogicalOpShrUn = FindLogicalOpMethodShrUn (type);  	if (LogicalOpShrUn == null)  		continue;  	LogicalOpShl = FindLogicalOpMethodShl (type);  	LogicalOpShr = FindLogicalOpMethodShr (type);  	LogicalOpAnd = FindLogicalOpMethodAnd (type);  	LogicalOpXor = FindLogicalOpMethodXor (type);  	LogicalOpOr = FindLogicalOpMethodOr (type);  	if (LogicalOpShrUn != null && LogicalOpShl != null && LogicalOpShr != null && LogicalOpAnd != null && LogicalOpXor != null && LogicalOpOr != null)  		return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLocalOpsMethods,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.BaseType == null || type.BaseType.FullName != "System.Object")  		continue;  	if (type.Methods.Count != 6 && type.Methods.Count != 7)  		continue;  	LogicalOpShrUn = FindLogicalOpMethodShrUn (type);  	if (LogicalOpShrUn == null)  		continue;  	LogicalOpShl = FindLogicalOpMethodShl (type);  	LogicalOpShr = FindLogicalOpMethodShr (type);  	LogicalOpAnd = FindLogicalOpMethodAnd (type);  	LogicalOpXor = FindLogicalOpMethodXor (type);  	LogicalOpOr = FindLogicalOpMethodOr (type);  	if (LogicalOpShrUn != null && LogicalOpShl != null && LogicalOpShr != null && LogicalOpAnd != null && LogicalOpXor != null && LogicalOpOr != null)  		return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLocalOpsMethods,The following statement contains a magic number: if (type.Methods.Count != 6 && type.Methods.Count != 7)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLocalOpsMethods,The following statement contains a magic number: if (type.Methods.Count != 6 && type.Methods.Count != 7)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' e1))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' e2))  			continue;  		var ldci4 = instrs [i + 4];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  			continue;  		if (instrs [i + 5].OpCode.Code != Code.And)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' e3))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' e1))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' e2))  			continue;  		var ldci4 = instrs [i + 4];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  			continue;  		if (instrs [i + 5].OpCode.Code != Code.And)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' e3))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' e1))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' e2))  			continue;  		var ldci4 = instrs [i + 4];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  			continue;  		if (instrs [i + 5].OpCode.Code != Code.And)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' e3))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' e1))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' e2))  			continue;  		var ldci4 = instrs [i + 4];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  			continue;  		if (instrs [i + 5].OpCode.Code != Code.And)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' e3))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' e1))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' e2))  			continue;  		var ldci4 = instrs [i + 4];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  			continue;  		if (instrs [i + 5].OpCode.Code != Code.And)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' e3))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' e1))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' e2))  			continue;  		var ldci4 = instrs [i + 4];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  			continue;  		if (instrs [i + 5].OpCode.Code != Code.And)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' e3))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' e1))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' e2))  			continue;  		var ldci4 = instrs [i + 4];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  			continue;  		if (instrs [i + 5].OpCode.Code != Code.And)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' e3))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' e1))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' e2))  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' e3))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' e1))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' e2))  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' e3))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' e1))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' e2))  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' e3))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' e1))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' e2))  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' e3))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' e1))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' e2))  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' e3))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' e1))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' e2))  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' e3))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' e1))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' e2))  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' e3))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: if (!CheckUnboxAny (instrs [i + 3]' e2))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: if (instrs [i + 5].OpCode.Code != Code.And)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: if (instrs [i + 6].OpCode.Code != code)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: if (!CheckBox (instrs [i + 7]' e3))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.I4))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.I4))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.I4))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.I4))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckLogicalMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.I4))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.I4))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.I4))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.I4))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.I4))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.I4))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != code)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindLogicalOpMethod,The following statement contains a magic number: if (!CheckBox (instrs [i + 5]' ElementType.I4))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckLogicalMethodSig,The following statement contains a magic number: return method != null && method.IsStatic && method.MethodSig.GetParamCount () == 2 && method.MethodSig.RetType.GetElementType () == ElementType.Object && method.MethodSig.Params [0].GetElementType () == ElementType.Object && method.MethodSig.Params [1].GetElementType () == ElementType.Object;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindComparerMethods,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.BaseType == null || type.BaseType.FullName != "System.Object")  		continue;  	if (type.Methods.Count != 9)  		continue;  	CompareLt = FindCompareLt (type);  	if (CompareLt == null)  		continue;  	CompareLte = FindCompareLte (type);  	CompareGt = FindCompareGt (type);  	CompareGte = FindCompareGte (type);  	CompareEq = FindCompareEq (type);  	CompareEqz = FindCompareEqz (type);  	if (CompareLt != null && CompareLte != null && CompareGt != null && CompareGte != null && CompareEq != null && CompareEqz != null)  		return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindComparerMethods,The following statement contains a magic number: if (type.Methods.Count != 9)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	int end = instrs.Count - 6;  	if (invert)  		end -= 2;  	for (int i = 0; i < end; i++) {  		int index = i;  		var ldarg0 = instrs [index++];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [index++]' ElementType.I4))  			continue;  		var ldarg1 = instrs [index++];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [index++]' ElementType.I4))  			continue;  		if (instrs [index++].OpCode.Code != code)  			continue;  		if (invert) {  			var ldci4 = instrs [index++];  			if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0)  				continue;  			if (instrs [index++].OpCode.Code != Code.Ceq)  				continue;  		}  		if (!instrs [index++].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	int end = instrs.Count - 6;  	if (invert)  		end -= 2;  	for (int i = 0; i < end; i++) {  		int index = i;  		var ldarg0 = instrs [index++];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [index++]' ElementType.I4))  			continue;  		var ldarg1 = instrs [index++];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [index++]' ElementType.I4))  			continue;  		if (instrs [index++].OpCode.Code != code)  			continue;  		if (invert) {  			var ldci4 = instrs [index++];  			if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0)  				continue;  			if (instrs [index++].OpCode.Code != Code.Ceq)  				continue;  		}  		if (!instrs [index++].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareMethod,The following statement contains a magic number: if (invert)  	end -= 2;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareMethod,The following statement contains a magic number: end -= 2;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckCompareMethodSig,The following statement contains a magic number: if (sig == null || sig.GetParamCount () != 3)  	return false;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareEqMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != Code.Ceq)  			continue;  		if (!instrs [i + 5].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareEqMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != Code.Ceq)  			continue;  		if (!instrs [i + 5].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareEqMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != Code.Ceq)  			continue;  		if (!instrs [i + 5].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareEqMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != Code.Ceq)  			continue;  		if (!instrs [i + 5].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareEqMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != Code.Ceq)  			continue;  		if (!instrs [i + 5].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Ceq)  		continue;  	if (!instrs [i + 5].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Ceq)  		continue;  	if (!instrs [i + 5].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Ceq)  		continue;  	if (!instrs [i + 5].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Ceq)  		continue;  	if (!instrs [i + 5].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Ceq)  		continue;  	if (!instrs [i + 5].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != Code.Ceq)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEq,The following statement contains a magic number: if (!instrs [i + 5].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckCompareEqMethodSig,The following statement contains a magic number: return method != null && method.IsStatic && method.MethodSig.GetParamCount () == 2 && method.MethodSig.RetType.GetElementType () == ElementType.Boolean && method.MethodSig.Params [0].GetElementType () == ElementType.Object && method.MethodSig.Params [1].GetElementType () == ElementType.Object;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareEqzMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 4; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldci4 = instrs [i + 2];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0)  			continue;  		if (instrs [i + 3].OpCode.Code != Code.Ceq)  			continue;  		if (!instrs [i + 4].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareEqzMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 4; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldci4 = instrs [i + 2];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0)  			continue;  		if (instrs [i + 3].OpCode.Code != Code.Ceq)  			continue;  		if (!instrs [i + 4].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareEqzMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 4; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldci4 = instrs [i + 2];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0)  			continue;  		if (instrs [i + 3].OpCode.Code != Code.Ceq)  			continue;  		if (!instrs [i + 4].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckCompareEqzMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 4; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldci4 = instrs [i + 2];  		if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0)  			continue;  		if (instrs [i + 3].OpCode.Code != Code.Ceq)  			continue;  		if (!instrs [i + 4].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ceq)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ceq)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ceq)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ceq)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Ceq)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindCompareEqz,The following statement contains a magic number: if (!instrs [i + 4].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticMethods,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.BaseType == null || type.BaseType.FullName != "System.Object")  		continue;  	if (type.Methods.Count != 15)  		continue;  	ArithmeticSubOvfUn = FindArithmeticSubOvfUn (type);  	if (ArithmeticSubOvfUn == null)  		continue;  	ArithmeticMulOvfUn = FindArithmeticMulOvfUn (type);  	ArithmeticRemUn = FindArithmeticRemUn (type);  	ArithmeticRem = FindArithmeticRem (type);  	ArithmeticDivUn = FindArithmeticDivUn (type);  	ArithmeticDiv = FindArithmeticDiv (type);  	ArithmeticMul = FindArithmeticMul (type);  	ArithmeticMulOvf = FindArithmeticMulOvf (type);  	ArithmeticSub = FindArithmeticSub (type);  	ArithmeticSubOvf = FindArithmeticSubOvf (type);  	ArithmeticAddOvfUn = FindArithmeticAddOvfUn (type);  	ArithmeticAddOvf = FindArithmeticAddOvf (type);  	ArithmeticAdd = FindArithmeticAdd (type);  	if (ArithmeticSubOvfUn != null && ArithmeticMulOvfUn != null && ArithmeticRemUn != null && ArithmeticRem != null && ArithmeticDivUn != null && ArithmeticDiv != null && ArithmeticMul != null && ArithmeticMulOvf != null && ArithmeticSub != null && ArithmeticSubOvf != null && ArithmeticAddOvfUn != null && ArithmeticAddOvf != null && ArithmeticAdd != null)  		return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticMethods,The following statement contains a magic number: if (type.Methods.Count != 15)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 8; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		var ldarg1 = instrs [i + 3];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' ElementType.U4))  			continue;  		if (!instrs [i + 8].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 8; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		var ldarg1 = instrs [i + 3];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' ElementType.U4))  			continue;  		if (!instrs [i + 8].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 8; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		var ldarg1 = instrs [i + 3];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' ElementType.U4))  			continue;  		if (!instrs [i + 8].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 8; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		var ldarg1 = instrs [i + 3];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' ElementType.U4))  			continue;  		if (!instrs [i + 8].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 8; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		var ldarg1 = instrs [i + 3];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' ElementType.U4))  			continue;  		if (!instrs [i + 8].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 8; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		var ldarg1 = instrs [i + 3];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' ElementType.U4))  			continue;  		if (!instrs [i + 8].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 8; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		var ldarg1 = instrs [i + 3];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' ElementType.U4))  			continue;  		if (!instrs [i + 8].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 8; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		var ldarg1 = instrs [i + 3];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  			continue;  		if (instrs [i + 6].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 7]' ElementType.U4))  			continue;  		if (!instrs [i + 8].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	var ldarg1 = instrs [i + 3];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' ElementType.U4))  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	var ldarg1 = instrs [i + 3];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' ElementType.U4))  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	var ldarg1 = instrs [i + 3];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' ElementType.U4))  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	var ldarg1 = instrs [i + 3];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' ElementType.U4))  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	var ldarg1 = instrs [i + 3];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' ElementType.U4))  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	var ldarg1 = instrs [i + 3];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' ElementType.U4))  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	var ldarg1 = instrs [i + 3];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' ElementType.U4))  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	var ldarg1 = instrs [i + 3];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  		continue;  	if (instrs [i + 6].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 7]' ElementType.U4))  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Conv_Ovf_U4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: if (!CheckCallvirt (instrs [i + 4]' "System.Int32"' "()"))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: if (instrs [i + 5].OpCode.Code != Code.Conv_Ovf_U4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: if (instrs [i + 6].OpCode.Code != code)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: if (!CheckBox (instrs [i + 7]' ElementType.U4))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOpUn,The following statement contains a magic number: if (!instrs [i + 8].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckArithmeticUnMethodSig,The following statement contains a magic number: return method != null && method.IsStatic && method.MethodSig.GetParamCount () == 2 && method.MethodSig.RetType.GetElementType () == ElementType.Object && method.MethodSig.Params [0].GetElementType () == ElementType.Class && method.MethodSig.Params [1].GetElementType () == ElementType.Class;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.U4))  			continue;  		if (!instrs [i + 6].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.U4))  			continue;  		if (!instrs [i + 6].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.U4))  			continue;  		if (!instrs [i + 6].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.U4))  			continue;  		if (!instrs [i + 6].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.U4))  			continue;  		if (!instrs [i + 6].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticUnMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 7; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.U4))  			continue;  		if (!instrs [i + 6].IsStloc ())  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.U4))  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.U4))  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.U4))  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.U4))  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.U4))  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckCallvirt (instrs [i + 1]' "System.Int32"' "()"))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.U4))  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: if (!CheckCallvirt (instrs [i + 3]' "System.Int32"' "()"))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != code)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: if (!CheckBox (instrs [i + 5]' ElementType.U4))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticDivOrRemUn,The following statement contains a magic number: if (!instrs [i + 6].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticOtherMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 6; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.I4))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticOtherMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 6; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.I4))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticOtherMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 6; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.I4))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticOtherMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 6; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.I4))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!CheckArithmeticOtherMethodSig (method))  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 6; i++) {  		var ldarg0 = instrs [i];  		if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  			continue;  		if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  			continue;  		var ldarg1 = instrs [i + 2];  		if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  			continue;  		if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  			continue;  		if (instrs [i + 4].OpCode.Code != code)  			continue;  		if (!CheckBox (instrs [i + 5]' ElementType.I4))  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.I4))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.I4))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.I4))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.I4))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldarg0 = instrs [i];  	if (!ldarg0.IsLdarg () || ldarg0.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	var ldarg1 = instrs [i + 2];  	if (!ldarg1.IsLdarg () || ldarg1.GetParameterIndex () != 1)  		continue;  	if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  		continue;  	if (instrs [i + 4].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 5]' ElementType.I4))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: if (!CheckUnboxAny (instrs [i + 3]' ElementType.I4))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != code)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArithmeticOther,The following statement contains a magic number: if (!CheckBox (instrs [i + 5]' ElementType.I4))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,CheckArithmeticOtherMethodSig,The following statement contains a magic number: return method != null && method.IsStatic && method.MethodSig.GetParamCount () == 2 && method.MethodSig.RetType.GetElementType () == ElementType.Object && method.MethodSig.Params [0].GetElementType () == ElementType.Object && method.MethodSig.Params [1].GetElementType () == ElementType.Object;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindUnaryOpMethod1,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.BaseType != VmHandlerBaseType)  		continue;  	if (type.Methods.Count != 4)  		continue;  	var method = FindUnaryMethod (type' code);  	if (method != null)  		return method;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindUnaryOpMethod1,The following statement contains a magic number: if (type.Methods.Count != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindUnaryOpMethod2,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.BaseType == null || type.BaseType.FullName != "System.Object")  		continue;  	if (type.Methods.Count != 3)  		continue;  	UnaryNot = FindUnaryMethod (type' Code.Not);  	UnaryNeg = FindUnaryMethod (type' Code.Neg);  	if (UnaryNot != null && UnaryNeg != null)  		return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindUnaryOpMethod2,The following statement contains a magic number: if (type.Methods.Count != 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	if (instrs [i + 2].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 3]' ElementType.I4))  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	if (instrs [i + 2].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 3]' ElementType.I4))  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	if (instrs [i + 2].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 3]' ElementType.I4))  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  		continue;  	if (!CheckUnboxAny (instrs [i + 1]' ElementType.I4))  		continue;  	if (instrs [i + 2].OpCode.Code != code)  		continue;  	if (!CheckBox (instrs [i + 3]' ElementType.I4))  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != code)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: if (!CheckBox (instrs [i + 3]' ElementType.I4))  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,IsUnsaryMethod,The following statement contains a magic number: if (!instrs [i + 4].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindArgsLocals,The following statement contains a magic number: return FindArgsLocals (ctor' 1' out ArgsGet' out ArgsSet) && FindArgsLocals (ctor' 2' out LocalsGet' out LocalsSet);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindVmState,The following statement contains a magic number: foreach (var method in VmHandlerBaseType.Methods) {  	if (method.IsStatic || !method.IsAbstract)  		continue;  	if (method.Parameters.Count != 2)  		continue;  	var arg1 = method.Parameters [1].Type.TryGetTypeDef ();  	if (arg1 == null)  		continue;  	return arg1;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,CsvmInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\CsvmInfo.cs,FindVmState,The following statement contains a magic number: if (method.Parameters.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq:  case Code.Beq_S:  	return GetHash (BASE_INDEX + 0);  case Code.Bge:  case Code.Bge_S:  	return GetHash (BASE_INDEX + 1);  case Code.Bge_Un:  case Code.Bge_Un_S:  	return GetHash (BASE_INDEX + 2);  case Code.Bgt:  case Code.Bgt_S:  	return GetHash (BASE_INDEX + 3);  case Code.Bgt_Un:  case Code.Bgt_Un_S:  	return GetHash (BASE_INDEX + 4);  case Code.Ble:  case Code.Ble_S:  	return GetHash (BASE_INDEX + 5);  case Code.Ble_Un:  case Code.Ble_Un_S:  	return GetHash (BASE_INDEX + 6);  case Code.Blt:  case Code.Blt_S:  	return GetHash (BASE_INDEX + 7);  case Code.Blt_Un:  case Code.Blt_Un_S:  	return GetHash (BASE_INDEX + 8);  case Code.Bne_Un:  case Code.Bne_Un_S:  	return GetHash (BASE_INDEX + 9);  case Code.Brfalse:  case Code.Brfalse_S:  	return GetHash (BASE_INDEX + 10);  case Code.Brtrue:  case Code.Brtrue_S:  	return GetHash (BASE_INDEX + 11);  case Code.Switch:  	return GetHash (BASE_INDEX + 12);  case Code.Ceq:  	return GetHash (BASE_INDEX + 13);  case Code.Cgt:  	return GetHash (BASE_INDEX + 14);  case Code.Cgt_Un:  	return GetHash (BASE_INDEX + 15);  case Code.Clt:  	return GetHash (BASE_INDEX + 16);  case Code.Clt_Un:  	return GetHash (BASE_INDEX + 17);  case Code.Ldc_I4:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  case Code.Ldc_I4_S:  	return GetHash (instr.GetLdcI4Value ());  case Code.Ldstr:  	return GetHash (instr.Operand as string);  case Code.Rethrow:  	return GetHash (BASE_INDEX + 18);  case Code.Throw:  	return GetHash (BASE_INDEX + 19);  case Code.Call:  case Code.Callvirt:  	Hash (instr.Operand);  	return (BlockElementHash)hasher.GetHash ();  case Code.Ldfld:  	var field = instr.Operand as FieldDef;  	if (!IsTypeField (field))  		return null;  	if (index + 1 >= instrs.Count || !instrs [index + 1].IsLdcI4 ())  		return null;  	index++;  	return GetHash (GetFieldId (field));  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 2);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 3);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 4);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 5);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 6);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 7);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 8);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 9);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 10);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 11);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 12);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 13);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 14);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 15);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 16);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 17);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 18);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,CalculateHash,The following statement contains a magic number: return GetHash (BASE_INDEX + 19);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,GetFieldId,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  	result += (int)fieldType.ElementType;  	if (fieldType.Next == null)  		break;  	result += 0x100;  	fieldType = fieldType.Next;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,Hash,The following statement contains a magic number: if (level++ > 20)  	return;  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,SigCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\SigCreator.cs,IsFromNonObfuscatedAssembly,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  	var asmRef = tr.ResolutionScope as AssemblyRef;  	if (asmRef != null)  		return IsNonObfuscatedAssembly (asmRef);  	var tr2 = tr.ResolutionScope as TypeRef;  	if (tr2 != null) {  		tr = tr2;  		continue;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.LogicalOpShl' 2);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.LogicalOpShr' 3);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.LogicalOpAnd' 4);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.LogicalOpXor' 5);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.LogicalOpOr' 6);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.CompareLt' 7);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.CompareLte' 8);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.CompareGt' 9);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.CompareGte' 10);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.CompareEq' 11);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.CompareEqz' 12);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticSubOvfUn' 13);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticMulOvfUn' 14);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticRemUn' 15);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticRem' 16);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticDivUn' 17);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticDiv' 18);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticMul' 19);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticMulOvf' 20);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticSub' 21);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticSubOvf' 22);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticAddOvfUn' 23);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticAddOvf' 24);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArithmeticAdd' 25);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.UnaryNot' 26);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.UnaryNeg' 27);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArgsGet' 28);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.ArgsSet' 29);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.LocalsGet' 30);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: creator.AddId (csvmInfo.LocalsSet' 31);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: AddTypeId (creator' csvmInfo.LogicalOpShrUn' 32);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: AddTypeId (creator' csvmInfo.CompareLt' 33);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: AddTypeId (creator' csvmInfo.ArithmeticSubOvfUn' 34);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: AddTypeId (creator' csvmInfo.UnaryNot' 35);  
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm.v2,VmOpCodeHandlerDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Agile_NET\vm\v2\VmOpCodeHandlerDetector.cs,CreateSigCreator,The following statement contains a magic number: AddTypeId (creator' csvmInfo.ArgsGet' 36);  
Magic Number,de4dot.code.deobfuscators,ArrayFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,GetArray,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  	var newarr = instrs [i++];  	if (newarr.OpCode.Code != Code.Newarr)  		continue;  	if (instrs [i++].OpCode.Code != Code.Dup)  		continue;  	var ldtoken = instrs [i++];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var field = ldtoken.Operand as FieldDef;  	if (field == null || field.InitialValue == null)  		continue;  	index = i - 3;  	type = newarr.Operand as IType;  	return field.InitialValue;  }  
Magic Number,de4dot.code.deobfuscators,ArrayFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,GetArray,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  	var newarr = instrs [i++];  	if (newarr.OpCode.Code != Code.Newarr)  		continue;  	if (instrs [i++].OpCode.Code != Code.Dup)  		continue;  	var ldtoken = instrs [i++];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var field = ldtoken.Operand as FieldDef;  	if (field == null || field.InitialValue == null)  		continue;  	index = i - 3;  	type = newarr.Operand as IType;  	return field.InitialValue;  }  
Magic Number,de4dot.code.deobfuscators,ArrayFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,GetArray,The following statement contains a magic number: index = i - 3;  
Magic Number,de4dot.code.deobfuscators,ArrayFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,GetInitializedArray,The following statement contains a magic number: for (i = newarrIndex + 1; i < instructions.Count; i++) {  	var instr = instructions [i];  	if (instr.OpCode.FlowControl != FlowControl.Next)  		break;  	if (instr.OpCode.Code == Code.Newarr)  		break;  	switch (instr.OpCode.Code) {  	case Code.Newarr:  	case Code.Newobj:  		goto done;  	case Code.Stloc:  	case Code.Stloc_S:  	case Code.Stloc_0:  	case Code.Stloc_1:  	case Code.Stloc_2:  	case Code.Stloc_3:  	case Code.Starg:  	case Code.Starg_S:  	case Code.Stsfld:  	case Code.Stfld:  		if (emulator.Peek () == theArray && i != newarrIndex + 1 && i != newarrIndex + 2)  			goto done;  		break;  	}  	if (instr.OpCode.Code == stelemOpCode) {  		var value = emulator.Pop ();  		var index = emulator.Pop () as Int32Value;  		var array = emulator.Pop ();  		if (ReferenceEquals (array' theArray) && index != null && index.AllBitsValid ()) {  			if (0 <= index.Value && index.Value < resultValueArray.Length)  				resultValueArray [index.Value] = value;  		}  	} else  		emulator.Emulate (instr);  }  
Magic Number,de4dot.code.deobfuscators,ArrayFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,GetInitializedArray,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Newarr:  case Code.Newobj:  	goto done;  case Code.Stloc:  case Code.Stloc_S:  case Code.Stloc_0:  case Code.Stloc_1:  case Code.Stloc_2:  case Code.Stloc_3:  case Code.Starg:  case Code.Starg_S:  case Code.Stsfld:  case Code.Stfld:  	if (emulator.Peek () == theArray && i != newarrIndex + 1 && i != newarrIndex + 2)  		goto done;  	break;  }  
Magic Number,de4dot.code.deobfuscators,ArrayFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,GetInitializedArray,The following statement contains a magic number: if (emulator.Peek () == theArray && i != newarrIndex + 1 && i != newarrIndex + 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  	P [i] = Pboxes [i] ^ (((uint)key [ki++ % kl] << 24) | ((uint)key [ki++ % kl] << 16) | ((uint)key [ki++ % kl] << 8) | key [ki++ % kl]);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  	P [i] = Pboxes [i] ^ (((uint)key [ki++ % kl] << 24) | ((uint)key [ki++ % kl] << 16) | ((uint)key [ki++ % kl] << 8) | key [ki++ % kl]);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  	P [i] = Pboxes [i] ^ (((uint)key [ki++ % kl] << 24) | ((uint)key [ki++ % kl] << 16) | ((uint)key [ki++ % kl] << 8) | key [ki++ % kl]);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  	P [i] = Pboxes [i] ^ (((uint)key [ki++ % kl] << 24) | ((uint)key [ki++ % kl] << 16) | ((uint)key [ki++ % kl] << 8) | key [ki++ % kl]);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: P [i] = Pboxes [i] ^ (((uint)key [ki++ % kl] << 24) | ((uint)key [ki++ % kl] << 16) | ((uint)key [ki++ % kl] << 8) | key [ki++ % kl]);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: P [i] = Pboxes [i] ^ (((uint)key [ki++ % kl] << 24) | ((uint)key [ki++ % kl] << 16) | ((uint)key [ki++ % kl] << 8) | key [ki++ % kl]);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: P [i] = Pboxes [i] ^ (((uint)key [ki++ % kl] << 24) | ((uint)key [ki++ % kl] << 16) | ((uint)key [ki++ % kl] << 8) | key [ki++ % kl]);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 18; i += 2) {  	Encrypt (ref xl' ref xr);  	P [i] = xl;  	P [i + 1] = xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 18; i += 2) {  	Encrypt (ref xl' ref xr);  	P [i] = xl;  	P [i + 1] = xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: i += 2
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 1024; i += 2) {  	Encrypt (ref xl' ref xr);  	S [i] = xl;  	S [i + 1] = xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 1024; i += 2) {  	Encrypt (ref xl' ref xr);  	S [i] = xl;  	S [i + 1] = xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Initialize,The following statement contains a magic number: i += 2
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: i += 8
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 1] = (byte)(xl >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 2] = (byte)(xl >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 2] = (byte)(xl >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 3] = (byte)(xl >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 3] = (byte)(xl >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 4] = (byte)xr;  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 5] = (byte)(xr >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 5] = (byte)(xr >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 6] = (byte)(xr >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 6] = (byte)(xr >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 7] = (byte)(xr >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt_LE,The following statement contains a magic number: data [i + 7] = (byte)(xr >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Encrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: i += 8
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i] = (byte)(xl >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 1] = (byte)(xl >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 2] = (byte)(xl >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 2] = (byte)(xl >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 3] = (byte)xl;  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 4] = (byte)(xr >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 4] = (byte)(xr >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 5] = (byte)(xr >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 5] = (byte)(xr >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 6] = (byte)(xr >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 6] = (byte)(xr >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: data [i + 7] = (byte)xr;  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: rxr = xl ^ P [16];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Encrypt,The following statement contains a magic number: rxl = xr ^ P [17];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = BitConverter.ToUInt32 (data' i);  	uint xr = BitConverter.ToUInt32 (data' i + 4);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)xl;  	data [i + 1] = (byte)(xl >> 8);  	data [i + 2] = (byte)(xl >> 16);  	data [i + 3] = (byte)(xl >> 24);  	data [i + 4] = (byte)xr;  	data [i + 5] = (byte)(xr >> 8);  	data [i + 6] = (byte)(xr >> 16);  	data [i + 7] = (byte)(xr >> 24);  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: i += 8
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 1] = (byte)(xl >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 2] = (byte)(xl >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 2] = (byte)(xl >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 3] = (byte)(xl >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 3] = (byte)(xl >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 4] = (byte)xr;  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 5] = (byte)(xr >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 5] = (byte)(xr >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 6] = (byte)(xr >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 6] = (byte)(xr >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 7] = (byte)(xr >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt_LE,The following statement contains a magic number: data [i + 7] = (byte)(xr >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  	uint xl = (uint)((data [i] << 24) | (data [i + 1] << 16) | (data [i + 2] << 8) | data [i + 3]);  	uint xr = (uint)((data [i + 4] << 24) | (data [i + 5] << 16) | (data [i + 6] << 8) | data [i + 7]);  	Decrypt (ref xl' ref xr);  	data [i] = (byte)(xl >> 24);  	data [i + 1] = (byte)(xl >> 16);  	data [i + 2] = (byte)(xl >> 8);  	data [i + 3] = (byte)xl;  	data [i + 4] = (byte)(xr >> 24);  	data [i + 5] = (byte)(xr >> 16);  	data [i + 6] = (byte)(xr >> 8);  	data [i + 7] = (byte)xr;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: i += 8
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i] = (byte)(xl >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 1] = (byte)(xl >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 2] = (byte)(xl >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 2] = (byte)(xl >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 3] = (byte)xl;  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 4] = (byte)(xr >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 4] = (byte)(xr >> 24);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 5] = (byte)(xr >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 5] = (byte)(xr >> 16);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 6] = (byte)(xr >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 6] = (byte)(xr >> 8);  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: data [i + 7] = (byte)xr;  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  	xl ^= P [i];  	xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  	uint t = xl;  	xl = xr;  	xr = t;  }  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,Blowfish,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Blowfish.cs,Decrypt,The following statement contains a magic number: xr ^= ((S [0 * 256 + (xl >> 24)] + S [1 * 256 + (byte)(xl >> 16)]) ^ S [2 * 256 + (byte)(xl >> 8)]) + S [3 * 256 + (byte)xl];  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt32 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldc_I4:  	case Code.Ldc_I4_S:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  		stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt32 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldc_I4:  	case Code.Ldc_I4_S:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  		stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt32 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldc_I4:  	case Code.Ldc_I4_S:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  		stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt32 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldc_I4:  	case Code.Ldc_I4_S:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  		stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt32 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldc_I4:  	case Code.Ldc_I4_S:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  		stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt32 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldc_I4:  	case Code.Ldc_I4_S:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  		stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt32 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldc_I4:  	case Code.Ldc_I4_S:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  		stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt32 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt32 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<int> (index' op1));  		break;  	case Code.Ldc_I4:  	case Code.Ldc_I4_S:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  		stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldc_I4:  case Code.Ldc_I4_S:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  	stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldc_I4:  case Code.Ldc_I4_S:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  	stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldc_I4:  case Code.Ldc_I4_S:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  	stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldc_I4:  case Code.Ldc_I4_S:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  	stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldc_I4:  case Code.Ldc_I4_S:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  	stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldc_I4:  case Code.Ldc_I4_S:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  	stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldc_I4:  case Code.Ldc_I4_S:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  	stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<int> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt32 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<int> (index' op1));  	break;  case Code.Ldc_I4:  case Code.Ldc_I4_S:  case Code.Ldc_I4_0:  case Code.Ldc_I4_1:  case Code.Ldc_I4_2:  case Code.Ldc_I4_3:  case Code.Ldc_I4_4:  case Code.Ldc_I4_5:  case Code.Ldc_I4_6:  case Code.Ldc_I4_7:  case Code.Ldc_I4_8:  case Code.Ldc_I4_M1:  	stack.Push (new ConstantInfo<int> (index' instr.GetLdcI4Value ()));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<int> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt32,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt64 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  		break;  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  		break;  	case Code.Conv_I8:  	case Code.Conv_U8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldc_I8:  		stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt64 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  		break;  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  		break;  	case Code.Conv_I8:  	case Code.Conv_U8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldc_I8:  		stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt64 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  		break;  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  		break;  	case Code.Conv_I8:  	case Code.Conv_U8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldc_I8:  		stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt64 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  		break;  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  		break;  	case Code.Conv_I8:  	case Code.Conv_U8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldc_I8:  		stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt64 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  		break;  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  		break;  	case Code.Conv_I8:  	case Code.Conv_U8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldc_I8:  		stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt64 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  		break;  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  		break;  	case Code.Conv_I8:  	case Code.Conv_U8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldc_I8:  		stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt64 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  		break;  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  		break;  	case Code.Conv_I8:  	case Code.Conv_U8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldc_I8:  		stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionInt64 (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_I1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  		break;  	case Code.Conv_U1:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  		break;  	case Code.Conv_I2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  		break;  	case Code.Conv_U2:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  		break;  	case Code.Conv_I4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  		break;  	case Code.Conv_U4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  		break;  	case Code.Conv_I8:  	case Code.Conv_U8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  		break;  	case Code.Not:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantInt64 (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<long> (index' op1));  		break;  	case Code.Ldc_I8:  		stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  		break;  	case Code.Xor:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  		break;  	case Code.Or:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  		break;  	case Code.And:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		if (info2.constant == 0)  			goto done;  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  	break;  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  	break;  case Code.Conv_I8:  case Code.Conv_U8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldc_I8:  	stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  	break;  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  	break;  case Code.Conv_I8:  case Code.Conv_U8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldc_I8:  	stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  	break;  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  	break;  case Code.Conv_I8:  case Code.Conv_U8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldc_I8:  	stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  	break;  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  	break;  case Code.Conv_I8:  case Code.Conv_U8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldc_I8:  	stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  	break;  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  	break;  case Code.Conv_I8:  case Code.Conv_U8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldc_I8:  	stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  	break;  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  	break;  case Code.Conv_I8:  case Code.Conv_U8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldc_I8:  	stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  	break;  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  	break;  case Code.Conv_I8:  case Code.Conv_U8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldc_I8:  	stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_I1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (sbyte)stack.Pop ().constant));  	break;  case Code.Conv_U1:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (byte)stack.Pop ().constant));  	break;  case Code.Conv_I2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (short)stack.Pop ().constant));  	break;  case Code.Conv_U2:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (ushort)stack.Pop ().constant));  	break;  case Code.Conv_I4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (int)stack.Pop ().constant));  	break;  case Code.Conv_U4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' (uint)stack.Pop ().constant));  	break;  case Code.Conv_I8:  case Code.Conv_U8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' stack.Pop ().constant));  	break;  case Code.Not:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' ~stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<long> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantInt64 (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<long> (index' op1));  	break;  case Code.Ldc_I8:  	stack.Push (new ConstantInfo<long> (index' (long)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant - info2.constant));  	break;  case Code.Xor:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant ^ info2.constant));  	break;  case Code.Or:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant | info2.constant));  	break;  case Code.And:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant & info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	if (info2.constant == 0)  		goto done;  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<long> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetInt64,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionDouble (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_R4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' (float)stack.Pop ().constant));  		break;  	case Code.Conv_R8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantDouble (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<double> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantDouble (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<double> (index' op1));  		break;  	case Code.Ldc_R4:  		stack.Push (new ConstantInfo<double> (index' (float)instr.Operand));  		break;  	case Code.Ldc_R8:  		stack.Push (new ConstantInfo<double> (index' (double)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant - info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionDouble (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_R4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' (float)stack.Pop ().constant));  		break;  	case Code.Conv_R8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantDouble (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<double> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantDouble (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<double> (index' op1));  		break;  	case Code.Ldc_R4:  		stack.Push (new ConstantInfo<double> (index' (float)instr.Operand));  		break;  	case Code.Ldc_R8:  		stack.Push (new ConstantInfo<double> (index' (double)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant - info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionDouble (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_R4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' (float)stack.Pop ().constant));  		break;  	case Code.Conv_R8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantDouble (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<double> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantDouble (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<double> (index' op1));  		break;  	case Code.Ldc_R4:  		stack.Push (new ConstantInfo<double> (index' (float)instr.Operand));  		break;  	case Code.Ldc_R8:  		stack.Push (new ConstantInfo<double> (index' (double)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant - info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionDouble (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_R4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' (float)stack.Pop ().constant));  		break;  	case Code.Conv_R8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantDouble (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<double> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantDouble (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<double> (index' op1));  		break;  	case Code.Ldc_R4:  		stack.Push (new ConstantInfo<double> (index' (float)instr.Operand));  		break;  	case Code.Ldc_R8:  		stack.Push (new ConstantInfo<double> (index' (double)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant - info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  	if (ProcessInstructionDouble (ref index' stack)) {  		index--;  		continue;  	}  	var instr = instructions [index];  	switch (instr.OpCode.Code) {  	case Code.Conv_R4:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' (float)stack.Pop ().constant));  		break;  	case Code.Conv_R8:  		if (!emulateConvInstrs || stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' stack.Pop ().constant));  		break;  	case Code.Neg:  		if (stack.Count < 1)  			goto done;  		stack.Push (new ConstantInfo<double> (index' -stack.Pop ().constant));  		break;  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  		if (!GetLocalConstantDouble (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<double> (index' op1));  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		if (!GetArgConstantDouble (instr' out op1))  			goto done;  		stack.Push (new ConstantInfo<double> (index' op1));  		break;  	case Code.Ldc_R4:  		stack.Push (new ConstantInfo<double> (index' (float)instr.Operand));  		break;  	case Code.Ldc_R8:  		stack.Push (new ConstantInfo<double> (index' (double)instr.Operand));  		break;  	case Code.Add:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant + info2.constant));  		break;  	case Code.Sub:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant - info2.constant));  		break;  	case Code.Mul:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant * info2.constant));  		break;  	case Code.Div:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' info1.constant / info2.constant));  		break;  	case Code.Div_Un:  		if (stack.Count < 2)  			goto done;  		info2 = stack.Pop ();  		info1 = stack.Pop ();  		stack.Push (new ConstantInfo<double> (index' (int)((uint)info1.constant / (uint)info2.constant)));  		break;  	default:  		goto done;  	}  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_R4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' (float)stack.Pop ().constant));  	break;  case Code.Conv_R8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantDouble (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<double> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantDouble (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<double> (index' op1));  	break;  case Code.Ldc_R4:  	stack.Push (new ConstantInfo<double> (index' (float)instr.Operand));  	break;  case Code.Ldc_R8:  	stack.Push (new ConstantInfo<double> (index' (double)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant - info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_R4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' (float)stack.Pop ().constant));  	break;  case Code.Conv_R8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantDouble (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<double> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantDouble (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<double> (index' op1));  	break;  case Code.Ldc_R4:  	stack.Push (new ConstantInfo<double> (index' (float)instr.Operand));  	break;  case Code.Ldc_R8:  	stack.Push (new ConstantInfo<double> (index' (double)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant - info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_R4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' (float)stack.Pop ().constant));  	break;  case Code.Conv_R8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantDouble (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<double> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantDouble (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<double> (index' op1));  	break;  case Code.Ldc_R4:  	stack.Push (new ConstantInfo<double> (index' (float)instr.Operand));  	break;  case Code.Ldc_R8:  	stack.Push (new ConstantInfo<double> (index' (double)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant - info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_R4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' (float)stack.Pop ().constant));  	break;  case Code.Conv_R8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantDouble (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<double> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantDouble (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<double> (index' op1));  	break;  case Code.Ldc_R4:  	stack.Push (new ConstantInfo<double> (index' (float)instr.Operand));  	break;  case Code.Ldc_R8:  	stack.Push (new ConstantInfo<double> (index' (double)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant - info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Conv_R4:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' (float)stack.Pop ().constant));  	break;  case Code.Conv_R8:  	if (!emulateConvInstrs || stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' stack.Pop ().constant));  	break;  case Code.Neg:  	if (stack.Count < 1)  		goto done;  	stack.Push (new ConstantInfo<double> (index' -stack.Pop ().constant));  	break;  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	if (!GetLocalConstantDouble (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<double> (index' op1));  	break;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  	if (!GetArgConstantDouble (instr' out op1))  		goto done;  	stack.Push (new ConstantInfo<double> (index' op1));  	break;  case Code.Ldc_R4:  	stack.Push (new ConstantInfo<double> (index' (float)instr.Operand));  	break;  case Code.Ldc_R8:  	stack.Push (new ConstantInfo<double> (index' (double)instr.Operand));  	break;  case Code.Add:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant + info2.constant));  	break;  case Code.Sub:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant - info2.constant));  	break;  case Code.Mul:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant * info2.constant));  	break;  case Code.Div:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' info1.constant / info2.constant));  	break;  case Code.Div_Un:  	if (stack.Count < 2)  		goto done;  	info2 = stack.Pop ();  	info1 = stack.Pop ();  	stack.Push (new ConstantInfo<double> (index' (int)((uint)info1.constant / (uint)info2.constant)));  	break;  default:  	goto done;  }  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,ConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,GetDouble,The following statement contains a magic number: if (stack.Count < 2)  	goto done;  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: foreach (var b in data) {  	int i = (byte)(checkSum ^ b);  	checkSum = (checkSum >> 8) ^ table [i];  }  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 16));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 24));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 16));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 24));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 16));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 24));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 32));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 40));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 48));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 56));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 8));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 16));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 24));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 32));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 40));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 48));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: i = (byte)(checkSum ^ (byte)(a >> 56));  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,Hash,The following statement contains a magic number: checkSum = (checkSum >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,CheckSum,The following statement contains a magic number: foreach (var b in data) {  	int i = (byte)(cs ^ b);  	cs = (cs >> 8) ^ table [i];  }  
Magic Number,de4dot.code.deobfuscators,CRC32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CRC32.cs,CheckSum,The following statement contains a magic number: cs = (cs >> 8) ^ table [i];  
Magic Number,de4dot.code.deobfuscators,DeobfuscatorBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,IsFatHeader,The following statement contains a magic number: if (body.InitLocals || body.MaxStack > 8)  	return true;  
Magic Number,de4dot.code.deobfuscators,DeobfuscatorBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,IsFatHeader,The following statement contains a magic number: if (GetCodeSize (method) > 63)  	return true;  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: do {  	int e = (int)((sum >> 2) & 3);  	int p;  	for (p = n - 1; p > 0; p--) {  		z = v [p - 1];  		y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  	}  	z = v [n - 1];  	y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  } while ((sum -= DELTA) != 0);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: for (p = n - 1; p > 0; p--) {  	z = v [p - 1];  	y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: for (p = n - 1; p > 0; p--) {  	z = v [p - 1];  	y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: for (p = n - 1; p > 0; p--) {  	z = v [p - 1];  	y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: for (p = n - 1; p > 0; p--) {  	z = v [p - 1];  	y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: for (p = n - 1; p > 0; p--) {  	z = v [p - 1];  	y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: y = v [p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XxteaDecrypt,The following statement contains a magic number: y = v [0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key [(p & 3) ^ e] ^ z)));  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  	v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  	sum -= delta;  	v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key [sum & 3]);  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  	v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  	sum -= delta;  	v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key [sum & 3]);  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  	v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  	sum -= delta;  	v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key [sum & 3]);  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  	v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  	sum -= delta;  	v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key [sum & 3]);  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  	v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  	sum -= delta;  	v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key [sum & 3]);  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  	v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  	sum -= delta;  	v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key [sum & 3]);  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  	v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  	sum -= delta;  	v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key [sum & 3]);  }  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key [(sum >> 11) & 3]);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key [sum & 3]);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key [sum & 3]);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,XteaDecrypt,The following statement contains a magic number: v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key [sum & 3]);  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,ReadVariableLengthInt32,The following statement contains a magic number: if ((b & 0x40) == 0)  	return (((int)b & 0x3F) << 8) + data [index++];  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,ReadVariableLengthInt32,The following statement contains a magic number: return (((int)b & 0x3F) << 8) + data [index++];  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,ReadVariableLengthInt32,The following statement contains a magic number: return (((int)b & 0x1F) << 24) + ((int)data [index++] << 16) + ((int)data [index++] << 8) + data [index++];  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,ReadVariableLengthInt32,The following statement contains a magic number: return (((int)b & 0x1F) << 24) + ((int)data [index++] << 16) + ((int)data [index++] << 8) + data [index++];  
Magic Number,de4dot.code.deobfuscators,DeobUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeobUtils.cs,ReadVariableLengthInt32,The following statement contains a magic number: return (((int)b & 0x1F) << 24) + ((int)data [index++] << 16) + ((int)data [index++] << 8) + data [index++];  
Magic Number,de4dot.code.deobfuscators,InlinedMethodsFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,Find,The following statement contains a magic number: foreach (var type in module.GetTypes ()) {  	foreach (var method in type.Methods) {  		if (!method.IsStatic)  			continue;  		if (!method.IsAssembly && !method.IsPrivateScope && !method.IsPrivate)  			continue;  		if (method.GenericParameters.Count > 0)  			continue;  		if (method.Name == ".cctor")  			continue;  		if (method.Body == null)  			continue;  		var instrs = method.Body.Instructions;  		if (instrs.Count < 2)  			continue;  		switch (instrs [0].OpCode.Code) {  		case Code.Ldc_I4:  		case Code.Ldc_I4_0:  		case Code.Ldc_I4_1:  		case Code.Ldc_I4_2:  		case Code.Ldc_I4_3:  		case Code.Ldc_I4_4:  		case Code.Ldc_I4_5:  		case Code.Ldc_I4_6:  		case Code.Ldc_I4_7:  		case Code.Ldc_I4_8:  		case Code.Ldc_I4_M1:  		case Code.Ldc_I4_S:  		case Code.Ldc_I8:  		case Code.Ldc_R4:  		case Code.Ldc_R8:  		case Code.Ldftn:  		case Code.Ldnull:  		case Code.Ldstr:  		case Code.Ldtoken:  		case Code.Ldsfld:  		case Code.Ldsflda:  			if (instrs [1].OpCode.Code != Code.Ret)  				continue;  			break;  		case Code.Ldarg:  		case Code.Ldarg_S:  		case Code.Ldarg_0:  		case Code.Ldarg_1:  		case Code.Ldarg_2:  		case Code.Ldarg_3:  		case Code.Ldarga:  		case Code.Ldarga_S:  		case Code.Call:  		case Code.Newobj:  			if (!IsCallMethod (method))  				continue;  			break;  		default:  			continue;  		}  		inlinedMethods.Add (method);  	}  }  
Magic Number,de4dot.code.deobfuscators,InlinedMethodsFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,Find,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!method.IsStatic)  		continue;  	if (!method.IsAssembly && !method.IsPrivateScope && !method.IsPrivate)  		continue;  	if (method.GenericParameters.Count > 0)  		continue;  	if (method.Name == ".cctor")  		continue;  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	if (instrs.Count < 2)  		continue;  	switch (instrs [0].OpCode.Code) {  	case Code.Ldc_I4:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  	case Code.Ldc_I4_S:  	case Code.Ldc_I8:  	case Code.Ldc_R4:  	case Code.Ldc_R8:  	case Code.Ldftn:  	case Code.Ldnull:  	case Code.Ldstr:  	case Code.Ldtoken:  	case Code.Ldsfld:  	case Code.Ldsflda:  		if (instrs [1].OpCode.Code != Code.Ret)  			continue;  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  	case Code.Ldarga:  	case Code.Ldarga_S:  	case Code.Call:  	case Code.Newobj:  		if (!IsCallMethod (method))  			continue;  		break;  	default:  		continue;  	}  	inlinedMethods.Add (method);  }  
Magic Number,de4dot.code.deobfuscators,InlinedMethodsFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,Find,The following statement contains a magic number: if (instrs.Count < 2)  	continue;  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  	mbHeader.flags = 2;  	mbHeader.maxStack = 8;  	mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  	mbHeader.localVarSigTok = 0;  	codeOffset = 1;  } else if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: mbHeader.flags = 2;  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: mbHeader.maxStack = 8;  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: mbHeader.codeSize = (uint)(reader.ReadByte () >> 2);  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((b & 7) == 3) {  	mbHeader.flags = reader.ReadUInt16 ();  	codeOffset = (uint)(4 * (mbHeader.flags >> 12));  	if (codeOffset != 12)  		throw new InvalidMethodBody ();  	mbHeader.maxStack = reader.ReadUInt16 ();  	mbHeader.codeSize = reader.ReadUInt32 ();  	if (mbHeader.codeSize > int.MaxValue)  		throw new InvalidMethodBody ();  	mbHeader.localVarSigTok = reader.ReadUInt32 ();  	if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  		throw new InvalidMethodBody ();  } else  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: codeOffset = (uint)(4 * (mbHeader.flags >> 12));  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: codeOffset = (uint)(4 * (mbHeader.flags >> 12));  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if (codeOffset != 12)  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  	throw new InvalidMethodBody ();  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseMethodBody2,The following statement contains a magic number: if ((mbHeader.flags & 8) != 0)  	extraSections = ReadExtraSections2 (reader);  else  	extraSections = null;  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ReadExtraSections2,The following statement contains a magic number: Align (reader' 4);  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  	Align (reader' 4);  	flags = reader.ReadByte ();  	if ((flags & 1) == 0)  		throw new InvalidMethodBody ("Not an exception section");  	if ((flags & 0x3E) != 0)  		throw new InvalidMethodBody ("Invalid bits set");  	if ((flags & 0x40) != 0) {  		reader.Position--;  		int num = (int)(reader.ReadUInt32 () >> 8) / 24;  		reader.Position += num * 24;  	} else {  		int num = reader.ReadByte () / 12;  		reader.Position += 2 + num * 12;  	}  } while ((flags & 0x80) != 0);  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  	Align (reader' 4);  	flags = reader.ReadByte ();  	if ((flags & 1) == 0)  		throw new InvalidMethodBody ("Not an exception section");  	if ((flags & 0x3E) != 0)  		throw new InvalidMethodBody ("Invalid bits set");  	if ((flags & 0x40) != 0) {  		reader.Position--;  		int num = (int)(reader.ReadUInt32 () >> 8) / 24;  		reader.Position += num * 24;  	} else {  		int num = reader.ReadByte () / 12;  		reader.Position += 2 + num * 12;  	}  } while ((flags & 0x80) != 0);  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  	Align (reader' 4);  	flags = reader.ReadByte ();  	if ((flags & 1) == 0)  		throw new InvalidMethodBody ("Not an exception section");  	if ((flags & 0x3E) != 0)  		throw new InvalidMethodBody ("Invalid bits set");  	if ((flags & 0x40) != 0) {  		reader.Position--;  		int num = (int)(reader.ReadUInt32 () >> 8) / 24;  		reader.Position += num * 24;  	} else {  		int num = reader.ReadByte () / 12;  		reader.Position += 2 + num * 12;  	}  } while ((flags & 0x80) != 0);  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  	Align (reader' 4);  	flags = reader.ReadByte ();  	if ((flags & 1) == 0)  		throw new InvalidMethodBody ("Not an exception section");  	if ((flags & 0x3E) != 0)  		throw new InvalidMethodBody ("Invalid bits set");  	if ((flags & 0x40) != 0) {  		reader.Position--;  		int num = (int)(reader.ReadUInt32 () >> 8) / 24;  		reader.Position += num * 24;  	} else {  		int num = reader.ReadByte () / 12;  		reader.Position += 2 + num * 12;  	}  } while ((flags & 0x80) != 0);  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  	Align (reader' 4);  	flags = reader.ReadByte ();  	if ((flags & 1) == 0)  		throw new InvalidMethodBody ("Not an exception section");  	if ((flags & 0x3E) != 0)  		throw new InvalidMethodBody ("Invalid bits set");  	if ((flags & 0x40) != 0) {  		reader.Position--;  		int num = (int)(reader.ReadUInt32 () >> 8) / 24;  		reader.Position += num * 24;  	} else {  		int num = reader.ReadByte () / 12;  		reader.Position += 2 + num * 12;  	}  } while ((flags & 0x80) != 0);  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  	Align (reader' 4);  	flags = reader.ReadByte ();  	if ((flags & 1) == 0)  		throw new InvalidMethodBody ("Not an exception section");  	if ((flags & 0x3E) != 0)  		throw new InvalidMethodBody ("Invalid bits set");  	if ((flags & 0x40) != 0) {  		reader.Position--;  		int num = (int)(reader.ReadUInt32 () >> 8) / 24;  		reader.Position += num * 24;  	} else {  		int num = reader.ReadByte () / 12;  		reader.Position += 2 + num * 12;  	}  } while ((flags & 0x80) != 0);  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: do {  	Align (reader' 4);  	flags = reader.ReadByte ();  	if ((flags & 1) == 0)  		throw new InvalidMethodBody ("Not an exception section");  	if ((flags & 0x3E) != 0)  		throw new InvalidMethodBody ("Invalid bits set");  	if ((flags & 0x40) != 0) {  		reader.Position--;  		int num = (int)(reader.ReadUInt32 () >> 8) / 24;  		reader.Position += num * 24;  	} else {  		int num = reader.ReadByte () / 12;  		reader.Position += 2 + num * 12;  	}  } while ((flags & 0x80) != 0);  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: Align (reader' 4);  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: if ((flags & 0x40) != 0) {  	reader.Position--;  	int num = (int)(reader.ReadUInt32 () >> 8) / 24;  	reader.Position += num * 24;  } else {  	int num = reader.ReadByte () / 12;  	reader.Position += 2 + num * 12;  }  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: if ((flags & 0x40) != 0) {  	reader.Position--;  	int num = (int)(reader.ReadUInt32 () >> 8) / 24;  	reader.Position += num * 24;  } else {  	int num = reader.ReadByte () / 12;  	reader.Position += 2 + num * 12;  }  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: if ((flags & 0x40) != 0) {  	reader.Position--;  	int num = (int)(reader.ReadUInt32 () >> 8) / 24;  	reader.Position += num * 24;  } else {  	int num = reader.ReadByte () / 12;  	reader.Position += 2 + num * 12;  }  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: if ((flags & 0x40) != 0) {  	reader.Position--;  	int num = (int)(reader.ReadUInt32 () >> 8) / 24;  	reader.Position += num * 24;  } else {  	int num = reader.ReadByte () / 12;  	reader.Position += 2 + num * 12;  }  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: if ((flags & 0x40) != 0) {  	reader.Position--;  	int num = (int)(reader.ReadUInt32 () >> 8) / 24;  	reader.Position += num * 24;  } else {  	int num = reader.ReadByte () / 12;  	reader.Position += 2 + num * 12;  }  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: if ((flags & 0x40) != 0) {  	reader.Position--;  	int num = (int)(reader.ReadUInt32 () >> 8) / 24;  	reader.Position += num * 24;  } else {  	int num = reader.ReadByte () / 12;  	reader.Position += 2 + num * 12;  }  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: reader.Position += num * 24;  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: reader.Position += 2 + num * 12;  
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,ParseSection,The following statement contains a magic number: reader.Position += 2 + num * 12;  
Magic Number,de4dot.code.deobfuscators,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	try {  		return Decrypt2 (serverVersion' filename' moduleCctorBytes);  	} catch (RemotingException ex) {  		lastEx = ex;  		continue;  	}  }  
Magic Number,de4dot.code.deobfuscators,MyPEImage,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt32,The following statement contains a magic number: peImageData [offset + 1] = (byte)(val >> 8);  
Magic Number,de4dot.code.deobfuscators,MyPEImage,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt32,The following statement contains a magic number: peImageData [offset + 2] = (byte)(val >> 16);  
Magic Number,de4dot.code.deobfuscators,MyPEImage,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt32,The following statement contains a magic number: peImageData [offset + 2] = (byte)(val >> 16);  
Magic Number,de4dot.code.deobfuscators,MyPEImage,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt32,The following statement contains a magic number: peImageData [offset + 3] = (byte)(val >> 24);  
Magic Number,de4dot.code.deobfuscators,MyPEImage,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt32,The following statement contains a magic number: peImageData [offset + 3] = (byte)(val >> 24);  
Magic Number,de4dot.code.deobfuscators,MyPEImage,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MyPEImage.cs,OffsetWriteUInt16,The following statement contains a magic number: peImageData [offset + 1] = (byte)(val >> 8);  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (true) {  	if (val1 == 1) {  		val1 = Read32 (inData' inIndex);  		inIndex += 4;  	}  	uint val2 = Read32 (inData' inIndex);  	if ((val1 & 1) == 1) {  		val1 >>= 1;  		if ((val2 & 3) == 0) {  			count = (val2 & 0xFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex++;  		} else if ((val2 & 2) == 0) {  			count = (val2 & 0xFFFF) >> 2;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  			outIndex += 3;  			inIndex += 2;  		} else if ((val2 & 1) == 0) {  			size = (int)((val2 >> 2) & 0x0F) + 3;  			count = (val2 & 0xFFFF) >> 6;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 2;  		} else if ((val2 & 4) == 0) {  			size = (int)((val2 >> 3) & 0x1F) + 3;  			count = (val2 & 0xFFFFFF) >> 8;  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  			inIndex += 3;  		} else if ((val2 & 8) == 0) {  			count = val2 >> 15;  			if (count != 0) {  				size = (int)((val2 >> 4) & 0x07FF) + 3;  				inIndex += 4;  			} else {  				size = (int)Read32 (inData' inIndex + 4);  				count = Read32 (inData' inIndex + 8);  				inIndex += 12;  			}  			Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  			outIndex += size;  		} else {  			byte b = (byte)(val2 >> 16);  			size = (int)(val2 >> 4) & 0x0FFF;  			if (size == 0) {  				size = (int)Read32 (inData' inIndex + 3);  				inIndex += 7;  			} else  				inIndex += 3;  			for (int i = 0; i < size; i++)  				outData [outIndex++] = b;  		}  	} else {  		Copy (inData' inIndex' outData' outIndex' 4);  		int index = (int)(val1 & 0x0F);  		outIndex += indexInc [index];  		inIndex += indexInc [index];  		val1 >>= indexInc [index];  		if (outIndex >= decompressedLength - 4)  			break;  	}  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (val1 == 1) {  	val1 = Read32 (inData' inIndex);  	inIndex += 4;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: inIndex += 4;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val1 & 1) == 1) {  	val1 >>= 1;  	if ((val2 & 3) == 0) {  		count = (val2 & 0xFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex++;  	} else if ((val2 & 2) == 0) {  		count = (val2 & 0xFFFF) >> 2;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  		outIndex += 3;  		inIndex += 2;  	} else if ((val2 & 1) == 0) {  		size = (int)((val2 >> 2) & 0x0F) + 3;  		count = (val2 & 0xFFFF) >> 6;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 2;  	} else if ((val2 & 4) == 0) {  		size = (int)((val2 >> 3) & 0x1F) + 3;  		count = (val2 & 0xFFFFFF) >> 8;  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  		inIndex += 3;  	} else if ((val2 & 8) == 0) {  		count = val2 >> 15;  		if (count != 0) {  			size = (int)((val2 >> 4) & 0x07FF) + 3;  			inIndex += 4;  		} else {  			size = (int)Read32 (inData' inIndex + 4);  			count = Read32 (inData' inIndex + 8);  			inIndex += 12;  		}  		Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  		outIndex += size;  	} else {  		byte b = (byte)(val2 >> 16);  		size = (int)(val2 >> 4) & 0x0FFF;  		if (size == 0) {  			size = (int)Read32 (inData' inIndex + 3);  			inIndex += 7;  		} else  			inIndex += 3;  		for (int i = 0; i < size; i++)  			outData [outIndex++] = b;  	}  } else {  	Copy (inData' inIndex' outData' outIndex' 4);  	int index = (int)(val1 & 0x0F);  	outIndex += indexInc [index];  	inIndex += indexInc [index];  	val1 >>= indexInc [index];  	if (outIndex >= decompressedLength - 4)  		break;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 3) == 0) {  	count = (val2 & 0xFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex++;  } else if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: count = (val2 & 0xFF) >> 2;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: outIndex += 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 2) == 0) {  	count = (val2 & 0xFFFF) >> 2;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  	outIndex += 3;  	inIndex += 2;  } else if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: count = (val2 & 0xFFFF) >> 2;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: Copy (outData' (int)(outIndex - count)' outData' outIndex' 3);  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: outIndex += 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: inIndex += 2;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 1) == 0) {  	size = (int)((val2 >> 2) & 0x0F) + 3;  	count = (val2 & 0xFFFF) >> 6;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 2;  } else if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: size = (int)((val2 >> 2) & 0x0F) + 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: size = (int)((val2 >> 2) & 0x0F) + 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: count = (val2 & 0xFFFF) >> 6;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: inIndex += 2;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 4) == 0) {  	size = (int)((val2 >> 3) & 0x1F) + 3;  	count = (val2 & 0xFFFFFF) >> 8;  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  	inIndex += 3;  } else if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: size = (int)((val2 >> 3) & 0x1F) + 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: size = (int)((val2 >> 3) & 0x1F) + 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: count = (val2 & 0xFFFFFF) >> 8;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: inIndex += 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if ((val2 & 8) == 0) {  	count = val2 >> 15;  	if (count != 0) {  		size = (int)((val2 >> 4) & 0x07FF) + 3;  		inIndex += 4;  	} else {  		size = (int)Read32 (inData' inIndex + 4);  		count = Read32 (inData' inIndex + 8);  		inIndex += 12;  	}  	Copy (outData' (int)(outIndex - count)' outData' outIndex' size);  	outIndex += size;  } else {  	byte b = (byte)(val2 >> 16);  	size = (int)(val2 >> 4) & 0x0FFF;  	if (size == 0) {  		size = (int)Read32 (inData' inIndex + 3);  		inIndex += 7;  	} else  		inIndex += 3;  	for (int i = 0; i < size; i++)  		outData [outIndex++] = b;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: count = val2 >> 15;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (count != 0) {  	size = (int)((val2 >> 4) & 0x07FF) + 3;  	inIndex += 4;  } else {  	size = (int)Read32 (inData' inIndex + 4);  	count = Read32 (inData' inIndex + 8);  	inIndex += 12;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (count != 0) {  	size = (int)((val2 >> 4) & 0x07FF) + 3;  	inIndex += 4;  } else {  	size = (int)Read32 (inData' inIndex + 4);  	count = Read32 (inData' inIndex + 8);  	inIndex += 12;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (count != 0) {  	size = (int)((val2 >> 4) & 0x07FF) + 3;  	inIndex += 4;  } else {  	size = (int)Read32 (inData' inIndex + 4);  	count = Read32 (inData' inIndex + 8);  	inIndex += 12;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (count != 0) {  	size = (int)((val2 >> 4) & 0x07FF) + 3;  	inIndex += 4;  } else {  	size = (int)Read32 (inData' inIndex + 4);  	count = Read32 (inData' inIndex + 8);  	inIndex += 12;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (count != 0) {  	size = (int)((val2 >> 4) & 0x07FF) + 3;  	inIndex += 4;  } else {  	size = (int)Read32 (inData' inIndex + 4);  	count = Read32 (inData' inIndex + 8);  	inIndex += 12;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (count != 0) {  	size = (int)((val2 >> 4) & 0x07FF) + 3;  	inIndex += 4;  } else {  	size = (int)Read32 (inData' inIndex + 4);  	count = Read32 (inData' inIndex + 8);  	inIndex += 12;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: size = (int)((val2 >> 4) & 0x07FF) + 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: size = (int)((val2 >> 4) & 0x07FF) + 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: inIndex += 4;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: size = (int)Read32 (inData' inIndex + 4);  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: count = Read32 (inData' inIndex + 8);  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: inIndex += 12;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: size = (int)(val2 >> 4) & 0x0FFF;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (size == 0) {  	size = (int)Read32 (inData' inIndex + 3);  	inIndex += 7;  } else  	inIndex += 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (size == 0) {  	size = (int)Read32 (inData' inIndex + 3);  	inIndex += 7;  } else  	inIndex += 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (size == 0) {  	size = (int)Read32 (inData' inIndex + 3);  	inIndex += 7;  } else  	inIndex += 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: size = (int)Read32 (inData' inIndex + 3);  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: inIndex += 7;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: inIndex += 3;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: Copy (inData' inIndex' outData' outIndex' 4);  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (outIndex >= decompressedLength - 4)  	break;  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: while (outIndex < decompressedLength) {  	if (val1 == 1) {  		inIndex += 4;  		val1 = 0x80000000;  	}  	outData [outIndex++] = inData [inIndex++];  	val1 >>= 1;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (val1 == 1) {  	inIndex += 4;  	val1 = 0x80000000;  }  
Magic Number,de4dot.code.deobfuscators,QuickLZBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: inIndex += 4;  
Magic Number,de4dot.code.deobfuscators,QuickLZ,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,IsCompressed,The following statement contains a magic number: if (data.Length < 4)  	return false;  
Magic Number,de4dot.code.deobfuscators,QuickLZ,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: BitConverter.ToInt32 (inData' 4);  
Magic Number,de4dot.code.deobfuscators,QuickLZ,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\QuickLZ.cs,Decompress,The following statement contains a magic number: if (BitConverter.ToInt32 (inData' 0) != sig || BitConverter.ToInt32 (inData' compressedLength - 4) != sig)  	throw new ApplicationException ("No QCLZ sig");  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: if (name.Length < 5)  	return true;  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  case 1:  	return vowels == words.Count;  case 2:  case 3:  	return vowels >= 1;  case 4:  case 5:  	return vowels >= 2;  case 6:  	return vowels >= 3;  case 7:  	return vowels >= 4;  default:  	return vowels >= words.Count - 4;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  case 1:  	return vowels == words.Count;  case 2:  case 3:  	return vowels >= 1;  case 4:  case 5:  	return vowels >= 2;  case 6:  	return vowels >= 3;  case 7:  	return vowels >= 4;  default:  	return vowels >= words.Count - 4;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  case 1:  	return vowels == words.Count;  case 2:  case 3:  	return vowels >= 1;  case 4:  case 5:  	return vowels >= 2;  case 6:  	return vowels >= 3;  case 7:  	return vowels >= 4;  default:  	return vowels >= words.Count - 4;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  case 1:  	return vowels == words.Count;  case 2:  case 3:  	return vowels >= 1;  case 4:  case 5:  	return vowels >= 2;  case 6:  	return vowels >= 3;  case 7:  	return vowels >= 4;  default:  	return vowels >= words.Count - 4;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  case 1:  	return vowels == words.Count;  case 2:  case 3:  	return vowels >= 1;  case 4:  case 5:  	return vowels >= 2;  case 6:  	return vowels >= 3;  case 7:  	return vowels >= 4;  default:  	return vowels >= words.Count - 4;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  case 1:  	return vowels == words.Count;  case 2:  case 3:  	return vowels >= 1;  case 4:  case 5:  	return vowels >= 2;  case 6:  	return vowels >= 3;  case 7:  	return vowels >= 4;  default:  	return vowels >= words.Count - 4;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  case 1:  	return vowels == words.Count;  case 2:  case 3:  	return vowels >= 1;  case 4:  case 5:  	return vowels >= 2;  case 6:  	return vowels >= 3;  case 7:  	return vowels >= 4;  default:  	return vowels >= words.Count - 4;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  case 1:  	return vowels == words.Count;  case 2:  case 3:  	return vowels >= 1;  case 4:  case 5:  	return vowels >= 2;  case 6:  	return vowels >= 3;  case 7:  	return vowels >= 4;  default:  	return vowels >= words.Count - 4;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  case 1:  	return vowels == words.Count;  case 2:  case 3:  	return vowels >= 1;  case 4:  case 5:  	return vowels >= 2;  case 6:  	return vowels >= 3;  case 7:  	return vowels >= 4;  default:  	return vowels >= words.Count - 4;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: switch (words.Count) {  case 1:  	return vowels == words.Count;  case 2:  case 3:  	return vowels >= 1;  case 4:  case 5:  	return vowels >= 2;  case 6:  	return vowels >= 3;  case 7:  	return vowels >= 4;  default:  	return vowels >= words.Count - 4;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: return vowels >= 2;  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: return vowels >= 3;  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: return vowels >= 4;  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsNonRandom,The following statement contains a magic number: return vowels >= words.Count - 4;  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (len < 5)  	return false;  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (CountNumbers (typeWords' 2))  	return true;  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (upper >= 3)  	return true;  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: for (int i = 2; i < typeWords.Count; i++) {  	if (IsDigit (typeWords [i - 1] [0]) && IsLower (typeWords [i - 2] [0]) && IsLower (typeWords [i] [0]))  		return true;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: for (int i = 2; i < typeWords.Count; i++) {  	if (IsDigit (typeWords [i - 1] [0]) && IsLower (typeWords [i - 2] [0]) && IsLower (typeWords [i] [0]))  		return true;  }  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (IsDigit (typeWords [i - 1] [0]) && IsLower (typeWords [i - 2] [0]) && IsLower (typeWords [i] [0]))  	return true;  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (IsLower (name [len - 3]) && IsUpper (name [len - 2]) && IsDigit (name [len - 1]))  	return true;  
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,IsRandom,The following statement contains a magic number: if (IsLower (name [len - 3]) && IsUpper (name [len - 2]) && IsDigit (name [len - 1]))  	return true;  
Magic Number,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateLoop,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  	bool modified = false;  	modified |= DeobfuscateFields ();  	modified |= DeobfuscateMethods ();  	if (!modified)  		break;  }  
Magic Number,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var instr = instructions [i];  	switch (instr.OpCode.Code) {  	case Code.Ret:  		if (!fixReturnType)  			break;  		bool wasNewobj;  		var type = GetLoadedType (method' method' instructions' i' out wasNewobj);  		if (type == null)  			break;  		methodReturnInfo.Add (type);  		break;  	case Code.Call:  	case Code.Calli:  	case Code.Callvirt:  	case Code.Newobj:  		pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  		var calledMethod = instr.Operand as IMethod;  		if (calledMethod == null)  			break;  		var calledMethodParams = DotNetUtils.GetArgs (calledMethod);  		for (int j = 0; j < pushedArgs.NumValidArgs; j++) {  			int calledMethodParamIndex = calledMethodParams.Count - j - 1;  			var ldInstr = pushedArgs.GetEnd (j);  			switch (ldInstr.OpCode.Code) {  			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  				AddMethodArgType (method' GetParameter (methodParams' ldInstr)' DotNetUtils.GetArg (calledMethodParams' calledMethodParamIndex));  				break;  			default:  				break;  			}  		}  		break;  	case Code.Castclass:  		pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  		if (pushedArgs.NumValidArgs < 1)  			break;  		AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' instr.Operand as ITypeDefOrRef);  		break;  	case Code.Stloc:  	case Code.Stloc_S:  	case Code.Stloc_0:  	case Code.Stloc_1:  	case Code.Stloc_2:  	case Code.Stloc_3:  		pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  		if (pushedArgs.NumValidArgs < 1)  			break;  		AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' instr.GetLocal (method.Body.Variables));  		break;  	case Code.Stsfld:  		pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  		if (pushedArgs.NumValidArgs < 1)  			break;  		AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' instr.Operand as IField);  		break;  	case Code.Stfld:  		pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  		if (pushedArgs.NumValidArgs >= 1) {  			var field = instr.Operand as IField;  			AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' field);  			if (pushedArgs.NumValidArgs >= 2 && field != null)  				AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (1))' field.DeclaringType);  		}  		break;  	case Code.Ldfld:  	case Code.Ldflda:  		pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  		if (pushedArgs.NumValidArgs < 1)  			break;  		AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' instr.Operand as IField);  		break;  	//TODO: For better results' these should be checked:  	case Code.Starg:  	case Code.Starg_S:  	case Code.Ldelema:  	case Code.Ldelem:  	case Code.Ldelem_I:  	case Code.Ldelem_I1:  	case Code.Ldelem_I2:  	case Code.Ldelem_I4:  	case Code.Ldelem_I8:  	case Code.Ldelem_R4:  	case Code.Ldelem_R8:  	case Code.Ldelem_Ref:  	case Code.Ldelem_U1:  	case Code.Ldelem_U2:  	case Code.Ldelem_U4:  	case Code.Ldind_I:  	case Code.Ldind_I1:  	case Code.Ldind_I2:  	case Code.Ldind_I4:  	case Code.Ldind_I8:  	case Code.Ldind_R4:  	case Code.Ldind_R8:  	case Code.Ldind_Ref:  	case Code.Ldind_U1:  	case Code.Ldind_U2:  	case Code.Ldind_U4:  	case Code.Ldobj:  	case Code.Stelem:  	case Code.Stelem_I:  	case Code.Stelem_I1:  	case Code.Stelem_I2:  	case Code.Stelem_I4:  	case Code.Stelem_I8:  	case Code.Stelem_R4:  	case Code.Stelem_R8:  	case Code.Stelem_Ref:  	case Code.Stind_I:  	case Code.Stind_I1:  	case Code.Stind_I2:  	case Code.Stind_I4:  	case Code.Stind_I8:  	case Code.Stind_R4:  	case Code.Stind_R8:  	case Code.Stind_Ref:  	case Code.Stobj:  	default:  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ret:  	if (!fixReturnType)  		break;  	bool wasNewobj;  	var type = GetLoadedType (method' method' instructions' i' out wasNewobj);  	if (type == null)  		break;  	methodReturnInfo.Add (type);  	break;  case Code.Call:  case Code.Calli:  case Code.Callvirt:  case Code.Newobj:  	pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  	var calledMethod = instr.Operand as IMethod;  	if (calledMethod == null)  		break;  	var calledMethodParams = DotNetUtils.GetArgs (calledMethod);  	for (int j = 0; j < pushedArgs.NumValidArgs; j++) {  		int calledMethodParamIndex = calledMethodParams.Count - j - 1;  		var ldInstr = pushedArgs.GetEnd (j);  		switch (ldInstr.OpCode.Code) {  		case Code.Ldarg:  		case Code.Ldarg_S:  		case Code.Ldarg_0:  		case Code.Ldarg_1:  		case Code.Ldarg_2:  		case Code.Ldarg_3:  			AddMethodArgType (method' GetParameter (methodParams' ldInstr)' DotNetUtils.GetArg (calledMethodParams' calledMethodParamIndex));  			break;  		default:  			break;  		}  	}  	break;  case Code.Castclass:  	pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  	if (pushedArgs.NumValidArgs < 1)  		break;  	AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' instr.Operand as ITypeDefOrRef);  	break;  case Code.Stloc:  case Code.Stloc_S:  case Code.Stloc_0:  case Code.Stloc_1:  case Code.Stloc_2:  case Code.Stloc_3:  	pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  	if (pushedArgs.NumValidArgs < 1)  		break;  	AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' instr.GetLocal (method.Body.Variables));  	break;  case Code.Stsfld:  	pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  	if (pushedArgs.NumValidArgs < 1)  		break;  	AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' instr.Operand as IField);  	break;  case Code.Stfld:  	pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  	if (pushedArgs.NumValidArgs >= 1) {  		var field = instr.Operand as IField;  		AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' field);  		if (pushedArgs.NumValidArgs >= 2 && field != null)  			AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (1))' field.DeclaringType);  	}  	break;  case Code.Ldfld:  case Code.Ldflda:  	pushedArgs = MethodStack.GetPushedArgInstructions (instructions' i);  	if (pushedArgs.NumValidArgs < 1)  		break;  	AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' instr.Operand as IField);  	break;  //TODO: For better results' these should be checked:  case Code.Starg:  case Code.Starg_S:  case Code.Ldelema:  case Code.Ldelem:  case Code.Ldelem_I:  case Code.Ldelem_I1:  case Code.Ldelem_I2:  case Code.Ldelem_I4:  case Code.Ldelem_I8:  case Code.Ldelem_R4:  case Code.Ldelem_R8:  case Code.Ldelem_Ref:  case Code.Ldelem_U1:  case Code.Ldelem_U2:  case Code.Ldelem_U4:  case Code.Ldind_I:  case Code.Ldind_I1:  case Code.Ldind_I2:  case Code.Ldind_I4:  case Code.Ldind_I8:  case Code.Ldind_R4:  case Code.Ldind_R8:  case Code.Ldind_Ref:  case Code.Ldind_U1:  case Code.Ldind_U2:  case Code.Ldind_U4:  case Code.Ldobj:  case Code.Stelem:  case Code.Stelem_I:  case Code.Stelem_I1:  case Code.Stelem_I2:  case Code.Stelem_I4:  case Code.Stelem_I8:  case Code.Stelem_R4:  case Code.Stelem_R8:  case Code.Stelem_Ref:  case Code.Stind_I:  case Code.Stind_I1:  case Code.Stind_I2:  case Code.Stind_I4:  case Code.Stind_I8:  case Code.Stind_R4:  case Code.Stind_R8:  case Code.Stind_Ref:  case Code.Stobj:  default:  	break;  }  
Magic Number,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,The following statement contains a magic number: if (pushedArgs.NumValidArgs >= 1) {  	var field = instr.Operand as IField;  	AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (0))' field);  	if (pushedArgs.NumValidArgs >= 2 && field != null)  		AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (1))' field.DeclaringType);  }  
Magic Number,de4dot.code.deobfuscators,TypesRestorerBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,DeobfuscateMethod,The following statement contains a magic number: if (pushedArgs.NumValidArgs >= 2 && field != null)  	AddMethodArgType (method' GetParameter (methodParams' pushedArgs.GetEnd (1))' field.DeclaringType);  
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,ReadHeader,The following statement contains a magic number: switch (type >> 1) {  case 1:  	blockType = STORED_BLOCK;  	break;  case 5:  	blockType = STATIC_TREES;  	break;  case 6:  	blockType = DYN_TREES;  	break;  default:  	throw new SharpZipBaseException ("Unknown block type: " + type);  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,ReadHeader,The following statement contains a magic number: switch (type >> 1) {  case 1:  	blockType = STORED_BLOCK;  	break;  case 5:  	blockType = STATIC_TREES;  	break;  case 6:  	blockType = DYN_TREES;  	break;  default:  	throw new SharpZipBaseException ("Unknown block type: " + type);  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,DecodeStoredLength,The following statement contains a magic number: if ((uncomprLen = input.PeekBits (16)) < 0)  	return false;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,DecodeStoredLength,The following statement contains a magic number: input.DropBits (16);  
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelMethodCallInliner.cs,GetNewValue,The following statement contains a magic number: while (true) {  	if (counter++ >= 50)  		return false;  	if (emulateIndex < 0 || emulateIndex >= instructions.Count)  		return false;  	instr = instructions [emulateIndex];  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  	case Code.Stloc:  	case Code.Stloc_S:  	case Code.Stloc_0:  	case Code.Stloc_1:  	case Code.Stloc_2:  	case Code.Stloc_3:  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  	case Code.Ldc_I4:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  	case Code.Ldc_I4_S:  	case Code.Add:  	case Code.Sub:  	case Code.Xor:  	case Code.Or:  	case Code.Nop:  	case Code.Dup:  	case Code.Mul:  	case Code.Rem:  	case Code.Div:  		emulator.Emulate (instr);  		emulateIndex++;  		break;  	case Code.Br:  	case Code.Br_S:  	case Code.Beq:  	case Code.Beq_S:  	case Code.Bge:  	case Code.Bge_S:  	case Code.Bge_Un:  	case Code.Bge_Un_S:  	case Code.Bgt:  	case Code.Bgt_S:  	case Code.Bgt_Un:  	case Code.Bgt_Un_S:  	case Code.Ble:  	case Code.Ble_S:  	case Code.Ble_Un:  	case Code.Ble_Un_S:  	case Code.Blt:  	case Code.Blt_S:  	case Code.Blt_Un:  	case Code.Blt_Un_S:  	case Code.Bne_Un:  	case Code.Bne_Un_S:  	case Code.Brfalse:  	case Code.Brfalse_S:  	case Code.Brtrue:  	case Code.Brtrue_S:  	case Code.Switch:  		if (!branchEmulator.Emulate (instr))  			return false;  		break;  	case Code.Ret:  		var retValue = emulator.Pop ();  		if (!retValue.IsInt32 ())  			return false;  		var retValue2 = (Int32Value)retValue;  		if (!retValue2.AllBitsValid ())  			return false;  		newValue = retValue2.Value;  		return true;  	default:  		if (instr.OpCode.OpCodeType != OpCodeType.Prefix)  			return false;  		emulateIndex++;  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelMethodCallInliner.cs,GetNewValue,The following statement contains a magic number: if (counter++ >= 50)  	return false;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelUtils.cs,GetXorKey2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldelem = instrs [i];  	if (ldelem.OpCode.Code != Code.Ldelem_U2)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	xorKey = ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelUtils.cs,GetXorKey2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldelem = instrs [i];  	if (ldelem.OpCode.Code != Code.Ldelem_U2)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	xorKey = ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\BabelUtils.cs,GetXorKey2,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	infos.Clear ();  	for (int i = 0; i < instrs.Count - 6; i++) {  		int index = i;  		var ldci4 = instrs [index++];  		if (!ldci4.IsLdcI4 ())  			continue;  		var newarr = instrs [index++];  		if (newarr.OpCode.Code != Code.Newarr)  			continue;  		if (newarr.Operand == null || newarr.Operand.ToString () != "System.Byte")  			continue;  		if (instrs [index++].OpCode.Code != Code.Dup)  			continue;  		var ldtoken = instrs [index++];  		if (ldtoken.OpCode.Code != Code.Ldtoken)  			continue;  		var field = ldtoken.Operand as FieldDef;  		if (field == null)  			continue;  		var call1 = instrs [index++];  		if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  			continue;  		if (!DotNetUtils.IsMethod (call1.Operand as IMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  			continue;  		var call2 = instrs [index++];  		if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  			continue;  		if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (call2.Operand as IMethod' arrayDecrypter))  			continue;  		var castclass = instrs [index++];  		if (castclass.OpCode.Code != Code.Castclass)  			continue;  		var arrayType = (castclass.Operand as ITypeDefOrRef).TryGetSZArraySig ();  		if (arrayType == null)  			continue;  		if (arrayType.Next.ElementType.GetPrimitiveSize () == -1) {  			Logger.w ("Can't decrypt non-primitive type array in method {0:X8}"' blocks.Method.MDToken.ToInt32 ());  			continue;  		}  		infos.Add (new ArrayInfo (i' index - i' field' arrayType));  	}  	infos.Reverse ();  	foreach (var info in infos) {  		var elemSize = info.arrayType.Next.ElementType.GetPrimitiveSize ();  		var decrypted = DecryptArray (info.encryptedField.InitialValue' elemSize);  		initializedDataCreator.AddInitializeArrayCode (block' info.start' info.len' info.arrayType.Next.ToTypeDefOrRef ()' decrypted);  		Logger.v ("Decrypted {0} array: {1} elements"' info.arrayType.Next.ToString ()' decrypted.Length / elemSize);  	}  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,Deobfuscate,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	int index = i;  	var ldci4 = instrs [index++];  	if (!ldci4.IsLdcI4 ())  		continue;  	var newarr = instrs [index++];  	if (newarr.OpCode.Code != Code.Newarr)  		continue;  	if (newarr.Operand == null || newarr.Operand.ToString () != "System.Byte")  		continue;  	if (instrs [index++].OpCode.Code != Code.Dup)  		continue;  	var ldtoken = instrs [index++];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var field = ldtoken.Operand as FieldDef;  	if (field == null)  		continue;  	var call1 = instrs [index++];  	if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  		continue;  	if (!DotNetUtils.IsMethod (call1.Operand as IMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  		continue;  	var call2 = instrs [index++];  	if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  		continue;  	if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (call2.Operand as IMethod' arrayDecrypter))  		continue;  	var castclass = instrs [index++];  	if (castclass.OpCode.Code != Code.Castclass)  		continue;  	var arrayType = (castclass.Operand as ITypeDefOrRef).TryGetSZArraySig ();  	if (arrayType == null)  		continue;  	if (arrayType.Next.ElementType.GetPrimitiveSize () == -1) {  		Logger.w ("Can't decrypt non-primitive type array in method {0:X8}"' blocks.Method.MDToken.ToInt32 ());  		continue;  	}  	infos.Add (new ArrayInfo (i' index - i' field' arrayType));  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundBabelAttribute)  	val += 10;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 10;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,CheckVersion,The following statement contains a magic number: if (versionField != null && versionField.IsLiteral && versionField.Constant != null && versionField.Constant.Value is string) {  	var val = Regex.Match ((string)versionField.Constant.Value' @"^(\d+\.\d+\.\d+\.\d+)$");  	if (val.Groups.Count < 2)  		return;  	obfuscatorName = string.Format ("{0} {1}"' DeobfuscatorInfo.THE_NAME' val.Groups [1].ToString ());  	return;  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,CheckVersion,The following statement contains a magic number: if (val.Groups.Count < 2)  	return;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: reader.Position = reader.Length - 4;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  	if (reader.ReadInt32 () == METADATA_SIG)  		return (int)reader.Position - 4;  	reader.Position -= 8;  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  	if (reader.ReadInt32 () == METADATA_SIG)  		return (int)reader.Position - 4;  	reader.Position -= 8;  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  	if (reader.ReadInt32 () == METADATA_SIG)  		return (int)reader.Position - 4;  	reader.Position -= 8;  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: if (reader.ReadInt32 () == METADATA_SIG)  	return (int)reader.Position - 4;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: return (int)reader.Position - 4;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,GetMetadataOffset,The following statement contains a magic number: reader.Position -= 8;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,GetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 16)  		continue;  	var callvirt = instrs [i + 1];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var ldci4_2 = instrs [i + 2];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Xor)  		continue;  	return ldci4_2.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,GetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 16)  		continue;  	var callvirt = instrs [i + 1];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var ldci4_2 = instrs [i + 2];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Xor)  		continue;  	return ldci4_2.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,GetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 16)  		continue;  	var callvirt = instrs [i + 1];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var ldci4_2 = instrs [i + 2];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Xor)  		continue;  	return ldci4_2.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,GetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 16)  		continue;  	var callvirt = instrs [i + 1];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var ldci4_2 = instrs [i + 2];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Xor)  		continue;  	return ldci4_2.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,GetMagic,The following statement contains a magic number: if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 16)  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,GetMagic,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,MethodBodyReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\MethodBodyReader.cs,ReadInlineTok,The following statement contains a magic number: switch (reader.ReadByte ()) {  case 0:  	return imageReader.ReadTypeSig ().ToTypeDefOrRef ();  case 1:  	return imageReader.ReadFieldRef ();  case 2:  	return imageReader.ReadMethodRef ();  default:  	throw new ApplicationException ("Unknown token type");  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	ITypeDefOrRef delegateType;  	IField delegateField;  	IMethod createMethod;  	int methodToken' declaringTypeToken;  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  	if (instrs != null) {  		delegateType = instrs [0].Operand as ITypeDefOrRef;  		methodToken = instrs [1].GetLdcI4Value ();  		declaringTypeToken = instrs [2].GetLdcI4Value ();  		delegateField = instrs [3].Operand as IField;  		createMethod = instrs [4].Operand as IMethod;  	} else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  		delegateType = instrs [0].Operand as ITypeDefOrRef;  		methodToken = instrs [1].GetLdcI4Value ();  		declaringTypeToken = -1;  		delegateField = instrs [2].Operand as IField;  		createMethod = instrs [3].Operand as IMethod;  	} else  		continue;  	if (delegateType == null)  		continue;  	if (delegateField == null)  		continue;  	if (createMethod == null)  		continue;  	var proxyCreatorType = methodToType.Find (createMethod);  	if (proxyCreatorType == ProxyCreatorType.None)  		continue;  	return new Context (delegateType' methodToken' declaringTypeToken' proxyCreatorType);  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	ITypeDefOrRef delegateType;  	IField delegateField;  	IMethod createMethod;  	int methodToken' declaringTypeToken;  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  	if (instrs != null) {  		delegateType = instrs [0].Operand as ITypeDefOrRef;  		methodToken = instrs [1].GetLdcI4Value ();  		declaringTypeToken = instrs [2].GetLdcI4Value ();  		delegateField = instrs [3].Operand as IField;  		createMethod = instrs [4].Operand as IMethod;  	} else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  		delegateType = instrs [0].Operand as ITypeDefOrRef;  		methodToken = instrs [1].GetLdcI4Value ();  		declaringTypeToken = -1;  		delegateField = instrs [2].Operand as IField;  		createMethod = instrs [3].Operand as IMethod;  	} else  		continue;  	if (delegateType == null)  		continue;  	if (delegateField == null)  		continue;  	if (createMethod == null)  		continue;  	var proxyCreatorType = methodToType.Find (createMethod);  	if (proxyCreatorType == ProxyCreatorType.None)  		continue;  	return new Context (delegateType' methodToken' declaringTypeToken' proxyCreatorType);  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	ITypeDefOrRef delegateType;  	IField delegateField;  	IMethod createMethod;  	int methodToken' declaringTypeToken;  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  	if (instrs != null) {  		delegateType = instrs [0].Operand as ITypeDefOrRef;  		methodToken = instrs [1].GetLdcI4Value ();  		declaringTypeToken = instrs [2].GetLdcI4Value ();  		delegateField = instrs [3].Operand as IField;  		createMethod = instrs [4].Operand as IMethod;  	} else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  		delegateType = instrs [0].Operand as ITypeDefOrRef;  		methodToken = instrs [1].GetLdcI4Value ();  		declaringTypeToken = -1;  		delegateField = instrs [2].Operand as IField;  		createMethod = instrs [3].Operand as IMethod;  	} else  		continue;  	if (delegateType == null)  		continue;  	if (delegateField == null)  		continue;  	if (createMethod == null)  		continue;  	var proxyCreatorType = methodToType.Find (createMethod);  	if (proxyCreatorType == ProxyCreatorType.None)  		continue;  	return new Context (delegateType' methodToken' declaringTypeToken' proxyCreatorType);  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	ITypeDefOrRef delegateType;  	IField delegateField;  	IMethod createMethod;  	int methodToken' declaringTypeToken;  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  	if (instrs != null) {  		delegateType = instrs [0].Operand as ITypeDefOrRef;  		methodToken = instrs [1].GetLdcI4Value ();  		declaringTypeToken = instrs [2].GetLdcI4Value ();  		delegateField = instrs [3].Operand as IField;  		createMethod = instrs [4].Operand as IMethod;  	} else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  		delegateType = instrs [0].Operand as ITypeDefOrRef;  		methodToken = instrs [1].GetLdcI4Value ();  		declaringTypeToken = -1;  		delegateField = instrs [2].Operand as IField;  		createMethod = instrs [3].Operand as IMethod;  	} else  		continue;  	if (delegateType == null)  		continue;  	if (delegateField == null)  		continue;  	if (createMethod == null)  		continue;  	var proxyCreatorType = methodToType.Find (createMethod);  	if (proxyCreatorType == ProxyCreatorType.None)  		continue;  	return new Context (delegateType' methodToken' declaringTypeToken' proxyCreatorType);  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	ITypeDefOrRef delegateType;  	IField delegateField;  	IMethod createMethod;  	int methodToken' declaringTypeToken;  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  	if (instrs != null) {  		delegateType = instrs [0].Operand as ITypeDefOrRef;  		methodToken = instrs [1].GetLdcI4Value ();  		declaringTypeToken = instrs [2].GetLdcI4Value ();  		delegateField = instrs [3].Operand as IField;  		createMethod = instrs [4].Operand as IMethod;  	} else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  		delegateType = instrs [0].Operand as ITypeDefOrRef;  		methodToken = instrs [1].GetLdcI4Value ();  		declaringTypeToken = -1;  		delegateField = instrs [2].Operand as IField;  		createMethod = instrs [3].Operand as IMethod;  	} else  		continue;  	if (delegateType == null)  		continue;  	if (delegateField == null)  		continue;  	if (createMethod == null)  		continue;  	var proxyCreatorType = methodToType.Find (createMethod);  	if (proxyCreatorType == ProxyCreatorType.None)  		continue;  	return new Context (delegateType' methodToken' declaringTypeToken' proxyCreatorType);  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = instrs [2].GetLdcI4Value ();  	delegateField = instrs [3].Operand as IField;  	createMethod = instrs [4].Operand as IMethod;  } else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = -1;  	delegateField = instrs [2].Operand as IField;  	createMethod = instrs [3].Operand as IMethod;  } else  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = instrs [2].GetLdcI4Value ();  	delegateField = instrs [3].Operand as IField;  	createMethod = instrs [4].Operand as IMethod;  } else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = -1;  	delegateField = instrs [2].Operand as IField;  	createMethod = instrs [3].Operand as IMethod;  } else  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = instrs [2].GetLdcI4Value ();  	delegateField = instrs [3].Operand as IField;  	createMethod = instrs [4].Operand as IMethod;  } else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = -1;  	delegateField = instrs [2].Operand as IField;  	createMethod = instrs [3].Operand as IMethod;  } else  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = instrs [2].GetLdcI4Value ();  	delegateField = instrs [3].Operand as IField;  	createMethod = instrs [4].Operand as IMethod;  } else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = -1;  	delegateField = instrs [2].Operand as IField;  	createMethod = instrs [3].Operand as IMethod;  } else  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = instrs [2].GetLdcI4Value ();  	delegateField = instrs [3].Operand as IField;  	createMethod = instrs [4].Operand as IMethod;  } else if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = -1;  	delegateField = instrs [2].Operand as IField;  	createMethod = instrs [3].Operand as IMethod;  } else  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: declaringTypeToken = instrs [2].GetLdcI4Value ();  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: delegateField = instrs [3].Operand as IField;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: createMethod = instrs [4].Operand as IMethod;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = -1;  	delegateField = instrs [2].Operand as IField;  	createMethod = instrs [3].Operand as IMethod;  } else  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if ((instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  	delegateType = instrs [0].Operand as ITypeDefOrRef;  	methodToken = instrs [1].GetLdcI4Value ();  	declaringTypeToken = -1;  	delegateField = instrs [2].Operand as IField;  	createMethod = instrs [3].Operand as IMethod;  } else  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: delegateField = instrs [2].Operand as IField;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: createMethod = instrs [3].Operand as IMethod;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (decryptMethod != null && DeobUtils.HasInteger (decryptMethod' 6))  	return new Decrypter3 (module' decryptMethod);  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,IsV30,The following statement contains a magic number: return data.Length > 10 && data [0] == 8 && data [9] <= 1 && data [10] == 8;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,IsV30,The following statement contains a magic number: return data.Length > 10 && data [0] == 8 && data [9] <= 1 && data [10] == 8;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,IsV30,The following statement contains a magic number: return data.Length > 10 && data [0] == 8 && data [9] <= 1 && data [10] == 8;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,IsV30,The following statement contains a magic number: return data.Length > 10 && data [0] == 8 && data [9] <= 1 && data [10] == 8;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,IsV30,The following statement contains a magic number: return data.Length > 10 && data [0] == 8 && data [9] <= 1 && data [10] == 8;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceResolver.cs,InitXorKeys,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	var callvirt = instrs [i];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var calledMethod = callvirt.Operand as IMethod;  	if (calledMethod == null)  		continue;  	if (calledMethod.FullName != "System.Int32 System.IO.BinaryReader::ReadInt32()")  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	ints.Add (ldci4.GetLdcI4Value ());  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceResolver.cs,InitXorKeys,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceResolver.cs,InitXorKeys,The following statement contains a magic number: if (ints.Count == 2) {  	hasXorKeys = true;  	xorKey1 = ints [0];  	xorKey2 = ints [1];  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckDecrypterType,The following statement contains a magic number: if (type.NestedTypes.Count > 2)  	return null;  
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckNested,The following statement contains a magic number: if (nested.Fields.Count == 1 || nested.Fields.Count == 3) {  	// 4.0+  	if (!HasFieldType (nested.Fields' nested))  		return null;  	var decrypterBuilderMethod = DotNetUtils.GetMethod (nested' "System.Reflection.Emit.MethodBuilder"' "(System.Reflection.Emit.TypeBuilder)");  	if (decrypterBuilderMethod == null)  		return null;  	resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod (nested.FindMethod (".ctor"));  	var nestedDecrypter = DotNetUtils.GetMethod (nested' "System.String"' "(System.Int32)");  	if (nestedDecrypter == null || nestedDecrypter.IsStatic)  		return null;  	var decrypter = DotNetUtils.GetMethod (type' "System.String"' "(System.Int32)");  	if (decrypter == null || !decrypter.IsStatic)  		return null;  	simpleDeobfuscator.Deobfuscate (decrypterBuilderMethod);  	return new DecrypterInfoV3 (resourceDecrypter) {  		Decrypter = decrypter'  		OffsetCalcInstructions = GetOffsetCalcInstructions (decrypterBuilderMethod)'  	};  } else if (nested.Fields.Count == 2) {  	// 3.0 - 3.5  	if (CheckFields (nested' "System.Collections.Hashtable"' nested)) {  		// 3.0 - 3.5  		var nestedDecrypter = DotNetUtils.GetMethod (nested' "System.String"' "(System.Int32)");  		if (nestedDecrypter == null || nestedDecrypter.IsStatic)  			return null;  		var decrypter = DotNetUtils.GetMethod (type' "System.String"' "(System.Int32)");  		if (decrypter == null || !decrypter.IsStatic)  			return null;  		resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod (nested.FindMethod (".ctor"));  		return new DecrypterInfoV3 (resourceDecrypter) {  			Decrypter = decrypter  		};  	} else if (CheckFields (nested' "System.Byte[]"' nested)) {  		// 3.0  		var nestedDecrypter = DotNetUtils.GetMethod (nested' "System.String"' "(System.String'System.Int32)");  		if (nestedDecrypter == null || nestedDecrypter.IsStatic)  			return null;  		var decrypter = DotNetUtils.GetMethod (type' "System.String"' "(System.String'System.Int32)");  		if (decrypter == null || !decrypter.IsStatic)  			return null;  		return new DecrypterInfoV2 {  			Decrypter = decrypter  		};  	} else  		return null;  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckNested,The following statement contains a magic number: if (nested.Fields.Count == 1 || nested.Fields.Count == 3) {  	// 4.0+  	if (!HasFieldType (nested.Fields' nested))  		return null;  	var decrypterBuilderMethod = DotNetUtils.GetMethod (nested' "System.Reflection.Emit.MethodBuilder"' "(System.Reflection.Emit.TypeBuilder)");  	if (decrypterBuilderMethod == null)  		return null;  	resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod (nested.FindMethod (".ctor"));  	var nestedDecrypter = DotNetUtils.GetMethod (nested' "System.String"' "(System.Int32)");  	if (nestedDecrypter == null || nestedDecrypter.IsStatic)  		return null;  	var decrypter = DotNetUtils.GetMethod (type' "System.String"' "(System.Int32)");  	if (decrypter == null || !decrypter.IsStatic)  		return null;  	simpleDeobfuscator.Deobfuscate (decrypterBuilderMethod);  	return new DecrypterInfoV3 (resourceDecrypter) {  		Decrypter = decrypter'  		OffsetCalcInstructions = GetOffsetCalcInstructions (decrypterBuilderMethod)'  	};  } else if (nested.Fields.Count == 2) {  	// 3.0 - 3.5  	if (CheckFields (nested' "System.Collections.Hashtable"' nested)) {  		// 3.0 - 3.5  		var nestedDecrypter = DotNetUtils.GetMethod (nested' "System.String"' "(System.Int32)");  		if (nestedDecrypter == null || nestedDecrypter.IsStatic)  			return null;  		var decrypter = DotNetUtils.GetMethod (type' "System.String"' "(System.Int32)");  		if (decrypter == null || !decrypter.IsStatic)  			return null;  		resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod (nested.FindMethod (".ctor"));  		return new DecrypterInfoV3 (resourceDecrypter) {  			Decrypter = decrypter  		};  	} else if (CheckFields (nested' "System.Byte[]"' nested)) {  		// 3.0  		var nestedDecrypter = DotNetUtils.GetMethod (nested' "System.String"' "(System.String'System.Int32)");  		if (nestedDecrypter == null || nestedDecrypter.IsStatic)  			return null;  		var decrypter = DotNetUtils.GetMethod (type' "System.String"' "(System.String'System.Int32)");  		if (decrypter == null || !decrypter.IsStatic)  			return null;  		return new DecrypterInfoV2 {  			Decrypter = decrypter  		};  	} else  		return null;  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckNested,The following statement contains a magic number: if (nested.Fields.Count == 2) {  	// 3.0 - 3.5  	if (CheckFields (nested' "System.Collections.Hashtable"' nested)) {  		// 3.0 - 3.5  		var nestedDecrypter = DotNetUtils.GetMethod (nested' "System.String"' "(System.Int32)");  		if (nestedDecrypter == null || nestedDecrypter.IsStatic)  			return null;  		var decrypter = DotNetUtils.GetMethod (type' "System.String"' "(System.Int32)");  		if (decrypter == null || !decrypter.IsStatic)  			return null;  		resourceDecrypter.DecryptMethod = ResourceDecrypter.FindDecrypterMethod (nested.FindMethod (".ctor"));  		return new DecrypterInfoV3 (resourceDecrypter) {  			Decrypter = decrypter  		};  	} else if (CheckFields (nested' "System.Byte[]"' nested)) {  		// 3.0  		var nestedDecrypter = DotNetUtils.GetMethod (nested' "System.String"' "(System.String'System.Int32)");  		if (nestedDecrypter == null || nestedDecrypter.IsStatic)  			return null;  		var decrypter = DotNetUtils.GetMethod (type' "System.String"' "(System.String'System.Int32)");  		if (decrypter == null || !decrypter.IsStatic)  			return null;  		return new DecrypterInfoV2 {  			Decrypter = decrypter  		};  	} else  		return null;  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,GetOffsetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	int index = i;  	var ldsfld1 = instrs [index++];  	if (ldsfld1.OpCode.Code != Code.Ldsfld)  		continue;  	var ldci4 = instrs [index++];  	if (!ldci4.IsLdcI4 ())  		continue;  	var callvirt = instrs [index++];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var calledMethod = callvirt.Operand as IMethod;  	if (calledMethod == null)  		continue;  	if (calledMethod.FullName != "System.Void System.Reflection.Emit.ILGenerator::Emit(System.Reflection.Emit.OpCode'System.Int32)")  		continue;  	if (!instrs [index++].IsLdloc ())  		continue;  	var ldsfld2 = instrs [index++];  	if (ldsfld2.OpCode.Code != Code.Ldsfld)  		continue;  	var field = ldsfld2.Operand as IField;  	if (field == null)  		continue;  	if (field.FullName != "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Xor")  		continue;  	// Here if Babel.NET 5.5  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,CheckFields,The following statement contains a magic number: if (type.Fields.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,CheckCalledMethods,The following statement contains a magic number: if (calls != 2)  	return null;  
Magic Number,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,GetEmbedPassword,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	int index = i;  	var ldstr1 = instrs [index++];  	if (ldstr1.OpCode.Code != Code.Ldstr)  		continue;  	var passphrase = GetString (ldstr1' instrs' ref index);  	var ldstr2 = instrs [index++];  	if (ldstr2.OpCode.Code != Code.Ldstr)  		continue;  	var salt = GetString (ldstr2' instrs' ref index);  	var ldci4 = instrs [index++];  	if (!ldci4.IsLdcI4 ())  		continue;  	var ldstr3 = instrs [index++];  	if (ldstr3.OpCode.Code != Code.Ldstr)  		continue;  	var iv = GetString (ldstr3' instrs' ref index);  	return new PasswordInfo (passphrase' salt' iv);  }  
Magic Number,de4dot.code.deobfuscators.CodeFort,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeFort,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeFort,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeFort,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeFort,PasswordFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\PasswordFinder.cs,FindEmbedPassword,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	int index = i;  	var ldstr1 = instrs [index++];  	if (ldstr1.OpCode != "ldstr")  		continue;  	var passphrase = GetString (ldstr1' instrs' ref index);  	var ldstr2 = instrs [index++];  	if (ldstr2.OpCode != "ldstr")  		continue;  	var salt = GetString (ldstr2' instrs' ref index);  	var ldc = instrs [index++];  	if (!ldc.OpCode.StartsWith ("ldc.i4"))  		continue;  	var ldstr3 = instrs [index++];  	if (ldstr3.OpCode != "ldstr")  		continue;  	var iv = GetString (ldstr3' instrs' ref index);  	return new PasswordInfo (passphrase' salt' iv);  }  
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,CheckMethods,The following statement contains a magic number: if (type.Methods.Count != 3)  	return null;  
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs.Count != 3)  	return null;  
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,GetCallInfo,The following statement contains a magic number: foreach (var c in field.Name.String)  	rid = (rid << 4) + (uint)HexToInt ((char)((byte)c + 0x2F));  
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,GetCallInfo,The following statement contains a magic number: rid = (rid << 4) + (uint)HexToInt ((char)((byte)c + 0x2F));  
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,HexToInt,The following statement contains a magic number: if ('a' <= c && c <= 'f')  	return c - 'a' + 10;  
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,HexToInt,The following statement contains a magic number: return c - 'a' + 10;  
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,HexToInt,The following statement contains a magic number: if ('A' <= c && c <= 'F')  	return c - 'A' + 10;  
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,HexToInt,The following statement contains a magic number: return c - 'A' + 10;  
Magic Number,de4dot.code.deobfuscators.CodeFort,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\StringDecrypter.cs,CheckMethods,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (method.Name == ".cctor")  		continue;  	if (!method.IsStatic || method.Body == null)  		return null;  	if (!DotNetUtils.IsMethod (method' "System.String"' "(System.String)"))  		return null;  	if (!HasDouble (method' 3992.0))  		return null;  	decryptMethod = method;  }  
Magic Number,de4dot.code.deobfuscators.CodeFort,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeFort\StringDecrypter.cs,CheckMethods,The following statement contains a magic number: if (!HasDouble (method' 3992.0))  	return null;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindBundleType,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.Namespace != "")  		continue;  	if (type.Fields.Count != 2)  		continue;  	var ctor = type.FindMethod (".ctor");  	if (ctor == null || !ctor.IsPrivate)  		continue;  	if (!DotNetUtils.IsMethod (ctor' "System.Void"' "(System.Reflection.Assembly)"))  		continue;  	var initMethodTmp = FindInitMethod (type);  	if (initMethodTmp == null)  		continue;  	var getTempFilenameMethod = FindGetTempFilenameMethod (type);  	if (getTempFilenameMethod == null)  		continue;  	return type;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindBundleType,The following statement contains a magic number: if (type.Fields.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindAssemblyManagerType,The following statement contains a magic number: foreach (var field in bundleType.Fields) {  	var type = field.FieldSig.GetFieldType ().TryGetTypeDef ();  	if (type == null)  		continue;  	if (type == bundleType)  		continue;  	if (type.Fields.Count != 2)  		continue;  	var ctor = type.FindMethod (".ctor");  	if (ctor == null)  		continue;  	var sig = ctor.MethodSig;  	if (sig == null || sig.Params.Count != 2)  		continue;  	var iface = sig.Params [1].TryGetTypeDef ();  	if (iface == null || !iface.IsInterface)  		continue;  	assemblyManagerType = type;  	bundleStreamProviderIFace = iface;  	return;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindAssemblyManagerType,The following statement contains a magic number: foreach (var field in bundleType.Fields) {  	var type = field.FieldSig.GetFieldType ().TryGetTypeDef ();  	if (type == null)  		continue;  	if (type == bundleType)  		continue;  	if (type.Fields.Count != 2)  		continue;  	var ctor = type.FindMethod (".ctor");  	if (ctor == null)  		continue;  	var sig = ctor.MethodSig;  	if (sig == null || sig.Params.Count != 2)  		continue;  	var iface = sig.Params [1].TryGetTypeDef ();  	if (iface == null || !iface.IsInterface)  		continue;  	assemblyManagerType = type;  	bundleStreamProviderIFace = iface;  	return;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindAssemblyManagerType,The following statement contains a magic number: if (type.Fields.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,FindAssemblyManagerType,The following statement contains a magic number: if (sig == null || sig.Params.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,Decrypt,The following statement contains a magic number: while (reader.Position < reader.Length) {  	block [0] = reader.ReadUInt32 ();  	block [1] = reader.ReadUInt32 ();  	block [2] = reader.ReadUInt32 ();  	block [3] = reader.ReadUInt32 ();  	DeobUtils.XxteaDecrypt (block' key);  	Buffer.BlockCopy (block' 0' decrypted' 0' decrypted.Length);  	outStream.Write (decrypted' 0' decrypted.Length);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,Decrypt,The following statement contains a magic number: while (reader.Position < reader.Length) {  	block [0] = reader.ReadUInt32 ();  	block [1] = reader.ReadUInt32 ();  	block [2] = reader.ReadUInt32 ();  	block [3] = reader.ReadUInt32 ();  	DeobUtils.XxteaDecrypt (block' key);  	Buffer.BlockCopy (block' 0' decrypted' 0' decrypted.Length);  	outStream.Write (decrypted' 0' decrypted.Length);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,Decrypt,The following statement contains a magic number: block [2] = reader.ReadUInt32 ();  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,Decrypt,The following statement contains a magic number: block [3] = reader.ReadUInt32 ();  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,Find,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	var ldci4_2 = instrs [i + 1];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	var call = instrs [i + 2];  	if (call.OpCode.Code != Code.Call)  		continue;  	var initMethodTmp = call.Operand as MethodDef;  	ObfuscatorVersion obfuscatorVersionTmp;  	if (!CheckInitMethod (initMethodTmp' out obfuscatorVersionTmp))  		continue;  	if (!CheckMethodsType (initMethodTmp.DeclaringType))  		continue;  	obfuscatorVersion = obfuscatorVersionTmp;  	theType = initMethodTmp.DeclaringType;  	initMethod = initMethodTmp;  	break;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,Find,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	var ldci4_2 = instrs [i + 1];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	var call = instrs [i + 2];  	if (call.OpCode.Code != Code.Call)  		continue;  	var initMethodTmp = call.Operand as MethodDef;  	ObfuscatorVersion obfuscatorVersionTmp;  	if (!CheckInitMethod (initMethodTmp' out obfuscatorVersionTmp))  		continue;  	if (!CheckMethodsType (initMethodTmp.DeclaringType))  		continue;  	obfuscatorVersion = obfuscatorVersionTmp;  	theType = initMethodTmp.DeclaringType;  	initMethod = initMethodTmp;  	break;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,CheckMethodsType,The following statement contains a magic number: if (fields.Count < 2)  	// RVAs for executive and stub are always present if encrypted methods  	return true;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 2; i++) {  		if (!instrs [i].IsLdcI4 ())  			continue;  		if (!instrs [i + 1].IsLdcI4 ())  			continue;  		var call = instrs [i + 2];  		if (call.OpCode.Code != Code.Call)  			continue;  		if (call.Operand != initMethod)  			continue;  		block.Remove (i' 3);  		return;  	}  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 2; i++) {  		if (!instrs [i].IsLdcI4 ())  			continue;  		if (!instrs [i + 1].IsLdcI4 ())  			continue;  		var call = instrs [i + 2];  		if (call.OpCode.Code != Code.Call)  			continue;  		if (call.Operand != initMethod)  			continue;  		block.Remove (i' 3);  		return;  	}  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 2; i++) {  		if (!instrs [i].IsLdcI4 ())  			continue;  		if (!instrs [i + 1].IsLdcI4 ())  			continue;  		var call = instrs [i + 2];  		if (call.OpCode.Code != Code.Call)  			continue;  		if (call.Operand != initMethod)  			continue;  		block.Remove (i' 3);  		return;  	}  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	if (!instrs [i].IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdcI4 ())  		continue;  	var call = instrs [i + 2];  	if (call.OpCode.Code != Code.Call)  		continue;  	if (call.Operand != initMethod)  		continue;  	block.Remove (i' 3);  	return;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	if (!instrs [i].IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdcI4 ())  		continue;  	var call = instrs [i + 2];  	if (call.OpCode.Code != Code.Call)  		continue;  	if (call.Operand != initMethod)  		continue;  	block.Remove (i' 3);  	return;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	if (!instrs [i].IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdcI4 ())  		continue;  	var call = instrs [i + 2];  	if (call.OpCode.Code != Code.Call)  		continue;  	if (call.Operand != initMethod)  		continue;  	block.Remove (i' 3);  	return;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,RemoveInitCall,The following statement contains a magic number: block.Remove (i' 3);  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	byte b = peImage.OffsetReadByte (bodyOffset);  	uint codeOffset;  	if ((b & 3) == 2) {  		if (b != 2)  			continue;  		// not zero byte code size  		dm.mhFlags = 2;  		dm.mhMaxStack = 8;  		dm.mhLocalVarSigTok = 0;  		codeOffset = bodyOffset + 1;  	} else {  		if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  			continue;  		// not zero byte code size  		dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  		dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  		dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  		codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  	}  	fileDataReader.Position = codeOffset;  	if (!decrypter.Decrypt (fileDataReader' dm))  		continue;  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	byte b = peImage.OffsetReadByte (bodyOffset);  	uint codeOffset;  	if ((b & 3) == 2) {  		if (b != 2)  			continue;  		// not zero byte code size  		dm.mhFlags = 2;  		dm.mhMaxStack = 8;  		dm.mhLocalVarSigTok = 0;  		codeOffset = bodyOffset + 1;  	} else {  		if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  			continue;  		// not zero byte code size  		dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  		dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  		dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  		codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  	}  	fileDataReader.Position = codeOffset;  	if (!decrypter.Decrypt (fileDataReader' dm))  		continue;  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	byte b = peImage.OffsetReadByte (bodyOffset);  	uint codeOffset;  	if ((b & 3) == 2) {  		if (b != 2)  			continue;  		// not zero byte code size  		dm.mhFlags = 2;  		dm.mhMaxStack = 8;  		dm.mhLocalVarSigTok = 0;  		codeOffset = bodyOffset + 1;  	} else {  		if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  			continue;  		// not zero byte code size  		dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  		dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  		dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  		codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  	}  	fileDataReader.Position = codeOffset;  	if (!decrypter.Decrypt (fileDataReader' dm))  		continue;  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	byte b = peImage.OffsetReadByte (bodyOffset);  	uint codeOffset;  	if ((b & 3) == 2) {  		if (b != 2)  			continue;  		// not zero byte code size  		dm.mhFlags = 2;  		dm.mhMaxStack = 8;  		dm.mhLocalVarSigTok = 0;  		codeOffset = bodyOffset + 1;  	} else {  		if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  			continue;  		// not zero byte code size  		dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  		dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  		dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  		codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  	}  	fileDataReader.Position = codeOffset;  	if (!decrypter.Decrypt (fileDataReader' dm))  		continue;  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	byte b = peImage.OffsetReadByte (bodyOffset);  	uint codeOffset;  	if ((b & 3) == 2) {  		if (b != 2)  			continue;  		// not zero byte code size  		dm.mhFlags = 2;  		dm.mhMaxStack = 8;  		dm.mhLocalVarSigTok = 0;  		codeOffset = bodyOffset + 1;  	} else {  		if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  			continue;  		// not zero byte code size  		dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  		dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  		dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  		codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  	}  	fileDataReader.Position = codeOffset;  	if (!decrypter.Decrypt (fileDataReader' dm))  		continue;  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	byte b = peImage.OffsetReadByte (bodyOffset);  	uint codeOffset;  	if ((b & 3) == 2) {  		if (b != 2)  			continue;  		// not zero byte code size  		dm.mhFlags = 2;  		dm.mhMaxStack = 8;  		dm.mhLocalVarSigTok = 0;  		codeOffset = bodyOffset + 1;  	} else {  		if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  			continue;  		// not zero byte code size  		dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  		dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  		dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  		codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  	}  	fileDataReader.Position = codeOffset;  	if (!decrypter.Decrypt (fileDataReader' dm))  		continue;  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	byte b = peImage.OffsetReadByte (bodyOffset);  	uint codeOffset;  	if ((b & 3) == 2) {  		if (b != 2)  			continue;  		// not zero byte code size  		dm.mhFlags = 2;  		dm.mhMaxStack = 8;  		dm.mhLocalVarSigTok = 0;  		codeOffset = bodyOffset + 1;  	} else {  		if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  			continue;  		// not zero byte code size  		dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  		dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  		dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  		codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  	}  	fileDataReader.Position = codeOffset;  	if (!decrypter.Decrypt (fileDataReader' dm))  		continue;  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	byte b = peImage.OffsetReadByte (bodyOffset);  	uint codeOffset;  	if ((b & 3) == 2) {  		if (b != 2)  			continue;  		// not zero byte code size  		dm.mhFlags = 2;  		dm.mhMaxStack = 8;  		dm.mhLocalVarSigTok = 0;  		codeOffset = bodyOffset + 1;  	} else {  		if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  			continue;  		// not zero byte code size  		dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  		dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  		dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  		codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  	}  	fileDataReader.Position = codeOffset;  	if (!decrypter.Decrypt (fileDataReader' dm))  		continue;  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	byte b = peImage.OffsetReadByte (bodyOffset);  	uint codeOffset;  	if ((b & 3) == 2) {  		if (b != 2)  			continue;  		// not zero byte code size  		dm.mhFlags = 2;  		dm.mhMaxStack = 8;  		dm.mhLocalVarSigTok = 0;  		codeOffset = bodyOffset + 1;  	} else {  		if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  			continue;  		// not zero byte code size  		dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  		dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  		dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  		codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  	}  	fileDataReader.Position = codeOffset;  	if (!decrypter.Decrypt (fileDataReader' dm))  		continue;  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	byte b = peImage.OffsetReadByte (bodyOffset);  	uint codeOffset;  	if ((b & 3) == 2) {  		if (b != 2)  			continue;  		// not zero byte code size  		dm.mhFlags = 2;  		dm.mhMaxStack = 8;  		dm.mhLocalVarSigTok = 0;  		codeOffset = bodyOffset + 1;  	} else {  		if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  			continue;  		// not zero byte code size  		dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  		dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  		dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  		codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  	}  	fileDataReader.Position = codeOffset;  	if (!decrypter.Decrypt (fileDataReader' dm))  		continue;  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if ((b & 3) == 2) {  	if (b != 2)  		continue;  	// not zero byte code size  	dm.mhFlags = 2;  	dm.mhMaxStack = 8;  	dm.mhLocalVarSigTok = 0;  	codeOffset = bodyOffset + 1;  } else {  	if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  		continue;  	// not zero byte code size  	dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  	dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  	dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  	codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if ((b & 3) == 2) {  	if (b != 2)  		continue;  	// not zero byte code size  	dm.mhFlags = 2;  	dm.mhMaxStack = 8;  	dm.mhLocalVarSigTok = 0;  	codeOffset = bodyOffset + 1;  } else {  	if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  		continue;  	// not zero byte code size  	dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  	dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  	dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  	codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if ((b & 3) == 2) {  	if (b != 2)  		continue;  	// not zero byte code size  	dm.mhFlags = 2;  	dm.mhMaxStack = 8;  	dm.mhLocalVarSigTok = 0;  	codeOffset = bodyOffset + 1;  } else {  	if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  		continue;  	// not zero byte code size  	dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  	dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  	dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  	codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if ((b & 3) == 2) {  	if (b != 2)  		continue;  	// not zero byte code size  	dm.mhFlags = 2;  	dm.mhMaxStack = 8;  	dm.mhLocalVarSigTok = 0;  	codeOffset = bodyOffset + 1;  } else {  	if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  		continue;  	// not zero byte code size  	dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  	dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  	dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  	codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if ((b & 3) == 2) {  	if (b != 2)  		continue;  	// not zero byte code size  	dm.mhFlags = 2;  	dm.mhMaxStack = 8;  	dm.mhLocalVarSigTok = 0;  	codeOffset = bodyOffset + 1;  } else {  	if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  		continue;  	// not zero byte code size  	dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  	dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  	dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  	codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if ((b & 3) == 2) {  	if (b != 2)  		continue;  	// not zero byte code size  	dm.mhFlags = 2;  	dm.mhMaxStack = 8;  	dm.mhLocalVarSigTok = 0;  	codeOffset = bodyOffset + 1;  } else {  	if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  		continue;  	// not zero byte code size  	dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  	dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  	dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  	codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if ((b & 3) == 2) {  	if (b != 2)  		continue;  	// not zero byte code size  	dm.mhFlags = 2;  	dm.mhMaxStack = 8;  	dm.mhLocalVarSigTok = 0;  	codeOffset = bodyOffset + 1;  } else {  	if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  		continue;  	// not zero byte code size  	dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  	dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  	dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  	codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if ((b & 3) == 2) {  	if (b != 2)  		continue;  	// not zero byte code size  	dm.mhFlags = 2;  	dm.mhMaxStack = 8;  	dm.mhLocalVarSigTok = 0;  	codeOffset = bodyOffset + 1;  } else {  	if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  		continue;  	// not zero byte code size  	dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  	dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  	dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  	codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if ((b & 3) == 2) {  	if (b != 2)  		continue;  	// not zero byte code size  	dm.mhFlags = 2;  	dm.mhMaxStack = 8;  	dm.mhLocalVarSigTok = 0;  	codeOffset = bodyOffset + 1;  } else {  	if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  		continue;  	// not zero byte code size  	dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  	dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  	dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  	codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if ((b & 3) == 2) {  	if (b != 2)  		continue;  	// not zero byte code size  	dm.mhFlags = 2;  	dm.mhMaxStack = 8;  	dm.mhLocalVarSigTok = 0;  	codeOffset = bodyOffset + 1;  } else {  	if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  		continue;  	// not zero byte code size  	dm.mhFlags = peImage.OffsetReadUInt16 (bodyOffset);  	dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  	dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  	codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if (b != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: dm.mhFlags = 2;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: dm.mhMaxStack = 8;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: if (peImage.OffsetReadUInt32 (bodyOffset + 4) != 0)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: dm.mhMaxStack = peImage.OffsetReadUInt16 (bodyOffset + 2);  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: dm.mhLocalVarSigTok = peImage.OffsetReadUInt32 (bodyOffset + 8);  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,CreateDumpedMethods,The following statement contains a magic number: codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,FindMethodsData,The following statement contains a magic number: for (int offset = GetStartOffset (peImage); offset < lastOffset;) {  	offset = FindSig (fileData' offset' lastOffset' initializeMethodEnd);  	if (offset < 0)  		return null;  	offset += initializeMethodEnd.Length;  	short retImm16 = BitConverter.ToInt16 (fileData' offset);  	if (retImm16 != 0x0C && retImm16 != 0x10)  		continue;  	offset += 2;  	if (offset + ENC_CODE_OFFSET + 4 > lastOffset)  		return null;  	// rva is 0 when the assembly has been embedded  	uint rva = BitConverter.ToUInt32 (fileData' offset + RVA_EXECUTIVE_OFFSET);  	if (rva != 0 && mainType.Rvas.IndexOf (rva) < 0)  		continue;  	int relOffs = BitConverter.ToInt32 (fileData' offset + ENC_CODE_OFFSET);  	if (relOffs <= 0 || relOffs >= section.SizeOfRawData)  		continue;  	reader.Position = section.PointerToRawData + relOffs;  	int size = (int)reader.ReadCompressedUInt32 ();  	int endOffset = relOffs + size;  	if (endOffset < relOffs || endOffset > section.SizeOfRawData)  		continue;  	return reader.ReadBytes (size);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,FindMethodsData,The following statement contains a magic number: for (int offset = GetStartOffset (peImage); offset < lastOffset;) {  	offset = FindSig (fileData' offset' lastOffset' initializeMethodEnd);  	if (offset < 0)  		return null;  	offset += initializeMethodEnd.Length;  	short retImm16 = BitConverter.ToInt16 (fileData' offset);  	if (retImm16 != 0x0C && retImm16 != 0x10)  		continue;  	offset += 2;  	if (offset + ENC_CODE_OFFSET + 4 > lastOffset)  		return null;  	// rva is 0 when the assembly has been embedded  	uint rva = BitConverter.ToUInt32 (fileData' offset + RVA_EXECUTIVE_OFFSET);  	if (rva != 0 && mainType.Rvas.IndexOf (rva) < 0)  		continue;  	int relOffs = BitConverter.ToInt32 (fileData' offset + ENC_CODE_OFFSET);  	if (relOffs <= 0 || relOffs >= section.SizeOfRawData)  		continue;  	reader.Position = section.PointerToRawData + relOffs;  	int size = (int)reader.ReadCompressedUInt32 ();  	int endOffset = relOffs + size;  	if (endOffset < relOffs || endOffset > section.SizeOfRawData)  		continue;  	return reader.ReadBytes (size);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,FindMethodsData,The following statement contains a magic number: offset += 2;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,FindMethodsData,The following statement contains a magic number: if (offset + ENC_CODE_OFFSET + 4 > lastOffset)  	return null;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,FindOtherTypes,The following statement contains a magic number: foreach (var method in info.proxyType.Methods) {  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 4)  		continue;  	if (sig.Params [2].GetFullName () != "System.Type[]")  		continue;  	var methodType = sig.Params [0].TryGetTypeDef ();  	var fieldType = sig.Params [1].TryGetTypeDef ();  	var ilgType = sig.Params [3].TryGetTypeDef ();  	if (!CheckMethodType (methodType))  		continue;  	if (!CheckFieldType (fieldType))  		continue;  	if (!CheckIlGeneratorType (ilgType))  		continue;  	info.ilgeneratorType = ilgType;  	info.methodInfoType = methodType;  	info.fieldInfoType = fieldType;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,FindOtherTypes,The following statement contains a magic number: foreach (var method in info.proxyType.Methods) {  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 4)  		continue;  	if (sig.Params [2].GetFullName () != "System.Type[]")  		continue;  	var methodType = sig.Params [0].TryGetTypeDef ();  	var fieldType = sig.Params [1].TryGetTypeDef ();  	var ilgType = sig.Params [3].TryGetTypeDef ();  	if (!CheckMethodType (methodType))  		continue;  	if (!CheckFieldType (fieldType))  		continue;  	if (!CheckIlGeneratorType (ilgType))  		continue;  	info.ilgeneratorType = ilgType;  	info.methodInfoType = methodType;  	info.fieldInfoType = fieldType;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,FindOtherTypes,The following statement contains a magic number: foreach (var method in info.proxyType.Methods) {  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 4)  		continue;  	if (sig.Params [2].GetFullName () != "System.Type[]")  		continue;  	var methodType = sig.Params [0].TryGetTypeDef ();  	var fieldType = sig.Params [1].TryGetTypeDef ();  	var ilgType = sig.Params [3].TryGetTypeDef ();  	if (!CheckMethodType (methodType))  		continue;  	if (!CheckFieldType (fieldType))  		continue;  	if (!CheckIlGeneratorType (ilgType))  		continue;  	info.ilgeneratorType = ilgType;  	info.methodInfoType = methodType;  	info.fieldInfoType = fieldType;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,FindOtherTypes,The following statement contains a magic number: if (sig == null || sig.Params.Count != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,FindOtherTypes,The following statement contains a magic number: if (sig.Params [2].GetFullName () != "System.Type[]")  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,Convert,The following statement contains a magic number: switch (type) {  case 1:  	// bool  	resourceData = dataCreator.Create (reader.ReadBoolean ());  	break;  case 2:  	// byte  	resourceData = dataCreator.Create (reader.ReadByte ());  	break;  case 3:  	// byte[]  	resourceData = dataCreator.Create (reader.ReadBytes (info.length));  	break;  case 4:  	// char[]  	resourceData = new CharArrayResourceData (dataCreator.CreateUserResourceType (CharArrayResourceData.ReflectionTypeName)' reader.ReadChars (info.length));  	break;  case 5:  	// sbyte  	resourceData = dataCreator.Create (reader.ReadSByte ());  	break;  case 6:  	// char  	resourceData = dataCreator.Create (reader.ReadChar ());  	break;  case 7:  	// decimal  	resourceData = dataCreator.Create (reader.ReadDecimal ());  	break;  case 8:  	// double  	resourceData = dataCreator.Create (reader.ReadDouble ());  	break;  case 9:  	// short  	resourceData = dataCreator.Create (reader.ReadInt16 ());  	break;  case 10:  	// int  	resourceData = dataCreator.Create (reader.ReadInt32 ());  	break;  case 11:  	// long  	resourceData = dataCreator.Create (reader.ReadInt64 ());  	break;  case 12:  	// float  	resourceData = dataCreator.Create (reader.ReadSingle ());  	break;  case 13:  	// string  	resourceData = dataCreator.Create (reader.ReadString ());  	break;  case 14:  	// ushort  	resourceData = dataCreator.Create (reader.ReadUInt16 ());  	break;  case 15:  	// uint  	resourceData = dataCreator.Create (reader.ReadUInt32 ());  	break;  case 16:  	// ulong  	resourceData = dataCreator.Create (reader.ReadUInt64 ());  	break;  case 17:  	// DateTime  	resourceData = dataCreator.Create (DateTime.FromBinary (reader.ReadInt64 ()));  	break;  case 18:  	// TimeSpan  	resourceData = dataCreator.Create (TimeSpan.FromTicks (reader.ReadInt64 ()));  	break;  case 19:  	// Icon  	resourceData = new IconResourceData (dataCreator.CreateUserResourceType (IconResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 20:  	// Image  	resourceData = new ImageResourceData (dataCreator.CreateUserResourceType (ImageResourceData.ReflectionTypeName)' reader.ReadBytes (info.length));  	break;  case 31:  	// binary  	resourceData = dataCreator.CreateSerialized (reader.ReadBytes (info.length));  	break;  case 21:  // Point (CV doesn't restore this type)  default:  	throw new Exception ("Unknown type");  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindResourceFlags,The following statement contains a magic number: if (sig == null || sig.Params.Count != 4)  	return;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindResType,The following statement contains a magic number: if (sig == null || sig.Params.Count != 4)  	return;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,GetDlxResDict,The following statement contains a magic number: foreach (var field in type.Fields) {  	var fieldType = field.FieldSig.GetFieldType ().ToGenericInstSig ();  	if (fieldType == null)  		continue;  	if (fieldType.GenericType.FullName != "System.Collections.Generic.Dictionary`2")  		continue;  	if (fieldType.GenericArguments.Count != 2)  		continue;  	if (fieldType.GenericArguments [0].FullName != "System.String")  		continue;  	if (fieldType.GenericArguments [1].TryGetTypeDef () == null)  		continue;  	return fieldType;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,GetDlxResDict,The following statement contains a magic number: if (fieldType.GenericArguments.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindXxteaMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!method.IsPrivate || method.IsStatic || method.Body == null)  		continue;  	if (DotNetUtils.IsMethod (method' "System.Void"' "(System.UInt32[]'System.UInt32[])")) {  		if (!DeobUtils.HasInteger (method' 0x9E3779B9))  			continue;  	} else if (DotNetUtils.IsMethod (method' "System.Void"' "(System.UInt32[]'System.UInt32[]'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32)")) {  		// Here if 5.0. 0x9E3779B9 is passed to it as the last arg.  	} else  		continue;  	if (!DeobUtils.HasInteger (method' 52))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,FindXxteaMethod,The following statement contains a magic number: if (!DeobUtils.HasInteger (method' 52))  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: if (encrypted) {  	var key = new uint[4];  	key [0] = dataReader.ReadUInt32 ();  	key [1] = dataReader.ReadUInt32 ();  	int numDwords = dataReader.ReadInt32 ();  	if (numDwords < 0 || numDwords >= 0x40000000)  		throw new ApplicationException ("Invalid number of encrypted dwords");  	var encryptedData = new uint[numDwords];  	for (int i = 0; i < numDwords; i++)  		encryptedData [i] = dataReader.ReadUInt32 ();  	key [2] = dataReader.ReadUInt32 ();  	key [3] = dataReader.ReadUInt32 ();  	DeobUtils.XxteaDecrypt (encryptedData' key);  	byte[] decryptedData = new byte[encryptedData.Length * 4];  	Buffer.BlockCopy (encryptedData' 0' decryptedData' 0' decryptedData.Length);  	dataReader = MemoryImageStream.Create (decryptedData);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: if (encrypted) {  	var key = new uint[4];  	key [0] = dataReader.ReadUInt32 ();  	key [1] = dataReader.ReadUInt32 ();  	int numDwords = dataReader.ReadInt32 ();  	if (numDwords < 0 || numDwords >= 0x40000000)  		throw new ApplicationException ("Invalid number of encrypted dwords");  	var encryptedData = new uint[numDwords];  	for (int i = 0; i < numDwords; i++)  		encryptedData [i] = dataReader.ReadUInt32 ();  	key [2] = dataReader.ReadUInt32 ();  	key [3] = dataReader.ReadUInt32 ();  	DeobUtils.XxteaDecrypt (encryptedData' key);  	byte[] decryptedData = new byte[encryptedData.Length * 4];  	Buffer.BlockCopy (encryptedData' 0' decryptedData' 0' decryptedData.Length);  	dataReader = MemoryImageStream.Create (decryptedData);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: if (encrypted) {  	var key = new uint[4];  	key [0] = dataReader.ReadUInt32 ();  	key [1] = dataReader.ReadUInt32 ();  	int numDwords = dataReader.ReadInt32 ();  	if (numDwords < 0 || numDwords >= 0x40000000)  		throw new ApplicationException ("Invalid number of encrypted dwords");  	var encryptedData = new uint[numDwords];  	for (int i = 0; i < numDwords; i++)  		encryptedData [i] = dataReader.ReadUInt32 ();  	key [2] = dataReader.ReadUInt32 ();  	key [3] = dataReader.ReadUInt32 ();  	DeobUtils.XxteaDecrypt (encryptedData' key);  	byte[] decryptedData = new byte[encryptedData.Length * 4];  	Buffer.BlockCopy (encryptedData' 0' decryptedData' 0' decryptedData.Length);  	dataReader = MemoryImageStream.Create (decryptedData);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: if (encrypted) {  	var key = new uint[4];  	key [0] = dataReader.ReadUInt32 ();  	key [1] = dataReader.ReadUInt32 ();  	int numDwords = dataReader.ReadInt32 ();  	if (numDwords < 0 || numDwords >= 0x40000000)  		throw new ApplicationException ("Invalid number of encrypted dwords");  	var encryptedData = new uint[numDwords];  	for (int i = 0; i < numDwords; i++)  		encryptedData [i] = dataReader.ReadUInt32 ();  	key [2] = dataReader.ReadUInt32 ();  	key [3] = dataReader.ReadUInt32 ();  	DeobUtils.XxteaDecrypt (encryptedData' key);  	byte[] decryptedData = new byte[encryptedData.Length * 4];  	Buffer.BlockCopy (encryptedData' 0' decryptedData' 0' decryptedData.Length);  	dataReader = MemoryImageStream.Create (decryptedData);  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: key [2] = dataReader.ReadUInt32 ();  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Read,The following statement contains a magic number: key [3] = dataReader.ReadUInt32 ();  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Rol3,The following statement contains a magic number: return (char)((s << 3) | (s >> (16 - 3)));  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Rol3,The following statement contains a magic number: return (char)((s << 3) | (s >> (16 - 3)));  
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,Rol3,The following statement contains a magic number: return (char)((s << 3) | (s >> (16 - 3)));  
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,CheckFields,The following statement contains a magic number: if (data == null || data.Length == 0 || data.Length % 4 != 0)  	return null;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,GetKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Newarr)  		continue;  	i++;  	var key = ArrayFinder.GetInitializedUInt32Array (4' method' ref i);  	if (key == null)  		continue;  	return key;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,GetKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Newarr)  		continue;  	i++;  	var key = ArrayFinder.GetInitializedUInt32Array (4' method' ref i);  	if (key == null)  		continue;  	return key;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,GetKey,The following statement contains a magic number: if (ldci4.GetLdcI4Value () != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,CallsMainTypeTamperCheckMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Call' OpCodes.Ldc_I8' OpCodes.Call);  	if (instrs == null)  		continue;  	if (!CheckInvokeCall (instrs [1]' "System.Type"' "(System.RuntimeTypeHandle)"))  		continue;  	if (!CheckInvokeCall (instrs [2]' "System.Reflection.Assembly"' "(System.Object)"))  		continue;  	if (!CheckInvokeCall (instrs [4]' "System.Void"' "(System.Reflection.Assembly'System.UInt64)"))  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,CallsMainTypeTamperCheckMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Call' OpCodes.Ldc_I8' OpCodes.Call);  	if (instrs == null)  		continue;  	if (!CheckInvokeCall (instrs [1]' "System.Type"' "(System.RuntimeTypeHandle)"))  		continue;  	if (!CheckInvokeCall (instrs [2]' "System.Reflection.Assembly"' "(System.Object)"))  		continue;  	if (!CheckInvokeCall (instrs [4]' "System.Void"' "(System.Reflection.Assembly'System.UInt64)"))  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.CodeVeil,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,CallsMainTypeTamperCheckMethod,The following statement contains a magic number: if (!CheckInvokeCall (instrs [2]' "System.Reflection.Assembly"' "(System.Object)"))  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeVeil,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,CallsMainTypeTamperCheckMethod,The following statement contains a magic number: if (!CheckInvokeCall (instrs [4]' "System.Void"' "(System.Reflection.Assembly'System.UInt64)"))  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,Decrypt,The following statement contains a magic number: return DeobUtils.Inflate (DeobUtils.AesDecrypt (encrypted' keyGenerator.GetBytes (32)' keyGenerator.GetBytes (16))' false);  
Magic Number,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,Decrypt,The following statement contains a magic number: return DeobUtils.Inflate (DeobUtils.AesDecrypt (encrypted' keyGenerator.GetBytes (32)' keyGenerator.GetBytes (16))' false);  
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (methodsDecrypter.Detected)  	val += 50;  
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 50;  
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,InitializeStringDecrypter,The following statement contains a magic number: foreach (var info in stringDecrypter.Infos)  	staticStringInliner.Add (info.Method' (method' gim' args) => stringDecrypter.Decrypt (method' (int)args [0]' (int)args [1]' (int)args [2]));  
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,InitializeStringDecrypter,The following statement contains a magic number: staticStringInliner.Add (info.Method' (method' gim' args) => stringDecrypter.Decrypt (method' (int)args [0]' (int)args [1]' (int)args [2]));  
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Find,The following statement contains a magic number: foreach (var cctor in DeobUtils.GetInitCctors (module' 3)) {  	if (CheckCctor (cctor))  		return;  }  
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	peImage.Reader.Position = bodyOffset;  	var mbHeader = MethodBodyParser.ParseMethodBody (peImage.Reader' out dm.code' out dm.extraSections);  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	if (dm.code.Length < 6 || dm.code [0] != 0x2A || dm.code [1] != 0x2A)  		continue;  	int seed = BitConverter.ToInt32 (dm.code' 2);  	Array.Copy (newCodeHeader' dm.code' newCodeHeader.Length);  	if (seed == 0)  		Decrypt (dm.code);  	else  		Decrypt (dm.code' seed);  	dumpedMethods.Add (dm);  	decrypted = true;  }  
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	peImage.Reader.Position = bodyOffset;  	var mbHeader = MethodBodyParser.ParseMethodBody (peImage.Reader' out dm.code' out dm.extraSections);  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	if (dm.code.Length < 6 || dm.code [0] != 0x2A || dm.code [1] != 0x2A)  		continue;  	int seed = BitConverter.ToInt32 (dm.code' 2);  	Array.Copy (newCodeHeader' dm.code' newCodeHeader.Length);  	if (seed == 0)  		Decrypt (dm.code);  	else  		Decrypt (dm.code' seed);  	dumpedMethods.Add (dm);  	decrypted = true;  }  
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (dm.code.Length < 6 || dm.code [0] != 0x2A || dm.code [1] != 0x2A)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 6; i < data.Length; i++)  	data [i] ^= decryptKey [i % decryptKey.Length];  
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 6; i < data.Length; i++)  	data [i] ^= key [i];  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,CheckMethodsV30,The following statement contains a magic number: if (type.Methods.Count < 1 || type.Methods.Count > 2)  	return null;  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,CheckMethodsV36,The following statement contains a magic number: if (type.Methods.Count != 2)  	return null;  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldloc = instrs [i];  	if (!ldloc.IsLdloc ())  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldloc = instrs [i];  	if (!ldloc.IsLdloc ())  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic3,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 2)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic3,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 2)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic3,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 2)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic3,The following statement contains a magic number: if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,FindMagic3,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMersenne,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMersenne.cs,Init0,The following statement contains a magic number: for (mti = 1; mti < MERS_N; mti++) {  	mt [mti] = (factor * (mt [mti - 1] ^ (mt [mti - 1] >> 30)) + (uint)mti);  }  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMersenne,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMersenne.cs,Init0,The following statement contains a magic number: mt [mti] = (factor * (mt [mti - 1] ^ (mt [mti - 1] >> 30)) + (uint)mti);  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMersenne,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMersenne.cs,RandomInit,The following statement contains a magic number: for (int i = 0; i < 37; i++)  	BRandom ();  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,RandomInit,The following statement contains a magic number: for (i = 0; i < 5; i++) {  	s = s * 29943829 - 1;  	x [i] = s;  }  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,RandomInit,The following statement contains a magic number: for (i = 0; i < 5; i++) {  	s = s * 29943829 - 1;  	x [i] = s;  }  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,RandomInit,The following statement contains a magic number: s = s * 29943829 - 1;  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,RandomInit,The following statement contains a magic number: for (i = 0; i < 19; i++)  	BRandom ();  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x [3] + (ulong)1492 * (ulong)(x [2]) + (ulong)1776 * (ulong)(x [1]) + (ulong)5115 * (ulong)(x [0]) + (ulong)x [4];  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x [3] + (ulong)1492 * (ulong)(x [2]) + (ulong)1776 * (ulong)(x [1]) + (ulong)5115 * (ulong)(x [0]) + (ulong)x [4];  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x [3] + (ulong)1492 * (ulong)(x [2]) + (ulong)1776 * (ulong)(x [1]) + (ulong)5115 * (ulong)(x [0]) + (ulong)x [4];  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x [3] + (ulong)1492 * (ulong)(x [2]) + (ulong)1776 * (ulong)(x [1]) + (ulong)5115 * (ulong)(x [0]) + (ulong)x [4];  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x [3] + (ulong)1492 * (ulong)(x [2]) + (ulong)1776 * (ulong)(x [1]) + (ulong)5115 * (ulong)(x [0]) + (ulong)x [4];  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x [3] + (ulong)1492 * (ulong)(x [2]) + (ulong)1776 * (ulong)(x [1]) + (ulong)5115 * (ulong)(x [0]) + (ulong)x [4];  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x [3] = x [2];  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x [3] = x [2];  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x [2] = x [1];  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x [4] = (uint)(sum >> 32);  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x [4] = (uint)(sum >> 32);  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,Random,The following statement contains a magic number: return (double)BRandom () * (1.0 / (65536.0 * 65536.0));  
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,Random,The following statement contains a magic number: return (double)BRandom () * (1.0 / (65536.0 * 65536.0));  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  	int failFastCalls = ConfuserUtils.CountCalls (antiDebugMethod' "System.Void System.Environment::FailFast(System.String)");  	if (failFastCalls != 6 && failFastCalls != 8)  		return false;  	if (!CheckProfilerStrings1 (initMethod))  		return false;  	if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v16_r61954_normal;  	} else if (failFastCalls == 8) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v17_r73822_normal;  	} else if (failFastCalls == 6) {  		if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  			return false;  		if (hasDebuggerStrings)  			version = ConfuserVersion.v17_r74021_normal;  		else  			version = ConfuserVersion.v19_r78363_normal;  	} else  		return false;  } else if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.ThreadStart::.ctor(System.Object'System.IntPtr)")) {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r57588_normal;  } else {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r60785_normal;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  	int failFastCalls = ConfuserUtils.CountCalls (antiDebugMethod' "System.Void System.Environment::FailFast(System.String)");  	if (failFastCalls != 6 && failFastCalls != 8)  		return false;  	if (!CheckProfilerStrings1 (initMethod))  		return false;  	if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v16_r61954_normal;  	} else if (failFastCalls == 8) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v17_r73822_normal;  	} else if (failFastCalls == 6) {  		if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  			return false;  		if (hasDebuggerStrings)  			version = ConfuserVersion.v17_r74021_normal;  		else  			version = ConfuserVersion.v19_r78363_normal;  	} else  		return false;  } else if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.ThreadStart::.ctor(System.Object'System.IntPtr)")) {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r57588_normal;  } else {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r60785_normal;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  	int failFastCalls = ConfuserUtils.CountCalls (antiDebugMethod' "System.Void System.Environment::FailFast(System.String)");  	if (failFastCalls != 6 && failFastCalls != 8)  		return false;  	if (!CheckProfilerStrings1 (initMethod))  		return false;  	if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v16_r61954_normal;  	} else if (failFastCalls == 8) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v17_r73822_normal;  	} else if (failFastCalls == 6) {  		if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  			return false;  		if (hasDebuggerStrings)  			version = ConfuserVersion.v17_r74021_normal;  		else  			version = ConfuserVersion.v19_r78363_normal;  	} else  		return false;  } else if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.ThreadStart::.ctor(System.Object'System.IntPtr)")) {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r57588_normal;  } else {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r60785_normal;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  	int failFastCalls = ConfuserUtils.CountCalls (antiDebugMethod' "System.Void System.Environment::FailFast(System.String)");  	if (failFastCalls != 6 && failFastCalls != 8)  		return false;  	if (!CheckProfilerStrings1 (initMethod))  		return false;  	if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v16_r61954_normal;  	} else if (failFastCalls == 8) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v17_r73822_normal;  	} else if (failFastCalls == 6) {  		if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  			return false;  		if (hasDebuggerStrings)  			version = ConfuserVersion.v17_r74021_normal;  		else  			version = ConfuserVersion.v19_r78363_normal;  	} else  		return false;  } else if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.ThreadStart::.ctor(System.Object'System.IntPtr)")) {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r57588_normal;  } else {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r60785_normal;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  	int failFastCalls = ConfuserUtils.CountCalls (antiDebugMethod' "System.Void System.Environment::FailFast(System.String)");  	if (failFastCalls != 6 && failFastCalls != 8)  		return false;  	if (!CheckProfilerStrings1 (initMethod))  		return false;  	if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v16_r61954_normal;  	} else if (failFastCalls == 8) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v17_r73822_normal;  	} else if (failFastCalls == 6) {  		if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  			return false;  		if (hasDebuggerStrings)  			version = ConfuserVersion.v17_r74021_normal;  		else  			version = ConfuserVersion.v19_r78363_normal;  	} else  		return false;  } else if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.ThreadStart::.ctor(System.Object'System.IntPtr)")) {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r57588_normal;  } else {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r60785_normal;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  	int failFastCalls = ConfuserUtils.CountCalls (antiDebugMethod' "System.Void System.Environment::FailFast(System.String)");  	if (failFastCalls != 6 && failFastCalls != 8)  		return false;  	if (!CheckProfilerStrings1 (initMethod))  		return false;  	if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v16_r61954_normal;  	} else if (failFastCalls == 8) {  		if (!hasDebuggerStrings)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  			return false;  		version = ConfuserVersion.v17_r73822_normal;  	} else if (failFastCalls == 6) {  		if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  			return false;  		if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  			return false;  		if (hasDebuggerStrings)  			version = ConfuserVersion.v17_r74021_normal;  		else  			version = ConfuserVersion.v19_r78363_normal;  	} else  		return false;  } else if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.ThreadStart::.ctor(System.Object'System.IntPtr)")) {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r57588_normal;  } else {  	if (!hasDebuggerStrings)  		return false;  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Diagnostics.Process::EnterDebugMode()"))  		return false;  	if (!CheckProfilerStrings1 (antiDebugMethod))  		return false;  	version = ConfuserVersion.v14_r60785_normal;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (failFastCalls != 6 && failFastCalls != 8)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (failFastCalls != 6 && failFastCalls != 8)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v16_r61954_normal;  } else if (failFastCalls == 8) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v17_r73822_normal;  } else if (failFastCalls == 6) {  	if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  		return false;  	if (hasDebuggerStrings)  		version = ConfuserVersion.v17_r74021_normal;  	else  		version = ConfuserVersion.v19_r78363_normal;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v16_r61954_normal;  } else if (failFastCalls == 8) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v17_r73822_normal;  } else if (failFastCalls == 6) {  	if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  		return false;  	if (hasDebuggerStrings)  		version = ConfuserVersion.v17_r74021_normal;  	else  		version = ConfuserVersion.v19_r78363_normal;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v16_r61954_normal;  } else if (failFastCalls == 8) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v17_r73822_normal;  } else if (failFastCalls == 6) {  	if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  		return false;  	if (hasDebuggerStrings)  		version = ConfuserVersion.v17_r74021_normal;  	else  		version = ConfuserVersion.v19_r78363_normal;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)")) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v16_r61954_normal;  } else if (failFastCalls == 8) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v17_r73822_normal;  } else if (failFastCalls == 6) {  	if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  		return false;  	if (hasDebuggerStrings)  		version = ConfuserVersion.v17_r74021_normal;  	else  		version = ConfuserVersion.v19_r78363_normal;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (failFastCalls == 8) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v17_r73822_normal;  } else if (failFastCalls == 6) {  	if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  		return false;  	if (hasDebuggerStrings)  		version = ConfuserVersion.v17_r74021_normal;  	else  		version = ConfuserVersion.v19_r78363_normal;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (failFastCalls == 8) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v17_r73822_normal;  } else if (failFastCalls == 6) {  	if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  		return false;  	if (hasDebuggerStrings)  		version = ConfuserVersion.v17_r74021_normal;  	else  		version = ConfuserVersion.v19_r78363_normal;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (failFastCalls == 8) {  	if (!hasDebuggerStrings)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  		return false;  	version = ConfuserVersion.v17_r73822_normal;  } else if (failFastCalls == 6) {  	if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  		return false;  	if (hasDebuggerStrings)  		version = ConfuserVersion.v17_r74021_normal;  	else  		version = ConfuserVersion.v19_r78363_normal;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_normal,The following statement contains a magic number: if (failFastCalls == 6) {  	if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  		return false;  	if (hasDebuggerStrings)  		version = ConfuserVersion.v17_r74021_normal;  	else  		version = ConfuserVersion.v19_r78363_normal;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_safe,The following statement contains a magic number: if (type == DotNetUtils.GetModuleType (module)) {  	if (!DotNetUtils.HasString (initMethod' "Debugger detected (Managed)"))  		return false;  	if (!CheckProfilerStrings1 (initMethod))  		return false;  	version = ConfuserVersion.v14_r57588_safe;  } else {  	var ntQueryInformationProcess = DotNetUtils.GetPInvokeMethod (type' "ntdll"' "NtQueryInformationProcess");  	if (ntQueryInformationProcess == null)  		return false;  	if (DotNetUtils.GetPInvokeMethod (type' "ntdll"' "NtSetInformationProcess") == null)  		return false;  	if (DotNetUtils.GetPInvokeMethod (type' "kernel32"' "CloseHandle") == null)  		return false;  	var antiDebugMethod = GetAntiDebugMethod (type' initMethod);  	if (antiDebugMethod == null)  		return false;  	bool hasDebuggerStrings = DotNetUtils.HasString (antiDebugMethod' "Debugger detected (Managed)") || DotNetUtils.HasString (antiDebugMethod' "Debugger is detected (Managed)");  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)"))  		return false;  	if (ConfuserUtils.CountCalls (antiDebugMethod' ntQueryInformationProcess) != 0)  		return false;  	if (!CheckProfilerStrings1 (initMethod) && !CheckProfilerStrings2 (initMethod))  		return false;  	int failFastCalls = ConfuserUtils.CountCalls (antiDebugMethod' "System.Void System.Environment::FailFast(System.String)");  	if (failFastCalls != 2)  		return false;  	if (hasDebuggerStrings) {  		if (!DotNetUtils.CallsMethod (antiDebugMethod' "System.Void System.Threading.Thread::.ctor(System.Threading.ParameterizedThreadStart)"))  			version = ConfuserVersion.v16_r61954_safe;  		else if (DotNetUtils.GetPInvokeMethod (type' "IsDebuggerPresent") == null)  			version = ConfuserVersion.v17_r73822_safe;  		else if (CheckProfilerStrings1 (initMethod))  			version = ConfuserVersion.v17_r74021_safe;  		else  			version = ConfuserVersion.v19_r76119_safe;  	} else {  		version = ConfuserVersion.v19_r78363_safe;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,CheckMethod_safe,The following statement contains a magic number: if (failFastCalls != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57588_safe:  	minRev = 57588;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_safe:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_safe:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_safe:  	minRev = 74021;  	maxRev = 76101;  	return true;  case ConfuserVersion.v19_r76119_safe:  	minRev = 76119;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_safe:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v14_r57588_normal:  	minRev = 57588;  	maxRev = 60408;  	return true;  case ConfuserVersion.v14_r60785_normal:  	minRev = 60785;  	maxRev = 60787;  	return true;  case ConfuserVersion.v16_r61954_normal:  	minRev = 61954;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_normal:  	minRev = 74021;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  	minRev = 78363;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 57588;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 60787;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 61954;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73791;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73822;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73822;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 74021;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 76101;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 76119;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 78342;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 78363;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 57588;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 60408;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 60785;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 60787;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 61954;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73791;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73822;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73822;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 74021;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 78342;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDebugger,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDebugger.cs,GetRevisionRange,The following statement contains a magic number: minRev = 78363;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58564,The following statement contains a magic number: if (ConfuserUtils.CountCalls (initMethod' virtualProtect) != 3)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58564,The following statement contains a magic number: if (!DeobUtils.HasInteger (initMethod' 224))  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58564,The following statement contains a magic number: if (!DeobUtils.HasInteger (initMethod' 240))  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58564,The following statement contains a magic number: if (!DeobUtils.HasInteger (initMethod' 267))  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (virtualProtectCalls != 14 && virtualProtectCalls != 16)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (virtualProtectCalls != 14 && virtualProtectCalls != 16)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (DeobUtils.HasInteger (initMethod' 0x18))  	version = ConfuserVersion.v14_r58852;  else if (virtualProtectCalls == 16)  	version = ConfuserVersion.v16_r69339;  else if (virtualProtectCalls == 14) {  	if (locallocs == 2)  		version = ConfuserVersion.v17_r74708;  	else if (locallocs == 1) {  		if (DotNetUtils.HasString (initMethod' "<Unknown>"))  			version = ConfuserVersion.v18_r75257;  		else if (IsRev75725 (initMethod))  			version = ConfuserVersion.v19_r75725;  		else  			version = ConfuserVersion.v19_r76186;  	} else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (DeobUtils.HasInteger (initMethod' 0x18))  	version = ConfuserVersion.v14_r58852;  else if (virtualProtectCalls == 16)  	version = ConfuserVersion.v16_r69339;  else if (virtualProtectCalls == 14) {  	if (locallocs == 2)  		version = ConfuserVersion.v17_r74708;  	else if (locallocs == 1) {  		if (DotNetUtils.HasString (initMethod' "<Unknown>"))  			version = ConfuserVersion.v18_r75257;  		else if (IsRev75725 (initMethod))  			version = ConfuserVersion.v19_r75725;  		else  			version = ConfuserVersion.v19_r76186;  	} else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (DeobUtils.HasInteger (initMethod' 0x18))  	version = ConfuserVersion.v14_r58852;  else if (virtualProtectCalls == 16)  	version = ConfuserVersion.v16_r69339;  else if (virtualProtectCalls == 14) {  	if (locallocs == 2)  		version = ConfuserVersion.v17_r74708;  	else if (locallocs == 1) {  		if (DotNetUtils.HasString (initMethod' "<Unknown>"))  			version = ConfuserVersion.v18_r75257;  		else if (IsRev75725 (initMethod))  			version = ConfuserVersion.v19_r75725;  		else  			version = ConfuserVersion.v19_r76186;  	} else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (virtualProtectCalls == 16)  	version = ConfuserVersion.v16_r69339;  else if (virtualProtectCalls == 14) {  	if (locallocs == 2)  		version = ConfuserVersion.v17_r74708;  	else if (locallocs == 1) {  		if (DotNetUtils.HasString (initMethod' "<Unknown>"))  			version = ConfuserVersion.v18_r75257;  		else if (IsRev75725 (initMethod))  			version = ConfuserVersion.v19_r75725;  		else  			version = ConfuserVersion.v19_r76186;  	} else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (virtualProtectCalls == 16)  	version = ConfuserVersion.v16_r69339;  else if (virtualProtectCalls == 14) {  	if (locallocs == 2)  		version = ConfuserVersion.v17_r74708;  	else if (locallocs == 1) {  		if (DotNetUtils.HasString (initMethod' "<Unknown>"))  			version = ConfuserVersion.v18_r75257;  		else if (IsRev75725 (initMethod))  			version = ConfuserVersion.v19_r75725;  		else  			version = ConfuserVersion.v19_r76186;  	} else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (virtualProtectCalls == 16)  	version = ConfuserVersion.v16_r69339;  else if (virtualProtectCalls == 14) {  	if (locallocs == 2)  		version = ConfuserVersion.v17_r74708;  	else if (locallocs == 1) {  		if (DotNetUtils.HasString (initMethod' "<Unknown>"))  			version = ConfuserVersion.v18_r75257;  		else if (IsRev75725 (initMethod))  			version = ConfuserVersion.v19_r75725;  		else  			version = ConfuserVersion.v19_r76186;  	} else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (virtualProtectCalls == 14) {  	if (locallocs == 2)  		version = ConfuserVersion.v17_r74708;  	else if (locallocs == 1) {  		if (DotNetUtils.HasString (initMethod' "<Unknown>"))  			version = ConfuserVersion.v18_r75257;  		else if (IsRev75725 (initMethod))  			version = ConfuserVersion.v19_r75725;  		else  			version = ConfuserVersion.v19_r76186;  	} else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (virtualProtectCalls == 14) {  	if (locallocs == 2)  		version = ConfuserVersion.v17_r74708;  	else if (locallocs == 1) {  		if (DotNetUtils.HasString (initMethod' "<Unknown>"))  			version = ConfuserVersion.v18_r75257;  		else if (IsRev75725 (initMethod))  			version = ConfuserVersion.v19_r75725;  		else  			version = ConfuserVersion.v19_r76186;  	} else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,CheckType_v14_r58852,The following statement contains a magic number: if (locallocs == 2)  	version = ConfuserVersion.v17_r74708;  else if (locallocs == 1) {  	if (DotNetUtils.HasString (initMethod' "<Unknown>"))  		version = ConfuserVersion.v18_r75257;  	else if (IsRev75725 (initMethod))  		version = ConfuserVersion.v19_r75725;  	else  		version = ConfuserVersion.v19_r76186;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 9; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  		continue;  	if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.ImplMap == null || calledMethod.ImplMap.Name != "VirtualProtect")  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Pop)  		continue;  	var ldloc = instrs [i + 5];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local == null)  		continue;  	if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  		continue;  	ldloc = instrs [i + 8];  	if (!ldloc.IsLdloc () || local != ldloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 8)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (!instrs [i + 1].IsLdcI4 () || instrs [i + 1].GetLdcI4Value () != 64)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Ldloca && instrs [i + 2].OpCode.Code != Code.Ldloca_S)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != Code.Pop)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (!instrs [i + 6].IsLdcI4 () || instrs [i + 6].GetLdcI4Value () != 0)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (instrs [i + 7].OpCode.Code != Code.Stind_I4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: ldloc = instrs [i + 8];  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,IsRev75725,The following statement contains a magic number: if (!instrs [i + 9].IsLdcI4 () || instrs [i + 9].GetLdcI4Value () != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 67058;  	return true;  case ConfuserVersion.v16_r69339:  	minRev = 69339;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708:  	minRev = 74708;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = 76163;  	return true;  case ConfuserVersion.v19_r76186:  	minRev = 76186;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58564;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58817;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58852;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 67058;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: minRev = 69339;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 74637;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: minRev = 74708;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75184;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75257;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75720;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75725;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 76163;  
Magic Number,de4dot.code.deobfuscators.Confuser,AntiDumping,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\AntiDumping.cs,GetRevisionRange,The following statement contains a magic number: minRev = 76186;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 4; i++) {  		var call = instrs [i];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Ldnull)  			continue;  		var ldftn = instrs [i + 2];  		if (ldftn.OpCode.Code != Code.Ldftn)  			continue;  		if (ldftn.Operand != handler)  			continue;  		var newobj = instrs [i + 3];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		var ctor = newobj.Operand as IMethod;  		if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  			continue;  		var callvirt = instrs [i + 4];  		if (callvirt.OpCode.Code != Code.Callvirt)  			continue;  		calledMethod = callvirt.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != installHandlerMethod)  			continue;  		block.Remove (i' 5);  		modified = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 4; i++) {  		var call = instrs [i];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Ldnull)  			continue;  		var ldftn = instrs [i + 2];  		if (ldftn.OpCode.Code != Code.Ldftn)  			continue;  		if (ldftn.Operand != handler)  			continue;  		var newobj = instrs [i + 3];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		var ctor = newobj.Operand as IMethod;  		if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  			continue;  		var callvirt = instrs [i + 4];  		if (callvirt.OpCode.Code != Code.Callvirt)  			continue;  		calledMethod = callvirt.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != installHandlerMethod)  			continue;  		block.Remove (i' 5);  		modified = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 4; i++) {  		var call = instrs [i];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Ldnull)  			continue;  		var ldftn = instrs [i + 2];  		if (ldftn.OpCode.Code != Code.Ldftn)  			continue;  		if (ldftn.Operand != handler)  			continue;  		var newobj = instrs [i + 3];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		var ctor = newobj.Operand as IMethod;  		if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  			continue;  		var callvirt = instrs [i + 4];  		if (callvirt.OpCode.Code != Code.Callvirt)  			continue;  		calledMethod = callvirt.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != installHandlerMethod)  			continue;  		block.Remove (i' 5);  		modified = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 4; i++) {  		var call = instrs [i];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Ldnull)  			continue;  		var ldftn = instrs [i + 2];  		if (ldftn.OpCode.Code != Code.Ldftn)  			continue;  		if (ldftn.Operand != handler)  			continue;  		var newobj = instrs [i + 3];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		var ctor = newobj.Operand as IMethod;  		if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  			continue;  		var callvirt = instrs [i + 4];  		if (callvirt.OpCode.Code != Code.Callvirt)  			continue;  		calledMethod = callvirt.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != installHandlerMethod)  			continue;  		block.Remove (i' 5);  		modified = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 4; i++) {  		var call = instrs [i];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Ldnull)  			continue;  		var ldftn = instrs [i + 2];  		if (ldftn.OpCode.Code != Code.Ldftn)  			continue;  		if (ldftn.Operand != handler)  			continue;  		var newobj = instrs [i + 3];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		var ctor = newobj.Operand as IMethod;  		if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  			continue;  		var callvirt = instrs [i + 4];  		if (callvirt.OpCode.Code != Code.Callvirt)  			continue;  		calledMethod = callvirt.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != installHandlerMethod)  			continue;  		block.Remove (i' 5);  		modified = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var call = instrs [i];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Ldnull)  		continue;  	var ldftn = instrs [i + 2];  	if (ldftn.OpCode.Code != Code.Ldftn)  		continue;  	if (ldftn.Operand != handler)  		continue;  	var newobj = instrs [i + 3];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	var ctor = newobj.Operand as IMethod;  	if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  		continue;  	var callvirt = instrs [i + 4];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	calledMethod = callvirt.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != installHandlerMethod)  		continue;  	block.Remove (i' 5);  	modified = true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var call = instrs [i];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Ldnull)  		continue;  	var ldftn = instrs [i + 2];  	if (ldftn.OpCode.Code != Code.Ldftn)  		continue;  	if (ldftn.Operand != handler)  		continue;  	var newobj = instrs [i + 3];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	var ctor = newobj.Operand as IMethod;  	if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  		continue;  	var callvirt = instrs [i + 4];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	calledMethod = callvirt.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != installHandlerMethod)  		continue;  	block.Remove (i' 5);  	modified = true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var call = instrs [i];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Ldnull)  		continue;  	var ldftn = instrs [i + 2];  	if (ldftn.OpCode.Code != Code.Ldftn)  		continue;  	if (ldftn.Operand != handler)  		continue;  	var newobj = instrs [i + 3];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	var ctor = newobj.Operand as IMethod;  	if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  		continue;  	var callvirt = instrs [i + 4];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	calledMethod = callvirt.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != installHandlerMethod)  		continue;  	block.Remove (i' 5);  	modified = true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var call = instrs [i];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Ldnull)  		continue;  	var ldftn = instrs [i + 2];  	if (ldftn.OpCode.Code != Code.Ldftn)  		continue;  	if (ldftn.Operand != handler)  		continue;  	var newobj = instrs [i + 3];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	var ctor = newobj.Operand as IMethod;  	if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  		continue;  	var callvirt = instrs [i + 4];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	calledMethod = callvirt.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != installHandlerMethod)  		continue;  	block.Remove (i' 5);  	modified = true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var call = instrs [i];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.AppDomain System.AppDomain::get_CurrentDomain()")  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Ldnull)  		continue;  	var ldftn = instrs [i + 2];  	if (ldftn.OpCode.Code != Code.Ldftn)  		continue;  	if (ldftn.Operand != handler)  		continue;  	var newobj = instrs [i + 3];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	var ctor = newobj.Operand as IMethod;  	if (ctor == null || ctor.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  		continue;  	var callvirt = instrs [i + 4];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	calledMethod = callvirt.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != installHandlerMethod)  		continue;  	block.Remove (i' 5);  	modified = true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,RemoveResolveHandlerCode,The following statement contains a magic number: block.Remove (i' 5);  
Magic Number,de4dot.code.deobfuscators.Confuser,ConfuserUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConfuserUtils.cs,IsLzmaType,The following statement contains a magic number: if (type.NestedTypes.Count != 6)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicLocal_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte System.IO.BinaryReader::ReadByte()");  	if (i < 0 || i + 5 >= instrs.Count)  		break;  	if (!instrs [i + 1].IsStloc ())  		continue;  	var ldloc = instrs [i + 2];  	if (!ldloc.IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x7F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	return ldloc.GetLocal (method.Body.Variables);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicLocal_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte System.IO.BinaryReader::ReadByte()");  	if (i < 0 || i + 5 >= instrs.Count)  		break;  	if (!instrs [i + 1].IsStloc ())  		continue;  	var ldloc = instrs [i + 2];  	if (!ldloc.IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x7F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	return ldloc.GetLocal (method.Body.Variables);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicLocal_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte System.IO.BinaryReader::ReadByte()");  	if (i < 0 || i + 5 >= instrs.Count)  		break;  	if (!instrs [i + 1].IsStloc ())  		continue;  	var ldloc = instrs [i + 2];  	if (!ldloc.IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x7F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	return ldloc.GetLocal (method.Body.Variables);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicLocal_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte System.IO.BinaryReader::ReadByte()");  	if (i < 0 || i + 5 >= instrs.Count)  		break;  	if (!instrs [i + 1].IsStloc ())  		continue;  	var ldloc = instrs [i + 2];  	if (!ldloc.IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x7F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	return ldloc.GetLocal (method.Body.Variables);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicLocal_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte System.IO.BinaryReader::ReadByte()");  	if (i < 0 || i + 5 >= instrs.Count)  		break;  	if (!instrs [i + 1].IsStloc ())  		continue;  	var ldloc = instrs [i + 2];  	if (!ldloc.IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x7F)  		continue;  	if (instrs [i + 5].OpCode.Code != Code.And)  		continue;  	return ldloc.GetLocal (method.Body.Variables);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicLocal_v17_r73740,The following statement contains a magic number: if (i < 0 || i + 5 >= instrs.Count)  	break;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicLocal_v17_r73740,The following statement contains a magic number: if (!instrs [i + 3].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicLocal_v17_r73740,The following statement contains a magic number: if (instrs [i + 5].OpCode.Code != Code.And)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	int index = i;  	var stloc = instrs [index++];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [index++].IsLdloc ())  		continue;  	if (instrs [index].OpCode.Code == Code.Call) {  		if (i + 7 >= instrs.Count)  			continue;  		index++;  		if (!instrs [index++].IsLdloc ())  			continue;  	}  	if (!instrs [index++].IsLdloc ())  		continue;  	var ldloc = instrs [index++];  	if (!ldloc.IsLdloc () || ldloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (instrs [index++].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [index++].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	int index = i;  	var stloc = instrs [index++];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [index++].IsLdloc ())  		continue;  	if (instrs [index].OpCode.Code == Code.Call) {  		if (i + 7 >= instrs.Count)  			continue;  		index++;  		if (!instrs [index++].IsLdloc ())  			continue;  	}  	if (!instrs [index++].IsLdloc ())  		continue;  	var ldloc = instrs [index++];  	if (!ldloc.IsLdloc () || ldloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (instrs [index++].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [index++].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r73740,The following statement contains a magic number: if (instrs [index].OpCode.Code == Code.Call) {  	if (i + 7 >= instrs.Count)  		continue;  	index++;  	if (!instrs [index++].IsLdloc ())  		continue;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r73740,The following statement contains a magic number: if (i + 7 >= instrs.Count)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 11; i++) {  	var stloc = instrs [i];  	if (!stloc.IsStloc () || stloc.GetLocal (method.Body.Variables) != local)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (!instrs [i + 2].IsLdloc ())  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 6];  	if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  		continue;  	if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (!instrs [i + 2].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (!instrs [i + 3].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (!instrs [i + 4].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (!instrs [i + 5].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (!ldci4.IsLdcI4 () || (ldci4.GetLdcI4Value () != 8 && ldci4.GetLdcI4Value () != 16))  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (instrs [i + 7].OpCode.Code != Code.Rem)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (instrs [i + 8].OpCode.Code != Code.Ldelem_U1)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (instrs [i + 9].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (instrs [i + 10].OpCode.Code != Code.Conv_U1)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,GetDynamicEndIndex_v17_r74788,The following statement contains a magic number: if (instrs [i + 11].OpCode.Code != Code.Stelem_I1)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,DecryptInt32,The following statement contains a magic number: if (data.Length != 4)  	throw new ApplicationException ("Invalid data length");  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,DecryptInt64,The following statement contains a magic number: if (data.Length != 8)  	throw new ApplicationException ("Invalid data length");  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,DecryptSingle,The following statement contains a magic number: if (data.Length != 4)  	throw new ApplicationException ("Invalid data length");  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterBase.cs,DecryptDouble,The following statement contains a magic number: if (data.Length != 8)  	throw new ApplicationException ("Invalid data length");  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v15_r60785_normal:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404_normal:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_normal:  	minRev = 73822;  	maxRev = 74637;  	return true;  case ConfuserVersion.v15_r60785_dynamic:  	minRev = 60785;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989_dynamic:  	minRev = 72989;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_dynamic:  	minRev = 73740;  	maxRev = 73740;  	return true;  case ConfuserVersion.v17_r73764_dynamic:  case ConfuserVersion.v17_r73764_native:  	minRev = 73764;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822_dynamic:  case ConfuserVersion.v17_r73822_native:  	minRev = 73822;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021_dynamic:  case ConfuserVersion.v17_r74021_native:  	minRev = 74021;  	maxRev = 74637;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: minRev = 60785;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 72989;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73404;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73791;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73822;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 74637;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: minRev = 60785;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 72868;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: minRev = 72989;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73605;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73740;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73740;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73764;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73791;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73822;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73822;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: minRev = 74021;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV15,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV15.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 74637;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The following statement contains a magic number: if (resourceName != null) {  	simpleDeobfuscator.Deobfuscate (method);  	keyArraySize = GetKeyArraySize (method);  	if (keyArraySize == 8)  		InitVersion (method' ConfuserVersion.v17_r75056_normal' ConfuserVersion.v17_r75056_dynamic' ConfuserVersion.v17_r75056_native);  	else if (keyArraySize == 16)  		InitVersion (method' ConfuserVersion.v18_r75257_normal' ConfuserVersion.v18_r75257_dynamic' ConfuserVersion.v18_r75257_native);  	else  		return;  } else if (DotNetUtils.CallsMethod (method' "System.String System.Reflection.Module::get_ScopeName()"))  	InitVersion (method' ConfuserVersion.v17_r74816_normal' ConfuserVersion.v17_r74816_dynamic' ConfuserVersion.v17_r74816_native);  else if (DotNetUtils.CallsMethod (method' "System.Reflection.Module System.Reflection.Assembly::GetModule(System.String)"))  	InitVersion (method' ConfuserVersion.v17_r74788_normal' ConfuserVersion.v17_r74788_dynamic' ConfuserVersion.v17_r74788_native);  else  	InitVersion (method' ConfuserVersion.v17_r74708_normal' ConfuserVersion.v17_r74708_dynamic' ConfuserVersion.v17_r74708_native);  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The following statement contains a magic number: if (resourceName != null) {  	simpleDeobfuscator.Deobfuscate (method);  	keyArraySize = GetKeyArraySize (method);  	if (keyArraySize == 8)  		InitVersion (method' ConfuserVersion.v17_r75056_normal' ConfuserVersion.v17_r75056_dynamic' ConfuserVersion.v17_r75056_native);  	else if (keyArraySize == 16)  		InitVersion (method' ConfuserVersion.v18_r75257_normal' ConfuserVersion.v18_r75257_dynamic' ConfuserVersion.v18_r75257_native);  	else  		return;  } else if (DotNetUtils.CallsMethod (method' "System.String System.Reflection.Module::get_ScopeName()"))  	InitVersion (method' ConfuserVersion.v17_r74816_normal' ConfuserVersion.v17_r74816_dynamic' ConfuserVersion.v17_r74816_native);  else if (DotNetUtils.CallsMethod (method' "System.Reflection.Module System.Reflection.Assembly::GetModule(System.String)"))  	InitVersion (method' ConfuserVersion.v17_r74788_normal' ConfuserVersion.v17_r74788_dynamic' ConfuserVersion.v17_r74788_native);  else  	InitVersion (method' ConfuserVersion.v17_r74708_normal' ConfuserVersion.v17_r74708_dynamic' ConfuserVersion.v17_r74708_native);  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The following statement contains a magic number: if (keyArraySize == 8)  	InitVersion (method' ConfuserVersion.v17_r75056_normal' ConfuserVersion.v17_r75056_dynamic' ConfuserVersion.v17_r75056_native);  else if (keyArraySize == 16)  	InitVersion (method' ConfuserVersion.v18_r75257_normal' ConfuserVersion.v18_r75257_dynamic' ConfuserVersion.v18_r75257_native);  else  	return;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The following statement contains a magic number: if (keyArraySize == 8)  	InitVersion (method' ConfuserVersion.v17_r75056_normal' ConfuserVersion.v17_r75056_dynamic' ConfuserVersion.v17_r75056_native);  else if (keyArraySize == 16)  	InitVersion (method' ConfuserVersion.v18_r75257_normal' ConfuserVersion.v18_r75257_dynamic' ConfuserVersion.v18_r75257_native);  else  	return;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,Find,The following statement contains a magic number: if (keyArraySize == 16)  	InitVersion (method' ConfuserVersion.v18_r75257_normal' ConfuserVersion.v18_r75257_dynamic' ConfuserVersion.v18_r75257_native);  else  	return;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetKeyArraySize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Ldelem_U1)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetKeyArraySize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Ldelem_U1)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetKeyArraySize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Ldelem_U1)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetKeyArraySize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Rem)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Ldelem_U1)  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetKeyArraySize,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Rem)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetKeyArraySize,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != Code.Ldelem_U1)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_dynamic:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 74708;  	return true;  case ConfuserVersion.v17_r74788_normal:  case ConfuserVersion.v17_r74788_dynamic:  case ConfuserVersion.v17_r74788_native:  	minRev = 74788;  	maxRev = 74788;  	return true;  case ConfuserVersion.v17_r74816_normal:  case ConfuserVersion.v17_r74816_dynamic:  case ConfuserVersion.v17_r74816_native:  	minRev = 74816;  	maxRev = 74852;  	return true;  case ConfuserVersion.v17_r75056_normal:  case ConfuserVersion.v17_r75056_dynamic:  case ConfuserVersion.v17_r75056_native:  	minRev = 75056;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257_normal:  case ConfuserVersion.v18_r75257_dynamic:  case ConfuserVersion.v18_r75257_native:  	minRev = 75257;  	maxRev = 75349;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_dynamic:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 74708;  	return true;  case ConfuserVersion.v17_r74788_normal:  case ConfuserVersion.v17_r74788_dynamic:  case ConfuserVersion.v17_r74788_native:  	minRev = 74788;  	maxRev = 74788;  	return true;  case ConfuserVersion.v17_r74816_normal:  case ConfuserVersion.v17_r74816_dynamic:  case ConfuserVersion.v17_r74816_native:  	minRev = 74816;  	maxRev = 74852;  	return true;  case ConfuserVersion.v17_r75056_normal:  case ConfuserVersion.v17_r75056_dynamic:  case ConfuserVersion.v17_r75056_native:  	minRev = 75056;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257_normal:  case ConfuserVersion.v18_r75257_dynamic:  case ConfuserVersion.v18_r75257_native:  	minRev = 75257;  	maxRev = 75349;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_dynamic:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 74708;  	return true;  case ConfuserVersion.v17_r74788_normal:  case ConfuserVersion.v17_r74788_dynamic:  case ConfuserVersion.v17_r74788_native:  	minRev = 74788;  	maxRev = 74788;  	return true;  case ConfuserVersion.v17_r74816_normal:  case ConfuserVersion.v17_r74816_dynamic:  case ConfuserVersion.v17_r74816_native:  	minRev = 74816;  	maxRev = 74852;  	return true;  case ConfuserVersion.v17_r75056_normal:  case ConfuserVersion.v17_r75056_dynamic:  case ConfuserVersion.v17_r75056_native:  	minRev = 75056;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257_normal:  case ConfuserVersion.v18_r75257_dynamic:  case ConfuserVersion.v18_r75257_native:  	minRev = 75257;  	maxRev = 75349;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_dynamic:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 74708;  	return true;  case ConfuserVersion.v17_r74788_normal:  case ConfuserVersion.v17_r74788_dynamic:  case ConfuserVersion.v17_r74788_native:  	minRev = 74788;  	maxRev = 74788;  	return true;  case ConfuserVersion.v17_r74816_normal:  case ConfuserVersion.v17_r74816_dynamic:  case ConfuserVersion.v17_r74816_native:  	minRev = 74816;  	maxRev = 74852;  	return true;  case ConfuserVersion.v17_r75056_normal:  case ConfuserVersion.v17_r75056_dynamic:  case ConfuserVersion.v17_r75056_native:  	minRev = 75056;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257_normal:  case ConfuserVersion.v18_r75257_dynamic:  case ConfuserVersion.v18_r75257_native:  	minRev = 75257;  	maxRev = 75349;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_dynamic:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 74708;  	return true;  case ConfuserVersion.v17_r74788_normal:  case ConfuserVersion.v17_r74788_dynamic:  case ConfuserVersion.v17_r74788_native:  	minRev = 74788;  	maxRev = 74788;  	return true;  case ConfuserVersion.v17_r74816_normal:  case ConfuserVersion.v17_r74816_dynamic:  case ConfuserVersion.v17_r74816_native:  	minRev = 74816;  	maxRev = 74852;  	return true;  case ConfuserVersion.v17_r75056_normal:  case ConfuserVersion.v17_r75056_dynamic:  case ConfuserVersion.v17_r75056_native:  	minRev = 75056;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257_normal:  case ConfuserVersion.v18_r75257_dynamic:  case ConfuserVersion.v18_r75257_native:  	minRev = 75257;  	maxRev = 75349;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_dynamic:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 74708;  	return true;  case ConfuserVersion.v17_r74788_normal:  case ConfuserVersion.v17_r74788_dynamic:  case ConfuserVersion.v17_r74788_native:  	minRev = 74788;  	maxRev = 74788;  	return true;  case ConfuserVersion.v17_r74816_normal:  case ConfuserVersion.v17_r74816_dynamic:  case ConfuserVersion.v17_r74816_native:  	minRev = 74816;  	maxRev = 74852;  	return true;  case ConfuserVersion.v17_r75056_normal:  case ConfuserVersion.v17_r75056_dynamic:  case ConfuserVersion.v17_r75056_native:  	minRev = 75056;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257_normal:  case ConfuserVersion.v18_r75257_dynamic:  case ConfuserVersion.v18_r75257_native:  	minRev = 75257;  	maxRev = 75349;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_dynamic:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 74708;  	return true;  case ConfuserVersion.v17_r74788_normal:  case ConfuserVersion.v17_r74788_dynamic:  case ConfuserVersion.v17_r74788_native:  	minRev = 74788;  	maxRev = 74788;  	return true;  case ConfuserVersion.v17_r74816_normal:  case ConfuserVersion.v17_r74816_dynamic:  case ConfuserVersion.v17_r74816_native:  	minRev = 74816;  	maxRev = 74852;  	return true;  case ConfuserVersion.v17_r75056_normal:  case ConfuserVersion.v17_r75056_dynamic:  case ConfuserVersion.v17_r75056_native:  	minRev = 75056;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257_normal:  case ConfuserVersion.v18_r75257_dynamic:  case ConfuserVersion.v18_r75257_native:  	minRev = 75257;  	maxRev = 75349;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_dynamic:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 74708;  	return true;  case ConfuserVersion.v17_r74788_normal:  case ConfuserVersion.v17_r74788_dynamic:  case ConfuserVersion.v17_r74788_native:  	minRev = 74788;  	maxRev = 74788;  	return true;  case ConfuserVersion.v17_r74816_normal:  case ConfuserVersion.v17_r74816_dynamic:  case ConfuserVersion.v17_r74816_native:  	minRev = 74816;  	maxRev = 74852;  	return true;  case ConfuserVersion.v17_r75056_normal:  case ConfuserVersion.v17_r75056_dynamic:  case ConfuserVersion.v17_r75056_native:  	minRev = 75056;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257_normal:  case ConfuserVersion.v18_r75257_dynamic:  case ConfuserVersion.v18_r75257_native:  	minRev = 75257;  	maxRev = 75349;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_dynamic:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 74708;  	return true;  case ConfuserVersion.v17_r74788_normal:  case ConfuserVersion.v17_r74788_dynamic:  case ConfuserVersion.v17_r74788_native:  	minRev = 74788;  	maxRev = 74788;  	return true;  case ConfuserVersion.v17_r74816_normal:  case ConfuserVersion.v17_r74816_dynamic:  case ConfuserVersion.v17_r74816_native:  	minRev = 74816;  	maxRev = 74852;  	return true;  case ConfuserVersion.v17_r75056_normal:  case ConfuserVersion.v17_r75056_dynamic:  case ConfuserVersion.v17_r75056_native:  	minRev = 75056;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257_normal:  case ConfuserVersion.v18_r75257_dynamic:  case ConfuserVersion.v18_r75257_native:  	minRev = 75257;  	maxRev = 75349;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_dynamic:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 74708;  	return true;  case ConfuserVersion.v17_r74788_normal:  case ConfuserVersion.v17_r74788_dynamic:  case ConfuserVersion.v17_r74788_native:  	minRev = 74788;  	maxRev = 74788;  	return true;  case ConfuserVersion.v17_r74816_normal:  case ConfuserVersion.v17_r74816_dynamic:  case ConfuserVersion.v17_r74816_native:  	minRev = 74816;  	maxRev = 74852;  	return true;  case ConfuserVersion.v17_r75056_normal:  case ConfuserVersion.v17_r75056_dynamic:  case ConfuserVersion.v17_r75056_native:  	minRev = 75056;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257_normal:  case ConfuserVersion.v18_r75257_dynamic:  case ConfuserVersion.v18_r75257_native:  	minRev = 75257;  	maxRev = 75349;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: minRev = 74708;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 74708;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: minRev = 74788;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 74788;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: minRev = 74816;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 74852;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75056;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75184;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75257;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV17,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV17.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75349;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (FindKeys_v18_r75367 (info))  	InitVersion (cctor' ConfuserVersion.v18_r75367_normal' ConfuserVersion.v18_r75367_dynamic' ConfuserVersion.v18_r75367_native);  else if (FindKeys_v18_r75369 (info)) {  	lzmaType = ConfuserUtils.FindLzmaType (cctor);  	if (lzmaType == null)  		InitVersion (cctor' ConfuserVersion.v18_r75369_normal' ConfuserVersion.v18_r75369_dynamic' ConfuserVersion.v18_r75369_native);  	else if (!DotNetUtils.CallsMethod (method' "System.Void System.Threading.Monitor::Exit(System.Object)"))  		InitVersion (cctor' ConfuserVersion.v19_r77172_normal' ConfuserVersion.v19_r77172_dynamic' ConfuserVersion.v19_r77172_native);  	else if (DotNetUtils.CallsMethod (method' "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))  		InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native);  	else {  		int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  		int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  		if (index1 < 0 || index2 < 0) {  		}  		if (index2 - index1 == 3)  			InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  		else if (index2 - index1 == -4)  			InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  	}  } else  	return;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (FindKeys_v18_r75367 (info))  	InitVersion (cctor' ConfuserVersion.v18_r75367_normal' ConfuserVersion.v18_r75367_dynamic' ConfuserVersion.v18_r75367_native);  else if (FindKeys_v18_r75369 (info)) {  	lzmaType = ConfuserUtils.FindLzmaType (cctor);  	if (lzmaType == null)  		InitVersion (cctor' ConfuserVersion.v18_r75369_normal' ConfuserVersion.v18_r75369_dynamic' ConfuserVersion.v18_r75369_native);  	else if (!DotNetUtils.CallsMethod (method' "System.Void System.Threading.Monitor::Exit(System.Object)"))  		InitVersion (cctor' ConfuserVersion.v19_r77172_normal' ConfuserVersion.v19_r77172_dynamic' ConfuserVersion.v19_r77172_native);  	else if (DotNetUtils.CallsMethod (method' "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))  		InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native);  	else {  		int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  		int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  		if (index1 < 0 || index2 < 0) {  		}  		if (index2 - index1 == 3)  			InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  		else if (index2 - index1 == -4)  			InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  	}  } else  	return;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (FindKeys_v18_r75369 (info)) {  	lzmaType = ConfuserUtils.FindLzmaType (cctor);  	if (lzmaType == null)  		InitVersion (cctor' ConfuserVersion.v18_r75369_normal' ConfuserVersion.v18_r75369_dynamic' ConfuserVersion.v18_r75369_native);  	else if (!DotNetUtils.CallsMethod (method' "System.Void System.Threading.Monitor::Exit(System.Object)"))  		InitVersion (cctor' ConfuserVersion.v19_r77172_normal' ConfuserVersion.v19_r77172_dynamic' ConfuserVersion.v19_r77172_native);  	else if (DotNetUtils.CallsMethod (method' "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))  		InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native);  	else {  		int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  		int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  		if (index1 < 0 || index2 < 0) {  		}  		if (index2 - index1 == 3)  			InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  		else if (index2 - index1 == -4)  			InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  	}  } else  	return;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (FindKeys_v18_r75369 (info)) {  	lzmaType = ConfuserUtils.FindLzmaType (cctor);  	if (lzmaType == null)  		InitVersion (cctor' ConfuserVersion.v18_r75369_normal' ConfuserVersion.v18_r75369_dynamic' ConfuserVersion.v18_r75369_native);  	else if (!DotNetUtils.CallsMethod (method' "System.Void System.Threading.Monitor::Exit(System.Object)"))  		InitVersion (cctor' ConfuserVersion.v19_r77172_normal' ConfuserVersion.v19_r77172_dynamic' ConfuserVersion.v19_r77172_native);  	else if (DotNetUtils.CallsMethod (method' "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))  		InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native);  	else {  		int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  		int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  		if (index1 < 0 || index2 < 0) {  		}  		if (index2 - index1 == 3)  			InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  		else if (index2 - index1 == -4)  			InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  	}  } else  	return;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (lzmaType == null)  	InitVersion (cctor' ConfuserVersion.v18_r75369_normal' ConfuserVersion.v18_r75369_dynamic' ConfuserVersion.v18_r75369_native);  else if (!DotNetUtils.CallsMethod (method' "System.Void System.Threading.Monitor::Exit(System.Object)"))  	InitVersion (cctor' ConfuserVersion.v19_r77172_normal' ConfuserVersion.v19_r77172_dynamic' ConfuserVersion.v19_r77172_native);  else if (DotNetUtils.CallsMethod (method' "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))  	InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native);  else {  	int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	if (index1 < 0 || index2 < 0) {  	}  	if (index2 - index1 == 3)  		InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  	else if (index2 - index1 == -4)  		InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (lzmaType == null)  	InitVersion (cctor' ConfuserVersion.v18_r75369_normal' ConfuserVersion.v18_r75369_dynamic' ConfuserVersion.v18_r75369_native);  else if (!DotNetUtils.CallsMethod (method' "System.Void System.Threading.Monitor::Exit(System.Object)"))  	InitVersion (cctor' ConfuserVersion.v19_r77172_normal' ConfuserVersion.v19_r77172_dynamic' ConfuserVersion.v19_r77172_native);  else if (DotNetUtils.CallsMethod (method' "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))  	InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native);  else {  	int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	if (index1 < 0 || index2 < 0) {  	}  	if (index2 - index1 == 3)  		InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  	else if (index2 - index1 == -4)  		InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (!DotNetUtils.CallsMethod (method' "System.Void System.Threading.Monitor::Exit(System.Object)"))  	InitVersion (cctor' ConfuserVersion.v19_r77172_normal' ConfuserVersion.v19_r77172_dynamic' ConfuserVersion.v19_r77172_native);  else if (DotNetUtils.CallsMethod (method' "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))  	InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native);  else {  	int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	if (index1 < 0 || index2 < 0) {  	}  	if (index2 - index1 == 3)  		InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  	else if (index2 - index1 == -4)  		InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (!DotNetUtils.CallsMethod (method' "System.Void System.Threading.Monitor::Exit(System.Object)"))  	InitVersion (cctor' ConfuserVersion.v19_r77172_normal' ConfuserVersion.v19_r77172_dynamic' ConfuserVersion.v19_r77172_native);  else if (DotNetUtils.CallsMethod (method' "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))  	InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native);  else {  	int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	if (index1 < 0 || index2 < 0) {  	}  	if (index2 - index1 == 3)  		InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  	else if (index2 - index1 == -4)  		InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (DotNetUtils.CallsMethod (method' "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))  	InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native);  else {  	int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	if (index1 < 0 || index2 < 0) {  	}  	if (index2 - index1 == 3)  		InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  	else if (index2 - index1 == -4)  		InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (DotNetUtils.CallsMethod (method' "System.Void System.Diagnostics.StackFrame::.ctor(System.Int32)"))  	InitVersion (cctor' ConfuserVersion.v19_r78363_normal' ConfuserVersion.v19_r78363_dynamic' ConfuserVersion.v19_r78363_native);  else {  	int index1 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	int index2 = ConfuserUtils.FindCallMethod (cctor.Body.Instructions' 0' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	if (index1 < 0 || index2 < 0) {  	}  	if (index2 - index1 == 3)  		InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  	else if (index2 - index1 == -4)  		InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (index2 - index1 == 3)  	InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  else if (index2 - index1 == -4)  	InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (index2 - index1 == 3)  	InitVersion (cctor' ConfuserVersion.v19_r78056_normal' ConfuserVersion.v19_r78056_dynamic' ConfuserVersion.v19_r78056_native);  else if (index2 - index1 == -4)  	InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,Find,The following statement contains a magic number: if (index2 - index1 == -4)  	InitVersion (cctor' ConfuserVersion.v19_r79630_normal' ConfuserVersion.v19_r79630_dynamic' ConfuserVersion.v19_r79630_native);  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Text.Encoding System.Text.Encoding::get_UTF8()");  	if (index < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Byte[] System.BitConverter::GetBytes(System.Int32)");  	if (index2 - index != 2)  		continue;  	var ldci4 = instrs [index + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0,The following statement contains a magic number: if (index2 - index != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	if (index < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	int ldci4Index;  	switch (index2 - index) {  	case 3:  		// rev <= r79440  		ldci4Index = index + 1;  		break;  	case -4:  		// rev >= r79630  		ldci4Index = index2 - 2;  		break;  	default:  		continue;  	}  	var ldci4 = instrs [ldci4Index];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (!instrs [ldci4Index + 1].IsLdloc ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	if (index < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	int ldci4Index;  	switch (index2 - index) {  	case 3:  		// rev <= r79440  		ldci4Index = index + 1;  		break;  	case -4:  		// rev >= r79630  		ldci4Index = index2 - 2;  		break;  	default:  		continue;  	}  	var ldci4 = instrs [ldci4Index];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (!instrs [ldci4Index + 1].IsLdloc ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	if (index < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	int ldci4Index;  	switch (index2 - index) {  	case 3:  		// rev <= r79440  		ldci4Index = index + 1;  		break;  	case -4:  		// rev >= r79630  		ldci4Index = index2 - 2;  		break;  	default:  		continue;  	}  	var ldci4 = instrs [ldci4Index];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (!instrs [ldci4Index + 1].IsLdloc ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d,The following statement contains a magic number: switch (index2 - index) {  case 3:  	// rev <= r79440  	ldci4Index = index + 1;  	break;  case -4:  	// rev >= r79630  	ldci4Index = index2 - 2;  	break;  default:  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d,The following statement contains a magic number: switch (index2 - index) {  case 3:  	// rev <= r79440  	ldci4Index = index + 1;  	break;  case -4:  	// rev >= r79630  	ldci4Index = index2 - 2;  	break;  default:  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d,The following statement contains a magic number: switch (index2 - index) {  case 3:  	// rev <= r79440  	ldci4Index = index + 1;  	break;  case -4:  	// rev >= r79630  	ldci4Index = index2 - 2;  	break;  default:  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d,The following statement contains a magic number: ldci4Index = index2 - 2;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,IsDecryptMethodSignature,The following statement contains a magic number: if (sig.Params.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 10; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 7].IsStloc ())  		continue;  	var ldci4_3 = instrs [i + 8];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 10].IsStloc ())  		continue;  	info.key0l = (uint)ldci4_1.GetLdcI4Value ();  	info.key1l = (uint)ldci4_2.GetLdcI4Value ();  	info.key2l = (uint)ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 10; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 7].IsStloc ())  		continue;  	var ldci4_3 = instrs [i + 8];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 10].IsStloc ())  		continue;  	info.key0l = (uint)ldci4_1.GetLdcI4Value ();  	info.key1l = (uint)ldci4_2.GetLdcI4Value ();  	info.key2l = (uint)ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 10; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 7].IsStloc ())  		continue;  	var ldci4_3 = instrs [i + 8];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 10].IsStloc ())  		continue;  	info.key0l = (uint)ldci4_1.GetLdcI4Value ();  	info.key1l = (uint)ldci4_2.GetLdcI4Value ();  	info.key2l = (uint)ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 10; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 7].IsStloc ())  		continue;  	var ldci4_3 = instrs [i + 8];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 10].IsStloc ())  		continue;  	info.key0l = (uint)ldci4_1.GetLdcI4Value ();  	info.key1l = (uint)ldci4_2.GetLdcI4Value ();  	info.key2l = (uint)ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 10; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 7].IsStloc ())  		continue;  	var ldci4_3 = instrs [i + 8];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 10].IsStloc ())  		continue;  	info.key0l = (uint)ldci4_1.GetLdcI4Value ();  	info.key1l = (uint)ldci4_2.GetLdcI4Value ();  	info.key2l = (uint)ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 10; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 7].IsStloc ())  		continue;  	var ldci4_3 = instrs [i + 8];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 10].IsStloc ())  		continue;  	info.key0l = (uint)ldci4_1.GetLdcI4Value ();  	info.key1l = (uint)ldci4_2.GetLdcI4Value ();  	info.key2l = (uint)ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 10; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 7].IsStloc ())  		continue;  	var ldci4_3 = instrs [i + 8];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 10].IsStloc ())  		continue;  	info.key0l = (uint)ldci4_1.GetLdcI4Value ();  	info.key1l = (uint)ldci4_2.GetLdcI4Value ();  	info.key2l = (uint)ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 10; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 7].IsStloc ())  		continue;  	var ldci4_3 = instrs [i + 8];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 10].IsStloc ())  		continue;  	info.key0l = (uint)ldci4_1.GetLdcI4Value ();  	info.key1l = (uint)ldci4_2.GetLdcI4Value ();  	info.key2l = (uint)ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 10; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 7].IsStloc ())  		continue;  	var ldci4_3 = instrs [i + 8];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 10].IsStloc ())  		continue;  	info.key0l = (uint)ldci4_1.GetLdcI4Value ();  	info.key1l = (uint)ldci4_2.GetLdcI4Value ();  	info.key2l = (uint)ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 10; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 7].IsStloc ())  		continue;  	var ldci4_3 = instrs [i + 8];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  		continue;  	if (!instrs [i + 10].IsStloc ())  		continue;  	info.key0l = (uint)ldci4_1.GetLdcI4Value ();  	info.key1l = (uint)ldci4_2.GetLdcI4Value ();  	info.key2l = (uint)ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: if (!instrs [i + 4].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: if (instrs [i + 6].OpCode.Code != Code.Conv_I8)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: if (!instrs [i + 7].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: if (instrs [i + 9].OpCode.Code != Code.Conv_I8)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75367,The following statement contains a magic number: if (!instrs [i + 10].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_I8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Add)  		continue;  	info.key0 = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_I8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Add)  		continue;  	info.key0 = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_I8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Add)  		continue;  	info.key0 = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_I8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Add)  		continue;  	info.key0 = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75367,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Conv_I8)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75367,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Mul)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75367,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != Code.Add)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	if (index < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' index' Code.Call' "System.Byte[] System.BitConverter::GetBytes(System.Int32)");  	if (index2 < 0)  		break;  	if (index2 - index != 3)  		continue;  	var ldci4 = instrs [index + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 2].OpCode.Code != Code.Xor)  		continue;  	info.key0d = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.Reflection.MemberInfo::get_MetadataToken()");  	if (index < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' index' Code.Call' "System.Byte[] System.BitConverter::GetBytes(System.Int32)");  	if (index2 < 0)  		break;  	if (index2 - index != 3)  		continue;  	var ldci4 = instrs [index + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 2].OpCode.Code != Code.Xor)  		continue;  	info.key0d = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d_v18_r75367,The following statement contains a magic number: if (index2 - index != 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0d_v18_r75367,The following statement contains a magic number: if (instrs [index + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldci8_1 = instrs [i];  	if (ldci8_1.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci8_2 = instrs [i + 5];  	if (ldci8_2.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	var ldci8_3 = instrs [i + 7];  	if (ldci8_3.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	info.key0l = (ulong)(long)ldci8_1.Operand;  	info.key1l = (ulong)(long)ldci8_2.Operand;  	info.key2l = (ulong)(long)ldci8_3.Operand;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldci8_1 = instrs [i];  	if (ldci8_1.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci8_2 = instrs [i + 5];  	if (ldci8_2.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	var ldci8_3 = instrs [i + 7];  	if (ldci8_3.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	info.key0l = (ulong)(long)ldci8_1.Operand;  	info.key1l = (ulong)(long)ldci8_2.Operand;  	info.key2l = (ulong)(long)ldci8_3.Operand;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldci8_1 = instrs [i];  	if (ldci8_1.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci8_2 = instrs [i + 5];  	if (ldci8_2.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	var ldci8_3 = instrs [i + 7];  	if (ldci8_3.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	info.key0l = (ulong)(long)ldci8_1.Operand;  	info.key1l = (ulong)(long)ldci8_2.Operand;  	info.key2l = (ulong)(long)ldci8_3.Operand;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldci8_1 = instrs [i];  	if (ldci8_1.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci8_2 = instrs [i + 5];  	if (ldci8_2.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	var ldci8_3 = instrs [i + 7];  	if (ldci8_3.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	info.key0l = (ulong)(long)ldci8_1.Operand;  	info.key1l = (ulong)(long)ldci8_2.Operand;  	info.key2l = (ulong)(long)ldci8_3.Operand;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldci8_1 = instrs [i];  	if (ldci8_1.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci8_2 = instrs [i + 5];  	if (ldci8_2.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	var ldci8_3 = instrs [i + 7];  	if (ldci8_3.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	info.key0l = (ulong)(long)ldci8_1.Operand;  	info.key1l = (ulong)(long)ldci8_2.Operand;  	info.key2l = (ulong)(long)ldci8_3.Operand;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldci8_1 = instrs [i];  	if (ldci8_1.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci8_2 = instrs [i + 5];  	if (ldci8_2.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	var ldci8_3 = instrs [i + 7];  	if (ldci8_3.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	info.key0l = (ulong)(long)ldci8_1.Operand;  	info.key1l = (ulong)(long)ldci8_2.Operand;  	info.key2l = (ulong)(long)ldci8_3.Operand;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldci8_1 = instrs [i];  	if (ldci8_1.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci8_2 = instrs [i + 5];  	if (ldci8_2.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	var ldci8_3 = instrs [i + 7];  	if (ldci8_3.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	info.key0l = (ulong)(long)ldci8_1.Operand;  	info.key1l = (ulong)(long)ldci8_2.Operand;  	info.key2l = (ulong)(long)ldci8_3.Operand;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 8; i++) {  	var ldci8_1 = instrs [i];  	if (ldci8_1.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Mul)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	var ldci8_2 = instrs [i + 5];  	if (ldci8_2.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 6].IsStloc ())  		continue;  	var ldci8_3 = instrs [i + 7];  	if (ldci8_3.OpCode.Code != Code.Ldc_I8)  		continue;  	if (!instrs [i + 8].IsStloc ())  		continue;  	info.key0l = (ulong)(long)ldci8_1.Operand;  	info.key1l = (ulong)(long)ldci8_2.Operand;  	info.key2l = (ulong)(long)ldci8_3.Operand;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Conv_U8)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Mul)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: if (!instrs [i + 4].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: if (!instrs [i + 6].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindLKeys_v18_r75369,The following statement contains a magic number: if (!instrs [i + 8].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Mul)  		continue;  	info.key0 = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Mul)  		continue;  	info.key0 = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Mul)  		continue;  	info.key0 = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Mul)  		continue;  	info.key0 = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75369,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Conv_U8)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,FindKey0_v18_r75369,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != Code.Mul)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetDynamicLocal,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Void System.IO.BinaryWriter::Write(System.Byte)");  	if (i < 0)  		break;  	int index = i - 2;  	if (index < 0)  		continue;  	var ldloc = instrs [index];  	if (!ldloc.IsLdloc ())  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Conv_U1)  		continue;  	instrIndex = index;  	return ldloc.GetLocal (installMethod.Body.Variables);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_dynamic:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_dynamic:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172_normal:  case ConfuserVersion.v19_r77172_dynamic:  case ConfuserVersion.v19_r77172_native:  	minRev = 77172;  	maxRev = 77501;  	return true;  case ConfuserVersion.v19_r78056_normal:  case ConfuserVersion.v19_r78056_dynamic:  case ConfuserVersion.v19_r78056_native:  	minRev = 78056;  	// r78964 removed code that made it impossible to differentiate it from this  	// version. All we know is that it can't be r78363-r78963.  	maxRev = 79440;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_dynamic:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	maxRev = 78963;  	return true;  case ConfuserVersion.v19_r79630_normal:  case ConfuserVersion.v19_r79630_dynamic:  case ConfuserVersion.v19_r79630_native:  	minRev = 79630;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75367;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75367;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75369;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 77124;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: minRev = 77172;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 77501;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: minRev = 78056;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 79440;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: minRev = 78363;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 78963;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsDecrypterV18,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsDecrypterV18.cs,GetRevisionRange,The following statement contains a magic number: minRev = 79630;  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = 0;  	Instruction newInstr = null;  	var instr = instrs [i];  	if (constantsReader.IsLoadConstantInt32 (instr.Instruction)) {  		index = i;  		int val;  		if (!constantsReader.GetInt32 (ref index' out val))  			continue;  		newInstr = Instruction.CreateLdcI4 (val);  	} else if (constantsReader.IsLoadConstantInt64 (instr.Instruction)) {  		index = i;  		long val;  		if (!constantsReader.GetInt64 (ref index' out val))  			continue;  		newInstr = Instruction.Create (OpCodes.Ldc_I8' val);  	} else if (constantsReader.IsLoadConstantDouble (instr.Instruction)) {  		index = i;  		double val;  		if (!constantsReader.GetDouble (ref index' out val))  			continue;  		newInstr = Instruction.Create (OpCodes.Ldc_R8' val);  	}  	if (newInstr != null && index - i > 1) {  		block.Insert (index++' Instruction.Create (OpCodes.Pop));  		block.Insert (index++' newInstr);  		i = index - 1;  		constantsReader = CreateConstantsReader (instrs);  		modified = true;  		continue;  	}  	// Convert ldc.r4/r8 followed by conv to the appropriate ldc.i4/i8 instr  	if (i + 1 < instrs.Count && (instr.OpCode.Code == Code.Ldc_R4 || instr.OpCode.Code == Code.Ldc_R8)) {  		var conv = instrs [i + 1];  		/*int vali32 = instr.OpCode.Code == Code.Ldc_R4 ? (int)(float)instr.Operand : (int)(double)instr.Operand; 					long vali64 = instr.OpCode.Code == Code.Ldc_R4 ? (long)(float)instr.Operand : (long)(double)instr.Operand; 					uint valu32 = instr.OpCode.Code == Code.Ldc_R4 ? (uint)(float)instr.Operand : (uint)(double)instr.Operand; 					ulong valu64 = instr.OpCode.Code == Code.Ldc_R4 ? (ulong)(float)instr.Operand : (ulong)(double)instr.Operand;*/switch (conv.OpCode.Code) {  		case Code.Conv_I1:  			newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (sbyte)(float)instr.Operand : (sbyte)(double)instr.Operand);  			break;  		case Code.Conv_U1:  			newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (byte)(float)instr.Operand : (byte)(double)instr.Operand);  			break;  		case Code.Conv_I2:  			newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (short)(float)instr.Operand : (short)(double)instr.Operand);  			break;  		case Code.Conv_U2:  			newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (ushort)(float)instr.Operand : (ushort)(double)instr.Operand);  			break;  		case Code.Conv_I4:  			newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (int)(float)instr.Operand : (int)(double)instr.Operand);  			break;  		case Code.Conv_U4:  			newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (int)(uint)(float)instr.Operand : (int)(uint)(double)instr.Operand);  			break;  		case Code.Conv_I8:  			newInstr = Instruction.Create (OpCodes.Ldc_I8' instr.OpCode.Code == Code.Ldc_R4 ? (long)(float)instr.Operand : (long)(double)instr.Operand);  			break;  		case Code.Conv_U8:  			newInstr = Instruction.Create (OpCodes.Ldc_I8' instr.OpCode.Code == Code.Ldc_R4 ? (ulong)(float)instr.Operand : (ulong)(double)instr.Operand);  			break;  		default:  			newInstr = null;  			break;  		}  		if (newInstr != null) {  			block.Replace (i' 2' newInstr);  			constantsReader = CreateConstantsReader (instrs);  			modified = true;  			continue;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The following statement contains a magic number: if (i + 1 < instrs.Count && (instr.OpCode.Code == Code.Ldc_R4 || instr.OpCode.Code == Code.Ldc_R8)) {  	var conv = instrs [i + 1];  	/*int vali32 = instr.OpCode.Code == Code.Ldc_R4 ? (int)(float)instr.Operand : (int)(double)instr.Operand; 					long vali64 = instr.OpCode.Code == Code.Ldc_R4 ? (long)(float)instr.Operand : (long)(double)instr.Operand; 					uint valu32 = instr.OpCode.Code == Code.Ldc_R4 ? (uint)(float)instr.Operand : (uint)(double)instr.Operand; 					ulong valu64 = instr.OpCode.Code == Code.Ldc_R4 ? (ulong)(float)instr.Operand : (ulong)(double)instr.Operand;*/switch (conv.OpCode.Code) {  	case Code.Conv_I1:  		newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (sbyte)(float)instr.Operand : (sbyte)(double)instr.Operand);  		break;  	case Code.Conv_U1:  		newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (byte)(float)instr.Operand : (byte)(double)instr.Operand);  		break;  	case Code.Conv_I2:  		newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (short)(float)instr.Operand : (short)(double)instr.Operand);  		break;  	case Code.Conv_U2:  		newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (ushort)(float)instr.Operand : (ushort)(double)instr.Operand);  		break;  	case Code.Conv_I4:  		newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (int)(float)instr.Operand : (int)(double)instr.Operand);  		break;  	case Code.Conv_U4:  		newInstr = Instruction.CreateLdcI4 (instr.OpCode.Code == Code.Ldc_R4 ? (int)(uint)(float)instr.Operand : (int)(uint)(double)instr.Operand);  		break;  	case Code.Conv_I8:  		newInstr = Instruction.Create (OpCodes.Ldc_I8' instr.OpCode.Code == Code.Ldc_R4 ? (long)(float)instr.Operand : (long)(double)instr.Operand);  		break;  	case Code.Conv_U8:  		newInstr = Instruction.Create (OpCodes.Ldc_I8' instr.OpCode.Code == Code.Ldc_R4 ? (ulong)(float)instr.Operand : (ulong)(double)instr.Operand);  		break;  	default:  		newInstr = null;  		break;  	}  	if (newInstr != null) {  		block.Replace (i' 2' newInstr);  		constantsReader = CreateConstantsReader (instrs);  		modified = true;  		continue;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The following statement contains a magic number: if (newInstr != null) {  	block.Replace (i' 2' newInstr);  	constantsReader = CreateConstantsReader (instrs);  	modified = true;  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ConstantsFolder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ConstantsFolder.cs,Deobfuscate,The following statement contains a magic number: block.Replace (i' 2' newInstr);  
Magic Number,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,SetConfuserVersion,The following statement contains a magic number: if (val.Groups.Count < 5)  	return;  
Magic Number,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,SetConfuserVersion,The following statement contains a magic number: approxVersion = new Version (int.Parse (val.Groups [1].ToString ())' int.Parse (val.Groups [2].ToString ())' int.Parse (val.Groups [3].ToString ())' int.Parse (val.Groups [4].ToString ()));  
Magic Number,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,SetConfuserVersion,The following statement contains a magic number: approxVersion = new Version (int.Parse (val.Groups [1].ToString ())' int.Parse (val.Groups [2].ToString ())' int.Parse (val.Groups [3].ToString ())' int.Parse (val.Groups [4].ToString ()));  
Magic Number,de4dot.code.deobfuscators.Confuser,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Deobfuscator.cs,SetConfuserVersion,The following statement contains a magic number: approxVersion = new Version (int.Parse (val.Groups [1].ToString ())' int.Parse (val.Groups [2].ToString ())' int.Parse (val.Groups [3].ToString ())' int.Parse (val.Groups [4].ToString ()));  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: switch (type.NestedTypes.Count) {  case 35:  	if (type.Fields.Count == 9)  		theVersion = ConfuserVersion.v17_r73404;  	else if (type.Fields.Count == 10)  		theVersion = ConfuserVersion.v17_r73430;  	else  		return false;  	break;  case 38:  	switch (CountInt32s (compileMethod' 0xFF)) {  	case 2:  		theVersion = ConfuserVersion.v17_r73477;  		break;  	case 4:  		theVersion = ConfuserVersion.v17_r73479;  		break;  	default:  		return false;  	}  	break;  case 39:  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Console::WriteLine(System.Char)")) {  		if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  			theVersion = ConfuserVersion.v17_r74021;  		else  			theVersion = ConfuserVersion.v18_r75291;  	} else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  		theVersion = ConfuserVersion.v18_r75257;  	else  		theVersion = ConfuserVersion.v18_r75288;  	break;  case 27:  	if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v18_r75402;  	else  		theVersion = ConfuserVersion.v19_r75725;  	break;  default:  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: switch (type.NestedTypes.Count) {  case 35:  	if (type.Fields.Count == 9)  		theVersion = ConfuserVersion.v17_r73404;  	else if (type.Fields.Count == 10)  		theVersion = ConfuserVersion.v17_r73430;  	else  		return false;  	break;  case 38:  	switch (CountInt32s (compileMethod' 0xFF)) {  	case 2:  		theVersion = ConfuserVersion.v17_r73477;  		break;  	case 4:  		theVersion = ConfuserVersion.v17_r73479;  		break;  	default:  		return false;  	}  	break;  case 39:  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Console::WriteLine(System.Char)")) {  		if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  			theVersion = ConfuserVersion.v17_r74021;  		else  			theVersion = ConfuserVersion.v18_r75291;  	} else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  		theVersion = ConfuserVersion.v18_r75257;  	else  		theVersion = ConfuserVersion.v18_r75288;  	break;  case 27:  	if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v18_r75402;  	else  		theVersion = ConfuserVersion.v19_r75725;  	break;  default:  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: switch (type.NestedTypes.Count) {  case 35:  	if (type.Fields.Count == 9)  		theVersion = ConfuserVersion.v17_r73404;  	else if (type.Fields.Count == 10)  		theVersion = ConfuserVersion.v17_r73430;  	else  		return false;  	break;  case 38:  	switch (CountInt32s (compileMethod' 0xFF)) {  	case 2:  		theVersion = ConfuserVersion.v17_r73477;  		break;  	case 4:  		theVersion = ConfuserVersion.v17_r73479;  		break;  	default:  		return false;  	}  	break;  case 39:  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Console::WriteLine(System.Char)")) {  		if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  			theVersion = ConfuserVersion.v17_r74021;  		else  			theVersion = ConfuserVersion.v18_r75291;  	} else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  		theVersion = ConfuserVersion.v18_r75257;  	else  		theVersion = ConfuserVersion.v18_r75288;  	break;  case 27:  	if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v18_r75402;  	else  		theVersion = ConfuserVersion.v19_r75725;  	break;  default:  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: switch (type.NestedTypes.Count) {  case 35:  	if (type.Fields.Count == 9)  		theVersion = ConfuserVersion.v17_r73404;  	else if (type.Fields.Count == 10)  		theVersion = ConfuserVersion.v17_r73430;  	else  		return false;  	break;  case 38:  	switch (CountInt32s (compileMethod' 0xFF)) {  	case 2:  		theVersion = ConfuserVersion.v17_r73477;  		break;  	case 4:  		theVersion = ConfuserVersion.v17_r73479;  		break;  	default:  		return false;  	}  	break;  case 39:  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Console::WriteLine(System.Char)")) {  		if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  			theVersion = ConfuserVersion.v17_r74021;  		else  			theVersion = ConfuserVersion.v18_r75291;  	} else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  		theVersion = ConfuserVersion.v18_r75257;  	else  		theVersion = ConfuserVersion.v18_r75288;  	break;  case 27:  	if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v18_r75402;  	else  		theVersion = ConfuserVersion.v19_r75725;  	break;  default:  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: switch (type.NestedTypes.Count) {  case 35:  	if (type.Fields.Count == 9)  		theVersion = ConfuserVersion.v17_r73404;  	else if (type.Fields.Count == 10)  		theVersion = ConfuserVersion.v17_r73430;  	else  		return false;  	break;  case 38:  	switch (CountInt32s (compileMethod' 0xFF)) {  	case 2:  		theVersion = ConfuserVersion.v17_r73477;  		break;  	case 4:  		theVersion = ConfuserVersion.v17_r73479;  		break;  	default:  		return false;  	}  	break;  case 39:  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Console::WriteLine(System.Char)")) {  		if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  			theVersion = ConfuserVersion.v17_r74021;  		else  			theVersion = ConfuserVersion.v18_r75291;  	} else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  		theVersion = ConfuserVersion.v18_r75257;  	else  		theVersion = ConfuserVersion.v18_r75288;  	break;  case 27:  	if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v18_r75402;  	else  		theVersion = ConfuserVersion.v19_r75725;  	break;  default:  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: switch (type.NestedTypes.Count) {  case 35:  	if (type.Fields.Count == 9)  		theVersion = ConfuserVersion.v17_r73404;  	else if (type.Fields.Count == 10)  		theVersion = ConfuserVersion.v17_r73430;  	else  		return false;  	break;  case 38:  	switch (CountInt32s (compileMethod' 0xFF)) {  	case 2:  		theVersion = ConfuserVersion.v17_r73477;  		break;  	case 4:  		theVersion = ConfuserVersion.v17_r73479;  		break;  	default:  		return false;  	}  	break;  case 39:  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Console::WriteLine(System.Char)")) {  		if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  			theVersion = ConfuserVersion.v17_r74021;  		else  			theVersion = ConfuserVersion.v18_r75291;  	} else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  		theVersion = ConfuserVersion.v18_r75257;  	else  		theVersion = ConfuserVersion.v18_r75288;  	break;  case 27:  	if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v18_r75402;  	else  		theVersion = ConfuserVersion.v19_r75725;  	break;  default:  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: switch (type.NestedTypes.Count) {  case 35:  	if (type.Fields.Count == 9)  		theVersion = ConfuserVersion.v17_r73404;  	else if (type.Fields.Count == 10)  		theVersion = ConfuserVersion.v17_r73430;  	else  		return false;  	break;  case 38:  	switch (CountInt32s (compileMethod' 0xFF)) {  	case 2:  		theVersion = ConfuserVersion.v17_r73477;  		break;  	case 4:  		theVersion = ConfuserVersion.v17_r73479;  		break;  	default:  		return false;  	}  	break;  case 39:  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Console::WriteLine(System.Char)")) {  		if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  			theVersion = ConfuserVersion.v17_r74021;  		else  			theVersion = ConfuserVersion.v18_r75291;  	} else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  		theVersion = ConfuserVersion.v18_r75257;  	else  		theVersion = ConfuserVersion.v18_r75288;  	break;  case 27:  	if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v18_r75402;  	else  		theVersion = ConfuserVersion.v19_r75725;  	break;  default:  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: switch (type.NestedTypes.Count) {  case 35:  	if (type.Fields.Count == 9)  		theVersion = ConfuserVersion.v17_r73404;  	else if (type.Fields.Count == 10)  		theVersion = ConfuserVersion.v17_r73430;  	else  		return false;  	break;  case 38:  	switch (CountInt32s (compileMethod' 0xFF)) {  	case 2:  		theVersion = ConfuserVersion.v17_r73477;  		break;  	case 4:  		theVersion = ConfuserVersion.v17_r73479;  		break;  	default:  		return false;  	}  	break;  case 39:  	if (!DotNetUtils.CallsMethod (initMethod' "System.Void System.Console::WriteLine(System.Char)")) {  		if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  			theVersion = ConfuserVersion.v17_r74021;  		else  			theVersion = ConfuserVersion.v18_r75291;  	} else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  		theVersion = ConfuserVersion.v18_r75257;  	else  		theVersion = ConfuserVersion.v18_r75288;  	break;  case 27:  	if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v18_r75402;  	else  		theVersion = ConfuserVersion.v19_r75725;  	break;  default:  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (type.Fields.Count == 9)  	theVersion = ConfuserVersion.v17_r73404;  else if (type.Fields.Count == 10)  	theVersion = ConfuserVersion.v17_r73430;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (type.Fields.Count == 9)  	theVersion = ConfuserVersion.v17_r73404;  else if (type.Fields.Count == 10)  	theVersion = ConfuserVersion.v17_r73430;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (type.Fields.Count == 10)  	theVersion = ConfuserVersion.v17_r73430;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: switch (CountInt32s (compileMethod' 0xFF)) {  case 2:  	theVersion = ConfuserVersion.v17_r73477;  	break;  case 4:  	theVersion = ConfuserVersion.v17_r73479;  	break;  default:  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,CheckType,The following statement contains a magic number: switch (CountInt32s (compileMethod' 0xFF)) {  case 2:  	theVersion = ConfuserVersion.v17_r73477;  	break;  case 4:  	theVersion = ConfuserVersion.v17_r73479;  	break;  default:  	return false;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindCompileMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!method.IsStatic || method.Body == null)  		continue;  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 6)  		continue;  	if (sig.RetType.GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [0].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [3].GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [4].GetFullName () != "System.Byte**")  		continue;  	if (sig.Params [5].GetFullName () != "System.UInt32*")  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindCompileMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!method.IsStatic || method.Body == null)  		continue;  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 6)  		continue;  	if (sig.RetType.GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [0].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [3].GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [4].GetFullName () != "System.Byte**")  		continue;  	if (sig.Params [5].GetFullName () != "System.UInt32*")  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindCompileMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!method.IsStatic || method.Body == null)  		continue;  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 6)  		continue;  	if (sig.RetType.GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [0].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [3].GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [4].GetFullName () != "System.Byte**")  		continue;  	if (sig.Params [5].GetFullName () != "System.UInt32*")  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindCompileMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!method.IsStatic || method.Body == null)  		continue;  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 6)  		continue;  	if (sig.RetType.GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [0].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [3].GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [4].GetFullName () != "System.Byte**")  		continue;  	if (sig.Params [5].GetFullName () != "System.UInt32*")  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindCompileMethod,The following statement contains a magic number: if (sig == null || sig.Params.Count != 6)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindCompileMethod,The following statement contains a magic number: if (sig.Params [3].GetElementType () != ElementType.U4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindCompileMethod,The following statement contains a magic number: if (sig.Params [4].GetFullName () != "System.Byte**")  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindCompileMethod,The following statement contains a magic number: if (sig.Params [5].GetFullName () != "System.UInt32*")  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: foreach (var nested in type.NestedTypes) {  	if (nested.Fields.Count != 8 && nested.Fields.Count != 10)  		continue;  	foreach (var method in nested.Methods) {  		if (method.IsStatic || method.Body == null)  			continue;  		var sig = method.MethodSig;  		if (sig == null || sig.Params.Count != 4)  			continue;  		if (sig.Params [0].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [1].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [2].GetElementType () != ElementType.U4)  			continue;  		if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: foreach (var nested in type.NestedTypes) {  	if (nested.Fields.Count != 8 && nested.Fields.Count != 10)  		continue;  	foreach (var method in nested.Methods) {  		if (method.IsStatic || method.Body == null)  			continue;  		var sig = method.MethodSig;  		if (sig == null || sig.Params.Count != 4)  			continue;  		if (sig.Params [0].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [1].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [2].GetElementType () != ElementType.U4)  			continue;  		if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: foreach (var nested in type.NestedTypes) {  	if (nested.Fields.Count != 8 && nested.Fields.Count != 10)  		continue;  	foreach (var method in nested.Methods) {  		if (method.IsStatic || method.Body == null)  			continue;  		var sig = method.MethodSig;  		if (sig == null || sig.Params.Count != 4)  			continue;  		if (sig.Params [0].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [1].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [2].GetElementType () != ElementType.U4)  			continue;  		if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: foreach (var nested in type.NestedTypes) {  	if (nested.Fields.Count != 8 && nested.Fields.Count != 10)  		continue;  	foreach (var method in nested.Methods) {  		if (method.IsStatic || method.Body == null)  			continue;  		var sig = method.MethodSig;  		if (sig == null || sig.Params.Count != 4)  			continue;  		if (sig.Params [0].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [1].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [2].GetElementType () != ElementType.U4)  			continue;  		if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: foreach (var nested in type.NestedTypes) {  	if (nested.Fields.Count != 8 && nested.Fields.Count != 10)  		continue;  	foreach (var method in nested.Methods) {  		if (method.IsStatic || method.Body == null)  			continue;  		var sig = method.MethodSig;  		if (sig == null || sig.Params.Count != 4)  			continue;  		if (sig.Params [0].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [1].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [2].GetElementType () != ElementType.U4)  			continue;  		if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: foreach (var nested in type.NestedTypes) {  	if (nested.Fields.Count != 8 && nested.Fields.Count != 10)  		continue;  	foreach (var method in nested.Methods) {  		if (method.IsStatic || method.Body == null)  			continue;  		var sig = method.MethodSig;  		if (sig == null || sig.Params.Count != 4)  			continue;  		if (sig.Params [0].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [1].GetElementType () != ElementType.I)  			continue;  		if (sig.Params [2].GetElementType () != ElementType.U4)  			continue;  		if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  			continue;  		return method;  	}  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: if (nested.Fields.Count != 8 && nested.Fields.Count != 10)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: if (nested.Fields.Count != 8 && nested.Fields.Count != 10)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: foreach (var method in nested.Methods) {  	if (method.IsStatic || method.Body == null)  		continue;  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 4)  		continue;  	if (sig.Params [0].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [1].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [2].GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: foreach (var method in nested.Methods) {  	if (method.IsStatic || method.Body == null)  		continue;  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 4)  		continue;  	if (sig.Params [0].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [1].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [2].GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: foreach (var method in nested.Methods) {  	if (method.IsStatic || method.Body == null)  		continue;  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 4)  		continue;  	if (sig.Params [0].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [1].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [2].GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: foreach (var method in nested.Methods) {  	if (method.IsStatic || method.Body == null)  		continue;  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 4)  		continue;  	if (sig.Params [0].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [1].GetElementType () != ElementType.I)  		continue;  	if (sig.Params [2].GetElementType () != ElementType.U4)  		continue;  	if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: if (sig == null || sig.Params.Count != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: if (sig.Params [2].GetElementType () != ElementType.U4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindHookConstructStr,The following statement contains a magic number: if (sig.Params [3].GetElementType () != ElementType.I && sig.Params [3].GetFullName () != "System.IntPtr&")  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: for (int index = 0; index < instrs.Count; index++) {  	index = ConfuserUtils.FindCallMethod (instrs' index' Code.Call' "System.Void System.Runtime.InteropServices.Marshal::Copy(System.Byte[]'System.Int32'System.IntPtr'System.Int32)");  	if (index < 0)  		break;  	if (index + 2 >= instrs.Count)  		continue;  	if (!instrs [index + 1].IsLdloc ())  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: for (int index = 0; index < instrs.Count; index++) {  	index = ConfuserUtils.FindCallMethod (instrs' index' Code.Call' "System.Void System.Runtime.InteropServices.Marshal::Copy(System.Byte[]'System.Int32'System.IntPtr'System.Int32)");  	if (index < 0)  		break;  	if (index + 2 >= instrs.Count)  		continue;  	if (!instrs [index + 1].IsLdloc ())  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: if (index + 2 >= instrs.Count)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: for (int i = 0; i + 4 < instrs.Count; i++) {  	int index = i;  	var ldci4_8 = instrs [index++];  	if (!ldci4_8.IsLdcI4 () || ldci4_8.GetLdcI4Value () != 8)  		continue;  	if (instrs [index++].OpCode.Code != Code.Shl)  		continue;  	if (instrs [index++].OpCode.Code != Code.Or)  		continue;  	var ldci4 = instrs [index++];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Xor)  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: for (int i = 0; i + 4 < instrs.Count; i++) {  	int index = i;  	var ldci4_8 = instrs [index++];  	if (!ldci4_8.IsLdcI4 () || ldci4_8.GetLdcI4Value () != 8)  		continue;  	if (instrs [index++].OpCode.Code != Code.Shl)  		continue;  	if (instrs [index++].OpCode.Code != Code.Or)  		continue;  	var ldci4 = instrs [index++];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Xor)  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: if (!ldci4_8.IsLdcI4 () || ldci4_8.GetLdcI4Value () != 8)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt_v17_r73404,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	var codeData = DecryptMethodData_v17_r73404 (methodsData' mdOffs + 2' (uint)key' len);  	var reader = MemoryImageStream.Create (codeData);  	var mbHeader = MethodBodyParser.ParseMethodBody (reader' out dm.code' out dm.extraSections);  	if (reader.Position != reader.Length)  		throw new ApplicationException ("Invalid method data");  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt_v17_r73404,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	var codeData = DecryptMethodData_v17_r73404 (methodsData' mdOffs + 2' (uint)key' len);  	var reader = MemoryImageStream.Create (codeData);  	var mbHeader = MethodBodyParser.ParseMethodBody (reader' out dm.code' out dm.extraSections);  	if (reader.Position != reader.Length)  		throw new ApplicationException ("Invalid method data");  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt_v17_r73404,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	var codeData = DecryptMethodData_v17_r73404 (methodsData' mdOffs + 2' (uint)key' len);  	var reader = MemoryImageStream.Create (codeData);  	var mbHeader = MethodBodyParser.ParseMethodBody (reader' out dm.code' out dm.extraSections);  	if (reader.Position != reader.Length)  		throw new ApplicationException ("Invalid method data");  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt_v17_r73404,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	var codeData = DecryptMethodData_v17_r73404 (methodsData' mdOffs + 2' (uint)key' len);  	var reader = MemoryImageStream.Create (codeData);  	var mbHeader = MethodBodyParser.ParseMethodBody (reader' out dm.code' out dm.extraSections);  	if (reader.Position != reader.Length)  		throw new ApplicationException ("Invalid method data");  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	int methodDataOffset = mdOffs + 2;  	uint[] methodData;  	byte[] codeData;  	decrypter.Decrypt (methodsData' methodDataOffset' (uint)key' len' out methodData' out codeData);  	dm.mhFlags = 0x03;  	int maxStack = (int)methodData [methodDataIndexes.maxStack];  	dm.mhMaxStack = (ushort)maxStack;  	dm.mhLocalVarSigTok = methodData [methodDataIndexes.localVarSigTok];  	if (dm.mhLocalVarSigTok != 0 && (dm.mhLocalVarSigTok >> 24) != 0x11)  		throw new ApplicationException ("Invalid local var sig token");  	int numExceptions = (int)methodData [methodDataIndexes.ehs];  	uint options = methodData [methodDataIndexes.options];  	int codeSize = (int)methodData [methodDataIndexes.codeSize];  	var codeDataReader = MemoryImageStream.Create (codeData);  	if (decrypter.IsCodeFollowedByExtraSections (options)) {  		dm.code = codeDataReader.ReadBytes (codeSize);  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  	} else {  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  		dm.code = codeDataReader.ReadBytes (codeSize);  	}  	if (codeDataReader.Position != codeDataReader.Length)  		throw new ApplicationException ("Invalid method data");  	if (dm.extraSections != null)  		dm.mhFlags |= 8;  	dm.mhCodeSize = (uint)dm.code.Length;  	// Figure out if the original method was tiny or not.  	bool isTiny = dm.code.Length <= 0x3F && dm.mhLocalVarSigTok == 0 && dm.extraSections == null && dm.mhMaxStack == 8;  	if (isTiny)  		dm.mhFlags |= 0x10;  	// Set 'init locals'  	dm.mhFlags |= (ushort)(options & 0x10);  	// copy 'init locals' bit  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	int methodDataOffset = mdOffs + 2;  	uint[] methodData;  	byte[] codeData;  	decrypter.Decrypt (methodsData' methodDataOffset' (uint)key' len' out methodData' out codeData);  	dm.mhFlags = 0x03;  	int maxStack = (int)methodData [methodDataIndexes.maxStack];  	dm.mhMaxStack = (ushort)maxStack;  	dm.mhLocalVarSigTok = methodData [methodDataIndexes.localVarSigTok];  	if (dm.mhLocalVarSigTok != 0 && (dm.mhLocalVarSigTok >> 24) != 0x11)  		throw new ApplicationException ("Invalid local var sig token");  	int numExceptions = (int)methodData [methodDataIndexes.ehs];  	uint options = methodData [methodDataIndexes.options];  	int codeSize = (int)methodData [methodDataIndexes.codeSize];  	var codeDataReader = MemoryImageStream.Create (codeData);  	if (decrypter.IsCodeFollowedByExtraSections (options)) {  		dm.code = codeDataReader.ReadBytes (codeSize);  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  	} else {  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  		dm.code = codeDataReader.ReadBytes (codeSize);  	}  	if (codeDataReader.Position != codeDataReader.Length)  		throw new ApplicationException ("Invalid method data");  	if (dm.extraSections != null)  		dm.mhFlags |= 8;  	dm.mhCodeSize = (uint)dm.code.Length;  	// Figure out if the original method was tiny or not.  	bool isTiny = dm.code.Length <= 0x3F && dm.mhLocalVarSigTok == 0 && dm.extraSections == null && dm.mhMaxStack == 8;  	if (isTiny)  		dm.mhFlags |= 0x10;  	// Set 'init locals'  	dm.mhFlags |= (ushort)(options & 0x10);  	// copy 'init locals' bit  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	int methodDataOffset = mdOffs + 2;  	uint[] methodData;  	byte[] codeData;  	decrypter.Decrypt (methodsData' methodDataOffset' (uint)key' len' out methodData' out codeData);  	dm.mhFlags = 0x03;  	int maxStack = (int)methodData [methodDataIndexes.maxStack];  	dm.mhMaxStack = (ushort)maxStack;  	dm.mhLocalVarSigTok = methodData [methodDataIndexes.localVarSigTok];  	if (dm.mhLocalVarSigTok != 0 && (dm.mhLocalVarSigTok >> 24) != 0x11)  		throw new ApplicationException ("Invalid local var sig token");  	int numExceptions = (int)methodData [methodDataIndexes.ehs];  	uint options = methodData [methodDataIndexes.options];  	int codeSize = (int)methodData [methodDataIndexes.codeSize];  	var codeDataReader = MemoryImageStream.Create (codeData);  	if (decrypter.IsCodeFollowedByExtraSections (options)) {  		dm.code = codeDataReader.ReadBytes (codeSize);  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  	} else {  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  		dm.code = codeDataReader.ReadBytes (codeSize);  	}  	if (codeDataReader.Position != codeDataReader.Length)  		throw new ApplicationException ("Invalid method data");  	if (dm.extraSections != null)  		dm.mhFlags |= 8;  	dm.mhCodeSize = (uint)dm.code.Length;  	// Figure out if the original method was tiny or not.  	bool isTiny = dm.code.Length <= 0x3F && dm.mhLocalVarSigTok == 0 && dm.extraSections == null && dm.mhMaxStack == 8;  	if (isTiny)  		dm.mhFlags |= 0x10;  	// Set 'init locals'  	dm.mhFlags |= (ushort)(options & 0x10);  	// copy 'init locals' bit  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	int methodDataOffset = mdOffs + 2;  	uint[] methodData;  	byte[] codeData;  	decrypter.Decrypt (methodsData' methodDataOffset' (uint)key' len' out methodData' out codeData);  	dm.mhFlags = 0x03;  	int maxStack = (int)methodData [methodDataIndexes.maxStack];  	dm.mhMaxStack = (ushort)maxStack;  	dm.mhLocalVarSigTok = methodData [methodDataIndexes.localVarSigTok];  	if (dm.mhLocalVarSigTok != 0 && (dm.mhLocalVarSigTok >> 24) != 0x11)  		throw new ApplicationException ("Invalid local var sig token");  	int numExceptions = (int)methodData [methodDataIndexes.ehs];  	uint options = methodData [methodDataIndexes.options];  	int codeSize = (int)methodData [methodDataIndexes.codeSize];  	var codeDataReader = MemoryImageStream.Create (codeData);  	if (decrypter.IsCodeFollowedByExtraSections (options)) {  		dm.code = codeDataReader.ReadBytes (codeSize);  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  	} else {  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  		dm.code = codeDataReader.ReadBytes (codeSize);  	}  	if (codeDataReader.Position != codeDataReader.Length)  		throw new ApplicationException ("Invalid method data");  	if (dm.extraSections != null)  		dm.mhFlags |= 8;  	dm.mhCodeSize = (uint)dm.code.Length;  	// Figure out if the original method was tiny or not.  	bool isTiny = dm.code.Length <= 0x3F && dm.mhLocalVarSigTok == 0 && dm.extraSections == null && dm.mhMaxStack == 8;  	if (isTiny)  		dm.mhFlags |= 0x10;  	// Set 'init locals'  	dm.mhFlags |= (ushort)(options & 0x10);  	// copy 'init locals' bit  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	int methodDataOffset = mdOffs + 2;  	uint[] methodData;  	byte[] codeData;  	decrypter.Decrypt (methodsData' methodDataOffset' (uint)key' len' out methodData' out codeData);  	dm.mhFlags = 0x03;  	int maxStack = (int)methodData [methodDataIndexes.maxStack];  	dm.mhMaxStack = (ushort)maxStack;  	dm.mhLocalVarSigTok = methodData [methodDataIndexes.localVarSigTok];  	if (dm.mhLocalVarSigTok != 0 && (dm.mhLocalVarSigTok >> 24) != 0x11)  		throw new ApplicationException ("Invalid local var sig token");  	int numExceptions = (int)methodData [methodDataIndexes.ehs];  	uint options = methodData [methodDataIndexes.options];  	int codeSize = (int)methodData [methodDataIndexes.codeSize];  	var codeDataReader = MemoryImageStream.Create (codeData);  	if (decrypter.IsCodeFollowedByExtraSections (options)) {  		dm.code = codeDataReader.ReadBytes (codeSize);  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  	} else {  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  		dm.code = codeDataReader.ReadBytes (codeSize);  	}  	if (codeDataReader.Position != codeDataReader.Length)  		throw new ApplicationException ("Invalid method data");  	if (dm.extraSections != null)  		dm.mhFlags |= 8;  	dm.mhCodeSize = (uint)dm.code.Length;  	// Figure out if the original method was tiny or not.  	bool isTiny = dm.code.Length <= 0x3F && dm.mhLocalVarSigTok == 0 && dm.extraSections == null && dm.mhMaxStack == 8;  	if (isTiny)  		dm.mhFlags |= 0x10;  	// Set 'init locals'  	dm.mhFlags |= (ushort)(options & 0x10);  	// copy 'init locals' bit  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	int methodDataOffset = mdOffs + 2;  	uint[] methodData;  	byte[] codeData;  	decrypter.Decrypt (methodsData' methodDataOffset' (uint)key' len' out methodData' out codeData);  	dm.mhFlags = 0x03;  	int maxStack = (int)methodData [methodDataIndexes.maxStack];  	dm.mhMaxStack = (ushort)maxStack;  	dm.mhLocalVarSigTok = methodData [methodDataIndexes.localVarSigTok];  	if (dm.mhLocalVarSigTok != 0 && (dm.mhLocalVarSigTok >> 24) != 0x11)  		throw new ApplicationException ("Invalid local var sig token");  	int numExceptions = (int)methodData [methodDataIndexes.ehs];  	uint options = methodData [methodDataIndexes.options];  	int codeSize = (int)methodData [methodDataIndexes.codeSize];  	var codeDataReader = MemoryImageStream.Create (codeData);  	if (decrypter.IsCodeFollowedByExtraSections (options)) {  		dm.code = codeDataReader.ReadBytes (codeSize);  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  	} else {  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  		dm.code = codeDataReader.ReadBytes (codeSize);  	}  	if (codeDataReader.Position != codeDataReader.Length)  		throw new ApplicationException ("Invalid method data");  	if (dm.extraSections != null)  		dm.mhFlags |= 8;  	dm.mhCodeSize = (uint)dm.code.Length;  	// Figure out if the original method was tiny or not.  	bool isTiny = dm.code.Length <= 0x3F && dm.mhLocalVarSigTok == 0 && dm.extraSections == null && dm.mhMaxStack == 8;  	if (isTiny)  		dm.mhFlags |= 0x10;  	// Set 'init locals'  	dm.mhFlags |= (ushort)(options & 0x10);  	// copy 'init locals' bit  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' rid);  	if (dm.mdRVA == 0)  		continue;  	uint bodyOffset = peImage.RvaToOffset (dm.mdRVA);  	if (!IsEncryptedMethod (fileData' (int)bodyOffset))  		continue;  	int key = BitConverter.ToInt32 (fileData' (int)bodyOffset + 6);  	int mdOffs = BitConverter.ToInt32 (fileData' (int)bodyOffset + 2) ^ key;  	int len = BitConverter.ToInt32 (fileData' (int)bodyOffset + 11) ^ ~key;  	int methodDataOffset = mdOffs + 2;  	uint[] methodData;  	byte[] codeData;  	decrypter.Decrypt (methodsData' methodDataOffset' (uint)key' len' out methodData' out codeData);  	dm.mhFlags = 0x03;  	int maxStack = (int)methodData [methodDataIndexes.maxStack];  	dm.mhMaxStack = (ushort)maxStack;  	dm.mhLocalVarSigTok = methodData [methodDataIndexes.localVarSigTok];  	if (dm.mhLocalVarSigTok != 0 && (dm.mhLocalVarSigTok >> 24) != 0x11)  		throw new ApplicationException ("Invalid local var sig token");  	int numExceptions = (int)methodData [methodDataIndexes.ehs];  	uint options = methodData [methodDataIndexes.options];  	int codeSize = (int)methodData [methodDataIndexes.codeSize];  	var codeDataReader = MemoryImageStream.Create (codeData);  	if (decrypter.IsCodeFollowedByExtraSections (options)) {  		dm.code = codeDataReader.ReadBytes (codeSize);  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  	} else {  		dm.extraSections = ReadExceptionHandlers (codeDataReader' numExceptions);  		dm.code = codeDataReader.ReadBytes (codeSize);  	}  	if (codeDataReader.Position != codeDataReader.Length)  		throw new ApplicationException ("Invalid method data");  	if (dm.extraSections != null)  		dm.mhFlags |= 8;  	dm.mhCodeSize = (uint)dm.code.Length;  	// Figure out if the original method was tiny or not.  	bool isTiny = dm.code.Length <= 0x3F && dm.mhLocalVarSigTok == 0 && dm.extraSections == null && dm.mhMaxStack == 8;  	if (isTiny)  		dm.mhFlags |= 0x10;  	// Set 'init locals'  	dm.mhFlags |= (ushort)(options & 0x10);  	// copy 'init locals' bit  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (dm.mhLocalVarSigTok != 0 && (dm.mhLocalVarSigTok >> 24) != 0x11)  	throw new ApplicationException ("Invalid local var sig token");  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (dm.extraSections != null)  	dm.mhFlags |= 8;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,Decrypt,The following statement contains a magic number: dm.mhFlags |= 8;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,IsEncryptedMethod,The following statement contains a magic number: return fileData [offset] == 0x46 && fileData [offset + 1] == 0x21 && fileData [offset + 10] == 0x20 && fileData [offset + 15] == 0x26;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,IsEncryptedMethod,The following statement contains a magic number: return fileData [offset] == 0x46 && fileData [offset + 1] == 0x21 && fileData [offset + 10] == 0x20 && fileData [offset + 15] == 0x26;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,DecryptMethodData_v17_r73404,The following statement contains a magic number: for (int i = 0; i < size; i++)  	data [i] = (byte)(fileData [offset + i] ^ kbytes [i & 3]);  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,DecryptMethodData_v17_r73404,The following statement contains a magic number: data [i] = (byte)(fileData [offset + i] ^ kbytes [i & 3]);  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,ReadUserString,The following statement contains a magic number: using (var reader = MemoryImageStream.Create (methodsData)) {  	reader.Position = (token & ~0xFF800000) + 2;  	int len = reader.ReadInt32 ();  	if ((len & 1) != 1)  		throw new ApplicationException ("Invalid string len");  	int chars = len / 2;  	var sb = new StringBuilder (chars);  	for (int i = 0; i < chars; i++)  		sb.Append ((char)(reader.ReadUInt16 () ^ key5));  	return sb.ToString ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,ReadUserString,The following statement contains a magic number: using (var reader = MemoryImageStream.Create (methodsData)) {  	reader.Position = (token & ~0xFF800000) + 2;  	int len = reader.ReadInt32 ();  	if ((len & 1) != 1)  		throw new ApplicationException ("Invalid string len");  	int chars = len / 2;  	var sb = new StringBuilder (chars);  	for (int i = 0; i < chars; i++)  		sb.Append ((char)(reader.ReadUInt16 () ^ key5));  	return sb.ToString ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,ReadUserString,The following statement contains a magic number: reader.Position = (token & ~0xFF800000) + 2;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73404;  	return true;  case ConfuserVersion.v17_r73430:  	minRev = 73430;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73822;  	return true;  case ConfuserVersion.v17_r74021:  	minRev = 74021;  	maxRev = 75184;  	return true;  case ConfuserVersion.v18_r75257:  	minRev = 75257;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75288;  	return true;  case ConfuserVersion.v18_r75291:  	minRev = 75291;  	maxRev = 75369;  	return true;  case ConfuserVersion.v18_r75402:  	minRev = 75402;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73404;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73404;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73430;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73430;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73477;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73477;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73479;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73822;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 74021;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75184;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75257;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75267;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75288;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75288;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75291;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75369;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75402;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75720;  
Magic Number,de4dot.code.deobfuscators.Confuser,JitMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\JitMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75725;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (type.Methods.Count != 3)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (!DotNetUtils.HasString (initMethod' "Module error"))  	version = ConfuserVersion.v14_r57884;  else if (virtProtect.IsPrivate && callsFileStreamCtor) {  	int calls = ConfuserUtils.CountCalls (initMethod' "System.Void System.Buffer::BlockCopy(System.Array'System.Int32'System.Array'System.Int32'System.Int32)");  	if (calls <= 1)  		version = ConfuserVersion.v14_r58564;  	else if (calls == 2)  		version = ConfuserVersion.v14_r58852;  	else if (calls == 4)  		version = ConfuserVersion.v15_r59014;  	else  		return false;  } else if (callsFileStreamCtor)  	version = ConfuserVersion.v14_r58004;  else if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.Object::GetHashCode()")) {  	if (DotNetUtils.HasString (initMethod' "<Unknown>"))  		version = ConfuserVersion.v17_r72989;  	else  		version = ConfuserVersion.v16_r71742;  } else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  	version = ConfuserVersion.v17_r73605;  else if (DotNetUtils.HasString (initMethod' "<Unknown>"))  	version = ConfuserVersion.v18_r75288;  else  	version = ConfuserVersion.v19_r75725;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (!DotNetUtils.HasString (initMethod' "Module error"))  	version = ConfuserVersion.v14_r57884;  else if (virtProtect.IsPrivate && callsFileStreamCtor) {  	int calls = ConfuserUtils.CountCalls (initMethod' "System.Void System.Buffer::BlockCopy(System.Array'System.Int32'System.Array'System.Int32'System.Int32)");  	if (calls <= 1)  		version = ConfuserVersion.v14_r58564;  	else if (calls == 2)  		version = ConfuserVersion.v14_r58852;  	else if (calls == 4)  		version = ConfuserVersion.v15_r59014;  	else  		return false;  } else if (callsFileStreamCtor)  	version = ConfuserVersion.v14_r58004;  else if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.Object::GetHashCode()")) {  	if (DotNetUtils.HasString (initMethod' "<Unknown>"))  		version = ConfuserVersion.v17_r72989;  	else  		version = ConfuserVersion.v16_r71742;  } else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  	version = ConfuserVersion.v17_r73605;  else if (DotNetUtils.HasString (initMethod' "<Unknown>"))  	version = ConfuserVersion.v18_r75288;  else  	version = ConfuserVersion.v19_r75725;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (virtProtect.IsPrivate && callsFileStreamCtor) {  	int calls = ConfuserUtils.CountCalls (initMethod' "System.Void System.Buffer::BlockCopy(System.Array'System.Int32'System.Array'System.Int32'System.Int32)");  	if (calls <= 1)  		version = ConfuserVersion.v14_r58564;  	else if (calls == 2)  		version = ConfuserVersion.v14_r58852;  	else if (calls == 4)  		version = ConfuserVersion.v15_r59014;  	else  		return false;  } else if (callsFileStreamCtor)  	version = ConfuserVersion.v14_r58004;  else if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.Object::GetHashCode()")) {  	if (DotNetUtils.HasString (initMethod' "<Unknown>"))  		version = ConfuserVersion.v17_r72989;  	else  		version = ConfuserVersion.v16_r71742;  } else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  	version = ConfuserVersion.v17_r73605;  else if (DotNetUtils.HasString (initMethod' "<Unknown>"))  	version = ConfuserVersion.v18_r75288;  else  	version = ConfuserVersion.v19_r75725;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (virtProtect.IsPrivate && callsFileStreamCtor) {  	int calls = ConfuserUtils.CountCalls (initMethod' "System.Void System.Buffer::BlockCopy(System.Array'System.Int32'System.Array'System.Int32'System.Int32)");  	if (calls <= 1)  		version = ConfuserVersion.v14_r58564;  	else if (calls == 2)  		version = ConfuserVersion.v14_r58852;  	else if (calls == 4)  		version = ConfuserVersion.v15_r59014;  	else  		return false;  } else if (callsFileStreamCtor)  	version = ConfuserVersion.v14_r58004;  else if (DotNetUtils.CallsMethod (initMethod' "System.Int32 System.Object::GetHashCode()")) {  	if (DotNetUtils.HasString (initMethod' "<Unknown>"))  		version = ConfuserVersion.v17_r72989;  	else  		version = ConfuserVersion.v16_r71742;  } else if (DotNetUtils.CallsMethod (decryptMethod' "System.Security.Cryptography.Rijndael System.Security.Cryptography.Rijndael::Create()"))  	version = ConfuserVersion.v17_r73605;  else if (DotNetUtils.HasString (initMethod' "<Unknown>"))  	version = ConfuserVersion.v18_r75288;  else  	version = ConfuserVersion.v19_r75725;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (calls <= 1)  	version = ConfuserVersion.v14_r58564;  else if (calls == 2)  	version = ConfuserVersion.v14_r58852;  else if (calls == 4)  	version = ConfuserVersion.v15_r59014;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (calls <= 1)  	version = ConfuserVersion.v14_r58564;  else if (calls == 2)  	version = ConfuserVersion.v14_r58852;  else if (calls == 4)  	version = ConfuserVersion.v15_r59014;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (calls == 2)  	version = ConfuserVersion.v14_r58852;  else if (calls == 4)  	version = ConfuserVersion.v15_r59014;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (calls == 2)  	version = ConfuserVersion.v14_r58852;  else if (calls == 4)  	version = ConfuserVersion.v15_r59014;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,CheckType,The following statement contains a magic number: if (calls == 4)  	version = ConfuserVersion.v15_r59014;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	if (i >= 2) {  		if (instrs [i - 2].OpCode.Code == Code.Pop)  			continue;  	}  	if (i + 4 >= instrs.Count)  		break;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) != stloc.GetLocal (method.Body.Variables))  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	if (i >= 2) {  		if (instrs [i - 2].OpCode.Code == Code.Pop)  			continue;  	}  	if (i + 4 >= instrs.Count)  		break;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) != stloc.GetLocal (method.Body.Variables))  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	if (i >= 2) {  		if (instrs [i - 2].OpCode.Code == Code.Pop)  			continue;  	}  	if (i + 4 >= instrs.Count)  		break;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) != stloc.GetLocal (method.Body.Variables))  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	if (i >= 2) {  		if (instrs [i - 2].OpCode.Code == Code.Pop)  			continue;  	}  	if (i + 4 >= instrs.Count)  		break;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) != stloc.GetLocal (method.Body.Variables))  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	if (i >= 2) {  		if (instrs [i - 2].OpCode.Code == Code.Pop)  			continue;  	}  	if (i + 4 >= instrs.Count)  		break;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) != stloc.GetLocal (method.Body.Variables))  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	if (i >= 2) {  		if (instrs [i - 2].OpCode.Code == Code.Pop)  			continue;  	}  	if (i + 4 >= instrs.Count)  		break;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) != stloc.GetLocal (method.Body.Variables))  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: if (i >= 2) {  	if (instrs [i - 2].OpCode.Code == Code.Pop)  		continue;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: if (i >= 2) {  	if (instrs [i - 2].OpCode.Code == Code.Pop)  		continue;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: if (instrs [i - 2].OpCode.Code == Code.Pop)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: if (i + 4 >= instrs.Count)  	break;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey4,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.BinaryReader::ReadInt32()");  	if (index2 < 0)  		break;  	if (index2 - i != 6)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) == stloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.BinaryReader::ReadInt32()");  	if (index2 < 0)  		break;  	if (index2 - i != 6)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) == stloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.BinaryReader::ReadInt32()");  	if (index2 < 0)  		break;  	if (index2 - i != 6)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) == stloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.BinaryReader::ReadInt32()");  	if (index2 < 0)  		break;  	if (index2 - i != 6)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) == stloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.BinaryReader::ReadInt32()");  	if (index2 < 0)  		break;  	if (index2 - i != 6)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	var stloc = instrs [i + 3];  	if (!stloc.IsStloc ())  		continue;  	var ldloc = instrs [i + 4];  	if (!ldloc.IsLdloc ())  		continue;  	if (ldloc.GetLocal (method.Body.Variables) == stloc.GetLocal (method.Body.Variables))  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: if (index2 - i != 6)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,FindKey5,The following statement contains a magic number: if (!instrs [i + 5].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,DecryptMethodsData_v14_r57884,The following statement contains a magic number: Array.Clear (md5SumData' csOffs' 4);  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r57884:  	minRev = 57884;  	maxRev = 57884;  	return true;  case ConfuserVersion.v14_r58004:  	minRev = 58004;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 58919;  	return true;  case ConfuserVersion.v15_r59014:  	minRev = 59014;  	maxRev = 70489;  	return true;  case ConfuserVersion.v16_r71742:  	minRev = 71742;  	maxRev = 72868;  	return true;  case ConfuserVersion.v17_r72989:  	minRev = 72989;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73605:  	minRev = 73605;  	maxRev = 75267;  	return true;  case ConfuserVersion.v18_r75288:  	minRev = 75288;  	maxRev = 75720;  	return true;  case ConfuserVersion.v19_r75725:  	minRev = 75725;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 57884;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 57884;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58004;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58446;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58564;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58817;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58852;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58919;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 59014;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 70489;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 71742;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 72868;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 72989;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 72989;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73605;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75267;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75288;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75720;  
Magic Number,de4dot.code.deobfuscators.Confuser,MemoryMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MemoryMethodsDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75725;  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindKey0_v16_r71742,The following statement contains a magic number: for (int i = 0; i + 5 < instrs.Count; i++) {  	i = FindCallvirtReadUInt32 (instrs' i);  	if (i < 0)  		break;  	int index = i + 1;  	var ldci4_1 = instrs [index++];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [index++].IsStloc ())  		continue;  	if (!instrs [index++].IsLdloc ())  		continue;  	var ldci4_2 = instrs [index++];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (ldci4_1.GetLdcI4Value () != ldci4_2.GetLdcI4Value ())  		continue;  	key = (uint)ldci4_1.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindKey0_v14_r58564,The following statement contains a magic number: for (int i = 0; i + 5 < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.BinaryReader::ReadInt32()");  	if (i < 0)  		break;  	int index = i + 1;  	var ldci4_1 = instrs [index++];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [index++].IsStloc ())  		continue;  	if (!instrs [index++].IsLdloc ())  		continue;  	var ldci4_2 = instrs [index++];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (ldci4_2.GetLdcI4Value () != 0 && ldci4_1.GetLdcI4Value () != ldci4_2.GetLdcI4Value ())  		continue;  	key = (uint)ldci4_1.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,CheckCallvirtReadUInt32,The following statement contains a magic number: if (index + 2 >= instrs.Count)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,CheckCallvirtReadUInt32,The following statement contains a magic number: if (!instrs [index + 2].IsStloc () && instrs [index + 2].OpCode.Code != Code.Pop)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,CheckCallvirtReadUInt32,The following statement contains a magic number: if (!instrs [index + 2].IsStloc () && instrs [index + 2].OpCode.Code != Code.Pop)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,CheckCallvirtReadUInt32,The following statement contains a magic number: index += 3;  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindKey2OrKey3,The following statement contains a magic number: if (index + 6 >= instrs.Count)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,FindKey6,The following statement contains a magic number: for (int i = 0; i + 4 < instrs.Count; i++) {  	int index = i;  	if (!instrs [index++].IsLdloc ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Sub)  		continue;  	if (instrs [index++].OpCode.Code != Code.Ldelem_U1)  		continue;  	var ldci4 = instrs [index++];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Xor)  		continue;  	if (instrs [index++].OpCode.Code != Code.Conv_U1)  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,CalcChecksum,The following statement contains a magic number: return BitConverter.ToUInt64 (sum' 0) ^ BitConverter.ToUInt64 (sum' 8);  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < decrypted.Length; i += 64) {  	int j;  	for (j = 0; j < 64 && i + j < decrypted.Length; j++)  		decrypted [i + j] ^= (byte)(hash [j] ^ key6);  	hash = sha.ComputeHash (decrypted' i' j);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < decrypted.Length; i += 64) {  	int j;  	for (j = 0; j < 64 && i + j < decrypted.Length; j++)  		decrypted [i + j] ^= (byte)(hash [j] ^ key6);  	hash = sha.ComputeHash (decrypted' i' j);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,Decrypt,The following statement contains a magic number: i += 64
Magic Number,de4dot.code.deobfuscators.Confuser,MethodsDecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\MethodsDecrypterBase.cs,Decrypt,The following statement contains a magic number: for (j = 0; j < 64 && i + j < decrypted.Length; j++)  	decrypted [i + j] ^= (byte)(hash [j] ^ key6);  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetCallInfo_v10_r48717,The following statement contains a magic number: if (offs + 2 > info.field.Name.String.Length) {  	calledMethod = null;  	callOpcode = OpCodes.Call;  	return;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetCallInfo_v10_r48717,The following statement contains a magic number: if (table != 0 && table != 6 && table != 0x0A && table != 0x2B)  	throw new ApplicationException ("Invalid method token");  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetCallInfo_v10_r48717,The following statement contains a magic number: if (isNew || info.field.Name.String [0] == (char)1 || table != 0x06)  	calledMethod = module.ResolveToken (token) as IMethod;  else {  	var asmRef = module.ResolveAssemblyRef ((uint)info.field.Name.String [0] - 2 + 1);  	calledMethod = CreateMethodReference (asmRef' token);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetCallInfo_v14_r58857,The following statement contains a magic number: if (table != 6 && table != 0x0A && table != 0x2B)  	throw new ApplicationException ("Invalid method token");  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Extract_v17_r73740,The following statement contains a magic number: switch (creatorInfo.proxyCreatorType) {  case ProxyCreatorType.CallOrCallvirt:  	arg = BitConverter.ToUInt32 (nameInfo' 1);  	table = (uint)(nameInfo [0] & 0x7F) << 24;  	isCallvirt = (nameInfo [0] & 0x80) != 0;  	break;  case ProxyCreatorType.Newobj:  	arg = BitConverter.ToUInt32 (nameInfo' 0);  	table = (uint)nameInfo [4] << 24;  	isCallvirt = false;  	break;  default:  	throw new ApplicationException ("Invalid creator type");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Extract_v17_r73740,The following statement contains a magic number: switch (creatorInfo.proxyCreatorType) {  case ProxyCreatorType.CallOrCallvirt:  	arg = BitConverter.ToUInt32 (nameInfo' 1);  	table = (uint)(nameInfo [0] & 0x7F) << 24;  	isCallvirt = (nameInfo [0] & 0x80) != 0;  	break;  case ProxyCreatorType.Newobj:  	arg = BitConverter.ToUInt32 (nameInfo' 0);  	table = (uint)nameInfo [4] << 24;  	isCallvirt = false;  	break;  default:  	throw new ApplicationException ("Invalid creator type");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Extract_v17_r73740,The following statement contains a magic number: switch (creatorInfo.proxyCreatorType) {  case ProxyCreatorType.CallOrCallvirt:  	arg = BitConverter.ToUInt32 (nameInfo' 1);  	table = (uint)(nameInfo [0] & 0x7F) << 24;  	isCallvirt = (nameInfo [0] & 0x80) != 0;  	break;  case ProxyCreatorType.Newobj:  	arg = BitConverter.ToUInt32 (nameInfo' 0);  	table = (uint)nameInfo [4] << 24;  	isCallvirt = false;  	break;  default:  	throw new ApplicationException ("Invalid creator type");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Extract_v17_r73740,The following statement contains a magic number: table = (uint)(nameInfo [0] & 0x7F) << 24;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Extract_v17_r73740,The following statement contains a magic number: table = (uint)nameInfo [4] << 24;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Extract_v17_r73740,The following statement contains a magic number: table = (uint)nameInfo [4] << 24;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetCallInfo_v18_r75367,The following statement contains a magic number: if (table != 6 && table != 0x0A && table != 0x2B)  	throw new ApplicationException ("Invalid method token");  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (method.Body == null || !method.IsStatic || !method.IsAssembly)  		continue;  	ConfuserVersion theVersion = ConfuserVersion.Unknown;  	if (DotNetUtils.IsMethod (method' "System.Void"' "(System.String'System.RuntimeFieldHandle)"))  		theVersion = ConfuserVersion.v10_r42915;  	else if (DotNetUtils.IsMethod (method' "System.Void"' "(System.RuntimeFieldHandle)"))  		theVersion = ConfuserVersion.v10_r48717;  	else  		continue;  	int tmpVer;  	var proxyType = GetProxyCreatorType (method' simpleDeobfuscator' out tmpVer);  	if (proxyType == ProxyCreatorType.None)  		continue;  	if (proxyType == ProxyCreatorType.Newobj)  		foundNewobjProxy = true;  	simpleDeobfuscator.Deobfuscate (method' SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);  	MethodDef nativeMethod = null;  	uint magic;  	if (FindMagic_v14_r58564 (method' out magic)) {  		if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)")) {  			if (!IsMethodCreator_v14_r58802 (method' proxyType))  				theVersion = ConfuserVersion.v14_r58564;  			else  				theVersion = ConfuserVersion.v14_r58802;  		} else if (DotNetUtils.CallsMethod (method' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"))  			theVersion = ConfuserVersion.v17_r73479;  		else if (proxyType != ProxyCreatorType.CallOrCallvirt || !HasFieldReference (method' "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Castclass"))  			theVersion = ConfuserVersion.v14_r58857;  		else if (proxyType == ProxyCreatorType.CallOrCallvirt && DotNetUtils.CallsMethod (method' "System.Void System.Reflection.Emit.DynamicMethod::.ctor(System.String'System.Type'System.Type[]'System.Boolean)"))  			theVersion = ConfuserVersion.v16_r66631;  		else if (proxyType == ProxyCreatorType.CallOrCallvirt)  			theVersion = ConfuserVersion.v16_r70489;  	} else if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)") && DotNetUtils.CallsMethod (method' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) {  		if (proxyType == ProxyCreatorType.CallOrCallvirt && !FindCallvirtChar (method' out callvirtChar))  			continue;  		if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  			theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  		else if (FindMagic_v18_r75367 (method' out magic))  			theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  		else if (FindMagic_v19_r76101 (method' out magic))  			CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  		else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  			CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  		else {  			if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  				theVersion = ConfuserVersion.v11_r50378;  			int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  			if (numCalls == 2)  				theVersion = ConfuserVersion.v12_r54564;  			if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  				theVersion = ConfuserVersion.v13_r55346;  			if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  				theVersion = ConfuserVersion.v13_r55604;  		}  	} else if (Is_v17_r73740 (method)) {  		if (DotNetUtils.CallsMethod (method' "System.Boolean System.Type::get_IsArray()")) {  			if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  				theVersion = ConfuserVersion.v17_r74708_native;  			else if (FindMagic_v17_r73740 (method' out magic))  				theVersion = ConfuserVersion.v17_r74708_normal;  			else  				continue;  		} else {  			if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  				theVersion = ConfuserVersion.v17_r73740_native;  			else if (FindMagic_v17_r73740 (method' out magic))  				theVersion = ConfuserVersion.v17_r73740_normal;  			else  				continue;  		}  	} else if (theVersion == ConfuserVersion.v10_r42915) {  		if (DeobUtils.HasInteger (method' 0x06000000))  			theVersion = ConfuserVersion.v10_r42919;  	}  	SetDelegateCreatorMethod (method);  	methodToInfo.Add (method' new ProxyCreatorInfo (method' proxyType' theVersion' magic' nativeMethod' callvirtChar));  	version = (ConfuserVersion)Math.Max ((int)version' (int)theVersion);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (method.Body == null || !method.IsStatic || !method.IsAssembly)  		continue;  	ConfuserVersion theVersion = ConfuserVersion.Unknown;  	if (DotNetUtils.IsMethod (method' "System.Void"' "(System.String'System.RuntimeFieldHandle)"))  		theVersion = ConfuserVersion.v10_r42915;  	else if (DotNetUtils.IsMethod (method' "System.Void"' "(System.RuntimeFieldHandle)"))  		theVersion = ConfuserVersion.v10_r48717;  	else  		continue;  	int tmpVer;  	var proxyType = GetProxyCreatorType (method' simpleDeobfuscator' out tmpVer);  	if (proxyType == ProxyCreatorType.None)  		continue;  	if (proxyType == ProxyCreatorType.Newobj)  		foundNewobjProxy = true;  	simpleDeobfuscator.Deobfuscate (method' SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);  	MethodDef nativeMethod = null;  	uint magic;  	if (FindMagic_v14_r58564 (method' out magic)) {  		if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)")) {  			if (!IsMethodCreator_v14_r58802 (method' proxyType))  				theVersion = ConfuserVersion.v14_r58564;  			else  				theVersion = ConfuserVersion.v14_r58802;  		} else if (DotNetUtils.CallsMethod (method' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"))  			theVersion = ConfuserVersion.v17_r73479;  		else if (proxyType != ProxyCreatorType.CallOrCallvirt || !HasFieldReference (method' "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Castclass"))  			theVersion = ConfuserVersion.v14_r58857;  		else if (proxyType == ProxyCreatorType.CallOrCallvirt && DotNetUtils.CallsMethod (method' "System.Void System.Reflection.Emit.DynamicMethod::.ctor(System.String'System.Type'System.Type[]'System.Boolean)"))  			theVersion = ConfuserVersion.v16_r66631;  		else if (proxyType == ProxyCreatorType.CallOrCallvirt)  			theVersion = ConfuserVersion.v16_r70489;  	} else if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)") && DotNetUtils.CallsMethod (method' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) {  		if (proxyType == ProxyCreatorType.CallOrCallvirt && !FindCallvirtChar (method' out callvirtChar))  			continue;  		if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  			theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  		else if (FindMagic_v18_r75367 (method' out magic))  			theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  		else if (FindMagic_v19_r76101 (method' out magic))  			CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  		else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  			CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  		else {  			if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  				theVersion = ConfuserVersion.v11_r50378;  			int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  			if (numCalls == 2)  				theVersion = ConfuserVersion.v12_r54564;  			if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  				theVersion = ConfuserVersion.v13_r55346;  			if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  				theVersion = ConfuserVersion.v13_r55604;  		}  	} else if (Is_v17_r73740 (method)) {  		if (DotNetUtils.CallsMethod (method' "System.Boolean System.Type::get_IsArray()")) {  			if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  				theVersion = ConfuserVersion.v17_r74708_native;  			else if (FindMagic_v17_r73740 (method' out magic))  				theVersion = ConfuserVersion.v17_r74708_normal;  			else  				continue;  		} else {  			if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  				theVersion = ConfuserVersion.v17_r73740_native;  			else if (FindMagic_v17_r73740 (method' out magic))  				theVersion = ConfuserVersion.v17_r73740_normal;  			else  				continue;  		}  	} else if (theVersion == ConfuserVersion.v10_r42915) {  		if (DeobUtils.HasInteger (method' 0x06000000))  			theVersion = ConfuserVersion.v10_r42919;  	}  	SetDelegateCreatorMethod (method);  	methodToInfo.Add (method' new ProxyCreatorInfo (method' proxyType' theVersion' magic' nativeMethod' callvirtChar));  	version = (ConfuserVersion)Math.Max ((int)version' (int)theVersion);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (method.Body == null || !method.IsStatic || !method.IsAssembly)  		continue;  	ConfuserVersion theVersion = ConfuserVersion.Unknown;  	if (DotNetUtils.IsMethod (method' "System.Void"' "(System.String'System.RuntimeFieldHandle)"))  		theVersion = ConfuserVersion.v10_r42915;  	else if (DotNetUtils.IsMethod (method' "System.Void"' "(System.RuntimeFieldHandle)"))  		theVersion = ConfuserVersion.v10_r48717;  	else  		continue;  	int tmpVer;  	var proxyType = GetProxyCreatorType (method' simpleDeobfuscator' out tmpVer);  	if (proxyType == ProxyCreatorType.None)  		continue;  	if (proxyType == ProxyCreatorType.Newobj)  		foundNewobjProxy = true;  	simpleDeobfuscator.Deobfuscate (method' SimpleDeobfuscatorFlags.DisableConstantsFolderExtraInstrs);  	MethodDef nativeMethod = null;  	uint magic;  	if (FindMagic_v14_r58564 (method' out magic)) {  		if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)")) {  			if (!IsMethodCreator_v14_r58802 (method' proxyType))  				theVersion = ConfuserVersion.v14_r58564;  			else  				theVersion = ConfuserVersion.v14_r58802;  		} else if (DotNetUtils.CallsMethod (method' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"))  			theVersion = ConfuserVersion.v17_r73479;  		else if (proxyType != ProxyCreatorType.CallOrCallvirt || !HasFieldReference (method' "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Castclass"))  			theVersion = ConfuserVersion.v14_r58857;  		else if (proxyType == ProxyCreatorType.CallOrCallvirt && DotNetUtils.CallsMethod (method' "System.Void System.Reflection.Emit.DynamicMethod::.ctor(System.String'System.Type'System.Type[]'System.Boolean)"))  			theVersion = ConfuserVersion.v16_r66631;  		else if (proxyType == ProxyCreatorType.CallOrCallvirt)  			theVersion = ConfuserVersion.v16_r70489;  	} else if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)") && DotNetUtils.CallsMethod (method' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) {  		if (proxyType == ProxyCreatorType.CallOrCallvirt && !FindCallvirtChar (method' out callvirtChar))  			continue;  		if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  			theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  		else if (FindMagic_v18_r75367 (method' out magic))  			theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  		else if (FindMagic_v19_r76101 (method' out magic))  			CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  		else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  			CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  		else {  			if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  				theVersion = ConfuserVersion.v11_r50378;  			int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  			if (numCalls == 2)  				theVersion = ConfuserVersion.v12_r54564;  			if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  				theVersion = ConfuserVersion.v13_r55346;  			if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  				theVersion = ConfuserVersion.v13_r55604;  		}  	} else if (Is_v17_r73740 (method)) {  		if (DotNetUtils.CallsMethod (method' "System.Boolean System.Type::get_IsArray()")) {  			if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  				theVersion = ConfuserVersion.v17_r74708_native;  			else if (FindMagic_v17_r73740 (method' out magic))  				theVersion = ConfuserVersion.v17_r74708_normal;  			else  				continue;  		} else {  			if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  				theVersion = ConfuserVersion.v17_r73740_native;  			else if (FindMagic_v17_r73740 (method' out magic))  				theVersion = ConfuserVersion.v17_r73740_normal;  			else  				continue;  		}  	} else if (theVersion == ConfuserVersion.v10_r42915) {  		if (DeobUtils.HasInteger (method' 0x06000000))  			theVersion = ConfuserVersion.v10_r42919;  	}  	SetDelegateCreatorMethod (method);  	methodToInfo.Add (method' new ProxyCreatorInfo (method' proxyType' theVersion' magic' nativeMethod' callvirtChar));  	version = (ConfuserVersion)Math.Max ((int)version' (int)theVersion);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if (FindMagic_v14_r58564 (method' out magic)) {  	if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)")) {  		if (!IsMethodCreator_v14_r58802 (method' proxyType))  			theVersion = ConfuserVersion.v14_r58564;  		else  			theVersion = ConfuserVersion.v14_r58802;  	} else if (DotNetUtils.CallsMethod (method' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"))  		theVersion = ConfuserVersion.v17_r73479;  	else if (proxyType != ProxyCreatorType.CallOrCallvirt || !HasFieldReference (method' "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Castclass"))  		theVersion = ConfuserVersion.v14_r58857;  	else if (proxyType == ProxyCreatorType.CallOrCallvirt && DotNetUtils.CallsMethod (method' "System.Void System.Reflection.Emit.DynamicMethod::.ctor(System.String'System.Type'System.Type[]'System.Boolean)"))  		theVersion = ConfuserVersion.v16_r66631;  	else if (proxyType == ProxyCreatorType.CallOrCallvirt)  		theVersion = ConfuserVersion.v16_r70489;  } else if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)") && DotNetUtils.CallsMethod (method' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !FindCallvirtChar (method' out callvirtChar))  		continue;  	if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  	else if (FindMagic_v18_r75367 (method' out magic))  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  	else if (FindMagic_v19_r76101 (method' out magic))  		CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  	else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  		CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  	else {  		if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  			theVersion = ConfuserVersion.v11_r50378;  		int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  		if (numCalls == 2)  			theVersion = ConfuserVersion.v12_r54564;  		if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  			theVersion = ConfuserVersion.v13_r55346;  		if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  			theVersion = ConfuserVersion.v13_r55604;  	}  } else if (Is_v17_r73740 (method)) {  	if (DotNetUtils.CallsMethod (method' "System.Boolean System.Type::get_IsArray()")) {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r74708_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r74708_normal;  		else  			continue;  	} else {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r73740_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r73740_normal;  		else  			continue;  	}  } else if (theVersion == ConfuserVersion.v10_r42915) {  	if (DeobUtils.HasInteger (method' 0x06000000))  		theVersion = ConfuserVersion.v10_r42919;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if (FindMagic_v14_r58564 (method' out magic)) {  	if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)")) {  		if (!IsMethodCreator_v14_r58802 (method' proxyType))  			theVersion = ConfuserVersion.v14_r58564;  		else  			theVersion = ConfuserVersion.v14_r58802;  	} else if (DotNetUtils.CallsMethod (method' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"))  		theVersion = ConfuserVersion.v17_r73479;  	else if (proxyType != ProxyCreatorType.CallOrCallvirt || !HasFieldReference (method' "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Castclass"))  		theVersion = ConfuserVersion.v14_r58857;  	else if (proxyType == ProxyCreatorType.CallOrCallvirt && DotNetUtils.CallsMethod (method' "System.Void System.Reflection.Emit.DynamicMethod::.ctor(System.String'System.Type'System.Type[]'System.Boolean)"))  		theVersion = ConfuserVersion.v16_r66631;  	else if (proxyType == ProxyCreatorType.CallOrCallvirt)  		theVersion = ConfuserVersion.v16_r70489;  } else if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)") && DotNetUtils.CallsMethod (method' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !FindCallvirtChar (method' out callvirtChar))  		continue;  	if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  	else if (FindMagic_v18_r75367 (method' out magic))  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  	else if (FindMagic_v19_r76101 (method' out magic))  		CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  	else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  		CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  	else {  		if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  			theVersion = ConfuserVersion.v11_r50378;  		int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  		if (numCalls == 2)  			theVersion = ConfuserVersion.v12_r54564;  		if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  			theVersion = ConfuserVersion.v13_r55346;  		if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  			theVersion = ConfuserVersion.v13_r55604;  	}  } else if (Is_v17_r73740 (method)) {  	if (DotNetUtils.CallsMethod (method' "System.Boolean System.Type::get_IsArray()")) {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r74708_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r74708_normal;  		else  			continue;  	} else {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r73740_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r73740_normal;  		else  			continue;  	}  } else if (theVersion == ConfuserVersion.v10_r42915) {  	if (DeobUtils.HasInteger (method' 0x06000000))  		theVersion = ConfuserVersion.v10_r42919;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if (FindMagic_v14_r58564 (method' out magic)) {  	if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)")) {  		if (!IsMethodCreator_v14_r58802 (method' proxyType))  			theVersion = ConfuserVersion.v14_r58564;  		else  			theVersion = ConfuserVersion.v14_r58802;  	} else if (DotNetUtils.CallsMethod (method' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()"))  		theVersion = ConfuserVersion.v17_r73479;  	else if (proxyType != ProxyCreatorType.CallOrCallvirt || !HasFieldReference (method' "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Castclass"))  		theVersion = ConfuserVersion.v14_r58857;  	else if (proxyType == ProxyCreatorType.CallOrCallvirt && DotNetUtils.CallsMethod (method' "System.Void System.Reflection.Emit.DynamicMethod::.ctor(System.String'System.Type'System.Type[]'System.Boolean)"))  		theVersion = ConfuserVersion.v16_r66631;  	else if (proxyType == ProxyCreatorType.CallOrCallvirt)  		theVersion = ConfuserVersion.v16_r70489;  } else if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)") && DotNetUtils.CallsMethod (method' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !FindCallvirtChar (method' out callvirtChar))  		continue;  	if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  	else if (FindMagic_v18_r75367 (method' out magic))  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  	else if (FindMagic_v19_r76101 (method' out magic))  		CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  	else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  		CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  	else {  		if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  			theVersion = ConfuserVersion.v11_r50378;  		int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  		if (numCalls == 2)  			theVersion = ConfuserVersion.v12_r54564;  		if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  			theVersion = ConfuserVersion.v13_r55346;  		if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  			theVersion = ConfuserVersion.v13_r55604;  	}  } else if (Is_v17_r73740 (method)) {  	if (DotNetUtils.CallsMethod (method' "System.Boolean System.Type::get_IsArray()")) {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r74708_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r74708_normal;  		else  			continue;  	} else {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r73740_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r73740_normal;  		else  			continue;  	}  } else if (theVersion == ConfuserVersion.v10_r42915) {  	if (DeobUtils.HasInteger (method' 0x06000000))  		theVersion = ConfuserVersion.v10_r42919;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)") && DotNetUtils.CallsMethod (method' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !FindCallvirtChar (method' out callvirtChar))  		continue;  	if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  	else if (FindMagic_v18_r75367 (method' out magic))  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  	else if (FindMagic_v19_r76101 (method' out magic))  		CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  	else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  		CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  	else {  		if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  			theVersion = ConfuserVersion.v11_r50378;  		int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  		if (numCalls == 2)  			theVersion = ConfuserVersion.v12_r54564;  		if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  			theVersion = ConfuserVersion.v13_r55346;  		if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  			theVersion = ConfuserVersion.v13_r55604;  	}  } else if (Is_v17_r73740 (method)) {  	if (DotNetUtils.CallsMethod (method' "System.Boolean System.Type::get_IsArray()")) {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r74708_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r74708_normal;  		else  			continue;  	} else {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r73740_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r73740_normal;  		else  			continue;  	}  } else if (theVersion == ConfuserVersion.v10_r42915) {  	if (DeobUtils.HasInteger (method' 0x06000000))  		theVersion = ConfuserVersion.v10_r42919;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)") && DotNetUtils.CallsMethod (method' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !FindCallvirtChar (method' out callvirtChar))  		continue;  	if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  	else if (FindMagic_v18_r75367 (method' out magic))  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  	else if (FindMagic_v19_r76101 (method' out magic))  		CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  	else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  		CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  	else {  		if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  			theVersion = ConfuserVersion.v11_r50378;  		int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  		if (numCalls == 2)  			theVersion = ConfuserVersion.v12_r54564;  		if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  			theVersion = ConfuserVersion.v13_r55346;  		if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  			theVersion = ConfuserVersion.v13_r55604;  	}  } else if (Is_v17_r73740 (method)) {  	if (DotNetUtils.CallsMethod (method' "System.Boolean System.Type::get_IsArray()")) {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r74708_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r74708_normal;  		else  			continue;  	} else {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r73740_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r73740_normal;  		else  			continue;  	}  } else if (theVersion == ConfuserVersion.v10_r42915) {  	if (DeobUtils.HasInteger (method' 0x06000000))  		theVersion = ConfuserVersion.v10_r42919;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if (!DotNetUtils.CallsMethod (method' "System.Byte[] System.Convert::FromBase64String(System.String)") && DotNetUtils.CallsMethod (method' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)")) {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !FindCallvirtChar (method' out callvirtChar))  		continue;  	if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  	else if (FindMagic_v18_r75367 (method' out magic))  		theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  	else if (FindMagic_v19_r76101 (method' out magic))  		CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  	else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  		CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  	else {  		if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  			theVersion = ConfuserVersion.v11_r50378;  		int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  		if (numCalls == 2)  			theVersion = ConfuserVersion.v12_r54564;  		if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  			theVersion = ConfuserVersion.v13_r55346;  		if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  			theVersion = ConfuserVersion.v13_r55604;  	}  } else if (Is_v17_r73740 (method)) {  	if (DotNetUtils.CallsMethod (method' "System.Boolean System.Type::get_IsArray()")) {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r74708_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r74708_normal;  		else  			continue;  	} else {  		if ((nativeMethod = FindNativeMethod_v17_r73740 (method)) != null)  			theVersion = ConfuserVersion.v17_r73740_native;  		else if (FindMagic_v17_r73740 (method' out magic))  			theVersion = ConfuserVersion.v17_r73740_normal;  		else  			continue;  	}  } else if (theVersion == ConfuserVersion.v10_r42915) {  	if (DeobUtils.HasInteger (method' 0x06000000))  		theVersion = ConfuserVersion.v10_r42919;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  	theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  else if (FindMagic_v18_r75367 (method' out magic))  	theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  else if (FindMagic_v19_r76101 (method' out magic))  	CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  	CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  else {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v11_r50378;  	int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  	if (numCalls == 2)  		theVersion = ConfuserVersion.v12_r54564;  	if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  		theVersion = ConfuserVersion.v13_r55346;  	if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  		theVersion = ConfuserVersion.v13_r55604;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  	theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  else if (FindMagic_v18_r75367 (method' out magic))  	theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  else if (FindMagic_v19_r76101 (method' out magic))  	CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  	CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  else {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v11_r50378;  	int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  	if (numCalls == 2)  		theVersion = ConfuserVersion.v12_r54564;  	if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  		theVersion = ConfuserVersion.v13_r55346;  	if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  		theVersion = ConfuserVersion.v13_r55604;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if ((nativeMethod = FindNativeMethod_v18_r75367 (method)) != null)  	theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  else if (FindMagic_v18_r75367 (method' out magic))  	theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  else if (FindMagic_v19_r76101 (method' out magic))  	CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  	CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  else {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v11_r50378;  	int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  	if (numCalls == 2)  		theVersion = ConfuserVersion.v12_r54564;  	if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  		theVersion = ConfuserVersion.v13_r55346;  	if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  		theVersion = ConfuserVersion.v13_r55604;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_native : ConfuserVersion.v18_r75369_native;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if (FindMagic_v18_r75367 (method' out magic))  	theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  else if (FindMagic_v19_r76101 (method' out magic))  	CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  	CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  else {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v11_r50378;  	int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  	if (numCalls == 2)  		theVersion = ConfuserVersion.v12_r54564;  	if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  		theVersion = ConfuserVersion.v13_r55346;  	if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  		theVersion = ConfuserVersion.v13_r55604;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if (FindMagic_v18_r75367 (method' out magic))  	theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  else if (FindMagic_v19_r76101 (method' out magic))  	CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  	CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  else {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v11_r50378;  	int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  	if (numCalls == 2)  		theVersion = ConfuserVersion.v12_r54564;  	if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  		theVersion = ConfuserVersion.v13_r55346;  	if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  		theVersion = ConfuserVersion.v13_r55604;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: theVersion = proxyType != ProxyCreatorType.CallOrCallvirt || callvirtChar == 9 ? ConfuserVersion.v18_r75367_normal : ConfuserVersion.v18_r75369_normal;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if (FindMagic_v19_r76101 (method' out magic))  	CommonCheckVersion19 (method' true' tmpVer' ref theVersion);  else if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  	CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  else {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v11_r50378;  	int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  	if (numCalls == 2)  		theVersion = ConfuserVersion.v12_r54564;  	if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  		theVersion = ConfuserVersion.v13_r55346;  	if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  		theVersion = ConfuserVersion.v13_r55604;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if ((nativeMethod = FindNativeMethod_v19_r76101 (method)) != null)  	CommonCheckVersion19 (method' false' tmpVer' ref theVersion);  else {  	if (proxyType == ProxyCreatorType.CallOrCallvirt && !DotNetUtils.CallsMethod (method' "System.Int32 System.String::get_Length()"))  		theVersion = ConfuserVersion.v11_r50378;  	int numCalls = ConfuserUtils.CountCalls (method' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  	if (numCalls == 2)  		theVersion = ConfuserVersion.v12_r54564;  	if (!DotNetUtils.CallsMethod (method' "System.Reflection.Assembly System.Reflection.Assembly::Load(System.Reflection.AssemblyName)"))  		theVersion = ConfuserVersion.v13_r55346;  	if (DotNetUtils.CallsMethod (method' "System.Void System.Runtime.CompilerServices.RuntimeHelpers::RunClassConstructor(System.RuntimeTypeHandle)"))  		theVersion = ConfuserVersion.v13_r55604;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindDelegateCreator,The following statement contains a magic number: if (numCalls == 2)  	theVersion = ConfuserVersion.v12_r54564;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CommonCheckVersion19,The following statement contains a magic number: if (tmpProxyVer == 1) {  	theVersion = isNormal ? ConfuserVersion.v19_r76101_normal : ConfuserVersion.v19_r76101_native;  	return true;  } else if (tmpProxyVer == 2) {  	if (!CheckCtorProxyType_v19_r78963 (method))  		theVersion = isNormal ? ConfuserVersion.v19_r78363_normal : ConfuserVersion.v19_r78363_native;  	else  		theVersion = isNormal ? ConfuserVersion.v19_r78963_normal_Newobj : ConfuserVersion.v19_r78963_native_Newobj;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CommonCheckVersion19,The following statement contains a magic number: if (tmpProxyVer == 2) {  	if (!CheckCtorProxyType_v19_r78963 (method))  		theVersion = isNormal ? ConfuserVersion.v19_r78363_normal : ConfuserVersion.v19_r78363_native;  	else  		theVersion = isNormal ? ConfuserVersion.v19_r78963_normal_Newobj : ConfuserVersion.v19_r78963_native_Newobj;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,IsMethodCreator_v14_r58802,The following statement contains a magic number: switch (proxyType) {  case ProxyCreatorType.Newobj:  	if (index == 1)  		return false;  	if (index == 0)  		return true;  	break;  case ProxyCreatorType.CallOrCallvirt:  	if (index == 2)  		return false;  	if (index == 1)  		return true;  	break;  default:  	throw new ApplicationException ("Invalid proxy creator type");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,IsMethodCreator_v14_r58802,The following statement contains a magic number: if (index == 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetFieldNameIndex,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  	if (i < 0)  		break;  	if (i < 2)  		continue;  	var ldci4 = instrs [i - 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetFieldNameIndex,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.Text.Encoding::GetBytes(System.Char[]'System.Int32'System.Int32)");  	if (i < 0)  		break;  	if (i < 2)  		continue;  	var ldci4 = instrs [i - 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	return ldci4.GetLdcI4Value ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetFieldNameIndex,The following statement contains a magic number: if (i < 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4_2 = instrs [i + 6];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4_2 = instrs [i + 6];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4_2 = instrs [i + 6];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4_2 = instrs [i + 6];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4_2 = instrs [i + 6];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4_2 = instrs [i + 6];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4_2 = instrs [i + 6];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 7; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var ldci4_2 = instrs [i + 6];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	if (instrs [i + 7].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: if (!ldci4_1.IsLdcI4 () || ldci4_1.GetLdcI4Value () != 24)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Or)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: if (!instrs [i + 3].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: if (!instrs [i + 4].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: if (!instrs [i + 5].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v19_r76101,The following statement contains a magic number: if (instrs [i + 7].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var call = instrs [i + 6];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)  		continue;  	return calledMethod;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var call = instrs [i + 6];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)  		continue;  	return calledMethod;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var call = instrs [i + 6];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)  		continue;  	return calledMethod;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var call = instrs [i + 6];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)  		continue;  	return calledMethod;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var call = instrs [i + 6];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)  		continue;  	return calledMethod;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var call = instrs [i + 6];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)  		continue;  	return calledMethod;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Or)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	if (!instrs [i + 4].IsLdloc ())  		continue;  	if (!instrs [i + 5].IsLdloc ())  		continue;  	var call = instrs [i + 6];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)  		continue;  	return calledMethod;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Or)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: if (!instrs [i + 3].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: if (!instrs [i + 4].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v19_r76101,The following statement contains a magic number: if (!instrs [i + 5].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	if (i < 0 || i + 3 >= instrs.Count)  		break;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	if (i < 0 || i + 3 >= instrs.Count)  		break;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	if (i < 0 || i + 3 >= instrs.Count)  		break;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v18_r75367,The following statement contains a magic number: if (i < 0 || i + 3 >= instrs.Count)  	break;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v18_r75367,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	if (i < 0 || i + 2 >= instrs.Count)  		break;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	var call = instrs [i + 2];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)  		continue;  	return calledMethod;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.Module System.Reflection.MemberInfo::get_Module()");  	if (i < 0 || i + 2 >= instrs.Count)  		break;  	if (!instrs [i + 1].IsLdloc ())  		continue;  	var call = instrs [i + 2];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null || calledMethod.Body != null || !calledMethod.IsNative)  		continue;  	return calledMethod;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindNativeMethod_v18_r75367,The following statement contains a magic number: if (i < 0 || i + 2 >= instrs.Count)  	break;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Int32 System.BitConverter::ToInt32(System.Byte[]'System.Int32)");  	if (index < 0)  		break;  	if (index < 1 || index + 2 >= instrs.Count)  		continue;  	if (!instrs [index - 1].IsLdcI4 ())  		continue;  	var ldci4 = instrs [index + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 2].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Int32 System.BitConverter::ToInt32(System.Byte[]'System.Int32)");  	if (index < 0)  		break;  	if (index < 1 || index + 2 >= instrs.Count)  		continue;  	if (!instrs [index - 1].IsLdcI4 ())  		continue;  	var ldci4 = instrs [index + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 2].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v17_r73740,The following statement contains a magic number: if (index < 1 || index + 2 >= instrs.Count)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v17_r73740,The following statement contains a magic number: if (instrs [index + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Is_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)");  	if (index < 0)  		break;  	if (index < 3)  		continue;  	index -= 3;  	var ldci4 = instrs [index];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [index + 2].OpCode.Code != Code.Or)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Is_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)");  	if (index < 0)  		break;  	if (index < 3)  		continue;  	index -= 3;  	var ldci4 = instrs [index];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [index + 2].OpCode.Code != Code.Or)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Is_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)");  	if (index < 0)  		break;  	if (index < 3)  		continue;  	index -= 3;  	var ldci4 = instrs [index];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [index + 2].OpCode.Code != Code.Or)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Is_v17_r73740,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)");  	if (index < 0)  		break;  	if (index < 3)  		continue;  	index -= 3;  	var ldci4 = instrs [index];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Shl)  		continue;  	if (instrs [index + 2].OpCode.Code != Code.Or)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Is_v17_r73740,The following statement contains a magic number: if (index < 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Is_v17_r73740,The following statement contains a magic number: index -= 3;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Is_v17_r73740,The following statement contains a magic number: if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 24)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,Is_v17_r73740,The following statement contains a magic number: if (instrs [index + 2].OpCode.Code != Code.Or)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v14_r58564,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Int32 System.BitConverter::ToInt32(System.Byte[]'System.Int32)");  	if (index < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)");  	if (index2 < 0 || index2 - index != 3)  		continue;  	var ldci4 = instrs [index + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 2].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v14_r58564,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Call' "System.Int32 System.BitConverter::ToInt32(System.Byte[]'System.Int32)");  	if (index < 0)  		break;  	int index2 = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)");  	if (index2 < 0 || index2 - index != 3)  		continue;  	var ldci4 = instrs [index + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 2].OpCode.Code != Code.Xor)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v14_r58564,The following statement contains a magic number: if (index2 < 0 || index2 - index != 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,FindMagic_v14_r58564,The following statement contains a magic number: if (instrs [index + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetProxyCreatorType,The following statement contains a magic number: if (type != ProxyCreatorType.None) {  	version = 2;  	return type;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetProxyCreatorType,The following statement contains a magic number: version = 2;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCtorProxyTypeV2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 2)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x73)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Stelem_I1)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCtorProxyTypeV2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 2)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x73)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Stelem_I1)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCtorProxyTypeV2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 2)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x73)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Stelem_I1)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCtorProxyTypeV2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 2)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x73)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Stelem_I1)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCtorProxyTypeV2,The following statement contains a magic number: if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCtorProxyTypeV2,The following statement contains a magic number: ldci4 = instrs [i + 2];  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCtorProxyTypeV2,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Stelem_I1)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCtorProxyType_v19_r78963,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	if (instrs [i].OpCode.Code != Code.Add)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x74)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Stelem_I1)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCtorProxyType_v19_r78963,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	if (instrs [i].OpCode.Code != Code.Add)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0x74)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Stelem_I1)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CheckCtorProxyType_v19_r78963,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Stelem_I1)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CreateDelegateInitInfos_v10_r42915,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldstr = instrs [i];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var info = ldstr.Operand as string;  	if (info == null)  		continue;  	var ldtoken = instrs [i + 1];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var delegateField = ldtoken.Operand as FieldDef;  	if (delegateField == null)  		continue;  	var delegateType = delegateField.FieldType.TryGetTypeDef ();  	if (!DotNetUtils.DerivesFromDelegate (delegateType))  		continue;  	var call = instrs [i + 2];  	if (call.OpCode.Code != Code.Call)  		continue;  	var delegateCreatorMethod = call.Operand as MethodDef;  	if (delegateCreatorMethod == null || !IsDelegateCreatorMethod (delegateCreatorMethod))  		continue;  	infos.Add (delegateField' new DelegateInitInfo (info' delegateField' delegateCreatorMethod));  	i += 2;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CreateDelegateInitInfos_v10_r42915,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldstr = instrs [i];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var info = ldstr.Operand as string;  	if (info == null)  		continue;  	var ldtoken = instrs [i + 1];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var delegateField = ldtoken.Operand as FieldDef;  	if (delegateField == null)  		continue;  	var delegateType = delegateField.FieldType.TryGetTypeDef ();  	if (!DotNetUtils.DerivesFromDelegate (delegateType))  		continue;  	var call = instrs [i + 2];  	if (call.OpCode.Code != Code.Call)  		continue;  	var delegateCreatorMethod = call.Operand as MethodDef;  	if (delegateCreatorMethod == null || !IsDelegateCreatorMethod (delegateCreatorMethod))  		continue;  	infos.Add (delegateField' new DelegateInitInfo (info' delegateField' delegateCreatorMethod));  	i += 2;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CreateDelegateInitInfos_v10_r42915,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldstr = instrs [i];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var info = ldstr.Operand as string;  	if (info == null)  		continue;  	var ldtoken = instrs [i + 1];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var delegateField = ldtoken.Operand as FieldDef;  	if (delegateField == null)  		continue;  	var delegateType = delegateField.FieldType.TryGetTypeDef ();  	if (!DotNetUtils.DerivesFromDelegate (delegateType))  		continue;  	var call = instrs [i + 2];  	if (call.OpCode.Code != Code.Call)  		continue;  	var delegateCreatorMethod = call.Operand as MethodDef;  	if (delegateCreatorMethod == null || !IsDelegateCreatorMethod (delegateCreatorMethod))  		continue;  	infos.Add (delegateField' new DelegateInitInfo (info' delegateField' delegateCreatorMethod));  	i += 2;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,CreateDelegateInitInfos_v10_r42915,The following statement contains a magic number: i += 2;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 42917;  	return true;  case ConfuserVersion.v10_r42919:  	minRev = 42919;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 54431;  	return true;  case ConfuserVersion.v11_r50378:  	minRev = 50378;  	maxRev = 54431;  	return true;  case ConfuserVersion.v12_r54564:  	minRev = 54564;  	maxRev = 54574;  	return true;  case ConfuserVersion.v13_r55346:  	minRev = 55346;  	maxRev = 55346;  	return true;  case ConfuserVersion.v13_r55604:  	minRev = 55604;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58852;  	return true;  case ConfuserVersion.v14_r58857:  	minRev = 58857;  	maxRev = 73477;  	return true;  case ConfuserVersion.v16_r66631:  	minRev = 66631;  	maxRev = 69666;  	return true;  case ConfuserVersion.v16_r70489:  	minRev = 70489;  	maxRev = 73477;  	return true;  case ConfuserVersion.v17_r73479:  	minRev = 73479;  	maxRev = 73605;  	return true;  case ConfuserVersion.v17_r73740_normal:  case ConfuserVersion.v17_r73740_native:  	minRev = 73740;  	maxRev = 74637;  	return true;  case ConfuserVersion.v17_r74708_normal:  case ConfuserVersion.v17_r74708_native:  	minRev = 74708;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367_normal:  case ConfuserVersion.v18_r75367_native:  	minRev = 75367;  	maxRev = 75926;  	return true;  case ConfuserVersion.v18_r75369_normal:  case ConfuserVersion.v18_r75369_native:  	minRev = 75369;  	maxRev = 75926;  	return true;  case ConfuserVersion.v19_r76101_normal:  case ConfuserVersion.v19_r76101_native:  	minRev = 76101;  	maxRev = 78342;  	return true;  case ConfuserVersion.v19_r78363_normal:  case ConfuserVersion.v19_r78363_native:  	minRev = 78363;  	// We can only detect the r78963 version if a method ctor proxy is used.  	// If it's not used' then maxRev must be the same maxRev as in the next case.  	// If a method ctor proxy is found' then we know that rev <= 78962.  	if (foundNewobjProxy)  		maxRev = 78962;  	else  		maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v19_r78963_normal_Newobj:  case ConfuserVersion.v19_r78963_native_Newobj:  	minRev = 78963;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 42915;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 42917;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 42919;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 48509;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 48717;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 54431;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 50378;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 54431;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 54564;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 54574;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 55346;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 55346;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 55604;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58446;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58564;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58741;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58802;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58852;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58857;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73477;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 66631;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 69666;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 70489;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73477;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73479;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73605;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73740;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 74637;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 74708;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75349;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75367;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75926;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75369;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75926;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 76101;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 78342;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 78363;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: if (foundNewobjProxy)  	maxRev = 78962;  else  	maxRev = int.MaxValue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 78962;  
Magic Number,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetRevisionRange,The following statement contains a magic number: minRev = 78963;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetHandler,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldftn = instrs [i];  	if (ldftn.OpCode.Code != Code.Ldftn)  		continue;  	var handler = ldftn.Operand as MethodDef;  	if (handler == null)  		continue;  	var newobj = instrs [i + 1];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	var callvirt = instrs [i + 2];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var calledMethod = callvirt.Operand as IMethod;  	if (calledMethod == null)  		continue;  	if (calledMethod.FullName != "System.Void System.AppDomain::add_ResourceResolve(System.ResolveEventHandler)")  		continue;  	return handler;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetHandler,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldftn = instrs [i];  	if (ldftn.OpCode.Code != Code.Ldftn)  		continue;  	var handler = ldftn.Operand as MethodDef;  	if (handler == null)  		continue;  	var newobj = instrs [i + 1];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	var callvirt = instrs [i + 2];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var calledMethod = callvirt.Operand as IMethod;  	if (calledMethod == null)  		continue;  	if (calledMethod.FullName != "System.Void System.AppDomain::add_ResourceResolve(System.ResolveEventHandler)")  		continue;  	return handler;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.Stream::Read(System.Byte[]'System.Int32'System.Int32)");  	if (i < 0)  		break;  	if (i + 3 >= instrs.Count)  		break;  	if (instrs [i + 1].OpCode.Code != Code.Pop)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	key0 = (byte)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.Stream::Read(System.Byte[]'System.Int32'System.Int32)");  	if (i < 0)  		break;  	if (i + 3 >= instrs.Count)  		break;  	if (instrs [i + 1].OpCode.Code != Code.Pop)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	key0 = (byte)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v18_r75367,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	i = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Int32 System.IO.Stream::Read(System.Byte[]'System.Int32'System.Int32)");  	if (i < 0)  		break;  	if (i + 3 >= instrs.Count)  		break;  	if (instrs [i + 1].OpCode.Code != Code.Pop)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	key0 = (byte)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v18_r75367,The following statement contains a magic number: if (i + 3 >= instrs.Count)  	break;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v18_r75367,The following statement contains a magic number: if (!instrs [i + 3].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v18_r75369,The following statement contains a magic number: for (int index = 0; index < instrs.Count; index++) {  	index = ConfuserUtils.FindCallMethod (instrs' index' Code.Callvirt' "System.Int32 System.IO.Stream::Read(System.Byte[]'System.Int32'System.Int32)");  	if (index < 0)  		break;  	if (index + 4 >= instrs.Count)  		break;  	index++;  	if (instrs [index++].OpCode.Code != Code.Pop)  		continue;  	var ldci4 = instrs [index++];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Conv_U1)  		continue;  	if (!instrs [index++].IsStloc ())  		continue;  	key0 = (byte)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v18_r75369,The following statement contains a magic number: if (index + 4 >= instrs.Count)  	break;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey1_v18_r75369,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	int index = i;  	if (!instrs [index++].IsLdloc ())  		continue;  	var ldci4_1 = instrs [index++];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Mul)  		continue;  	var ldci4_2 = instrs [index++];  	if (!ldci4_2.IsLdcI4 () || ldci4_2.GetLdcI4Value () != 0x100)  		continue;  	if (instrs [index++].OpCode.Code != Code.Rem)  		continue;  	key1 = (byte)ldci4_1.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0Key1_v14_r55802,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	if (!instrs [i].IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Add)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldelem_U1)  		continue;  	var ldci4_1 = instrs [i + 3];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Xor)  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	key0 = (byte)ldci4_1.GetLdcI4Value ();  	key1 = (byte)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0Key1_v14_r55802,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	if (!instrs [i].IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Add)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldelem_U1)  		continue;  	var ldci4_1 = instrs [i + 3];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Xor)  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	key0 = (byte)ldci4_1.GetLdcI4Value ();  	key1 = (byte)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0Key1_v14_r55802,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	if (!instrs [i].IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Add)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldelem_U1)  		continue;  	var ldci4_1 = instrs [i + 3];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Xor)  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	key0 = (byte)ldci4_1.GetLdcI4Value ();  	key1 = (byte)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0Key1_v14_r55802,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	if (!instrs [i].IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Add)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldelem_U1)  		continue;  	var ldci4_1 = instrs [i + 3];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Xor)  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	key0 = (byte)ldci4_1.GetLdcI4Value ();  	key1 = (byte)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0Key1_v14_r55802,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	if (!instrs [i].IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Add)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldelem_U1)  		continue;  	var ldci4_1 = instrs [i + 3];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Xor)  		continue;  	var ldci4_2 = instrs [i + 5];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	key0 = (byte)ldci4_1.GetLdcI4Value ();  	key1 = (byte)ldci4_2.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0Key1_v14_r55802,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Ldelem_U1)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0Key1_v14_r55802,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v17_r73404,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)");  	if (index < 0)  		break;  	if (index + 3 >= instrs.Count)  		break;  	if (!instrs [index + 1].IsStloc ())  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (!instrs [index + 3].IsStloc ())  		continue;  	key = (byte)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v17_r73404,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)");  	if (index < 0)  		break;  	if (index + 3 >= instrs.Count)  		break;  	if (!instrs [index + 1].IsStloc ())  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (!instrs [index + 3].IsStloc ())  		continue;  	key = (byte)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v17_r73404,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)");  	if (index < 0)  		break;  	if (index + 3 >= instrs.Count)  		break;  	if (!instrs [index + 1].IsStloc ())  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (!instrs [index + 3].IsStloc ())  		continue;  	key = (byte)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v17_r73404,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)");  	if (index < 0)  		break;  	if (index + 3 >= instrs.Count)  		break;  	if (!instrs [index + 1].IsStloc ())  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (!instrs [index + 3].IsStloc ())  		continue;  	key = (byte)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v17_r73404,The following statement contains a magic number: if (index + 3 >= instrs.Count)  	break;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey0_v17_r73404,The following statement contains a magic number: if (!instrs [index + 3].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey1_v17_r73404,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	var ldci4_2 = instrs [i + 2];  	if (!ldci4_2.IsLdcI4 () || ldci4_2.GetLdcI4Value () != 0x100)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Rem)  		continue;  	key = (byte)ldci4_1.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey1_v17_r73404,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	var ldci4_2 = instrs [i + 2];  	if (!ldci4_2.IsLdcI4 () || ldci4_2.GetLdcI4Value () != 0x100)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Rem)  		continue;  	key = (byte)ldci4_1.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey1_v17_r73404,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	var ldci4_2 = instrs [i + 2];  	if (!ldci4_2.IsLdcI4 () || ldci4_2.GetLdcI4Value () != 0x100)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Rem)  		continue;  	key = (byte)ldci4_1.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,FindKey1_v17_r73404,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Rem)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,Decrypt_v14_r55802,The following statement contains a magic number: for (int i = 0; i < decrypted.Length; i++)  	decrypted [i] = (byte)((encypted [i * 2 + 1] ^ key0) * key1 + (encypted [i * 2] ^ key0));  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,Decrypt_v14_r55802,The following statement contains a magic number: for (int i = 0; i < decrypted.Length; i++)  	decrypted [i] = (byte)((encypted [i * 2 + 1] ^ key0) * key1 + (encypted [i * 2] ^ key0));  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,Decrypt_v14_r55802,The following statement contains a magic number: decrypted [i] = (byte)((encypted [i * 2 + 1] ^ key0) * key1 + (encypted [i * 2] ^ key0));  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,Decrypt_v14_r55802,The following statement contains a magic number: decrypted [i] = (byte)((encypted [i * 2 + 1] ^ key0) * key1 + (encypted [i * 2] ^ key0));  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v14_r55802:  	minRev = 55802;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73791;  	return true;  case ConfuserVersion.v17_r73822:  	minRev = 73822;  	maxRev = 75349;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 75367;  	return true;  case ConfuserVersion.v18_r75369:  	minRev = 75369;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 55802;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 72989;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73404;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73791;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73822;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75349;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75367;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75367;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75369;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 77124;  
Magic Number,de4dot.code.deobfuscators.Confuser,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ResourceDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 77172;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)");  	if (index < 0)  		break;  	if (index < 4)  		continue;  	index -= 4;  	if (!instrs [index].IsLdarg ())  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 3].OpCode.Code != Code.Sub)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)");  	if (index < 0)  		break;  	if (index < 4)  		continue;  	index -= 4;  	if (!instrs [index].IsLdarg ())  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 3].OpCode.Code != Code.Sub)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)");  	if (index < 0)  		break;  	if (index < 4)  		continue;  	index -= 4;  	if (!instrs [index].IsLdarg ())  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 3].OpCode.Code != Code.Sub)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)");  	if (index < 0)  		break;  	if (index < 4)  		continue;  	index -= 4;  	if (!instrs [index].IsLdarg ())  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 3].OpCode.Code != Code.Sub)  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: if (index < 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: index -= 4;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic1,The following statement contains a magic number: if (instrs [index + 3].OpCode.Code != Code.Sub)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindNewMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Ldarg_0)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Sub)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindNewMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Ldarg_0)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Sub)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindNewMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Ldarg_0)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Sub)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindNewMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Ldarg_0)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Sub)  		continue;  	if (!instrs [i + 4].IsStloc ())  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindNewMagic1,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Sub)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindNewMagic1,The following statement contains a magic number: if (!instrs [i + 4].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.UInt32 System.IO.BinaryReader::ReadUInt32()");  	if (index < 0)  		break;  	if (index + 4 >= instrs.Count)  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Not)  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 3].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [index + 4].IsStloc ())  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.UInt32 System.IO.BinaryReader::ReadUInt32()");  	if (index < 0)  		break;  	if (index + 4 >= instrs.Count)  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Not)  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 3].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [index + 4].IsStloc ())  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.UInt32 System.IO.BinaryReader::ReadUInt32()");  	if (index < 0)  		break;  	if (index + 4 >= instrs.Count)  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Not)  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 3].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [index + 4].IsStloc ())  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = ConfuserUtils.FindCallMethod (instrs' i' Code.Callvirt' "System.UInt32 System.IO.BinaryReader::ReadUInt32()");  	if (index < 0)  		break;  	if (index + 4 >= instrs.Count)  		continue;  	if (instrs [index + 1].OpCode.Code != Code.Not)  		continue;  	var ldci4 = instrs [index + 2];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [index + 3].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [index + 4].IsStloc ())  		continue;  	magic = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: if (index + 4 >= instrs.Count)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: if (instrs [index + 3].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,FindMagic2,The following statement contains a magic number: if (!instrs [index + 4].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48771;  	return true;  case ConfuserVersion.v10_r48832:  	minRev = 48832;  	maxRev = 49238;  	return true;  case ConfuserVersion.v11_r49299:  	minRev = 49299;  	maxRev = 58741;  	return true;  case ConfuserVersion.v13_r55604_safe:  	minRev = 55604;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802_safe:  case ConfuserVersion.v14_r58802_dynamic:  	minRev = 58802;  	maxRev = 60408;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48771;  	return true;  case ConfuserVersion.v10_r48832:  	minRev = 48832;  	maxRev = 49238;  	return true;  case ConfuserVersion.v11_r49299:  	minRev = 49299;  	maxRev = 58741;  	return true;  case ConfuserVersion.v13_r55604_safe:  	minRev = 55604;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802_safe:  case ConfuserVersion.v14_r58802_dynamic:  	minRev = 58802;  	maxRev = 60408;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48771;  	return true;  case ConfuserVersion.v10_r48832:  	minRev = 48832;  	maxRev = 49238;  	return true;  case ConfuserVersion.v11_r49299:  	minRev = 49299;  	maxRev = 58741;  	return true;  case ConfuserVersion.v13_r55604_safe:  	minRev = 55604;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802_safe:  case ConfuserVersion.v14_r58802_dynamic:  	minRev = 58802;  	maxRev = 60408;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48771;  	return true;  case ConfuserVersion.v10_r48832:  	minRev = 48832;  	maxRev = 49238;  	return true;  case ConfuserVersion.v11_r49299:  	minRev = 49299;  	maxRev = 58741;  	return true;  case ConfuserVersion.v13_r55604_safe:  	minRev = 55604;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802_safe:  case ConfuserVersion.v14_r58802_dynamic:  	minRev = 58802;  	maxRev = 60408;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48771;  	return true;  case ConfuserVersion.v10_r48832:  	minRev = 48832;  	maxRev = 49238;  	return true;  case ConfuserVersion.v11_r49299:  	minRev = 49299;  	maxRev = 58741;  	return true;  case ConfuserVersion.v13_r55604_safe:  	minRev = 55604;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802_safe:  case ConfuserVersion.v14_r58802_dynamic:  	minRev = 58802;  	maxRev = 60408;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48771;  	return true;  case ConfuserVersion.v10_r48832:  	minRev = 48832;  	maxRev = 49238;  	return true;  case ConfuserVersion.v11_r49299:  	minRev = 49299;  	maxRev = 58741;  	return true;  case ConfuserVersion.v13_r55604_safe:  	minRev = 55604;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802_safe:  case ConfuserVersion.v14_r58802_dynamic:  	minRev = 58802;  	maxRev = 60408;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48771;  	return true;  case ConfuserVersion.v10_r48832:  	minRev = 48832;  	maxRev = 49238;  	return true;  case ConfuserVersion.v11_r49299:  	minRev = 49299;  	maxRev = 58741;  	return true;  case ConfuserVersion.v13_r55604_safe:  	minRev = 55604;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802_safe:  case ConfuserVersion.v14_r58802_dynamic:  	minRev = 58802;  	maxRev = 60408;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48771;  	return true;  case ConfuserVersion.v10_r48832:  	minRev = 48832;  	maxRev = 49238;  	return true;  case ConfuserVersion.v11_r49299:  	minRev = 49299;  	maxRev = 58741;  	return true;  case ConfuserVersion.v13_r55604_safe:  	minRev = 55604;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802_safe:  case ConfuserVersion.v14_r58802_dynamic:  	minRev = 58802;  	maxRev = 60408;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48771;  	return true;  case ConfuserVersion.v10_r48832:  	minRev = 48832;  	maxRev = 49238;  	return true;  case ConfuserVersion.v11_r49299:  	minRev = 49299;  	maxRev = 58741;  	return true;  case ConfuserVersion.v13_r55604_safe:  	minRev = 55604;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802_safe:  case ConfuserVersion.v14_r58802_dynamic:  	minRev = 58802;  	maxRev = 60408;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48771;  	return true;  case ConfuserVersion.v10_r48832:  	minRev = 48832;  	maxRev = 49238;  	return true;  case ConfuserVersion.v11_r49299:  	minRev = 49299;  	maxRev = 58741;  	return true;  case ConfuserVersion.v13_r55604_safe:  	minRev = 55604;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802_safe:  case ConfuserVersion.v14_r58802_dynamic:  	minRev = 58802;  	maxRev = 60408;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 42915;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 48771;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 48832;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 49238;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 49299;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58741;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 55604;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58741;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58802;  
Magic Number,de4dot.code.deobfuscators.Confuser,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\StringDecrypter.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 60408;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindEntryPointToken,The following statement contains a magic number: if ((token >> 24) != 0x06)  	throw new ApplicationException ("Illegal entry point token");  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindBase,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldci8 = instrs [i];  	if (ldci8.OpCode.Code != Code.Ldc_I8)  		continue;  	var stsfld = instrs [i + 1];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	var field = stsfld.Operand as FieldDef;  	if (field == null || field.DeclaringType != method.DeclaringType)  		continue;  	if (field.FieldType.GetElementType () != ElementType.U8)  		continue;  	@base = (ulong)(long)ldci8.Operand;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,IsDecryptMethod_v17_r73404,The following statement contains a magic number: if (instrs.Count < 4)  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,IsDecryptMethod_v17_r73404,The following statement contains a magic number: if (!IsCallorNewobj (instrs [1]) && !IsCallorNewobj (instrs [2]))  	return false;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey0_v14_r58564,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	if (instrs [i].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey0_v14_r58564,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	if (instrs [i].OpCode.Code != Code.Xor)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey0_v14_r58564,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey0_v14_r58852,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 2];  	if (!ldci4_2.IsLdcI4 () && ldci4_2.GetLdcI4Value () != 0)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	key = (uint)ldci4_1.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey0_v14_r58852,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 2];  	if (!ldci4_2.IsLdcI4 () && ldci4_2.GetLdcI4Value () != 0)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	key = (uint)ldci4_1.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey0_v14_r58852,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	if (!instrs [i + 1].IsStloc ())  		continue;  	var ldci4_2 = instrs [i + 2];  	if (!ldci4_2.IsLdcI4 () && ldci4_2.GetLdcI4Value () != 0)  		continue;  	if (!instrs [i + 3].IsStloc ())  		continue;  	key = (uint)ldci4_1.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey0_v14_r58852,The following statement contains a magic number: if (!instrs [i + 3].IsStloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Ldelem_U1)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Xor)  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Ldelem_U1)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Xor)  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Ldelem_U1)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Xor)  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (instrs [i].OpCode.Code != Code.Ldelem_U1)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [i + 3].IsLdloc ())  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Xor)  		continue;  	key = (uint)ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey1,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey1,The following statement contains a magic number: if (!instrs [i + 3].IsLdloc ())  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,FindKey1,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v14_r58852,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	if ((i & 1) == 0)  		data [i] ^= (byte)((key0 & 0xF) - i);  	else  		data [i] ^= (byte)((key0 >> 4) + i);  	data [i] -= (byte)i;  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v14_r58852,The following statement contains a magic number: if ((i & 1) == 0)  	data [i] ^= (byte)((key0 & 0xF) - i);  else  	data [i] ^= (byte)((key0 >> 4) + i);  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v14_r58852,The following statement contains a magic number: data [i] ^= (byte)((key0 >> 4) + i);  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: for (int i = 0; i < key.Length; i += 4) {  	key [i] ^= (byte)key0;  	key [i + 1] ^= (byte)(key0 >> 8);  	key [i + 2] ^= (byte)(key0 >> 16);  	key [i + 3] ^= (byte)(key0 >> 24);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: for (int i = 0; i < key.Length; i += 4) {  	key [i] ^= (byte)key0;  	key [i + 1] ^= (byte)(key0 >> 8);  	key [i + 2] ^= (byte)(key0 >> 16);  	key [i + 3] ^= (byte)(key0 >> 24);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: for (int i = 0; i < key.Length; i += 4) {  	key [i] ^= (byte)key0;  	key [i + 1] ^= (byte)(key0 >> 8);  	key [i + 2] ^= (byte)(key0 >> 16);  	key [i + 3] ^= (byte)(key0 >> 24);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: for (int i = 0; i < key.Length; i += 4) {  	key [i] ^= (byte)key0;  	key [i + 1] ^= (byte)(key0 >> 8);  	key [i + 2] ^= (byte)(key0 >> 16);  	key [i + 3] ^= (byte)(key0 >> 24);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: for (int i = 0; i < key.Length; i += 4) {  	key [i] ^= (byte)key0;  	key [i + 1] ^= (byte)(key0 >> 8);  	key [i + 2] ^= (byte)(key0 >> 16);  	key [i + 3] ^= (byte)(key0 >> 24);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: for (int i = 0; i < key.Length; i += 4) {  	key [i] ^= (byte)key0;  	key [i + 1] ^= (byte)(key0 >> 8);  	key [i + 2] ^= (byte)(key0 >> 16);  	key [i + 3] ^= (byte)(key0 >> 24);  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: i += 4
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: key [i + 1] ^= (byte)(key0 >> 8);  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: key [i + 2] ^= (byte)(key0 >> 16);  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: key [i + 2] ^= (byte)(key0 >> 16);  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: key [i + 3] ^= (byte)(key0 >> 24);  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,Decrypt_v15_r60785,The following statement contains a magic number: key [i + 3] ^= (byte)(key0 >> 24);  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: switch (version) {  case ConfuserVersion.Unknown:  	minRev = maxRev = 0;  	return false;  case ConfuserVersion.v10_r42915:  	minRev = 42915;  	maxRev = 48509;  	return true;  case ConfuserVersion.v10_r48717:  	minRev = 48717;  	maxRev = 57699;  	return true;  case ConfuserVersion.v14_r57778:  	minRev = 57778;  	maxRev = 58446;  	return true;  case ConfuserVersion.v14_r58564:  	minRev = 58564;  	maxRev = 58741;  	return true;  case ConfuserVersion.v14_r58802:  	minRev = 58802;  	maxRev = 58817;  	return true;  case ConfuserVersion.v14_r58852:  	minRev = 58852;  	maxRev = 60408;  	return true;  case ConfuserVersion.v15_r60785:  	minRev = 60785;  	maxRev = 72989;  	return true;  case ConfuserVersion.v17_r73404:  	minRev = 73404;  	maxRev = 73430;  	return true;  case ConfuserVersion.v17_r73477:  	minRev = 73477;  	maxRev = 73479;  	return true;  case ConfuserVersion.v17_r73566:  	minRev = 73566;  	maxRev = 75056;  	return true;  case ConfuserVersion.v17_r75076:  	minRev = 75076;  	maxRev = 75158;  	return true;  case ConfuserVersion.v18_r75184:  	minRev = 75184;  	maxRev = int.MaxValue;  	return true;  case ConfuserVersion.v18_r75367:  	minRev = 75367;  	maxRev = 77124;  	return true;  case ConfuserVersion.v19_r77172:  	minRev = 77172;  	maxRev = int.MaxValue;  	return true;  default:  	throw new ApplicationException ("Invalid version");  }  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 42915;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 48509;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 48717;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 57699;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 57778;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58446;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58564;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58741;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58802;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 58817;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 58852;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 60408;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 60785;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 72989;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73404;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73430;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73477;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 73479;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 73566;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75056;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75076;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 75158;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75184;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 75367;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: maxRev = 77124;  
Magic Number,de4dot.code.deobfuscators.Confuser,Unpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\Unpacker.cs,GetRevisionRange,The following statement contains a magic number: minRev = 77172;  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,Decode,The following statement contains a magic number: switch (opc) {  case 0x01:  	// ADD Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Add_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x29:  	// SUB Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Sub_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x31:  	// XOR Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Xor_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x58:  // POP EAX  case 0x59:  // POP ECX  case 0x5A:  // POP EDX  case 0x5B:  // POP EBX  case 0x5C:  // POP ESP  case 0x5D:  // POP EBP  case 0x5E:  // POP ESI  case 0x5F:  	// POP EDI  	return new Instruction (OpCode.Pop_R' new RegOperand (opc - 0x58));  case 0x81:  	// Grp1 Ed'Id  	ParseModRM ();  	switch (reg) {  	case 0:  		return new Instruction (OpCode.Add_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	case 5:  		return new Instruction (OpCode.Sub_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	case 6:  		return new Instruction (OpCode.Xor_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	default:  		throw new NotSupportedException ();  	}  case 0x89:  	// MOV Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Mov_RR' new RegOperand (rm)' new RegOperand (reg));  case 0xB8:  // MOV EAX'Id  case 0xB9:  // MOV ECX'Id  case 0xBA:  // MOV EDX'Id  case 0xBB:  // MOV EBX'Id  case 0xBC:  // MOV ESP'Id  case 0xBD:  // MOV EBP'Id  case 0xBE:  // MOV ESI'Id  case 0xBF:  	// MOV EDI'Id  	return new Instruction (OpCode.Mov_RI' new RegOperand (opc - 0xB8)' new ImmOperand (reader.ReadInt32 ()));  case 0xF7:  	// Grp3 Ev  	ParseModRM ();  	switch (reg) {  	case 2:  		return new Instruction (OpCode.Not_R' new RegOperand (rm));  	case 3:  		return new Instruction (OpCode.Neg_R' new RegOperand (rm));  	default:  		throw new NotSupportedException ();  	}  default:  	throw new NotSupportedException (string.Format ("Invalid opcode: {0:X2}"' opc));  }  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,Decode,The following statement contains a magic number: switch (opc) {  case 0x01:  	// ADD Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Add_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x29:  	// SUB Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Sub_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x31:  	// XOR Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Xor_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x58:  // POP EAX  case 0x59:  // POP ECX  case 0x5A:  // POP EDX  case 0x5B:  // POP EBX  case 0x5C:  // POP ESP  case 0x5D:  // POP EBP  case 0x5E:  // POP ESI  case 0x5F:  	// POP EDI  	return new Instruction (OpCode.Pop_R' new RegOperand (opc - 0x58));  case 0x81:  	// Grp1 Ed'Id  	ParseModRM ();  	switch (reg) {  	case 0:  		return new Instruction (OpCode.Add_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	case 5:  		return new Instruction (OpCode.Sub_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	case 6:  		return new Instruction (OpCode.Xor_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	default:  		throw new NotSupportedException ();  	}  case 0x89:  	// MOV Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Mov_RR' new RegOperand (rm)' new RegOperand (reg));  case 0xB8:  // MOV EAX'Id  case 0xB9:  // MOV ECX'Id  case 0xBA:  // MOV EDX'Id  case 0xBB:  // MOV EBX'Id  case 0xBC:  // MOV ESP'Id  case 0xBD:  // MOV EBP'Id  case 0xBE:  // MOV ESI'Id  case 0xBF:  	// MOV EDI'Id  	return new Instruction (OpCode.Mov_RI' new RegOperand (opc - 0xB8)' new ImmOperand (reader.ReadInt32 ()));  case 0xF7:  	// Grp3 Ev  	ParseModRM ();  	switch (reg) {  	case 2:  		return new Instruction (OpCode.Not_R' new RegOperand (rm));  	case 3:  		return new Instruction (OpCode.Neg_R' new RegOperand (rm));  	default:  		throw new NotSupportedException ();  	}  default:  	throw new NotSupportedException (string.Format ("Invalid opcode: {0:X2}"' opc));  }  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,Decode,The following statement contains a magic number: switch (opc) {  case 0x01:  	// ADD Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Add_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x29:  	// SUB Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Sub_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x31:  	// XOR Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Xor_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x58:  // POP EAX  case 0x59:  // POP ECX  case 0x5A:  // POP EDX  case 0x5B:  // POP EBX  case 0x5C:  // POP ESP  case 0x5D:  // POP EBP  case 0x5E:  // POP ESI  case 0x5F:  	// POP EDI  	return new Instruction (OpCode.Pop_R' new RegOperand (opc - 0x58));  case 0x81:  	// Grp1 Ed'Id  	ParseModRM ();  	switch (reg) {  	case 0:  		return new Instruction (OpCode.Add_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	case 5:  		return new Instruction (OpCode.Sub_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	case 6:  		return new Instruction (OpCode.Xor_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	default:  		throw new NotSupportedException ();  	}  case 0x89:  	// MOV Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Mov_RR' new RegOperand (rm)' new RegOperand (reg));  case 0xB8:  // MOV EAX'Id  case 0xB9:  // MOV ECX'Id  case 0xBA:  // MOV EDX'Id  case 0xBB:  // MOV EBX'Id  case 0xBC:  // MOV ESP'Id  case 0xBD:  // MOV EBP'Id  case 0xBE:  // MOV ESI'Id  case 0xBF:  	// MOV EDI'Id  	return new Instruction (OpCode.Mov_RI' new RegOperand (opc - 0xB8)' new ImmOperand (reader.ReadInt32 ()));  case 0xF7:  	// Grp3 Ev  	ParseModRM ();  	switch (reg) {  	case 2:  		return new Instruction (OpCode.Not_R' new RegOperand (rm));  	case 3:  		return new Instruction (OpCode.Neg_R' new RegOperand (rm));  	default:  		throw new NotSupportedException ();  	}  default:  	throw new NotSupportedException (string.Format ("Invalid opcode: {0:X2}"' opc));  }  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,Decode,The following statement contains a magic number: switch (opc) {  case 0x01:  	// ADD Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Add_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x29:  	// SUB Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Sub_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x31:  	// XOR Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Xor_RR' new RegOperand (rm)' new RegOperand (reg));  case 0x58:  // POP EAX  case 0x59:  // POP ECX  case 0x5A:  // POP EDX  case 0x5B:  // POP EBX  case 0x5C:  // POP ESP  case 0x5D:  // POP EBP  case 0x5E:  // POP ESI  case 0x5F:  	// POP EDI  	return new Instruction (OpCode.Pop_R' new RegOperand (opc - 0x58));  case 0x81:  	// Grp1 Ed'Id  	ParseModRM ();  	switch (reg) {  	case 0:  		return new Instruction (OpCode.Add_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	case 5:  		return new Instruction (OpCode.Sub_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	case 6:  		return new Instruction (OpCode.Xor_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  	default:  		throw new NotSupportedException ();  	}  case 0x89:  	// MOV Ed'Gd  	ParseModRM ();  	return new Instruction (OpCode.Mov_RR' new RegOperand (rm)' new RegOperand (reg));  case 0xB8:  // MOV EAX'Id  case 0xB9:  // MOV ECX'Id  case 0xBA:  // MOV EDX'Id  case 0xBB:  // MOV EBX'Id  case 0xBC:  // MOV ESP'Id  case 0xBD:  // MOV EBP'Id  case 0xBE:  // MOV ESI'Id  case 0xBF:  	// MOV EDI'Id  	return new Instruction (OpCode.Mov_RI' new RegOperand (opc - 0xB8)' new ImmOperand (reader.ReadInt32 ()));  case 0xF7:  	// Grp3 Ev  	ParseModRM ();  	switch (reg) {  	case 2:  		return new Instruction (OpCode.Not_R' new RegOperand (rm));  	case 3:  		return new Instruction (OpCode.Neg_R' new RegOperand (rm));  	default:  		throw new NotSupportedException ();  	}  default:  	throw new NotSupportedException (string.Format ("Invalid opcode: {0:X2}"' opc));  }  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,Decode,The following statement contains a magic number: switch (reg) {  case 0:  	return new Instruction (OpCode.Add_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  case 5:  	return new Instruction (OpCode.Sub_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  case 6:  	return new Instruction (OpCode.Xor_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  default:  	throw new NotSupportedException ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,Decode,The following statement contains a magic number: switch (reg) {  case 0:  	return new Instruction (OpCode.Add_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  case 5:  	return new Instruction (OpCode.Sub_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  case 6:  	return new Instruction (OpCode.Xor_RI' new RegOperand (rm)' new ImmOperand (reader.ReadInt32 ()));  default:  	throw new NotSupportedException ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,Decode,The following statement contains a magic number: switch (reg) {  case 2:  	return new Instruction (OpCode.Not_R' new RegOperand (rm));  case 3:  	return new Instruction (OpCode.Neg_R' new RegOperand (rm));  default:  	throw new NotSupportedException ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,Decode,The following statement contains a magic number: switch (reg) {  case 2:  	return new Instruction (OpCode.Not_R' new RegOperand (rm));  case 3:  	return new Instruction (OpCode.Neg_R' new RegOperand (rm));  default:  	throw new NotSupportedException ();  }  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,ParseModRM,The following statement contains a magic number: mod = (byte)((modRM >> 6) & 7);  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,ParseModRM,The following statement contains a magic number: mod = (byte)((modRM >> 6) & 7);  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,ParseModRM,The following statement contains a magic number: reg = (byte)((modRM >> 3) & 7);  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,ParseModRM,The following statement contains a magic number: reg = (byte)((modRM >> 3) & 7);  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,ParseModRM,The following statement contains a magic number: rm = (byte)(modRM & 7);  
Magic Number,de4dot.code.deobfuscators.Confuser,x86Emulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\x86Emulator.cs,ParseModRM,The following statement contains a magic number: if (mod != 3)  	throw new ApplicationException ("Memory operand");  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,CheckInitMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj);  	if (instrs == null)  		continue;  	IMethod methodRef;  	var ldftn = instrs [1];  	var newobj = instrs [2];  	methodRef = ldftn.Operand as IMethod;  	if (methodRef == null || !new SigComparer ().Equals (initMethod.DeclaringType' methodRef.DeclaringType))  		continue;  	methodRef = newobj.Operand as IMethod;  	if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,InitializeEmbeddedAssemblies,The following statement contains a magic number: for (int i = 0; i < tmpAssemblyInfos.Length; i += 2) {  	var assemblyName = tmpAssemblyInfos [i];  	var resourceName = tmpAssemblyInfos [i + 1];  	var resource = DotNetUtils.GetResource (module' resourceName) as EmbeddedResource;  	var symbolsResource = DotNetUtils.GetResource (module' resourceName + "#") as EmbeddedResource;  	if (resource == null)  		return null;  	newAssemblyInfos.Add (new AssemblyInfo (assemblyName' resource' symbolsResource));  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,InitializeEmbeddedAssemblies,The following statement contains a magic number: i += 2
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,CheckType,The following statement contains a magic number: if (type.Methods.Count != 7)  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,CheckType,The following statement contains a magic number: if (type.Fields.Count < 1 || type.Fields.Count > 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	infos.Clear ();  	for (int i = 0; i < instrs.Count - 5; i++) {  		int index = i;  		var ldci4_arySize = instrs [index++];  		if (!ldci4_arySize.IsLdcI4 ())  			continue;  		var newarr = instrs [index++];  		if (newarr.OpCode.Code != Code.Newarr)  			continue;  		var arrayType = module.CorLibTypes.GetCorLibTypeSig (newarr.Operand as ITypeDefOrRef);  		if (arrayType == null)  			continue;  		if (instrs [index++].OpCode.Code != Code.Dup)  			continue;  		var ldci4_index = instrs [index++];  		if (!ldci4_index.IsLdcI4 ())  			continue;  		var call = instrs [index++];  		if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  			continue;  		if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (call.Operand as IMethod' methodArray))  			continue;  		if (arrayType.ElementType.GetPrimitiveSize () == -1) {  			Logger.w ("Can't decrypt non-primitive type array in method {0:X8}"' blocks.Method.MDToken.ToInt32 ());  			continue;  		}  		infos.Add (new ArrayInfo (i' index - i' arrayType' ldci4_arySize.GetLdcI4Value ()' ldci4_index.GetLdcI4Value ()));  	}  	infos.Reverse ();  	foreach (var info in infos) {  		var elemSize = info.arrayType.ElementType.GetPrimitiveSize ();  		var decrypted = DecryptArray (info);  		initializedDataCreator.AddInitializeArrayCode (block' info.start' info.len' info.arrayType.ToTypeDefOrRef ()' decrypted);  		Logger.v ("Decrypted {0} array: {1} elements"' info.arrayType.ToString ()' decrypted.Length / elemSize);  	}  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,Deobfuscate,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	int index = i;  	var ldci4_arySize = instrs [index++];  	if (!ldci4_arySize.IsLdcI4 ())  		continue;  	var newarr = instrs [index++];  	if (newarr.OpCode.Code != Code.Newarr)  		continue;  	var arrayType = module.CorLibTypes.GetCorLibTypeSig (newarr.Operand as ITypeDefOrRef);  	if (arrayType == null)  		continue;  	if (instrs [index++].OpCode.Code != Code.Dup)  		continue;  	var ldci4_index = instrs [index++];  	if (!ldci4_index.IsLdcI4 ())  		continue;  	var call = instrs [index++];  	if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  		continue;  	if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (call.Operand as IMethod' methodArray))  		continue;  	if (arrayType.ElementType.GetPrimitiveSize () == -1) {  		Logger.w ("Can't decrypt non-primitive type array in method {0:X8}"' blocks.Method.MDToken.ToInt32 ());  		continue;  	}  	infos.Add (new ArrayInfo (i' index - i' arrayType' ldci4_arySize.GetLdcI4Value ()' ldci4_index.GetLdcI4Value ()));  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,DecryptResourceName,The following statement contains a magic number: while (--len >= 0)  	array [len] = (char)((int)array [len] ^ ((int)coddedBytes [key & 15] | key));  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,DecryptResourceName,The following statement contains a magic number: array [len] = (char)((int)array [len] ^ ((int)coddedBytes [key & 15] | key));  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,DecryptResourceName,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	if (instrs [i].OpCode != OpCodes.Ldstr)  		continue;  	if (!instrs [i + 1].IsLdcI4 ())  		break;  	key = instrs [i + 1].GetLdcI4Value ();  	resourceName = instrs [i].Operand as String;  	cctor = instrs [i + 2].Operand as MethodDef;  	break;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,DecryptResourceName,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	if (instrs [i].OpCode != OpCodes.Ldstr)  		continue;  	if (!instrs [i + 1].IsLdcI4 ())  		break;  	key = instrs [i + 1].GetLdcI4Value ();  	resourceName = instrs [i].Operand as String;  	cctor = instrs [i + 2].Operand as MethodDef;  	break;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,DecryptResourceName,The following statement contains a magic number: cctor = instrs [i + 2].Operand as MethodDef;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundCryptoObfuscatorAttribute || foundObfuscatedSymbols || foundObfuscatorUserString)  	val += 10;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 10;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: if (val.Groups.Count < 2)  	return;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,CheckCryptoObfuscator,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.Namespace != "A")  		continue;  	if (Regex.IsMatch (type.Name.String' "^c[0-9a-f]{32}$"))  		return true;  	else if (Regex.IsMatch (type.Name.String' "^A[A-Z]*$")) {  		if (++matched >= 10)  			return true;  	}  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,CheckCryptoObfuscator,The following statement contains a magic number: if (Regex.IsMatch (type.Name.String' "^c[0-9a-f]{32}$"))  	return true;  else if (Regex.IsMatch (type.Name.String' "^A[A-Z]*$")) {  	if (++matched >= 10)  		return true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,CheckCryptoObfuscator,The following statement contains a magic number: if (Regex.IsMatch (type.Name.String' "^A[A-Z]*$")) {  	if (++matched >= 10)  		return true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,CheckCryptoObfuscator,The following statement contains a magic number: if (++matched >= 10)  	return true;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodBodyReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: ReadExceptionHandlers ((totalSize - 4) / 24);  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodBodyReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: ReadExceptionHandlers ((totalSize - 4) / 24);  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,Check,The following statement contains a magic number: if (type.Fields.Count != 3)  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,GetTokens,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	var ldci4_2 = instrs [i + 1];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	var ldci4_3 = instrs [i + 2];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null)  		continue;  	if (calledMethod != decryptMethod)  		continue;  	delegateToken = ldci4_1.GetLdcI4Value ();  	encMethodToken = ldci4_2.GetLdcI4Value ();  	encDeclaringTypeToken = ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,GetTokens,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	var ldci4_2 = instrs [i + 1];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	var ldci4_3 = instrs [i + 2];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null)  		continue;  	if (calledMethod != decryptMethod)  		continue;  	delegateToken = ldci4_1.GetLdcI4Value ();  	encMethodToken = ldci4_2.GetLdcI4Value ();  	encDeclaringTypeToken = ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,GetTokens,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldci4_1 = instrs [i];  	if (!ldci4_1.IsLdcI4 ())  		continue;  	var ldci4_2 = instrs [i + 1];  	if (!ldci4_2.IsLdcI4 ())  		continue;  	var ldci4_3 = instrs [i + 2];  	if (!ldci4_3.IsLdcI4 ())  		continue;  	var call = instrs [i + 3];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null)  		continue;  	if (calledMethod != decryptMethod)  		continue;  	delegateToken = ldci4_1.GetLdcI4Value ();  	encMethodToken = ldci4_2.GetLdcI4Value ();  	encDeclaringTypeToken = ldci4_3.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Call);  	if (instrs == null)  		continue;  	uint typeToken = (uint)(int)instrs [0].Operand;  	uint methodToken = (uint)(int)instrs [1].Operand;  	uint declaringTypeToken = (uint)(int)instrs [2].Operand;  	var createMethod = instrs [3].Operand as MethodDef;  	ProxyCreatorType proxyCreatorType;  	if (!methodToType.TryGetValue (createMethod' out proxyCreatorType))  		continue;  	return new Context (typeToken' methodToken' declaringTypeToken' proxyCreatorType);  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Call);  	if (instrs == null)  		continue;  	uint typeToken = (uint)(int)instrs [0].Operand;  	uint methodToken = (uint)(int)instrs [1].Operand;  	uint declaringTypeToken = (uint)(int)instrs [2].Operand;  	var createMethod = instrs [3].Operand as MethodDef;  	ProxyCreatorType proxyCreatorType;  	if (!methodToType.TryGetValue (createMethod' out proxyCreatorType))  		continue;  	return new Context (typeToken' methodToken' declaringTypeToken' proxyCreatorType);  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,GetProxyCreateMethod,The following statement contains a magic number: if (type.Fields.Count < 1 || type.Fields.Count > 20)  	return null;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,FindDesktopOrCompactFramework,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.Fields.Count < 5)  		continue;  	if (!new FieldTypes (type).All (requiredTypes))  		continue;  	var cctor = type.FindStaticConstructor ();  	if (cctor == null)  		continue;  	if (!CheckCctor (cctor))  		continue;  	resourceDecrypterType = type;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,FindDesktopOrCompactFramework,The following statement contains a magic number: if (type.Fields.Count < 5)  	continue;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,InitializeHeaderInfo,The following statement contains a magic number: deflatedFlag = 2;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,InitializeHeaderInfo,The following statement contains a magic number: bitwiseNotEncryptedFlag = 4;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following statement contains a magic number: if (method == null || method.Body == null || method.Body.Variables.Count < 3)  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following statement contains a magic number: for (int i = 2; i < instructions.Count; i++) {  	var and = instructions [i];  	if (and.OpCode.Code != Code.And)  		continue;  	var ldci4 = instructions [i - 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	int flagValue = ldci4.GetLdcI4Value ();  	if (!IsFlag (flagValue))  		continue;  	var ldloc = instructions [i - 2];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local.Type.GetElementType ().GetPrimitiveSize () < 0)  		continue;  	constants.Add (flagValue);  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following statement contains a magic number: for (int i = 2; i < instructions.Count; i++) {  	var and = instructions [i];  	if (and.OpCode.Code != Code.And)  		continue;  	var ldci4 = instructions [i - 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	int flagValue = ldci4.GetLdcI4Value ();  	if (!IsFlag (flagValue))  		continue;  	var ldloc = instructions [i - 2];  	if (!ldloc.IsLdloc ())  		continue;  	var local = ldloc.GetLocal (method.Body.Variables);  	if (local.Type.GetElementType ().GetPrimitiveSize () < 0)  		continue;  	constants.Add (flagValue);  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following statement contains a magic number: switch (frameworkType) {  case FrameworkType.Desktop:  	if (!module.IsClr1x) {  		if (constants.Count == 2) {  			desEncryptedFlag = (byte)constants [0];  			deflatedFlag = (byte)constants [1];  			return true;  		}  	}  	if (constants.Count == 1) {  		desEncryptedFlag = (byte)constants [0];  		return true;  	}  	break;  case FrameworkType.Silverlight:  	if (constants.Count == 1) {  		bitwiseNotEncryptedFlag = (byte)constants [0];  		return true;  	}  	break;  case FrameworkType.CompactFramework:  	if (constants.Count == 1) {  		desEncryptedFlag = (byte)constants [0];  		return true;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following statement contains a magic number: if (!module.IsClr1x) {  	if (constants.Count == 2) {  		desEncryptedFlag = (byte)constants [0];  		deflatedFlag = (byte)constants [1];  		return true;  	}  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following statement contains a magic number: if (constants.Count == 2) {  	desEncryptedFlag = (byte)constants [0];  	deflatedFlag = (byte)constants [1];  	return true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,GetHeaderSkipBytes,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	int loopCount = ldci4.GetLdcI4Value ();  	if (loopCount < 2 || loopCount > 4)  		continue;  	var blt = instrs [i + 1];  	if (blt.OpCode.Code != Code.Blt && blt.OpCode.Code != Code.Blt_S && blt.OpCode.Code != Code.Clt)  		continue;  	index = i;  	return loopCount - 1;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,GetHeaderSkipBytes,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	int loopCount = ldci4.GetLdcI4Value ();  	if (loopCount < 2 || loopCount > 4)  		continue;  	var blt = instrs [i + 1];  	if (blt.OpCode.Code != Code.Blt && blt.OpCode.Code != Code.Blt_S && blt.OpCode.Code != Code.Clt)  		continue;  	index = i;  	return loopCount - 1;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,GetHeaderSkipBytes,The following statement contains a magic number: if (loopCount < 2 || loopCount > 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,GetHeaderSkipBytes,The following statement contains a magic number: if (loopCount < 2 || loopCount > 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: if ((flags & desEncryptedFlag) != 0) {  	var memStream = new MemoryStream ((int)resourceStream.Length);  	using (var provider = new DESCryptoServiceProvider ()) {  		var iv = new byte[8];  		sourceStream.Read (iv' 0' 8);  		provider.IV = iv;  		provider.Key = GetKey (sourceStream);  		using (var transform = provider.CreateDecryptor ()) {  			while (true) {  				int count = sourceStream.Read (buffer1' 0' buffer1.Length);  				if (count <= 0)  					break;  				int count2 = transform.TransformBlock (buffer1' 0' count' buffer2' 0);  				memStream.Write (buffer2' 0' count2);  			}  			var finalData = transform.TransformFinalBlock (buffer1' 0' 0);  			memStream.Write (finalData' 0' finalData.Length);  		}  	}  	sourceStream = memStream;  	sourceStreamOffset = 0;  	didSomething = true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: if ((flags & desEncryptedFlag) != 0) {  	var memStream = new MemoryStream ((int)resourceStream.Length);  	using (var provider = new DESCryptoServiceProvider ()) {  		var iv = new byte[8];  		sourceStream.Read (iv' 0' 8);  		provider.IV = iv;  		provider.Key = GetKey (sourceStream);  		using (var transform = provider.CreateDecryptor ()) {  			while (true) {  				int count = sourceStream.Read (buffer1' 0' buffer1.Length);  				if (count <= 0)  					break;  				int count2 = transform.TransformBlock (buffer1' 0' count' buffer2' 0);  				memStream.Write (buffer2' 0' count2);  			}  			var finalData = transform.TransformFinalBlock (buffer1' 0' 0);  			memStream.Write (finalData' 0' finalData.Length);  		}  	}  	sourceStream = memStream;  	sourceStreamOffset = 0;  	didSomething = true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: using (var provider = new DESCryptoServiceProvider ()) {  	var iv = new byte[8];  	sourceStream.Read (iv' 0' 8);  	provider.IV = iv;  	provider.Key = GetKey (sourceStream);  	using (var transform = provider.CreateDecryptor ()) {  		while (true) {  			int count = sourceStream.Read (buffer1' 0' buffer1.Length);  			if (count <= 0)  				break;  			int count2 = transform.TransformBlock (buffer1' 0' count' buffer2' 0);  			memStream.Write (buffer2' 0' count2);  		}  		var finalData = transform.TransformFinalBlock (buffer1' 0' 0);  		memStream.Write (finalData' 0' finalData.Length);  	}  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: using (var provider = new DESCryptoServiceProvider ()) {  	var iv = new byte[8];  	sourceStream.Read (iv' 0' 8);  	provider.IV = iv;  	provider.Key = GetKey (sourceStream);  	using (var transform = provider.CreateDecryptor ()) {  		while (true) {  			int count = sourceStream.Read (buffer1' 0' buffer1.Length);  			if (count <= 0)  				break;  			int count2 = transform.TransformBlock (buffer1' 0' count' buffer2' 0);  			memStream.Write (buffer2' 0' count2);  		}  		var finalData = transform.TransformFinalBlock (buffer1' 0' 0);  		memStream.Write (finalData' 0' finalData.Length);  	}  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: sourceStream.Read (iv' 0' 8);  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,CheckSetupMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj);  	if (instrs == null)  		continue;  	IMethod methodRef;  	var ldftn = instrs [1];  	var newobj = instrs [2];  	methodRef = ldftn.Operand as IMethod;  	if (methodRef == null || !new SigComparer ().Equals (setupMethod.DeclaringType' methodRef.DeclaringType))  		continue;  	methodRef = newobj.Operand as IMethod;  	if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  		continue;  	foundCount++;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,CheckSetupMethod,The following statement contains a magic number: switch (foundCount) {  case 1:  	return ResolverVersion.V1;  case 2:  	return ResolverVersion.V2;  default:  	return ResolverVersion.None;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,FindStringDecrypterType,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.IsPublic)  		continue;  	if (type.Fields.Count != 1)  		continue;  	if (DotNetUtils.FindFieldType (type' "System.Byte[]"' true) == null)  		continue;  	if (type.Methods.Count != 2 && type.Methods.Count != 3)  		continue;  	if (type.NestedTypes.Count > 0)  		continue;  	MethodDef method = null;  	foreach (var m in type.Methods) {  		if (m.Name == ".ctor" || m.Name == ".cctor")  			continue;  		if (DotNetUtils.IsMethod (m' "System.String"' "(System.Int32)")) {  			method = m;  			continue;  		}  		break;  	}  	if (method == null)  		continue;  	theType = type;  	theMethod = method;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,FindStringDecrypterType,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.IsPublic)  		continue;  	if (type.Fields.Count != 1)  		continue;  	if (DotNetUtils.FindFieldType (type' "System.Byte[]"' true) == null)  		continue;  	if (type.Methods.Count != 2 && type.Methods.Count != 3)  		continue;  	if (type.NestedTypes.Count > 0)  		continue;  	MethodDef method = null;  	foreach (var m in type.Methods) {  		if (m.Name == ".ctor" || m.Name == ".cctor")  			continue;  		if (DotNetUtils.IsMethod (m' "System.String"' "(System.Int32)")) {  			method = m;  			continue;  		}  		break;  	}  	if (method == null)  		continue;  	theType = type;  	theMethod = method;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,FindStringDecrypterType,The following statement contains a magic number: if (type.Methods.Count != 2 && type.Methods.Count != 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,FindStringDecrypterType,The following statement contains a magic number: if (type.Methods.Count != 2 && type.Methods.Count != 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (type.Methods.Count < 3 || type.Methods.Count > 31)  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (type.Methods.Count < 3 || type.Methods.Count > 31)  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (DotNetUtils.GetPInvokeMethod (type' "mscoree"' "StrongNameSignatureVerificationEx") != null) {  } else if (DotNetUtils.GetPInvokeMethod (type' "mscoree"' "CLRCreateInstance") != null) {  	if (type.NestedTypes.Count != 3)  		return false;  	if (!type.NestedTypes [0].IsInterface || !type.NestedTypes [1].IsInterface || !type.NestedTypes [2].IsInterface)  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (DotNetUtils.GetPInvokeMethod (type' "mscoree"' "StrongNameSignatureVerificationEx") != null) {  } else if (DotNetUtils.GetPInvokeMethod (type' "mscoree"' "CLRCreateInstance") != null) {  	if (type.NestedTypes.Count != 3)  		return false;  	if (!type.NestedTypes [0].IsInterface || !type.NestedTypes [1].IsInterface || !type.NestedTypes [2].IsInterface)  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (DotNetUtils.GetPInvokeMethod (type' "mscoree"' "CLRCreateInstance") != null) {  	if (type.NestedTypes.Count != 3)  		return false;  	if (!type.NestedTypes [0].IsInterface || !type.NestedTypes [1].IsInterface || !type.NestedTypes [2].IsInterface)  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (DotNetUtils.GetPInvokeMethod (type' "mscoree"' "CLRCreateInstance") != null) {  	if (type.NestedTypes.Count != 3)  		return false;  	if (!type.NestedTypes [0].IsInterface || !type.NestedTypes [1].IsInterface || !type.NestedTypes [2].IsInterface)  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (type.NestedTypes.Count != 3)  	return false;  
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,FindDesktop,The following statement contains a magic number: if (!type.NestedTypes [0].IsInterface || !type.NestedTypes [1].IsInterface || !type.NestedTypes [2].IsInterface)  	return false;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate1,The following statement contains a magic number: if (i >= instrs.Count - 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate1,The following statement contains a magic number: block.Remove (i' 3 - 1);  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate2,The following statement contains a magic number: if (i >= instrs.Count - 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate2,The following statement contains a magic number: block.Remove (i' 3 - 1);  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,Deobfuscate3,The following statement contains a magic number: i += 2;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var ldci4 = instructions [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	i++;  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  	if (instrs == null)  		continue;  	var arrayInitField = instrs [2].Operand as FieldDef;  	if (arrayInitField == null || arrayInitField.InitialValue == null || arrayInitField.InitialValue.Length == 0)  		continue;  	var calledMethod = instrs [3].Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  		continue;  	var targetField = instrs [4].Operand as FieldDef;  	if (targetField == null || targetField.FieldType.GetElementType () != ElementType.SZArray)  		continue;  	var etype = ((SZArraySig)targetField.FieldType).Next.GetElementType ();  	if (etype < ElementType.Boolean || etype > ElementType.U4)  		continue;  	if (fieldToInfo.Find (targetField) == null) {  		fieldToInfo.Add (targetField' new FieldInfo (targetField' arrayInitField));  		foundField = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var ldci4 = instructions [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	i++;  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  	if (instrs == null)  		continue;  	var arrayInitField = instrs [2].Operand as FieldDef;  	if (arrayInitField == null || arrayInitField.InitialValue == null || arrayInitField.InitialValue.Length == 0)  		continue;  	var calledMethod = instrs [3].Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  		continue;  	var targetField = instrs [4].Operand as FieldDef;  	if (targetField == null || targetField.FieldType.GetElementType () != ElementType.SZArray)  		continue;  	var etype = ((SZArraySig)targetField.FieldType).Next.GetElementType ();  	if (etype < ElementType.Boolean || etype > ElementType.U4)  		continue;  	if (fieldToInfo.Find (targetField) == null) {  		fieldToInfo.Add (targetField' new FieldInfo (targetField' arrayInitField));  		foundField = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,InitializeArrays2,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var ldci4 = instructions [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	i++;  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  	if (instrs == null)  		continue;  	var arrayInitField = instrs [2].Operand as FieldDef;  	if (arrayInitField == null || arrayInitField.InitialValue == null || arrayInitField.InitialValue.Length == 0)  		continue;  	var calledMethod = instrs [3].Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  		continue;  	var targetField = instrs [4].Operand as FieldDef;  	if (targetField == null || targetField.FieldType.GetElementType () != ElementType.SZArray)  		continue;  	var etype = ((SZArraySig)targetField.FieldType).Next.GetElementType ();  	if (etype < ElementType.Boolean || etype > ElementType.U4)  		continue;  	if (fieldToInfo.Find (targetField) == null) {  		fieldToInfo.Add (targetField' new FieldInfo (targetField' arrayInitField));  		foundField = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldci4 = instrs [i];  		if (!ldci4.IsLdcI4 ())  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Newarr)  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Dup)  			continue;  		var ldtoken = instrs [i + 3];  		if (ldtoken.OpCode.Code != Code.Ldtoken)  			continue;  		if (ldtoken.Operand != info.arrayInitField)  			continue;  		var call = instrs [i + 4];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  			continue;  		var stsfld = instrs [i + 5];  		if (stsfld.OpCode.Code != Code.Stsfld)  			continue;  		if (stsfld.Operand != info.field)  			continue;  		block.Remove (i' 6);  		i--;  		removedSomething = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldci4 = instrs [i];  		if (!ldci4.IsLdcI4 ())  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Newarr)  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Dup)  			continue;  		var ldtoken = instrs [i + 3];  		if (ldtoken.OpCode.Code != Code.Ldtoken)  			continue;  		if (ldtoken.Operand != info.arrayInitField)  			continue;  		var call = instrs [i + 4];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  			continue;  		var stsfld = instrs [i + 5];  		if (stsfld.OpCode.Code != Code.Stsfld)  			continue;  		if (stsfld.Operand != info.field)  			continue;  		block.Remove (i' 6);  		i--;  		removedSomething = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldci4 = instrs [i];  		if (!ldci4.IsLdcI4 ())  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Newarr)  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Dup)  			continue;  		var ldtoken = instrs [i + 3];  		if (ldtoken.OpCode.Code != Code.Ldtoken)  			continue;  		if (ldtoken.Operand != info.arrayInitField)  			continue;  		var call = instrs [i + 4];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  			continue;  		var stsfld = instrs [i + 5];  		if (stsfld.OpCode.Code != Code.Stsfld)  			continue;  		if (stsfld.Operand != info.field)  			continue;  		block.Remove (i' 6);  		i--;  		removedSomething = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldci4 = instrs [i];  		if (!ldci4.IsLdcI4 ())  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Newarr)  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Dup)  			continue;  		var ldtoken = instrs [i + 3];  		if (ldtoken.OpCode.Code != Code.Ldtoken)  			continue;  		if (ldtoken.Operand != info.arrayInitField)  			continue;  		var call = instrs [i + 4];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  			continue;  		var stsfld = instrs [i + 5];  		if (stsfld.OpCode.Code != Code.Stsfld)  			continue;  		if (stsfld.Operand != info.field)  			continue;  		block.Remove (i' 6);  		i--;  		removedSomething = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldci4 = instrs [i];  		if (!ldci4.IsLdcI4 ())  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Newarr)  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Dup)  			continue;  		var ldtoken = instrs [i + 3];  		if (ldtoken.OpCode.Code != Code.Ldtoken)  			continue;  		if (ldtoken.Operand != info.arrayInitField)  			continue;  		var call = instrs [i + 4];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  			continue;  		var stsfld = instrs [i + 5];  		if (stsfld.OpCode.Code != Code.Stsfld)  			continue;  		if (stsfld.Operand != info.field)  			continue;  		block.Remove (i' 6);  		i--;  		removedSomething = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 5; i++) {  		var ldci4 = instrs [i];  		if (!ldci4.IsLdcI4 ())  			continue;  		if (instrs [i + 1].OpCode.Code != Code.Newarr)  			continue;  		if (instrs [i + 2].OpCode.Code != Code.Dup)  			continue;  		var ldtoken = instrs [i + 3];  		if (ldtoken.OpCode.Code != Code.Ldtoken)  			continue;  		if (ldtoken.Operand != info.arrayInitField)  			continue;  		var call = instrs [i + 4];  		if (call.OpCode.Code != Code.Call)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  			continue;  		var stsfld = instrs [i + 5];  		if (stsfld.OpCode.Code != Code.Stsfld)  			continue;  		if (stsfld.Operand != info.field)  			continue;  		block.Remove (i' 6);  		i--;  		removedSomething = true;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Newarr)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Dup)  		continue;  	var ldtoken = instrs [i + 3];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	if (ldtoken.Operand != info.arrayInitField)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  		continue;  	var stsfld = instrs [i + 5];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	if (stsfld.Operand != info.field)  		continue;  	block.Remove (i' 6);  	i--;  	removedSomething = true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Newarr)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Dup)  		continue;  	var ldtoken = instrs [i + 3];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	if (ldtoken.Operand != info.arrayInitField)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  		continue;  	var stsfld = instrs [i + 5];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	if (stsfld.Operand != info.field)  		continue;  	block.Remove (i' 6);  	i--;  	removedSomething = true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Newarr)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Dup)  		continue;  	var ldtoken = instrs [i + 3];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	if (ldtoken.Operand != info.arrayInitField)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  		continue;  	var stsfld = instrs [i + 5];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	if (stsfld.Operand != info.field)  		continue;  	block.Remove (i' 6);  	i--;  	removedSomething = true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Newarr)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Dup)  		continue;  	var ldtoken = instrs [i + 3];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	if (ldtoken.Operand != info.arrayInitField)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  		continue;  	var stsfld = instrs [i + 5];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	if (stsfld.Operand != info.field)  		continue;  	block.Remove (i' 6);  	i--;  	removedSomething = true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Newarr)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Dup)  		continue;  	var ldtoken = instrs [i + 3];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	if (ldtoken.Operand != info.arrayInitField)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  		continue;  	var stsfld = instrs [i + 5];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	if (stsfld.Operand != info.field)  		continue;  	block.Remove (i' 6);  	i--;  	removedSomething = true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 5; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Newarr)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Dup)  		continue;  	var ldtoken = instrs [i + 3];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	if (ldtoken.Operand != info.arrayInitField)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  		continue;  	var stsfld = instrs [i + 5];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	if (stsfld.Operand != info.field)  		continue;  	block.Remove (i' 6);  	i--;  	removedSomething = true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Dup)  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,RemoveInitCode,The following statement contains a magic number: block.Remove (i' 6);  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV3SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Add)  		continue;  	if (!instrs [i + 2].IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.And)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV3SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Add)  		continue;  	if (!instrs [i + 2].IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.And)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV3SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	if (!instrs [i].IsLdloc ())  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Add)  		continue;  	if (!instrs [i + 2].IsLdcI4 ())  		continue;  	if (instrs [i + 3].OpCode.Code != Code.And)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV3SL,The following statement contains a magic number: if (!instrs [i + 2].IsLdcI4 ())  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV3SL,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.And)  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 5)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.And)  		continue;  	if (!instrs [i + 2].IsLdcI4 () || instrs [i + 2].GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.And)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 5)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.And)  		continue;  	if (!instrs [i + 2].IsLdcI4 () || instrs [i + 2].GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.And)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 5)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.And)  		continue;  	if (!instrs [i + 2].IsLdcI4 () || instrs [i + 2].GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.And)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 5)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.And)  		continue;  	if (!instrs [i + 2].IsLdcI4 () || instrs [i + 2].GetLdcI4Value () != 0x1F)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.And)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: if (!instrs [i].IsLdcI4 () || instrs [i].GetLdcI4Value () != 5)  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: if (!instrs [i + 2].IsLdcI4 () || instrs [i + 2].GetLdcI4Value () != 0x1F)  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: if (!instrs [i + 2].IsLdcI4 () || instrs [i + 2].GetLdcI4Value () != 0x1F)  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,IsV41SL,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.And)  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckHandlerV4,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	int index = i;  	var ldtoken = instrs [index++];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var field = ldtoken.Operand as FieldDef;  	if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)  		return false;  	var ldci4_len = instrs [index++];  	if (!ldci4_len.IsLdcI4 ())  		return false;  	if (ldci4_len.GetLdcI4Value () != field.InitialValue.Length)  		return false;  	var ldci4_magic = instrs [index++];  	if (!ldci4_magic.IsLdcI4 ())  		return false;  	int magic = ldci4_magic.GetLdcI4Value ();  	var call = instrs [index++];  	if (call.OpCode.Code == Code.Tailcall)  		call = instrs [index++];  	if (call.OpCode.Code != Code.Call)  		return false;  	var decryptMethodTmp = call.Operand as MethodDef;  	if (!DotNetUtils.IsMethod (decryptMethodTmp' "System.Reflection.Assembly"' "(System.RuntimeFieldHandle'System.Int32'System.Int32)"))  		return false;  	decryptMethod = decryptMethodTmp;  	fieldInfos.Add (new FieldInfo (field' magic));  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,CheckHandlerV404_41,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  	int index = i;  	var ldci4_len = instrs [index++];  	if (!ldci4_len.IsLdcI4 ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Newarr)  		continue;  	if (!instrs [index++].IsStloc ())  		continue;  	if (!instrs [index++].IsLdloc ())  		continue;  	var ldtoken = instrs [index++];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var field = ldtoken.Operand as FieldDef;  	if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)  		continue;  	var call1 = instrs [index++];  	if (call1.OpCode.Code != Code.Call)  		continue;  	if (!DotNetUtils.IsMethod (call1.Operand as IMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  		continue;  	int callIndex = GetCallDecryptMethodIndex (instrs' index);  	if (callIndex < 0)  		continue;  	var args = DsUtils.GetArgValues (instrs' callIndex);  	if (args == null)  		continue;  	var decryptMethodTmp = instrs [callIndex].Operand as MethodDef;  	if (decryptMethodTmp == null)  		continue;  	int magic;  	Version versionTmp;  	GetMagic (decryptMethodTmp' args' out versionTmp' out magic);  	version = versionTmp;  	decryptMethod = decryptMethodTmp;  	fieldInfos.Add (new FieldInfo (field' magic));  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,GetMagicIndex404,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	int index = i;  	if (!instrs [index++].IsLdloc ())  		continue;  	var ldarg = instrs [index++];  	if (!ldarg.IsLdarg ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Add)  		continue;  	var ldci4 = instrs [index++];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (ldci4.GetLdcI4Value () != 0xFF)  		continue;  	return ldarg.GetParameterIndex ();  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,GetMagicIndex41Trial,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	int index = i;  	if (instrs [index++].OpCode.Code != Code.Div)  		continue;  	var ldarg = instrs [index++];  	if (!ldarg.IsLdarg ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Add)  		continue;  	var ldci4 = instrs [index++];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (ldci4.GetLdcI4Value () != 0xFF)  		continue;  	return ldarg.GetParameterIndex ();  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,GetCallDecryptMethodIndex,The following statement contains a magic number: for (int i = index - 1; i >= 0; i--) {  	var instr = instrs [i];  	if (!IsCallOrNext (instr))  		break;  	if (instr.OpCode.Code != Code.Call)  		continue;  	var calledMethod = instr.Operand as IMethod;  	if (calledMethod == null || calledMethod.MethodSig.GetParamCount () < 2)  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,GetCallDecryptMethodIndex,The following statement contains a magic number: if (calledMethod == null || calledMethod.MethodSig.GetParamCount () < 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,Decrypt41Trial,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)  	data [i] ^= (byte)(i / 3 + magic);  
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,Decrypt41Trial,The following statement contains a magic number: data [i] ^= (byte)(i / 3 + magic);  
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectMethodProxyObfuscation,The following statement contains a magic number: foreach (var type in module.GetTypes ()) {  	foreach (var method in type.Methods) {  		if (foundProxies >= MIN_FOUND_PROXIES)  			goto done;  		if (!method.IsStatic || method.Body == null)  			continue;  		if (checkedMethods++ >= 1000)  			goto done;  		if (!DsMethodCallInliner.CanInline (method))  			continue;  		foundProxies++;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectMethodProxyObfuscation,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (foundProxies >= MIN_FOUND_PROXIES)  		goto done;  	if (!method.IsStatic || method.Body == null)  		continue;  	if (checkedMethods++ >= 1000)  		goto done;  	if (!DsMethodCallInliner.CanInline (method))  		continue;  	foundProxies++;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectMethodProxyObfuscation,The following statement contains a magic number: if (checkedMethods++ >= 1000)  	goto done;  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,InlineMethod,The following statement contains a magic number: if (instrIndex < 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,InlineMethod,The following statement contains a magic number: arg1 = parameters [parameters.Count - 2];  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,EmulateInstructions,The following statement contains a magic number: while (true) {  	if (counter++ >= 50)  		return false;  	if (index < 0 || index >= instrs.Count)  		return false;  	instr = instrs [index];  	foundOpCodes [instr.OpCode.Code] = true;  	switch (instr.OpCode.Code) {  	case Code.Stloc:  	case Code.Stloc_S:  	case Code.Stloc_0:  	case Code.Stloc_1:  	case Code.Stloc_2:  	case Code.Stloc_3:  	case Code.Ldloc:  	case Code.Ldloc_S:  	case Code.Ldloc_0:  	case Code.Ldloc_1:  	case Code.Ldloc_2:  	case Code.Ldloc_3:  	case Code.Ldc_I4:  	case Code.Ldc_I4_0:  	case Code.Ldc_I4_1:  	case Code.Ldc_I4_2:  	case Code.Ldc_I4_3:  	case Code.Ldc_I4_4:  	case Code.Ldc_I4_5:  	case Code.Ldc_I4_6:  	case Code.Ldc_I4_7:  	case Code.Ldc_I4_8:  	case Code.Ldc_I4_M1:  	case Code.Ldc_I4_S:  	case Code.Add:  	case Code.Sub:  	case Code.Xor:  	case Code.Or:  	case Code.Nop:  	case Code.Dup:  	case Code.Mul:  	case Code.Rem:  	case Code.Div:  		instructionEmulator.Emulate (instr);  		index++;  		break;  	case Code.Ldarg:  	case Code.Ldarg_S:  	case Code.Ldarg_0:  	case Code.Ldarg_1:  	case Code.Ldarg_2:  	case Code.Ldarg_3:  		var arg = instr.GetParameter (parameters);  		if (arg != arg1 && arg != arg2) {  			if (!allowUnknownArgs)  				goto done;  			checkInstrs = true;  		}  		instructionEmulator.Emulate (instr);  		index++;  		break;  	case Code.Call:  	case Code.Callvirt:  	case Code.Newobj:  		goto done;  	case Code.Switch:  		var value = instructionEmulator.Pop () as Int32Value;  		if (value == null || !value.AllBitsValid ())  			return false;  		var targets = (Instruction[])instr.Operand;  		if (value.Value >= 0 && value.Value < targets.Length)  			index = instrs.IndexOf (targets [value.Value]);  		else  			index++;  		break;  	case Code.Br:  	case Code.Br_S:  		index = instrs.IndexOf ((Instruction)instr.Operand);  		break;  	case Code.Brtrue:  	case Code.Brtrue_S:  		index = EmulateBrtrue (index);  		break;  	case Code.Brfalse:  	case Code.Brfalse_S:  		index = EmulateBrfalse (index);  		break;  	case Code.Isinst:  	case Code.Castclass:  		if (returnValue != null && instructionEmulator.Peek () == returnValue) {  			// Do nothing  		} else  			instructionEmulator.Emulate (instr);  		index++;  		break;  	default:  		if (instr.OpCode.OpCodeType != OpCodeType.Prefix)  			goto done;  		index++;  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,EmulateInstructions,The following statement contains a magic number: if (counter++ >= 50)  	return false;  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,CanInline,The following statement contains a magic number: if (paramCount < 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_M1:  	arg = -1;  	return true;  case Code.Ldc_I4_0:  	arg = 0;  	return true;  case Code.Ldc_I4_1:  	arg = 1;  	return true;  case Code.Ldc_I4_2:  	arg = 2;  	return true;  case Code.Ldc_I4_3:  	arg = 3;  	return true;  case Code.Ldc_I4_4:  	arg = 4;  	return true;  case Code.Ldc_I4_5:  	arg = 5;  	return true;  case Code.Ldc_I4_6:  	arg = 6;  	return true;  case Code.Ldc_I4_7:  	arg = 7;  	return true;  case Code.Ldc_I4_8:  	arg = 8;  	return true;  case Code.Ldnull:  	arg = null;  	return true;  case Code.Ldstr:  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  	arg = instr.Operand;  	return true;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	arg = null;  	return true;  default:  	arg = null;  	return false;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_M1:  	arg = -1;  	return true;  case Code.Ldc_I4_0:  	arg = 0;  	return true;  case Code.Ldc_I4_1:  	arg = 1;  	return true;  case Code.Ldc_I4_2:  	arg = 2;  	return true;  case Code.Ldc_I4_3:  	arg = 3;  	return true;  case Code.Ldc_I4_4:  	arg = 4;  	return true;  case Code.Ldc_I4_5:  	arg = 5;  	return true;  case Code.Ldc_I4_6:  	arg = 6;  	return true;  case Code.Ldc_I4_7:  	arg = 7;  	return true;  case Code.Ldc_I4_8:  	arg = 8;  	return true;  case Code.Ldnull:  	arg = null;  	return true;  case Code.Ldstr:  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  	arg = instr.Operand;  	return true;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	arg = null;  	return true;  default:  	arg = null;  	return false;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_M1:  	arg = -1;  	return true;  case Code.Ldc_I4_0:  	arg = 0;  	return true;  case Code.Ldc_I4_1:  	arg = 1;  	return true;  case Code.Ldc_I4_2:  	arg = 2;  	return true;  case Code.Ldc_I4_3:  	arg = 3;  	return true;  case Code.Ldc_I4_4:  	arg = 4;  	return true;  case Code.Ldc_I4_5:  	arg = 5;  	return true;  case Code.Ldc_I4_6:  	arg = 6;  	return true;  case Code.Ldc_I4_7:  	arg = 7;  	return true;  case Code.Ldc_I4_8:  	arg = 8;  	return true;  case Code.Ldnull:  	arg = null;  	return true;  case Code.Ldstr:  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  	arg = instr.Operand;  	return true;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	arg = null;  	return true;  default:  	arg = null;  	return false;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_M1:  	arg = -1;  	return true;  case Code.Ldc_I4_0:  	arg = 0;  	return true;  case Code.Ldc_I4_1:  	arg = 1;  	return true;  case Code.Ldc_I4_2:  	arg = 2;  	return true;  case Code.Ldc_I4_3:  	arg = 3;  	return true;  case Code.Ldc_I4_4:  	arg = 4;  	return true;  case Code.Ldc_I4_5:  	arg = 5;  	return true;  case Code.Ldc_I4_6:  	arg = 6;  	return true;  case Code.Ldc_I4_7:  	arg = 7;  	return true;  case Code.Ldc_I4_8:  	arg = 8;  	return true;  case Code.Ldnull:  	arg = null;  	return true;  case Code.Ldstr:  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  	arg = instr.Operand;  	return true;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	arg = null;  	return true;  default:  	arg = null;  	return false;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_M1:  	arg = -1;  	return true;  case Code.Ldc_I4_0:  	arg = 0;  	return true;  case Code.Ldc_I4_1:  	arg = 1;  	return true;  case Code.Ldc_I4_2:  	arg = 2;  	return true;  case Code.Ldc_I4_3:  	arg = 3;  	return true;  case Code.Ldc_I4_4:  	arg = 4;  	return true;  case Code.Ldc_I4_5:  	arg = 5;  	return true;  case Code.Ldc_I4_6:  	arg = 6;  	return true;  case Code.Ldc_I4_7:  	arg = 7;  	return true;  case Code.Ldc_I4_8:  	arg = 8;  	return true;  case Code.Ldnull:  	arg = null;  	return true;  case Code.Ldstr:  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  	arg = instr.Operand;  	return true;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	arg = null;  	return true;  default:  	arg = null;  	return false;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_M1:  	arg = -1;  	return true;  case Code.Ldc_I4_0:  	arg = 0;  	return true;  case Code.Ldc_I4_1:  	arg = 1;  	return true;  case Code.Ldc_I4_2:  	arg = 2;  	return true;  case Code.Ldc_I4_3:  	arg = 3;  	return true;  case Code.Ldc_I4_4:  	arg = 4;  	return true;  case Code.Ldc_I4_5:  	arg = 5;  	return true;  case Code.Ldc_I4_6:  	arg = 6;  	return true;  case Code.Ldc_I4_7:  	arg = 7;  	return true;  case Code.Ldc_I4_8:  	arg = 8;  	return true;  case Code.Ldnull:  	arg = null;  	return true;  case Code.Ldstr:  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  	arg = instr.Operand;  	return true;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	arg = null;  	return true;  default:  	arg = null;  	return false;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldc_I4_S:  	arg = (int)(sbyte)instr.Operand;  	return true;  case Code.Ldc_I4_M1:  	arg = -1;  	return true;  case Code.Ldc_I4_0:  	arg = 0;  	return true;  case Code.Ldc_I4_1:  	arg = 1;  	return true;  case Code.Ldc_I4_2:  	arg = 2;  	return true;  case Code.Ldc_I4_3:  	arg = 3;  	return true;  case Code.Ldc_I4_4:  	arg = 4;  	return true;  case Code.Ldc_I4_5:  	arg = 5;  	return true;  case Code.Ldc_I4_6:  	arg = 6;  	return true;  case Code.Ldc_I4_7:  	arg = 7;  	return true;  case Code.Ldc_I4_8:  	arg = 8;  	return true;  case Code.Ldnull:  	arg = null;  	return true;  case Code.Ldstr:  case Code.Ldc_I4:  case Code.Ldc_I8:  case Code.Ldc_R4:  case Code.Ldc_R8:  	arg = instr.Operand;  	return true;  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  case Code.Ldloc:  case Code.Ldloc_S:  case Code.Ldloc_0:  case Code.Ldloc_1:  case Code.Ldloc_2:  case Code.Ldloc_3:  	arg = null;  	return true;  default:  	arg = null;  	return false;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: arg = 2;  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: arg = 3;  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: arg = 4;  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: arg = 5;  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: arg = 6;  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: arg = 7;  
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,GetArgValue,The following statement contains a magic number: arg = 8;  
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,FixFieldCtorCalls,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count; i++) {  		var stfld = instrs [i];  		if (stfld.OpCode.Code != Code.Stfld)  			continue;  		var field = stfld.Operand as IField;  		if (field == null)  			continue;  		if (!structFieldsToFix.Find (field))  			continue;  		var instrs2 = ToInstructionList (instrs);  		var instrPushes = DotNetUtils.GetArgPushes (instrs2' i);  		if (instrPushes == null || instrPushes.Count != 2)  			continue;  		block.Remove (i' 1);  		block.Remove (instrs2.IndexOf (instrPushes [1])' 1);  		block.Remove (instrs2.IndexOf (instrPushes [0])' 1);  		i -= 3;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,FixFieldCtorCalls,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count; i++) {  		var stfld = instrs [i];  		if (stfld.OpCode.Code != Code.Stfld)  			continue;  		var field = stfld.Operand as IField;  		if (field == null)  			continue;  		if (!structFieldsToFix.Find (field))  			continue;  		var instrs2 = ToInstructionList (instrs);  		var instrPushes = DotNetUtils.GetArgPushes (instrs2' i);  		if (instrPushes == null || instrPushes.Count != 2)  			continue;  		block.Remove (i' 1);  		block.Remove (instrs2.IndexOf (instrPushes [1])' 1);  		block.Remove (instrs2.IndexOf (instrPushes [0])' 1);  		i -= 3;  	}  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,FixFieldCtorCalls,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	var stfld = instrs [i];  	if (stfld.OpCode.Code != Code.Stfld)  		continue;  	var field = stfld.Operand as IField;  	if (field == null)  		continue;  	if (!structFieldsToFix.Find (field))  		continue;  	var instrs2 = ToInstructionList (instrs);  	var instrPushes = DotNetUtils.GetArgPushes (instrs2' i);  	if (instrPushes == null || instrPushes.Count != 2)  		continue;  	block.Remove (i' 1);  	block.Remove (instrs2.IndexOf (instrPushes [1])' 1);  	block.Remove (instrs2.IndexOf (instrPushes [0])' 1);  	i -= 3;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,FixFieldCtorCalls,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	var stfld = instrs [i];  	if (stfld.OpCode.Code != Code.Stfld)  		continue;  	var field = stfld.Operand as IField;  	if (field == null)  		continue;  	if (!structFieldsToFix.Find (field))  		continue;  	var instrs2 = ToInstructionList (instrs);  	var instrPushes = DotNetUtils.GetArgPushes (instrs2' i);  	if (instrPushes == null || instrPushes.Count != 2)  		continue;  	block.Remove (i' 1);  	block.Remove (instrs2.IndexOf (instrPushes [1])' 1);  	block.Remove (instrs2.IndexOf (instrPushes [0])' 1);  	i -= 3;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,FixFieldCtorCalls,The following statement contains a magic number: if (instrPushes == null || instrPushes.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,FixFieldCtorCalls,The following statement contains a magic number: i -= 3;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResolverBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResolverBase.cs,DecryptResourceV41SL,The following statement contains a magic number: for (int i = 0; i < data.Length - 1; i++)  	data [i + 1] ^= (byte)((k << (i & 5)) + i);  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResolverBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResolverBase.cs,DecryptResourceV41SL,The following statement contains a magic number: data [i + 1] ^= (byte)((k << (i & 5)) + i);  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: if (data41.isTrial)  	data41.magic = (int)val >> 3;  else if (isOtherRetail)  	data41.magic = data41.resourceField.InitialValue.Length - (int)val;  else  	data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: if (data41.isTrial)  	data41.magic = (int)val >> 3;  else if (isOtherRetail)  	data41.magic = data41.resourceField.InitialValue.Length - (int)val;  else  	data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: if (data41.isTrial)  	data41.magic = (int)val >> 3;  else if (isOtherRetail)  	data41.magic = data41.resourceField.InitialValue.Length - (int)val;  else  	data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: data41.magic = (int)val >> 3;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: if (isOtherRetail)  	data41.magic = data41.resourceField.InitialValue.Length - (int)val;  else  	data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: if (isOtherRetail)  	data41.magic = data41.resourceField.InitialValue.Length - (int)val;  else  	data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,CheckHandlerV41,The following statement contains a magic number: data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	isOtherRetail = false;  	var ld = instrs [i];  	if (ld.IsLdarg ())  		isOtherRetail = true;  	else if (!ld.IsLdloc ())  		continue;  	var add = instrs [i + 1];  	if (add.OpCode.Code != Code.Add)  		continue;  	var ldarg = instrs [i + 2];  	if (!ldarg.IsLdarg ())  		continue;  	var sub = instrs [i + 3];  	if (sub.OpCode.Code != Code.Sub)  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0xFF)  		continue;  	return ldarg.GetParameterIndex ();  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	isOtherRetail = false;  	var ld = instrs [i];  	if (ld.IsLdarg ())  		isOtherRetail = true;  	else if (!ld.IsLdloc ())  		continue;  	var add = instrs [i + 1];  	if (add.OpCode.Code != Code.Add)  		continue;  	var ldarg = instrs [i + 2];  	if (!ldarg.IsLdarg ())  		continue;  	var sub = instrs [i + 3];  	if (sub.OpCode.Code != Code.Sub)  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0xFF)  		continue;  	return ldarg.GetParameterIndex ();  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	isOtherRetail = false;  	var ld = instrs [i];  	if (ld.IsLdarg ())  		isOtherRetail = true;  	else if (!ld.IsLdloc ())  		continue;  	var add = instrs [i + 1];  	if (add.OpCode.Code != Code.Add)  		continue;  	var ldarg = instrs [i + 2];  	if (!ldarg.IsLdarg ())  		continue;  	var sub = instrs [i + 3];  	if (sub.OpCode.Code != Code.Sub)  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0xFF)  		continue;  	return ldarg.GetParameterIndex ();  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	isOtherRetail = false;  	var ld = instrs [i];  	if (ld.IsLdarg ())  		isOtherRetail = true;  	else if (!ld.IsLdloc ())  		continue;  	var add = instrs [i + 1];  	if (add.OpCode.Code != Code.Add)  		continue;  	var ldarg = instrs [i + 2];  	if (!ldarg.IsLdarg ())  		continue;  	var sub = instrs [i + 3];  	if (sub.OpCode.Code != Code.Sub)  		continue;  	var ldci4 = instrs [i + 4];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 0xFF)  		continue;  	return ldarg.GetParameterIndex ();  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Trial,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg ())  		continue;  	if (!instrs [i + 1].IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Shr)  		continue;  	return ldarg.GetParameterIndex ();  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Trial,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg ())  		continue;  	if (!instrs [i + 1].IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Shr)  		continue;  	return ldarg.GetParameterIndex ();  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,GetMagicArgIndex41Trial,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Shr)  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	var newarr = instrs [i + 1];  	if (newarr.OpCode.Code != Code.Newarr)  		continue;  	if (newarr.Operand.ToString () != "System.Char")  		continue;  	var stloc = instrs [i + 2];  	if (!stloc.IsStloc ())  		continue;  	var local = stloc.GetLocal (initMethod.Body.Variables);  	int startInitIndex = i;  	i++;  	var array = ArrayFinder.GetInitializedInt16Array (ldci4.GetLdcI4Value ()' initMethod' ref i);  	if (array == null)  		continue;  	var field = GetStoreField (initMethod' startInitIndex' local);  	if (field == null)  		continue;  	if (fields.Find (field))  		return array;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	var newarr = instrs [i + 1];  	if (newarr.OpCode.Code != Code.Newarr)  		continue;  	if (newarr.Operand.ToString () != "System.Char")  		continue;  	var stloc = instrs [i + 2];  	if (!stloc.IsStloc ())  		continue;  	var local = stloc.GetLocal (initMethod.Body.Variables);  	int startInitIndex = i;  	i++;  	var array = ArrayFinder.GetInitializedInt16Array (ldci4.GetLdcI4Value ()' initMethod' ref i);  	if (array == null)  		continue;  	var field = GetStoreField (initMethod' startInitIndex' local);  	if (field == null)  		continue;  	if (fields.Find (field))  		return array;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	if ((arg1 = instrs [i].GetParameterIndex ()) < 0)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if ((arg2 = instrs [i + 3].GetParameterIndex ()) < 0)  		continue;  	magic = ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	if ((arg1 = instrs [i].GetParameterIndex ()) < 0)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if ((arg2 = instrs [i + 3].GetParameterIndex ()) < 0)  		continue;  	magic = ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	if ((arg1 = instrs [i].GetParameterIndex ()) < 0)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Xor)  		continue;  	if ((arg2 = instrs [i + 3].GetParameterIndex ()) < 0)  		continue;  	magic = ldci4.GetLdcI4Value ();  	return true;  }  
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindMagic,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Xor)  	continue;  
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,FindMagic,The following statement contains a magic number: if ((arg2 = instrs [i + 3].GetParameterIndex ()) < 0)  	continue;  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (stringDecrypter.Detected)  	val += 100;  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100;  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundDotfuscatorAttribute)  	val += 10;  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 10;  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: if (val.Groups.Count < 2)  	return;  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,The following statement contains a magic number: foreach (var method in DotNetUtils.FindMethods (type.Methods' "System.String"' new string[] {  	"System.String"'  	"System.Int32"  })) {  	if (method.Body.HasExceptionHandlers)  		continue;  	if (DotNetUtils.GetMethodCalls (method' "System.Char[] System.String::ToCharArray()") != 1)  		continue;  	if (DotNetUtils.GetMethodCalls (method' "System.String System.String::Intern(System.String)") != 1)  		continue;  	simpleDeobfuscator.Deobfuscate (method);  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 3; i++) {  		var ldarg = instrs [i];  		if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  			continue;  		var callvirt = instrs [i + 1];  		if (callvirt.OpCode.Code != Code.Callvirt)  			continue;  		var calledMethod = callvirt.Operand as MemberRef;  		if (calledMethod == null || calledMethod.FullName != "System.Char[] System.String::ToCharArray()")  			continue;  		var stloc = instrs [i + 2];  		if (!stloc.IsStloc ())  			continue;  		var ldci4 = instrs [i + 3];  		if (!ldci4.IsLdcI4 ())  			continue;  		var info = new StringDecrypterInfo (method' ldci4.GetLdcI4Value ());  		stringDecrypterMethods.Add (info.method' info);  		Logger.v ("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.RemoveNewlines (info.method)' info.magic);  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,The following statement contains a magic number: foreach (var method in DotNetUtils.FindMethods (type.Methods' "System.String"' new string[] {  	"System.String"'  	"System.Int32"  })) {  	if (method.Body.HasExceptionHandlers)  		continue;  	if (DotNetUtils.GetMethodCalls (method' "System.Char[] System.String::ToCharArray()") != 1)  		continue;  	if (DotNetUtils.GetMethodCalls (method' "System.String System.String::Intern(System.String)") != 1)  		continue;  	simpleDeobfuscator.Deobfuscate (method);  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 3; i++) {  		var ldarg = instrs [i];  		if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  			continue;  		var callvirt = instrs [i + 1];  		if (callvirt.OpCode.Code != Code.Callvirt)  			continue;  		var calledMethod = callvirt.Operand as MemberRef;  		if (calledMethod == null || calledMethod.FullName != "System.Char[] System.String::ToCharArray()")  			continue;  		var stloc = instrs [i + 2];  		if (!stloc.IsStloc ())  			continue;  		var ldci4 = instrs [i + 3];  		if (!ldci4.IsLdcI4 ())  			continue;  		var info = new StringDecrypterInfo (method' ldci4.GetLdcI4Value ());  		stringDecrypterMethods.Add (info.method' info);  		Logger.v ("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.RemoveNewlines (info.method)' info.magic);  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,The following statement contains a magic number: foreach (var method in DotNetUtils.FindMethods (type.Methods' "System.String"' new string[] {  	"System.String"'  	"System.Int32"  })) {  	if (method.Body.HasExceptionHandlers)  		continue;  	if (DotNetUtils.GetMethodCalls (method' "System.Char[] System.String::ToCharArray()") != 1)  		continue;  	if (DotNetUtils.GetMethodCalls (method' "System.String System.String::Intern(System.String)") != 1)  		continue;  	simpleDeobfuscator.Deobfuscate (method);  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count - 3; i++) {  		var ldarg = instrs [i];  		if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  			continue;  		var callvirt = instrs [i + 1];  		if (callvirt.OpCode.Code != Code.Callvirt)  			continue;  		var calledMethod = callvirt.Operand as MemberRef;  		if (calledMethod == null || calledMethod.FullName != "System.Char[] System.String::ToCharArray()")  			continue;  		var stloc = instrs [i + 2];  		if (!stloc.IsStloc ())  			continue;  		var ldci4 = instrs [i + 3];  		if (!ldci4.IsLdcI4 ())  			continue;  		var info = new StringDecrypterInfo (method' ldci4.GetLdcI4Value ());  		stringDecrypterMethods.Add (info.method' info);  		Logger.v ("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.RemoveNewlines (info.method)' info.magic);  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  		continue;  	var callvirt = instrs [i + 1];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var calledMethod = callvirt.Operand as MemberRef;  	if (calledMethod == null || calledMethod.FullName != "System.Char[] System.String::ToCharArray()")  		continue;  	var stloc = instrs [i + 2];  	if (!stloc.IsStloc ())  		continue;  	var ldci4 = instrs [i + 3];  	if (!ldci4.IsLdcI4 ())  		continue;  	var info = new StringDecrypterInfo (method' ldci4.GetLdcI4Value ());  	stringDecrypterMethods.Add (info.method' info);  	Logger.v ("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.RemoveNewlines (info.method)' info.magic);  	break;  }  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  		continue;  	var callvirt = instrs [i + 1];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var calledMethod = callvirt.Operand as MemberRef;  	if (calledMethod == null || calledMethod.FullName != "System.Char[] System.String::ToCharArray()")  		continue;  	var stloc = instrs [i + 2];  	if (!stloc.IsStloc ())  		continue;  	var ldci4 = instrs [i + 3];  	if (!ldci4.IsLdcI4 ())  		continue;  	var info = new StringDecrypterInfo (method' ldci4.GetLdcI4Value ());  	stringDecrypterMethods.Add (info.method' info);  	Logger.v ("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.RemoveNewlines (info.method)' info.magic);  	break;  }  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,FindStringDecrypterMethods,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  	var ldarg = instrs [i];  	if (!ldarg.IsLdarg () || ldarg.GetParameterIndex () != 0)  		continue;  	var callvirt = instrs [i + 1];  	if (callvirt.OpCode.Code != Code.Callvirt)  		continue;  	var calledMethod = callvirt.Operand as MemberRef;  	if (calledMethod == null || calledMethod.FullName != "System.Char[] System.String::ToCharArray()")  		continue;  	var stloc = instrs [i + 2];  	if (!stloc.IsStloc ())  		continue;  	var ldci4 = instrs [i + 3];  	if (!ldci4.IsLdcI4 ())  		continue;  	var info = new StringDecrypterInfo (method' ldci4.GetLdcI4Value ());  	stringDecrypterMethods.Add (info.method' info);  	Logger.v ("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.RemoveNewlines (info.method)' info.magic);  	break;  }  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < chars.Length; i++) {  	char c = chars [i];  	byte b1 = (byte)((byte)c ^ key++);  	byte b2 = (byte)((byte)(c >> 8) ^ key++);  	chars [i] = (char)((b1 << 8) | b2);  }  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < chars.Length; i++) {  	char c = chars [i];  	byte b1 = (byte)((byte)c ^ key++);  	byte b2 = (byte)((byte)(c >> 8) ^ key++);  	chars [i] = (char)((b1 << 8) | b2);  }  
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,Decrypt,The following statement contains a magic number: chars [i] = (char)((b1 << 8) | b2);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\AntiStrongName.cs,Remove,The following statement contains a magic number: if (badBlock == goodblock) {  	// All of the bad block was removed by the cflow deobfuscator. It was just a useless  	// calculation (div by zero).  	block.ReplaceLastInstrsWithBranch (numInstrsToRemove' goodblock);  } else if (badBlock.Sources.Count == 1) {  	instrs = badBlock.Instructions;  	if (instrs.Count != 12)  		return false;  	index = 0;  	if (!instrs [index++].IsLdcI4 ())  		return false;  	if (!instrs [index].IsStloc ())  		return false;  	var local = Instr.GetLocalVar (blocks.Locals' instrs [index++]);  	if (local == null)  		return false;  	if (!CheckLdloc (blocks.Locals' instrs [index++]' local))  		return false;  	if (!CheckLdloc (blocks.Locals' instrs [index++]' local))  		return false;  	if (instrs [index++].OpCode.Code != Code.Sub)  		return false;  	if (instrs [index++].OpCode.Code != Code.Conv_U1)  		return false;  	if (!CheckStloc (blocks.Locals' instrs [index++]' local))  		return false;  	if (!CheckLdloc (blocks.Locals' instrs [index++]' local))  		return false;  	if (!CheckLdloc (blocks.Locals' instrs [index++]' local))  		return false;  	if (instrs [index++].OpCode.Code != Code.Div)  		return false;  	if (instrs [index++].OpCode.Code != Code.Conv_U1)  		return false;  	if (!CheckStloc (blocks.Locals' instrs [index++]' local))  		return false;  	block.ReplaceLastInstrsWithBranch (numInstrsToRemove' goodblock);  	badBlock.Parent.RemoveDeadBlock (badBlock);  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\AntiStrongName.cs,Remove,The following statement contains a magic number: if (badBlock.Sources.Count == 1) {  	instrs = badBlock.Instructions;  	if (instrs.Count != 12)  		return false;  	index = 0;  	if (!instrs [index++].IsLdcI4 ())  		return false;  	if (!instrs [index].IsStloc ())  		return false;  	var local = Instr.GetLocalVar (blocks.Locals' instrs [index++]);  	if (local == null)  		return false;  	if (!CheckLdloc (blocks.Locals' instrs [index++]' local))  		return false;  	if (!CheckLdloc (blocks.Locals' instrs [index++]' local))  		return false;  	if (instrs [index++].OpCode.Code != Code.Sub)  		return false;  	if (instrs [index++].OpCode.Code != Code.Conv_U1)  		return false;  	if (!CheckStloc (blocks.Locals' instrs [index++]' local))  		return false;  	if (!CheckLdloc (blocks.Locals' instrs [index++]' local))  		return false;  	if (!CheckLdloc (blocks.Locals' instrs [index++]' local))  		return false;  	if (instrs [index++].OpCode.Code != Code.Div)  		return false;  	if (instrs [index++].OpCode.Code != Code.Conv_U1)  		return false;  	if (!CheckStloc (blocks.Locals' instrs [index++]' local))  		return false;  	block.ReplaceLastInstrsWithBranch (numInstrsToRemove' goodblock);  	badBlock.Parent.RemoveDeadBlock (badBlock);  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\AntiStrongName.cs,Remove,The following statement contains a magic number: if (instrs.Count != 12)  	return false;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,IniFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,IniFile,The following statement contains a magic number: using (var reader = new StreamReader (new MemoryStream (data)' Encoding.UTF8)) {  	while (true) {  		var line = reader.ReadLine ();  		if (line == null)  			break;  		var match = Regex.Match (line' @"^([^=]+)=([^;]+);?\s*$");  		if (match.Groups.Count < 3)  			continue;  		var name = match.Groups [1].ToString ().Trim ();  		var value = match.Groups [2].ToString ().Trim ();  		nameToValue [name] = value;  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,IniFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,IniFile,The following statement contains a magic number: using (var reader = new StreamReader (new MemoryStream (data)' Encoding.UTF8)) {  	while (true) {  		var line = reader.ReadLine ();  		if (line == null)  			break;  		var match = Regex.Match (line' @"^([^=]+)=([^;]+);?\s*$");  		if (match.Groups.Count < 3)  			continue;  		var name = match.Groups [1].ToString ().Trim ();  		var value = match.Groups [2].ToString ().Trim ();  		nameToValue [name] = value;  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,IniFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,IniFile,The following statement contains a magic number: while (true) {  	var line = reader.ReadLine ();  	if (line == null)  		break;  	var match = Regex.Match (line' @"^([^=]+)=([^;]+);?\s*$");  	if (match.Groups.Count < 3)  		continue;  	var name = match.Groups [1].ToString ().Trim ();  	var value = match.Groups [2].ToString ().Trim ();  	nameToValue [name] = value;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,IniFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,IniFile,The following statement contains a magic number: while (true) {  	var line = reader.ReadLine ();  	if (line == null)  		break;  	var match = Regex.Match (line' @"^([^=]+)=([^;]+);?\s*$");  	if (match.Groups.Count < 3)  		continue;  	var name = match.Groups [1].ToString ().Trim ();  	var value = match.Groups [2].ToString ().Trim ();  	nameToValue [name] = value;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,IniFile,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,IniFile,The following statement contains a magic number: if (match.Groups.Count < 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: if (clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000)  	return null;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: if (clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000)  	return null;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,Unpack2,The following statement contains a magic number: if (clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000)  	return null;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,ClearDllBit,The following statement contains a magic number: using (var mainPeImage = new MyPEImage (peImageData)) {  	uint characteristicsOffset = (uint)mainPeImage.PEImage.ImageNTHeaders.FileHeader.StartOffset + 18;  	ushort characteristics = mainPeImage.OffsetReadUInt16 (characteristicsOffset);  	characteristics &= 0xDFFF;  	characteristics |= 2;  	mainPeImage.OffsetWriteUInt16 (characteristicsOffset' characteristics);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,ClearDllBit,The following statement contains a magic number: using (var mainPeImage = new MyPEImage (peImageData)) {  	uint characteristicsOffset = (uint)mainPeImage.PEImage.ImageNTHeaders.FileHeader.StartOffset + 18;  	ushort characteristics = mainPeImage.OffsetReadUInt16 (characteristicsOffset);  	characteristics &= 0xDFFF;  	characteristics |= 2;  	mainPeImage.OffsetWriteUInt16 (characteristicsOffset' characteristics);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,ClearDllBit,The following statement contains a magic number: characteristics |= 2;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  	uint rva = GetValue (peImage.OffsetReadUInt32 (offset));  	var value = peImage.OffsetReadUInt32 (offset + 4);  	if (value == 4) {  		i++;  		offset += 8;  		rva = GetValue (peImage.OffsetReadUInt32 (offset));  		value = peImage.OffsetReadUInt32 (offset + 4);  	} else  		value = GetValue (value);  	// Seems there's a bug in their code where they sometimes overwrite valid data  	// with invalid data.  	if (startedPatchingBadData && value == 0x3115)  		continue;  	startedPatchingBadData |= !peImage.DotNetSafeWrite (rva' BitConverter.GetBytes (value));  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  	uint rva = GetValue (peImage.OffsetReadUInt32 (offset));  	var value = peImage.OffsetReadUInt32 (offset + 4);  	if (value == 4) {  		i++;  		offset += 8;  		rva = GetValue (peImage.OffsetReadUInt32 (offset));  		value = peImage.OffsetReadUInt32 (offset + 4);  	} else  		value = GetValue (value);  	// Seems there's a bug in their code where they sometimes overwrite valid data  	// with invalid data.  	if (startedPatchingBadData && value == 0x3115)  		continue;  	startedPatchingBadData |= !peImage.DotNetSafeWrite (rva' BitConverter.GetBytes (value));  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  	uint rva = GetValue (peImage.OffsetReadUInt32 (offset));  	var value = peImage.OffsetReadUInt32 (offset + 4);  	if (value == 4) {  		i++;  		offset += 8;  		rva = GetValue (peImage.OffsetReadUInt32 (offset));  		value = peImage.OffsetReadUInt32 (offset + 4);  	} else  		value = GetValue (value);  	// Seems there's a bug in their code where they sometimes overwrite valid data  	// with invalid data.  	if (startedPatchingBadData && value == 0x3115)  		continue;  	startedPatchingBadData |= !peImage.DotNetSafeWrite (rva' BitConverter.GetBytes (value));  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  	uint rva = GetValue (peImage.OffsetReadUInt32 (offset));  	var value = peImage.OffsetReadUInt32 (offset + 4);  	if (value == 4) {  		i++;  		offset += 8;  		rva = GetValue (peImage.OffsetReadUInt32 (offset));  		value = peImage.OffsetReadUInt32 (offset + 4);  	} else  		value = GetValue (value);  	// Seems there's a bug in their code where they sometimes overwrite valid data  	// with invalid data.  	if (startedPatchingBadData && value == 0x3115)  		continue;  	startedPatchingBadData |= !peImage.DotNetSafeWrite (rva' BitConverter.GetBytes (value));  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  	uint rva = GetValue (peImage.OffsetReadUInt32 (offset));  	var value = peImage.OffsetReadUInt32 (offset + 4);  	if (value == 4) {  		i++;  		offset += 8;  		rva = GetValue (peImage.OffsetReadUInt32 (offset));  		value = peImage.OffsetReadUInt32 (offset + 4);  	} else  		value = GetValue (value);  	// Seems there's a bug in their code where they sometimes overwrite valid data  	// with invalid data.  	if (startedPatchingBadData && value == 0x3115)  		continue;  	startedPatchingBadData |= !peImage.DotNetSafeWrite (rva' BitConverter.GetBytes (value));  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: offset += 8
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: if (value == 4) {  	i++;  	offset += 8;  	rva = GetValue (peImage.OffsetReadUInt32 (offset));  	value = peImage.OffsetReadUInt32 (offset + 4);  } else  	value = GetValue (value);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: if (value == 4) {  	i++;  	offset += 8;  	rva = GetValue (peImage.OffsetReadUInt32 (offset));  	value = peImage.OffsetReadUInt32 (offset + 4);  } else  	value = GetValue (value);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: if (value == 4) {  	i++;  	offset += 8;  	rva = GetValue (peImage.OffsetReadUInt32 (offset));  	value = peImage.OffsetReadUInt32 (offset + 4);  } else  	value = GetValue (value);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: offset += 8;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,Patch2,The following statement contains a magic number: value = peImage.OffsetReadUInt32 (offset + 4);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,GetValue,The following statement contains a magic number: if (value % 3 != 0)  	throw new Exception ();  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,GetValue,The following statement contains a magic number: return value / 3;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,GetPatchInfo,The following statement contains a magic number: if (size1 <= 0 || size1 > 35)  	return null;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,Decrypt,The following statement contains a magic number: if (decrypted.Length / 4 * 4 != decrypted.Length)  	return null;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,Decrypt,The following statement contains a magic number: if (decrypted.Length / 4 * 4 != decrypted.Length)  	return null;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newData.Length; i++)  	newData [i] = BitConverter.ToInt32 (decrypted' i * 4);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,Decrypt,The following statement contains a magic number: newData [i] = BitConverter.ToInt32 (decrypted' i * 4);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,CheckType,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!method.IsStatic || method.Body == null)  		continue;  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 2)  		continue;  	if (!CheckType (sig.RetType' ElementType.String))  		continue;  	if (!CheckType (sig.Params [0]' ElementType.String))  		continue;  	if (!CheckType (sig.Params [1]' ElementType.String))  		continue;  	var localTypes = new LocalTypes (method);  	if (!localTypes.All (requiredTypes))  		continue;  	antiStrongNameMethod = method;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,CheckType,The following statement contains a magic number: if (sig == null || sig.Params.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,Remove,The following statement contains a magic number: if (badBlock.Instructions.Count <= 1 && badBlock.LastInstr.OpCode.Code == Code.Nop) {  	if (badBlock.FallThrough != null && badBlock.Targets == null && badBlock.Sources.Count == 0) {  		var badBlock2 = badBlock.FallThrough;  		if (badBlock2.FallThrough == badBlock2 && badBlock2.Sources.Count == 2 && badBlock2.Targets == null) {  			badBlock.Parent.RemoveGuaranteedDeadBlock (badBlock);  			badBlock2.Parent.RemoveGuaranteedDeadBlock (badBlock2);  			return true;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,Remove,The following statement contains a magic number: if (badBlock.FallThrough != null && badBlock.Targets == null && badBlock.Sources.Count == 0) {  	var badBlock2 = badBlock.FallThrough;  	if (badBlock2.FallThrough == badBlock2 && badBlock2.Sources.Count == 2 && badBlock2.Targets == null) {  		badBlock.Parent.RemoveGuaranteedDeadBlock (badBlock);  		badBlock2.Parent.RemoveGuaranteedDeadBlock (badBlock2);  		return true;  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,Remove,The following statement contains a magic number: if (badBlock2.FallThrough == badBlock2 && badBlock2.Sources.Count == 2 && badBlock2.Targets == null) {  	badBlock.Parent.RemoveGuaranteedDeadBlock (badBlock);  	badBlock2.Parent.RemoveGuaranteedDeadBlock (badBlock2);  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	if (!block.LastInstr.IsBrfalse ())  		continue;  	var instructions = block.Instructions;  	if (instructions.Count < NUM_INSTRS)  		continue;  	int i = instructions.Count - NUM_INSTRS;  	if (instructions [i].OpCode.Code != Code.Ldtoken)  		continue;  	if (!(instructions [i].Operand is ITypeDefOrRef))  		continue;  	if (!CheckCall (instructions [i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  		continue;  	if (!CheckCall (instructions [i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  		continue;  	if (!CheckCall (instructions [i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  		continue;  	if (!CheckCall (instructions [i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  		continue;  	if (!CheckCall (instructions [i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  		continue;  	if (instructions [i + 6].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 7]' antiStrongNameMethod))  		continue;  	if (instructions [i + 8].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  		continue;  	numInstructions = NUM_INSTRS;  	foundBlock = block;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	if (!block.LastInstr.IsBrfalse ())  		continue;  	var instructions = block.Instructions;  	if (instructions.Count < NUM_INSTRS)  		continue;  	int i = instructions.Count - NUM_INSTRS;  	if (instructions [i].OpCode.Code != Code.Ldtoken)  		continue;  	if (!(instructions [i].Operand is ITypeDefOrRef))  		continue;  	if (!CheckCall (instructions [i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  		continue;  	if (!CheckCall (instructions [i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  		continue;  	if (!CheckCall (instructions [i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  		continue;  	if (!CheckCall (instructions [i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  		continue;  	if (!CheckCall (instructions [i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  		continue;  	if (instructions [i + 6].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 7]' antiStrongNameMethod))  		continue;  	if (instructions [i + 8].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  		continue;  	numInstructions = NUM_INSTRS;  	foundBlock = block;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	if (!block.LastInstr.IsBrfalse ())  		continue;  	var instructions = block.Instructions;  	if (instructions.Count < NUM_INSTRS)  		continue;  	int i = instructions.Count - NUM_INSTRS;  	if (instructions [i].OpCode.Code != Code.Ldtoken)  		continue;  	if (!(instructions [i].Operand is ITypeDefOrRef))  		continue;  	if (!CheckCall (instructions [i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  		continue;  	if (!CheckCall (instructions [i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  		continue;  	if (!CheckCall (instructions [i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  		continue;  	if (!CheckCall (instructions [i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  		continue;  	if (!CheckCall (instructions [i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  		continue;  	if (instructions [i + 6].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 7]' antiStrongNameMethod))  		continue;  	if (instructions [i + 8].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  		continue;  	numInstructions = NUM_INSTRS;  	foundBlock = block;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	if (!block.LastInstr.IsBrfalse ())  		continue;  	var instructions = block.Instructions;  	if (instructions.Count < NUM_INSTRS)  		continue;  	int i = instructions.Count - NUM_INSTRS;  	if (instructions [i].OpCode.Code != Code.Ldtoken)  		continue;  	if (!(instructions [i].Operand is ITypeDefOrRef))  		continue;  	if (!CheckCall (instructions [i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  		continue;  	if (!CheckCall (instructions [i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  		continue;  	if (!CheckCall (instructions [i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  		continue;  	if (!CheckCall (instructions [i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  		continue;  	if (!CheckCall (instructions [i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  		continue;  	if (instructions [i + 6].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 7]' antiStrongNameMethod))  		continue;  	if (instructions [i + 8].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  		continue;  	numInstructions = NUM_INSTRS;  	foundBlock = block;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	if (!block.LastInstr.IsBrfalse ())  		continue;  	var instructions = block.Instructions;  	if (instructions.Count < NUM_INSTRS)  		continue;  	int i = instructions.Count - NUM_INSTRS;  	if (instructions [i].OpCode.Code != Code.Ldtoken)  		continue;  	if (!(instructions [i].Operand is ITypeDefOrRef))  		continue;  	if (!CheckCall (instructions [i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  		continue;  	if (!CheckCall (instructions [i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  		continue;  	if (!CheckCall (instructions [i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  		continue;  	if (!CheckCall (instructions [i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  		continue;  	if (!CheckCall (instructions [i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  		continue;  	if (instructions [i + 6].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 7]' antiStrongNameMethod))  		continue;  	if (instructions [i + 8].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  		continue;  	numInstructions = NUM_INSTRS;  	foundBlock = block;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	if (!block.LastInstr.IsBrfalse ())  		continue;  	var instructions = block.Instructions;  	if (instructions.Count < NUM_INSTRS)  		continue;  	int i = instructions.Count - NUM_INSTRS;  	if (instructions [i].OpCode.Code != Code.Ldtoken)  		continue;  	if (!(instructions [i].Operand is ITypeDefOrRef))  		continue;  	if (!CheckCall (instructions [i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  		continue;  	if (!CheckCall (instructions [i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  		continue;  	if (!CheckCall (instructions [i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  		continue;  	if (!CheckCall (instructions [i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  		continue;  	if (!CheckCall (instructions [i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  		continue;  	if (instructions [i + 6].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 7]' antiStrongNameMethod))  		continue;  	if (instructions [i + 8].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  		continue;  	numInstructions = NUM_INSTRS;  	foundBlock = block;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	if (!block.LastInstr.IsBrfalse ())  		continue;  	var instructions = block.Instructions;  	if (instructions.Count < NUM_INSTRS)  		continue;  	int i = instructions.Count - NUM_INSTRS;  	if (instructions [i].OpCode.Code != Code.Ldtoken)  		continue;  	if (!(instructions [i].Operand is ITypeDefOrRef))  		continue;  	if (!CheckCall (instructions [i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  		continue;  	if (!CheckCall (instructions [i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  		continue;  	if (!CheckCall (instructions [i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  		continue;  	if (!CheckCall (instructions [i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  		continue;  	if (!CheckCall (instructions [i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  		continue;  	if (instructions [i + 6].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 7]' antiStrongNameMethod))  		continue;  	if (instructions [i + 8].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  		continue;  	numInstructions = NUM_INSTRS;  	foundBlock = block;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	if (!block.LastInstr.IsBrfalse ())  		continue;  	var instructions = block.Instructions;  	if (instructions.Count < NUM_INSTRS)  		continue;  	int i = instructions.Count - NUM_INSTRS;  	if (instructions [i].OpCode.Code != Code.Ldtoken)  		continue;  	if (!(instructions [i].Operand is ITypeDefOrRef))  		continue;  	if (!CheckCall (instructions [i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  		continue;  	if (!CheckCall (instructions [i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  		continue;  	if (!CheckCall (instructions [i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  		continue;  	if (!CheckCall (instructions [i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  		continue;  	if (!CheckCall (instructions [i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  		continue;  	if (instructions [i + 6].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 7]' antiStrongNameMethod))  		continue;  	if (instructions [i + 8].OpCode.Code != Code.Ldstr)  		continue;  	if (!CheckCall (instructions [i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  		continue;  	numInstructions = NUM_INSTRS;  	foundBlock = block;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: if (!CheckCall (instructions [i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: if (!CheckCall (instructions [i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: if (!CheckCall (instructions [i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: if (!CheckCall (instructions [i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: if (instructions [i + 6].OpCode.Code != Code.Ldstr)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: if (!CheckCall (instructions [i + 7]' antiStrongNameMethod))  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: if (instructions [i + 8].OpCode.Code != Code.Ldstr)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,FindBlock,The following statement contains a magic number: if (!CheckCall (instructions [i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,CheckMethod,The following statement contains a magic number: foreach (var method in DotNetUtils.GetCalledMethods (module' methodToCheck)) {  	var type = method.DeclaringType;  	if (!DotNetUtils.IsMethod (method' "System.Void"' "()"))  		continue;  	if (!method.IsStatic)  		continue;  	if (type.Fields.Count != 2)  		continue;  	if (type.HasNestedTypes)  		continue;  	if (type.HasEvents || type.HasProperties)  		continue;  	if (!CheckFields (type.Fields))  		continue;  	var resolverMethod = FindAssemblyResolveMethod (type);  	if (resolverMethod == null)  		continue;  	var localTypes = new LocalTypes (resolverMethod);  	if (!localTypes.All (resolverLocals))  		continue;  	assemblyResolverType = type;  	assemblyResolverMethod = resolverMethod;  	assemblyResolverInitMethod = method;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,CheckMethod,The following statement contains a magic number: if (type.Fields.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,CheckFields,The following statement contains a magic number: if (fields.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum == 0) {  	if (HasMetadataStream ("#GUlD") && HasMetadataStream ("#Blop"))  		val += 10;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (HasMetadataStream ("#GUlD") && HasMetadataStream ("#Blop"))  	val += 10;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 10;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: foreach (var info in stringDecrypter.DecrypterInfos) {  	if (info.key == null)  		continue;  	localTypes = new LocalTypes (info.method);  	if (!localTypes.Exists ("System.IntPtr"))  		return DeobfuscatorInfo.THE_NAME + " <= 3.7";  	minVer = 3800;  	break;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: minVer = 3800;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (methodsDecrypter.Method == null) {  	if (minVer >= 3800)  		return DeobfuscatorInfo.THE_NAME + " >= 3.8";  	return DeobfuscatorInfo.THE_NAME;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (minVer >= 3800)  	return DeobfuscatorInfo.THE_NAME + " >= 3.8";  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (localTypes.Exists ("System.Int32[]")) {  	if (minVer >= 3800)  		return DeobfuscatorInfo.THE_NAME + " 3.8.4.1 - 3.9.0.1";  	return DeobfuscatorInfo.THE_NAME + " <= 3.9.0.1";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (minVer >= 3800)  	return DeobfuscatorInfo.THE_NAME + " 3.8.4.1 - 3.9.0.1";  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  	bool callsReverse = DotNetUtils.CallsMethod (methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  	if (!callsReverse)  		return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";  	int numIntPtrSizeCompares = CountCompareSystemIntPtrSize (methodsDecrypter.Method);  	bool hasSymmetricAlgorithm = new LocalTypes (methodsDecrypter.Method).Exists ("System.Security.Cryptography.SymmetricAlgorithm");  	if (module.IsClr40) {  		switch (numIntPtrSizeCompares) {  		case 7:  		case 9:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 10:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	} else {  		switch (numIntPtrSizeCompares) {  		case 6:  		case 8:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 9:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	}  	// Should never be reached unless it's a new version  	return DeobfuscatorInfo.THE_NAME + " 4.5+";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  	bool callsReverse = DotNetUtils.CallsMethod (methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  	if (!callsReverse)  		return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";  	int numIntPtrSizeCompares = CountCompareSystemIntPtrSize (methodsDecrypter.Method);  	bool hasSymmetricAlgorithm = new LocalTypes (methodsDecrypter.Method).Exists ("System.Security.Cryptography.SymmetricAlgorithm");  	if (module.IsClr40) {  		switch (numIntPtrSizeCompares) {  		case 7:  		case 9:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 10:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	} else {  		switch (numIntPtrSizeCompares) {  		case 6:  		case 8:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 9:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	}  	// Should never be reached unless it's a new version  	return DeobfuscatorInfo.THE_NAME + " 4.5+";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  	bool callsReverse = DotNetUtils.CallsMethod (methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  	if (!callsReverse)  		return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";  	int numIntPtrSizeCompares = CountCompareSystemIntPtrSize (methodsDecrypter.Method);  	bool hasSymmetricAlgorithm = new LocalTypes (methodsDecrypter.Method).Exists ("System.Security.Cryptography.SymmetricAlgorithm");  	if (module.IsClr40) {  		switch (numIntPtrSizeCompares) {  		case 7:  		case 9:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 10:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	} else {  		switch (numIntPtrSizeCompares) {  		case 6:  		case 8:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 9:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	}  	// Should never be reached unless it's a new version  	return DeobfuscatorInfo.THE_NAME + " 4.5+";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  	bool callsReverse = DotNetUtils.CallsMethod (methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  	if (!callsReverse)  		return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";  	int numIntPtrSizeCompares = CountCompareSystemIntPtrSize (methodsDecrypter.Method);  	bool hasSymmetricAlgorithm = new LocalTypes (methodsDecrypter.Method).Exists ("System.Security.Cryptography.SymmetricAlgorithm");  	if (module.IsClr40) {  		switch (numIntPtrSizeCompares) {  		case 7:  		case 9:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 10:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	} else {  		switch (numIntPtrSizeCompares) {  		case 6:  		case 8:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 9:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	}  	// Should never be reached unless it's a new version  	return DeobfuscatorInfo.THE_NAME + " 4.5+";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  	bool callsReverse = DotNetUtils.CallsMethod (methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  	if (!callsReverse)  		return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";  	int numIntPtrSizeCompares = CountCompareSystemIntPtrSize (methodsDecrypter.Method);  	bool hasSymmetricAlgorithm = new LocalTypes (methodsDecrypter.Method).Exists ("System.Security.Cryptography.SymmetricAlgorithm");  	if (module.IsClr40) {  		switch (numIntPtrSizeCompares) {  		case 7:  		case 9:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 10:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	} else {  		switch (numIntPtrSizeCompares) {  		case 6:  		case 8:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 9:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	}  	// Should never be reached unless it's a new version  	return DeobfuscatorInfo.THE_NAME + " 4.5+";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (!hasCorEnableProfilingString) {  	bool callsReverse = DotNetUtils.CallsMethod (methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)");  	if (!callsReverse)  		return DeobfuscatorInfo.THE_NAME + " 4.0 - 4.4";  	int numIntPtrSizeCompares = CountCompareSystemIntPtrSize (methodsDecrypter.Method);  	bool hasSymmetricAlgorithm = new LocalTypes (methodsDecrypter.Method).Exists ("System.Security.Cryptography.SymmetricAlgorithm");  	if (module.IsClr40) {  		switch (numIntPtrSizeCompares) {  		case 7:  		case 9:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 10:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	} else {  		switch (numIntPtrSizeCompares) {  		case 6:  		case 8:  			return DeobfuscatorInfo.THE_NAME + " 4.5";  		case 9:  			if (!hasSymmetricAlgorithm)  				return DeobfuscatorInfo.THE_NAME + " 4.6";  			if (hasCatchString)  				return DeobfuscatorInfo.THE_NAME + " 4.7";  			return DeobfuscatorInfo.THE_NAME + " 4.8";  		}  	}  	// Should never be reached unless it's a new version  	return DeobfuscatorInfo.THE_NAME + " 4.5+";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (module.IsClr40) {  	switch (numIntPtrSizeCompares) {  	case 7:  	case 9:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 10:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  } else {  	switch (numIntPtrSizeCompares) {  	case 6:  	case 8:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 9:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (module.IsClr40) {  	switch (numIntPtrSizeCompares) {  	case 7:  	case 9:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 10:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  } else {  	switch (numIntPtrSizeCompares) {  	case 6:  	case 8:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 9:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (module.IsClr40) {  	switch (numIntPtrSizeCompares) {  	case 7:  	case 9:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 10:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  } else {  	switch (numIntPtrSizeCompares) {  	case 6:  	case 8:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 9:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (module.IsClr40) {  	switch (numIntPtrSizeCompares) {  	case 7:  	case 9:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 10:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  } else {  	switch (numIntPtrSizeCompares) {  	case 6:  	case 8:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 9:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (module.IsClr40) {  	switch (numIntPtrSizeCompares) {  	case 7:  	case 9:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 10:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  } else {  	switch (numIntPtrSizeCompares) {  	case 6:  	case 8:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 9:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (module.IsClr40) {  	switch (numIntPtrSizeCompares) {  	case 7:  	case 9:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 10:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  } else {  	switch (numIntPtrSizeCompares) {  	case 6:  	case 8:  		return DeobfuscatorInfo.THE_NAME + " 4.5";  	case 9:  		if (!hasSymmetricAlgorithm)  			return DeobfuscatorInfo.THE_NAME + " 4.6";  		if (hasCatchString)  			return DeobfuscatorInfo.THE_NAME + " 4.7";  		return DeobfuscatorInfo.THE_NAME + " 4.8";  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: switch (numIntPtrSizeCompares) {  case 7:  case 9:  	return DeobfuscatorInfo.THE_NAME + " 4.5";  case 10:  	if (!hasSymmetricAlgorithm)  		return DeobfuscatorInfo.THE_NAME + " 4.6";  	if (hasCatchString)  		return DeobfuscatorInfo.THE_NAME + " 4.7";  	return DeobfuscatorInfo.THE_NAME + " 4.8";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: switch (numIntPtrSizeCompares) {  case 7:  case 9:  	return DeobfuscatorInfo.THE_NAME + " 4.5";  case 10:  	if (!hasSymmetricAlgorithm)  		return DeobfuscatorInfo.THE_NAME + " 4.6";  	if (hasCatchString)  		return DeobfuscatorInfo.THE_NAME + " 4.7";  	return DeobfuscatorInfo.THE_NAME + " 4.8";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: switch (numIntPtrSizeCompares) {  case 7:  case 9:  	return DeobfuscatorInfo.THE_NAME + " 4.5";  case 10:  	if (!hasSymmetricAlgorithm)  		return DeobfuscatorInfo.THE_NAME + " 4.6";  	if (hasCatchString)  		return DeobfuscatorInfo.THE_NAME + " 4.7";  	return DeobfuscatorInfo.THE_NAME + " 4.8";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: switch (numIntPtrSizeCompares) {  case 6:  case 8:  	return DeobfuscatorInfo.THE_NAME + " 4.5";  case 9:  	if (!hasSymmetricAlgorithm)  		return DeobfuscatorInfo.THE_NAME + " 4.6";  	if (hasCatchString)  		return DeobfuscatorInfo.THE_NAME + " 4.7";  	return DeobfuscatorInfo.THE_NAME + " 4.8";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: switch (numIntPtrSizeCompares) {  case 6:  case 8:  	return DeobfuscatorInfo.THE_NAME + " 4.5";  case 9:  	if (!hasSymmetricAlgorithm)  		return DeobfuscatorInfo.THE_NAME + " 4.6";  	if (hasCatchString)  		return DeobfuscatorInfo.THE_NAME + " 4.7";  	return DeobfuscatorInfo.THE_NAME + " 4.8";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: switch (numIntPtrSizeCompares) {  case 6:  case 8:  	return DeobfuscatorInfo.THE_NAME + " 4.5";  case 9:  	if (!hasSymmetricAlgorithm)  		return DeobfuscatorInfo.THE_NAME + " 4.6";  	if (hasCatchString)  		return DeobfuscatorInfo.THE_NAME + " 4.7";  	return DeobfuscatorInfo.THE_NAME + " 4.8";  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,CountCompareSystemIntPtrSize,The following statement contains a magic number: for (int i = 1; i < instrs.Count - 1; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (!instrs [i + 1].IsConditionalBranch ())  		continue;  	var call = instrs [i - 1];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MemberRef;  	if (calledMethod == null || calledMethod.FullName != "System.Int32 System.IntPtr::get_Size()")  		continue;  	count++;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,CountCompareSystemIntPtrSize,The following statement contains a magic number: if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,Initialize,The following statement contains a magic number: foreach (var type in module.GetTypes ()) {  	if (count >= 40)  		break;  	foreach (var method in type.Methods) {  		if (method.Name != ".ctor" && method.Name != ".cctor" && module.EntryPoint != method)  			continue;  		foreach (var calledMethod in DotNetUtils.GetCalledMethods (module' method)) {  			if (!calledMethod.IsStatic || calledMethod.Body == null)  				continue;  			if (!DotNetUtils.IsMethod (calledMethod' "System.Void"' "()"))  				continue;  			if (IsEmptyClass (calledMethod)) {  				callCounter.Add (calledMethod);  				count++;  			}  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,Initialize,The following statement contains a magic number: if (count >= 40)  	break;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,Initialize,The following statement contains a magic number: if (numCalls >= 10)  	emptyMethod = theMethod;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,IsEmptyClass,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (method.Name == ".ctor" || method.Name == ".cctor")  		continue;  	if (method == emptyMethod)  		continue;  	otherMethods++;  	if (method.Body == null)  		return false;  	if (method.Body.Instructions.Count > 20)  		return false;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,IsEmptyClass,The following statement contains a magic number: if (method.Body.Instructions.Count > 20)  	return false;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,IsEmptyClass,The following statement contains a magic number: if (otherMethods > 8)  	return false;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: if (UsesPublicKeyToken ()) {  	var publicKeyToken = module.Assembly.PublicKeyToken;  	if (publicKeyToken != null && publicKeyToken.Data.Length > 0) {  		for (int i = 0; i < 8; i++)  			iv [i * 2 + 1] = publicKeyToken.Data [i];  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: if (UsesPublicKeyToken ()) {  	var publicKeyToken = module.Assembly.PublicKeyToken;  	if (publicKeyToken != null && publicKeyToken.Data.Length > 0) {  		for (int i = 0; i < 8; i++)  			iv [i * 2 + 1] = publicKeyToken.Data [i];  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: if (publicKeyToken != null && publicKeyToken.Data.Length > 0) {  	for (int i = 0; i < 8; i++)  		iv [i * 2 + 1] = publicKeyToken.Data [i];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: if (publicKeyToken != null && publicKeyToken.Data.Length > 0) {  	for (int i = 0; i < 8; i++)  		iv [i * 2 + 1] = publicKeyToken.Data [i];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	iv [i * 2 + 1] = publicKeyToken.Data [i];  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	iv [i * 2 + 1] = publicKeyToken.Data [i];  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,Initialize,The following statement contains a magic number: iv [i * 2 + 1] = publicKeyToken.Data [i];  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,XorEncrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	long val = reader.ReadInt64 ();  	val ^= xorKey;  	stream.Position -= 8;  	writer.Write (val);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,XorEncrypt,The following statement contains a magic number: stream.Position -= 8;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: methodsDataReader.Position -= 4;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  	// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  	methodsDataReader.Position += 8L * patchCount;  	patchCount = methodsDataReader.ReadInt32 ();  	mode = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' patchCount);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		/*uint token =*/methodsDataReader.ReadUInt32 ();  		int numDwords = methodsDataReader.ReadInt32 ();  		PatchDwords (peImage' methodsDataReader' numDwords / 2);  	}  } else if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: while (methodsDataReader.Position < methodsData.Length - 1) {  	/*uint token =*/methodsDataReader.ReadUInt32 ();  	int numDwords = methodsDataReader.ReadInt32 ();  	PatchDwords (peImage' methodsDataReader' numDwords / 2);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: PatchDwords (peImage' methodsDataReader' numDwords / 2);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (!hooksJitter || mode == 1) {  	// DNR 3.9.8.0' 4.0+  	PatchDwords (peImage' methodsDataReader' patchCount);  	bool oldCode = !IsNewer45Decryption (encryptedResource.Method);  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		int size;  		if (oldCode) {  			methodsDataReader.ReadUInt32 ();  			// token' unknown' or index  			size = methodsDataReader.ReadInt32 ();  		} else  			size = methodsDataReader.ReadInt32 () * 4;  		var newData = methodsDataReader.ReadBytes (size);  		if (unpackedNativeFile)  			peImage.DotNetSafeWriteOffset (rva' newData);  		else  			peImage.DotNetSafeWrite (rva' newData);  	}  } else {  	// DNR 4.0+ (jitter is hooked)  	var methodDef = peImage.MetaData.TablesStream.MethodTable;  	var rvaToIndex = new Dictionary<uint' int> ((int)methodDef.Rows);  	uint offset = (uint)methodDef.StartOffset;  	for (int i = 0; i < methodDef.Rows; i++) {  		uint rva = peImage.OffsetReadUInt32 (offset);  		offset += methodDef.RowSize;  		if (rva == 0)  			continue;  		if ((peImage.ReadByte (rva) & 3) == 2)  			rva++;  		else  			rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  		rvaToIndex [rva] = i;  	}  	PatchDwords (peImage' methodsDataReader' patchCount);  	/*int count =*/methodsDataReader.ReadInt32 ();  	dumpedMethods = new DumpedMethods ();  	while (methodsDataReader.Position < methodsData.Length - 1) {  		uint rva = methodsDataReader.ReadUInt32 ();  		uint index = methodsDataReader.ReadUInt32 ();  		bool isNativeCode = index >= 0x70000000;  		int size = methodsDataReader.ReadInt32 ();  		var methodData = methodsDataReader.ReadBytes (size);  		int methodIndex;  		if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  			Logger.w ("Could not find method having code RVA {0:X8}"' rva);  			continue;  		}  		uint methodToken = 0x06000001 + (uint)methodIndex;  		if (isNativeCode) {  			totalEncryptedNativeMethods++;  			if (tokenToNativeCode != null)  				tokenToNativeCode [methodToken] = methodData;  			// Convert return true / false methods. The others are converted to  			// throw 0xDEADCODE.  			if (DeobUtils.IsCode (nativeLdci4' methodData)) {  				uint val = BitConverter.ToUInt32 (methodData' 4);  				// ldc.i4 XXXXXXXXh / ret  				methodData = new byte[] {  					0x20'  					0'  					0'  					0'  					0'  					0x2A  				};  				methodData [1] = (byte)val;  				methodData [2] = (byte)(val >> 8);  				methodData [3] = (byte)(val >> 16);  				methodData [4] = (byte)(val >> 24);  			} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  				// ldc.i4.0 / ret  				methodData = new byte[] {  					0x16'  					0x2A  				};  			} else {  				tokenToNativeMethod [methodToken] = methodData;  				// ldc.i4 0xDEADCODE / conv.u4 / throw  				methodData = new byte[] {  					0x20'  					0xDE'  					0xC0'  					0xAD'  					0xDE'  					0x6D'  					0x7A  				};  			}  		}  		var dm = new DumpedMethod ();  		peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  		dm.code = methodData;  		var codeReader = peImage.Reader;  		codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  		byte[] code;  		var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  		peImage.UpdateMethodHeaderInfo (dm' mbHeader);  		dumpedMethods.Add (dm);  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: while (methodsDataReader.Position < methodsData.Length - 1) {  	uint rva = methodsDataReader.ReadUInt32 ();  	int size;  	if (oldCode) {  		methodsDataReader.ReadUInt32 ();  		// token' unknown' or index  		size = methodsDataReader.ReadInt32 ();  	} else  		size = methodsDataReader.ReadInt32 () * 4;  	var newData = methodsDataReader.ReadBytes (size);  	if (unpackedNativeFile)  		peImage.DotNetSafeWriteOffset (rva' newData);  	else  		peImage.DotNetSafeWrite (rva' newData);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (oldCode) {  	methodsDataReader.ReadUInt32 ();  	// token' unknown' or index  	size = methodsDataReader.ReadInt32 ();  } else  	size = methodsDataReader.ReadInt32 () * 4;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: size = methodsDataReader.ReadInt32 () * 4;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < methodDef.Rows; i++) {  	uint rva = peImage.OffsetReadUInt32 (offset);  	offset += methodDef.RowSize;  	if (rva == 0)  		continue;  	if ((peImage.ReadByte (rva) & 3) == 2)  		rva++;  	else  		rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  	rvaToIndex [rva] = i;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < methodDef.Rows; i++) {  	uint rva = peImage.OffsetReadUInt32 (offset);  	offset += methodDef.RowSize;  	if (rva == 0)  		continue;  	if ((peImage.ReadByte (rva) & 3) == 2)  		rva++;  	else  		rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  	rvaToIndex [rva] = i;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < methodDef.Rows; i++) {  	uint rva = peImage.OffsetReadUInt32 (offset);  	offset += methodDef.RowSize;  	if (rva == 0)  		continue;  	if ((peImage.ReadByte (rva) & 3) == 2)  		rva++;  	else  		rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  	rvaToIndex [rva] = i;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < methodDef.Rows; i++) {  	uint rva = peImage.OffsetReadUInt32 (offset);  	offset += methodDef.RowSize;  	if (rva == 0)  		continue;  	if ((peImage.ReadByte (rva) & 3) == 2)  		rva++;  	else  		rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  	rvaToIndex [rva] = i;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((peImage.ReadByte (rva) & 3) == 2)  	rva++;  else  	rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((peImage.ReadByte (rva) & 3) == 2)  	rva++;  else  	rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((peImage.ReadByte (rva) & 3) == 2)  	rva++;  else  	rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if ((peImage.ReadByte (rva) & 3) == 2)  	rva++;  else  	rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: rva += (uint)(4 * (peImage.ReadByte (rva + 1) >> 4));  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: while (methodsDataReader.Position < methodsData.Length - 1) {  	uint rva = methodsDataReader.ReadUInt32 ();  	uint index = methodsDataReader.ReadUInt32 ();  	bool isNativeCode = index >= 0x70000000;  	int size = methodsDataReader.ReadInt32 ();  	var methodData = methodsDataReader.ReadBytes (size);  	int methodIndex;  	if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  		Logger.w ("Could not find method having code RVA {0:X8}"' rva);  		continue;  	}  	uint methodToken = 0x06000001 + (uint)methodIndex;  	if (isNativeCode) {  		totalEncryptedNativeMethods++;  		if (tokenToNativeCode != null)  			tokenToNativeCode [methodToken] = methodData;  		// Convert return true / false methods. The others are converted to  		// throw 0xDEADCODE.  		if (DeobUtils.IsCode (nativeLdci4' methodData)) {  			uint val = BitConverter.ToUInt32 (methodData' 4);  			// ldc.i4 XXXXXXXXh / ret  			methodData = new byte[] {  				0x20'  				0'  				0'  				0'  				0'  				0x2A  			};  			methodData [1] = (byte)val;  			methodData [2] = (byte)(val >> 8);  			methodData [3] = (byte)(val >> 16);  			methodData [4] = (byte)(val >> 24);  		} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  			// ldc.i4.0 / ret  			methodData = new byte[] {  				0x16'  				0x2A  			};  		} else {  			tokenToNativeMethod [methodToken] = methodData;  			// ldc.i4 0xDEADCODE / conv.u4 / throw  			methodData = new byte[] {  				0x20'  				0xDE'  				0xC0'  				0xAD'  				0xDE'  				0x6D'  				0x7A  			};  		}  	}  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  	dm.code = methodData;  	var codeReader = peImage.Reader;  	codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  	byte[] code;  	var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: while (methodsDataReader.Position < methodsData.Length - 1) {  	uint rva = methodsDataReader.ReadUInt32 ();  	uint index = methodsDataReader.ReadUInt32 ();  	bool isNativeCode = index >= 0x70000000;  	int size = methodsDataReader.ReadInt32 ();  	var methodData = methodsDataReader.ReadBytes (size);  	int methodIndex;  	if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  		Logger.w ("Could not find method having code RVA {0:X8}"' rva);  		continue;  	}  	uint methodToken = 0x06000001 + (uint)methodIndex;  	if (isNativeCode) {  		totalEncryptedNativeMethods++;  		if (tokenToNativeCode != null)  			tokenToNativeCode [methodToken] = methodData;  		// Convert return true / false methods. The others are converted to  		// throw 0xDEADCODE.  		if (DeobUtils.IsCode (nativeLdci4' methodData)) {  			uint val = BitConverter.ToUInt32 (methodData' 4);  			// ldc.i4 XXXXXXXXh / ret  			methodData = new byte[] {  				0x20'  				0'  				0'  				0'  				0'  				0x2A  			};  			methodData [1] = (byte)val;  			methodData [2] = (byte)(val >> 8);  			methodData [3] = (byte)(val >> 16);  			methodData [4] = (byte)(val >> 24);  		} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  			// ldc.i4.0 / ret  			methodData = new byte[] {  				0x16'  				0x2A  			};  		} else {  			tokenToNativeMethod [methodToken] = methodData;  			// ldc.i4 0xDEADCODE / conv.u4 / throw  			methodData = new byte[] {  				0x20'  				0xDE'  				0xC0'  				0xAD'  				0xDE'  				0x6D'  				0x7A  			};  		}  	}  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  	dm.code = methodData;  	var codeReader = peImage.Reader;  	codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  	byte[] code;  	var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: while (methodsDataReader.Position < methodsData.Length - 1) {  	uint rva = methodsDataReader.ReadUInt32 ();  	uint index = methodsDataReader.ReadUInt32 ();  	bool isNativeCode = index >= 0x70000000;  	int size = methodsDataReader.ReadInt32 ();  	var methodData = methodsDataReader.ReadBytes (size);  	int methodIndex;  	if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  		Logger.w ("Could not find method having code RVA {0:X8}"' rva);  		continue;  	}  	uint methodToken = 0x06000001 + (uint)methodIndex;  	if (isNativeCode) {  		totalEncryptedNativeMethods++;  		if (tokenToNativeCode != null)  			tokenToNativeCode [methodToken] = methodData;  		// Convert return true / false methods. The others are converted to  		// throw 0xDEADCODE.  		if (DeobUtils.IsCode (nativeLdci4' methodData)) {  			uint val = BitConverter.ToUInt32 (methodData' 4);  			// ldc.i4 XXXXXXXXh / ret  			methodData = new byte[] {  				0x20'  				0'  				0'  				0'  				0'  				0x2A  			};  			methodData [1] = (byte)val;  			methodData [2] = (byte)(val >> 8);  			methodData [3] = (byte)(val >> 16);  			methodData [4] = (byte)(val >> 24);  		} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  			// ldc.i4.0 / ret  			methodData = new byte[] {  				0x16'  				0x2A  			};  		} else {  			tokenToNativeMethod [methodToken] = methodData;  			// ldc.i4 0xDEADCODE / conv.u4 / throw  			methodData = new byte[] {  				0x20'  				0xDE'  				0xC0'  				0xAD'  				0xDE'  				0x6D'  				0x7A  			};  		}  	}  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  	dm.code = methodData;  	var codeReader = peImage.Reader;  	codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  	byte[] code;  	var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: while (methodsDataReader.Position < methodsData.Length - 1) {  	uint rva = methodsDataReader.ReadUInt32 ();  	uint index = methodsDataReader.ReadUInt32 ();  	bool isNativeCode = index >= 0x70000000;  	int size = methodsDataReader.ReadInt32 ();  	var methodData = methodsDataReader.ReadBytes (size);  	int methodIndex;  	if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  		Logger.w ("Could not find method having code RVA {0:X8}"' rva);  		continue;  	}  	uint methodToken = 0x06000001 + (uint)methodIndex;  	if (isNativeCode) {  		totalEncryptedNativeMethods++;  		if (tokenToNativeCode != null)  			tokenToNativeCode [methodToken] = methodData;  		// Convert return true / false methods. The others are converted to  		// throw 0xDEADCODE.  		if (DeobUtils.IsCode (nativeLdci4' methodData)) {  			uint val = BitConverter.ToUInt32 (methodData' 4);  			// ldc.i4 XXXXXXXXh / ret  			methodData = new byte[] {  				0x20'  				0'  				0'  				0'  				0'  				0x2A  			};  			methodData [1] = (byte)val;  			methodData [2] = (byte)(val >> 8);  			methodData [3] = (byte)(val >> 16);  			methodData [4] = (byte)(val >> 24);  		} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  			// ldc.i4.0 / ret  			methodData = new byte[] {  				0x16'  				0x2A  			};  		} else {  			tokenToNativeMethod [methodToken] = methodData;  			// ldc.i4 0xDEADCODE / conv.u4 / throw  			methodData = new byte[] {  				0x20'  				0xDE'  				0xC0'  				0xAD'  				0xDE'  				0x6D'  				0x7A  			};  		}  	}  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  	dm.code = methodData;  	var codeReader = peImage.Reader;  	codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  	byte[] code;  	var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: while (methodsDataReader.Position < methodsData.Length - 1) {  	uint rva = methodsDataReader.ReadUInt32 ();  	uint index = methodsDataReader.ReadUInt32 ();  	bool isNativeCode = index >= 0x70000000;  	int size = methodsDataReader.ReadInt32 ();  	var methodData = methodsDataReader.ReadBytes (size);  	int methodIndex;  	if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  		Logger.w ("Could not find method having code RVA {0:X8}"' rva);  		continue;  	}  	uint methodToken = 0x06000001 + (uint)methodIndex;  	if (isNativeCode) {  		totalEncryptedNativeMethods++;  		if (tokenToNativeCode != null)  			tokenToNativeCode [methodToken] = methodData;  		// Convert return true / false methods. The others are converted to  		// throw 0xDEADCODE.  		if (DeobUtils.IsCode (nativeLdci4' methodData)) {  			uint val = BitConverter.ToUInt32 (methodData' 4);  			// ldc.i4 XXXXXXXXh / ret  			methodData = new byte[] {  				0x20'  				0'  				0'  				0'  				0'  				0x2A  			};  			methodData [1] = (byte)val;  			methodData [2] = (byte)(val >> 8);  			methodData [3] = (byte)(val >> 16);  			methodData [4] = (byte)(val >> 24);  		} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  			// ldc.i4.0 / ret  			methodData = new byte[] {  				0x16'  				0x2A  			};  		} else {  			tokenToNativeMethod [methodToken] = methodData;  			// ldc.i4 0xDEADCODE / conv.u4 / throw  			methodData = new byte[] {  				0x20'  				0xDE'  				0xC0'  				0xAD'  				0xDE'  				0x6D'  				0x7A  			};  		}  	}  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  	dm.code = methodData;  	var codeReader = peImage.Reader;  	codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  	byte[] code;  	var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: while (methodsDataReader.Position < methodsData.Length - 1) {  	uint rva = methodsDataReader.ReadUInt32 ();  	uint index = methodsDataReader.ReadUInt32 ();  	bool isNativeCode = index >= 0x70000000;  	int size = methodsDataReader.ReadInt32 ();  	var methodData = methodsDataReader.ReadBytes (size);  	int methodIndex;  	if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  		Logger.w ("Could not find method having code RVA {0:X8}"' rva);  		continue;  	}  	uint methodToken = 0x06000001 + (uint)methodIndex;  	if (isNativeCode) {  		totalEncryptedNativeMethods++;  		if (tokenToNativeCode != null)  			tokenToNativeCode [methodToken] = methodData;  		// Convert return true / false methods. The others are converted to  		// throw 0xDEADCODE.  		if (DeobUtils.IsCode (nativeLdci4' methodData)) {  			uint val = BitConverter.ToUInt32 (methodData' 4);  			// ldc.i4 XXXXXXXXh / ret  			methodData = new byte[] {  				0x20'  				0'  				0'  				0'  				0'  				0x2A  			};  			methodData [1] = (byte)val;  			methodData [2] = (byte)(val >> 8);  			methodData [3] = (byte)(val >> 16);  			methodData [4] = (byte)(val >> 24);  		} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  			// ldc.i4.0 / ret  			methodData = new byte[] {  				0x16'  				0x2A  			};  		} else {  			tokenToNativeMethod [methodToken] = methodData;  			// ldc.i4 0xDEADCODE / conv.u4 / throw  			methodData = new byte[] {  				0x20'  				0xDE'  				0xC0'  				0xAD'  				0xDE'  				0x6D'  				0x7A  			};  		}  	}  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  	dm.code = methodData;  	var codeReader = peImage.Reader;  	codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  	byte[] code;  	var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: while (methodsDataReader.Position < methodsData.Length - 1) {  	uint rva = methodsDataReader.ReadUInt32 ();  	uint index = methodsDataReader.ReadUInt32 ();  	bool isNativeCode = index >= 0x70000000;  	int size = methodsDataReader.ReadInt32 ();  	var methodData = methodsDataReader.ReadBytes (size);  	int methodIndex;  	if (!rvaToIndex.TryGetValue (rva' out methodIndex)) {  		Logger.w ("Could not find method having code RVA {0:X8}"' rva);  		continue;  	}  	uint methodToken = 0x06000001 + (uint)methodIndex;  	if (isNativeCode) {  		totalEncryptedNativeMethods++;  		if (tokenToNativeCode != null)  			tokenToNativeCode [methodToken] = methodData;  		// Convert return true / false methods. The others are converted to  		// throw 0xDEADCODE.  		if (DeobUtils.IsCode (nativeLdci4' methodData)) {  			uint val = BitConverter.ToUInt32 (methodData' 4);  			// ldc.i4 XXXXXXXXh / ret  			methodData = new byte[] {  				0x20'  				0'  				0'  				0'  				0'  				0x2A  			};  			methodData [1] = (byte)val;  			methodData [2] = (byte)(val >> 8);  			methodData [3] = (byte)(val >> 16);  			methodData [4] = (byte)(val >> 24);  		} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  			// ldc.i4.0 / ret  			methodData = new byte[] {  				0x16'  				0x2A  			};  		} else {  			tokenToNativeMethod [methodToken] = methodData;  			// ldc.i4 0xDEADCODE / conv.u4 / throw  			methodData = new byte[] {  				0x20'  				0xDE'  				0xC0'  				0xAD'  				0xDE'  				0x6D'  				0x7A  			};  		}  	}  	var dm = new DumpedMethod ();  	peImage.ReadMethodTableRowTo (dm' MDToken.ToRID (methodToken));  	dm.code = methodData;  	var codeReader = peImage.Reader;  	codeReader.Position = peImage.RvaToOffset (dm.mdRVA);  	byte[] code;  	var mbHeader = MethodBodyParser.ParseMethodBody (codeReader' out code' out dm.extraSections);  	peImage.UpdateMethodHeaderInfo (dm' mbHeader);  	dumpedMethods.Add (dm);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (isNativeCode) {  	totalEncryptedNativeMethods++;  	if (tokenToNativeCode != null)  		tokenToNativeCode [methodToken] = methodData;  	// Convert return true / false methods. The others are converted to  	// throw 0xDEADCODE.  	if (DeobUtils.IsCode (nativeLdci4' methodData)) {  		uint val = BitConverter.ToUInt32 (methodData' 4);  		// ldc.i4 XXXXXXXXh / ret  		methodData = new byte[] {  			0x20'  			0'  			0'  			0'  			0'  			0x2A  		};  		methodData [1] = (byte)val;  		methodData [2] = (byte)(val >> 8);  		methodData [3] = (byte)(val >> 16);  		methodData [4] = (byte)(val >> 24);  	} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  		// ldc.i4.0 / ret  		methodData = new byte[] {  			0x16'  			0x2A  		};  	} else {  		tokenToNativeMethod [methodToken] = methodData;  		// ldc.i4 0xDEADCODE / conv.u4 / throw  		methodData = new byte[] {  			0x20'  			0xDE'  			0xC0'  			0xAD'  			0xDE'  			0x6D'  			0x7A  		};  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (isNativeCode) {  	totalEncryptedNativeMethods++;  	if (tokenToNativeCode != null)  		tokenToNativeCode [methodToken] = methodData;  	// Convert return true / false methods. The others are converted to  	// throw 0xDEADCODE.  	if (DeobUtils.IsCode (nativeLdci4' methodData)) {  		uint val = BitConverter.ToUInt32 (methodData' 4);  		// ldc.i4 XXXXXXXXh / ret  		methodData = new byte[] {  			0x20'  			0'  			0'  			0'  			0'  			0x2A  		};  		methodData [1] = (byte)val;  		methodData [2] = (byte)(val >> 8);  		methodData [3] = (byte)(val >> 16);  		methodData [4] = (byte)(val >> 24);  	} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  		// ldc.i4.0 / ret  		methodData = new byte[] {  			0x16'  			0x2A  		};  	} else {  		tokenToNativeMethod [methodToken] = methodData;  		// ldc.i4 0xDEADCODE / conv.u4 / throw  		methodData = new byte[] {  			0x20'  			0xDE'  			0xC0'  			0xAD'  			0xDE'  			0x6D'  			0x7A  		};  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (isNativeCode) {  	totalEncryptedNativeMethods++;  	if (tokenToNativeCode != null)  		tokenToNativeCode [methodToken] = methodData;  	// Convert return true / false methods. The others are converted to  	// throw 0xDEADCODE.  	if (DeobUtils.IsCode (nativeLdci4' methodData)) {  		uint val = BitConverter.ToUInt32 (methodData' 4);  		// ldc.i4 XXXXXXXXh / ret  		methodData = new byte[] {  			0x20'  			0'  			0'  			0'  			0'  			0x2A  		};  		methodData [1] = (byte)val;  		methodData [2] = (byte)(val >> 8);  		methodData [3] = (byte)(val >> 16);  		methodData [4] = (byte)(val >> 24);  	} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  		// ldc.i4.0 / ret  		methodData = new byte[] {  			0x16'  			0x2A  		};  	} else {  		tokenToNativeMethod [methodToken] = methodData;  		// ldc.i4 0xDEADCODE / conv.u4 / throw  		methodData = new byte[] {  			0x20'  			0xDE'  			0xC0'  			0xAD'  			0xDE'  			0x6D'  			0x7A  		};  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (isNativeCode) {  	totalEncryptedNativeMethods++;  	if (tokenToNativeCode != null)  		tokenToNativeCode [methodToken] = methodData;  	// Convert return true / false methods. The others are converted to  	// throw 0xDEADCODE.  	if (DeobUtils.IsCode (nativeLdci4' methodData)) {  		uint val = BitConverter.ToUInt32 (methodData' 4);  		// ldc.i4 XXXXXXXXh / ret  		methodData = new byte[] {  			0x20'  			0'  			0'  			0'  			0'  			0x2A  		};  		methodData [1] = (byte)val;  		methodData [2] = (byte)(val >> 8);  		methodData [3] = (byte)(val >> 16);  		methodData [4] = (byte)(val >> 24);  	} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  		// ldc.i4.0 / ret  		methodData = new byte[] {  			0x16'  			0x2A  		};  	} else {  		tokenToNativeMethod [methodToken] = methodData;  		// ldc.i4 0xDEADCODE / conv.u4 / throw  		methodData = new byte[] {  			0x20'  			0xDE'  			0xC0'  			0xAD'  			0xDE'  			0x6D'  			0x7A  		};  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (isNativeCode) {  	totalEncryptedNativeMethods++;  	if (tokenToNativeCode != null)  		tokenToNativeCode [methodToken] = methodData;  	// Convert return true / false methods. The others are converted to  	// throw 0xDEADCODE.  	if (DeobUtils.IsCode (nativeLdci4' methodData)) {  		uint val = BitConverter.ToUInt32 (methodData' 4);  		// ldc.i4 XXXXXXXXh / ret  		methodData = new byte[] {  			0x20'  			0'  			0'  			0'  			0'  			0x2A  		};  		methodData [1] = (byte)val;  		methodData [2] = (byte)(val >> 8);  		methodData [3] = (byte)(val >> 16);  		methodData [4] = (byte)(val >> 24);  	} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  		// ldc.i4.0 / ret  		methodData = new byte[] {  			0x16'  			0x2A  		};  	} else {  		tokenToNativeMethod [methodToken] = methodData;  		// ldc.i4 0xDEADCODE / conv.u4 / throw  		methodData = new byte[] {  			0x20'  			0xDE'  			0xC0'  			0xAD'  			0xDE'  			0x6D'  			0x7A  		};  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (isNativeCode) {  	totalEncryptedNativeMethods++;  	if (tokenToNativeCode != null)  		tokenToNativeCode [methodToken] = methodData;  	// Convert return true / false methods. The others are converted to  	// throw 0xDEADCODE.  	if (DeobUtils.IsCode (nativeLdci4' methodData)) {  		uint val = BitConverter.ToUInt32 (methodData' 4);  		// ldc.i4 XXXXXXXXh / ret  		methodData = new byte[] {  			0x20'  			0'  			0'  			0'  			0'  			0x2A  		};  		methodData [1] = (byte)val;  		methodData [2] = (byte)(val >> 8);  		methodData [3] = (byte)(val >> 16);  		methodData [4] = (byte)(val >> 24);  	} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  		// ldc.i4.0 / ret  		methodData = new byte[] {  			0x16'  			0x2A  		};  	} else {  		tokenToNativeMethod [methodToken] = methodData;  		// ldc.i4 0xDEADCODE / conv.u4 / throw  		methodData = new byte[] {  			0x20'  			0xDE'  			0xC0'  			0xAD'  			0xDE'  			0x6D'  			0x7A  		};  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (isNativeCode) {  	totalEncryptedNativeMethods++;  	if (tokenToNativeCode != null)  		tokenToNativeCode [methodToken] = methodData;  	// Convert return true / false methods. The others are converted to  	// throw 0xDEADCODE.  	if (DeobUtils.IsCode (nativeLdci4' methodData)) {  		uint val = BitConverter.ToUInt32 (methodData' 4);  		// ldc.i4 XXXXXXXXh / ret  		methodData = new byte[] {  			0x20'  			0'  			0'  			0'  			0'  			0x2A  		};  		methodData [1] = (byte)val;  		methodData [2] = (byte)(val >> 8);  		methodData [3] = (byte)(val >> 16);  		methodData [4] = (byte)(val >> 24);  	} else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  		// ldc.i4.0 / ret  		methodData = new byte[] {  			0x16'  			0x2A  		};  	} else {  		tokenToNativeMethod [methodToken] = methodData;  		// ldc.i4 0xDEADCODE / conv.u4 / throw  		methodData = new byte[] {  			0x20'  			0xDE'  			0xC0'  			0xAD'  			0xDE'  			0x6D'  			0x7A  		};  	}  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (DeobUtils.IsCode (nativeLdci4' methodData)) {  	uint val = BitConverter.ToUInt32 (methodData' 4);  	// ldc.i4 XXXXXXXXh / ret  	methodData = new byte[] {  		0x20'  		0'  		0'  		0'  		0'  		0x2A  	};  	methodData [1] = (byte)val;  	methodData [2] = (byte)(val >> 8);  	methodData [3] = (byte)(val >> 16);  	methodData [4] = (byte)(val >> 24);  } else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  	// ldc.i4.0 / ret  	methodData = new byte[] {  		0x16'  		0x2A  	};  } else {  	tokenToNativeMethod [methodToken] = methodData;  	// ldc.i4 0xDEADCODE / conv.u4 / throw  	methodData = new byte[] {  		0x20'  		0xDE'  		0xC0'  		0xAD'  		0xDE'  		0x6D'  		0x7A  	};  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (DeobUtils.IsCode (nativeLdci4' methodData)) {  	uint val = BitConverter.ToUInt32 (methodData' 4);  	// ldc.i4 XXXXXXXXh / ret  	methodData = new byte[] {  		0x20'  		0'  		0'  		0'  		0'  		0x2A  	};  	methodData [1] = (byte)val;  	methodData [2] = (byte)(val >> 8);  	methodData [3] = (byte)(val >> 16);  	methodData [4] = (byte)(val >> 24);  } else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  	// ldc.i4.0 / ret  	methodData = new byte[] {  		0x16'  		0x2A  	};  } else {  	tokenToNativeMethod [methodToken] = methodData;  	// ldc.i4 0xDEADCODE / conv.u4 / throw  	methodData = new byte[] {  		0x20'  		0xDE'  		0xC0'  		0xAD'  		0xDE'  		0x6D'  		0x7A  	};  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (DeobUtils.IsCode (nativeLdci4' methodData)) {  	uint val = BitConverter.ToUInt32 (methodData' 4);  	// ldc.i4 XXXXXXXXh / ret  	methodData = new byte[] {  		0x20'  		0'  		0'  		0'  		0'  		0x2A  	};  	methodData [1] = (byte)val;  	methodData [2] = (byte)(val >> 8);  	methodData [3] = (byte)(val >> 16);  	methodData [4] = (byte)(val >> 24);  } else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  	// ldc.i4.0 / ret  	methodData = new byte[] {  		0x16'  		0x2A  	};  } else {  	tokenToNativeMethod [methodToken] = methodData;  	// ldc.i4 0xDEADCODE / conv.u4 / throw  	methodData = new byte[] {  		0x20'  		0xDE'  		0xC0'  		0xAD'  		0xDE'  		0x6D'  		0x7A  	};  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (DeobUtils.IsCode (nativeLdci4' methodData)) {  	uint val = BitConverter.ToUInt32 (methodData' 4);  	// ldc.i4 XXXXXXXXh / ret  	methodData = new byte[] {  		0x20'  		0'  		0'  		0'  		0'  		0x2A  	};  	methodData [1] = (byte)val;  	methodData [2] = (byte)(val >> 8);  	methodData [3] = (byte)(val >> 16);  	methodData [4] = (byte)(val >> 24);  } else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  	// ldc.i4.0 / ret  	methodData = new byte[] {  		0x16'  		0x2A  	};  } else {  	tokenToNativeMethod [methodToken] = methodData;  	// ldc.i4 0xDEADCODE / conv.u4 / throw  	methodData = new byte[] {  		0x20'  		0xDE'  		0xC0'  		0xAD'  		0xDE'  		0x6D'  		0x7A  	};  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (DeobUtils.IsCode (nativeLdci4' methodData)) {  	uint val = BitConverter.ToUInt32 (methodData' 4);  	// ldc.i4 XXXXXXXXh / ret  	methodData = new byte[] {  		0x20'  		0'  		0'  		0'  		0'  		0x2A  	};  	methodData [1] = (byte)val;  	methodData [2] = (byte)(val >> 8);  	methodData [3] = (byte)(val >> 16);  	methodData [4] = (byte)(val >> 24);  } else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  	// ldc.i4.0 / ret  	methodData = new byte[] {  		0x16'  		0x2A  	};  } else {  	tokenToNativeMethod [methodToken] = methodData;  	// ldc.i4 0xDEADCODE / conv.u4 / throw  	methodData = new byte[] {  		0x20'  		0xDE'  		0xC0'  		0xAD'  		0xDE'  		0x6D'  		0x7A  	};  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (DeobUtils.IsCode (nativeLdci4' methodData)) {  	uint val = BitConverter.ToUInt32 (methodData' 4);  	// ldc.i4 XXXXXXXXh / ret  	methodData = new byte[] {  		0x20'  		0'  		0'  		0'  		0'  		0x2A  	};  	methodData [1] = (byte)val;  	methodData [2] = (byte)(val >> 8);  	methodData [3] = (byte)(val >> 16);  	methodData [4] = (byte)(val >> 24);  } else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  	// ldc.i4.0 / ret  	methodData = new byte[] {  		0x16'  		0x2A  	};  } else {  	tokenToNativeMethod [methodToken] = methodData;  	// ldc.i4 0xDEADCODE / conv.u4 / throw  	methodData = new byte[] {  		0x20'  		0xDE'  		0xC0'  		0xAD'  		0xDE'  		0x6D'  		0x7A  	};  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: if (DeobUtils.IsCode (nativeLdci4' methodData)) {  	uint val = BitConverter.ToUInt32 (methodData' 4);  	// ldc.i4 XXXXXXXXh / ret  	methodData = new byte[] {  		0x20'  		0'  		0'  		0'  		0'  		0x2A  	};  	methodData [1] = (byte)val;  	methodData [2] = (byte)(val >> 8);  	methodData [3] = (byte)(val >> 16);  	methodData [4] = (byte)(val >> 24);  } else if (DeobUtils.IsCode (nativeLdci4_0' methodData)) {  	// ldc.i4.0 / ret  	methodData = new byte[] {  		0x16'  		0x2A  	};  } else {  	tokenToNativeMethod [methodToken] = methodData;  	// ldc.i4 0xDEADCODE / conv.u4 / throw  	methodData = new byte[] {  		0x20'  		0xDE'  		0xC0'  		0xAD'  		0xDE'  		0x6D'  		0x7A  	};  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: methodData [2] = (byte)(val >> 8);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: methodData [2] = (byte)(val >> 8);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: methodData [3] = (byte)(val >> 16);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: methodData [3] = (byte)(val >> 16);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: methodData [4] = (byte)(val >> 24);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,Decrypt,The following statement contains a magic number: methodData [4] = (byte)(val >> 24);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ldloca_S && instrs [i + 3].OpCode.Code != Code.Ldloca)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	if (!DotNetUtils.IsPinvokeMethod (call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ldloca_S && instrs [i + 3].OpCode.Code != Code.Ldloca)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	if (!DotNetUtils.IsPinvokeMethod (call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ldloca_S && instrs [i + 3].OpCode.Code != Code.Ldloca)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	if (!DotNetUtils.IsPinvokeMethod (call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ldloca_S && instrs [i + 3].OpCode.Code != Code.Ldloca)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	if (!DotNetUtils.IsPinvokeMethod (call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ldloca_S && instrs [i + 3].OpCode.Code != Code.Ldloca)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	if (!DotNetUtils.IsPinvokeMethod (call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ldloca_S && instrs [i + 3].OpCode.Code != Code.Ldloca)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	if (!DotNetUtils.IsPinvokeMethod (call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Mul)  		continue;  	ldci4 = instrs [i + 2];  	if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Ldloca_S && instrs [i + 3].OpCode.Code != Code.Ldloca)  		continue;  	var call = instrs [i + 4];  	if (call.OpCode.Code != Code.Call)  		continue;  	if (!DotNetUtils.IsPinvokeMethod (call.Operand as MethodDef' "kernel32"' "VirtualProtect"))  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: ldci4 = instrs [i + 2];  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: if (!ldci4.IsLdcI4 () || ldci4.GetLdcI4Value () != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Ldloca_S && instrs [i + 3].OpCode.Code != Code.Ldloca)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,IsNewer45Decryption,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Ldloca_S && instrs [i + 3].OpCode.Code != Code.Ldloca)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: foreach (var kv in methodToNativeMethod) {  	if (kv.Key.DeclaringType == null)  		continue;  	// Method was removed  	if (kv.Key.DeclaringType.Module != module)  		continue;  	// method.DeclaringType was removed  	validNativeMethods.Add (kv.Key);  	len += 3 * 4 + kv.Value.Length;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: foreach (var kv in methodToNativeMethod) {  	if (kv.Key.DeclaringType == null)  		continue;  	// Method was removed  	if (kv.Key.DeclaringType.Module != module)  		continue;  	// method.DeclaringType was removed  	validNativeMethods.Add (kv.Key);  	len += 3 * 4 + kv.Value.Length;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: len += 3 * 4 + kv.Value.Length;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: len += 3 * 4 + kv.Value.Length;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: len = (len & ~15) + 16;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,PrepareEncryptNativeMethods,The following statement contains a magic number: len = (len & ~15) + 16;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,EncryptNativeMethods,The following statement contains a magic number: foreach (var method in validNativeMethods) {  	var code = methodToNativeMethod [method];  	var mb = moduleWriter.MetaData.GetMethodBody (method);  	if (mb == null) {  		Logger.e ("Could not find method body for method {0} ({1:X8})"' method' method.MDToken.Raw);  		continue;  	}  	uint codeRva = (uint)mb.RVA;  	if (mb.IsTiny)  		codeRva++;  	else  		codeRva += (uint)(4 * (mb.Code [1] >> 4));  	Logger.v ("Native method {0:X8}' code RVA {1:X8}"' new MDToken (Table.Method' moduleWriter.MetaData.GetRid (method)).Raw' codeRva);  	writer.Write (codeRva);  	writer.Write (0x70000000 + index++);  	writer.Write (code.Length);  	writer.Write (code);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,EncryptNativeMethods,The following statement contains a magic number: foreach (var method in validNativeMethods) {  	var code = methodToNativeMethod [method];  	var mb = moduleWriter.MetaData.GetMethodBody (method);  	if (mb == null) {  		Logger.e ("Could not find method body for method {0} ({1:X8})"' method' method.MDToken.Raw);  		continue;  	}  	uint codeRva = (uint)mb.RVA;  	if (mb.IsTiny)  		codeRva++;  	else  		codeRva += (uint)(4 * (mb.Code [1] >> 4));  	Logger.v ("Native method {0:X8}' code RVA {1:X8}"' new MDToken (Table.Method' moduleWriter.MetaData.GetRid (method)).Raw' codeRva);  	writer.Write (codeRva);  	writer.Write (0x70000000 + index++);  	writer.Write (code.Length);  	writer.Write (code);  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,EncryptNativeMethods,The following statement contains a magic number: if (mb.IsTiny)  	codeRva++;  else  	codeRva += (uint)(4 * (mb.Code [1] >> 4));  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,EncryptNativeMethods,The following statement contains a magic number: if (mb.IsTiny)  	codeRva++;  else  	codeRva += (uint)(4 * (mb.Code [1] >> 4));  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,EncryptNativeMethods,The following statement contains a magic number: codeRva += (uint)(4 * (mb.Code [1] >> 4));  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,EncryptNativeMethods,The following statement contains a magic number: codeRva += (uint)(4 * (mb.Code [1] >> 4));  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,FindDnrCompileMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (!method.IsStatic || method.Body == null)  		continue;  	var sig = method.MethodSig;  	if (sig == null || sig.Params.Count != 6)  		continue;  	if (GetCompileMethodType (method) == CompileMethodType.Unknown)  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,FindDnrCompileMethod,The following statement contains a magic number: if (sig == null || sig.Params.Count != 6)  	continue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: key = new byte[32];  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 32; i++) {  	key [i] = (byte)(i + keyInit [i % keyInit.Length] * keyInit [((i + 0x0B) | 0x1F) % keyInit.Length]);  	kb += key [i];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	for (int j = 0; j < 256; j++)  		transformTemp [i' j] = 0x400;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	for (int j = 0; j < 256; j++)  		transformTemp [i' j] = 0x400;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int j = 0; j < 256; j++)  	transformTemp [i' j] = 0x400;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	while (true) {  		for (int j = key.Length - 1; j >= ki; j--)  			newByte += (byte)(key [j] + counter);  		bool done = true;  		ki = (ki + 1) % key.Length;  		for (int k = 0; k <= i; k++) {  			if (newByte == transformTemp [k' 0]) {  				done = false;  				break;  			}  		}  		if (done)  			break;  		counter++;  	}  	transformTemp [i' 0] = newByte;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  	ki++;  	int i1;  	do {  		counter++;  		i1 = 1 + (this.key [(i + 37 + counter) % key.Length] + counter + kb) % 255;  	} while (transformTemp [0' i1] != 0x400);  	for (int i0 = 0; i0 < 256; i0++)  		transformTemp [i0' i1] = transformTemp [(i0 + ki) % 256' 0];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  	ki++;  	int i1;  	do {  		counter++;  		i1 = 1 + (this.key [(i + 37 + counter) % key.Length] + counter + kb) % 255;  	} while (transformTemp [0' i1] != 0x400);  	for (int i0 = 0; i0 < 256; i0++)  		transformTemp [i0' i1] = transformTemp [(i0 + ki) % 256' 0];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  	ki++;  	int i1;  	do {  		counter++;  		i1 = 1 + (this.key [(i + 37 + counter) % key.Length] + counter + kb) % 255;  	} while (transformTemp [0' i1] != 0x400);  	for (int i0 = 0; i0 < 256; i0++)  		transformTemp [i0' i1] = transformTemp [(i0 + ki) % 256' 0];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  	ki++;  	int i1;  	do {  		counter++;  		i1 = 1 + (this.key [(i + 37 + counter) % key.Length] + counter + kb) % 255;  	} while (transformTemp [0' i1] != 0x400);  	for (int i0 = 0; i0 < 256; i0++)  		transformTemp [i0' i1] = transformTemp [(i0 + ki) % 256' 0];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  	ki++;  	int i1;  	do {  		counter++;  		i1 = 1 + (this.key [(i + 37 + counter) % key.Length] + counter + kb) % 255;  	} while (transformTemp [0' i1] != 0x400);  	for (int i0 = 0; i0 < 256; i0++)  		transformTemp [i0' i1] = transformTemp [(i0 + ki) % 256' 0];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: do {  	counter++;  	i1 = 1 + (this.key [(i + 37 + counter) % key.Length] + counter + kb) % 255;  } while (transformTemp [0' i1] != 0x400);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: do {  	counter++;  	i1 = 1 + (this.key [(i + 37 + counter) % key.Length] + counter + kb) % 255;  } while (transformTemp [0' i1] != 0x400);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: i1 = 1 + (this.key [(i + 37 + counter) % key.Length] + counter + kb) % 255;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: i1 = 1 + (this.key [(i + 37 + counter) % key.Length] + counter + kb) % 255;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i0 = 0; i0 < 256; i0++)  	transformTemp [i0' i1] = transformTemp [(i0 + ki) % 256' 0];  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i0 = 0; i0 < 256; i0++)  	transformTemp [i0' i1] = transformTemp [(i0 + ki) % 256' 0];  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: transformTemp [i0' i1] = transformTemp [(i0 + ki) % 256' 0];  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	for (int j = 0; j < 256; j++)  		transform [(byte)transformTemp [i' j]' j] = (byte)i;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	for (int j = 0; j < 256; j++)  		transform [(byte)transformTemp [i' j]' j] = (byte)i;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int j = 0; j < 256; j++)  	transform [(byte)transformTemp [i' j]' j] = (byte)i;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i += 1024' offset += 1024) {  	int blockLen = Math.Min (1024' count - i);  	if (blockLen == 1) {  		data [offset] = transform [data [offset]' kb];  		continue;  	}  	for (int j = 0; j < blockLen - 1; j++)  		data [offset + j] = transform [data [offset + j]' data [offset + j + 1]];  	data [offset + blockLen - 1] = transform [data [offset + blockLen - 1]' kb ^ 0x55];  	for (int j = blockLen - 1; j > 0; j--)  		data [offset + j] = transform [data [offset + j]' data [offset + j - 1]];  	data [offset] = transform [data [offset]' kb];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i += 1024' offset += 1024) {  	int blockLen = Math.Min (1024' count - i);  	if (blockLen == 1) {  		data [offset] = transform [data [offset]' kb];  		continue;  	}  	for (int j = 0; j < blockLen - 1; j++)  		data [offset + j] = transform [data [offset + j]' data [offset + j + 1]];  	data [offset + blockLen - 1] = transform [data [offset + blockLen - 1]' kb ^ 0x55];  	for (int j = blockLen - 1; j > 0; j--)  		data [offset + j] = transform [data [offset + j]' data [offset + j - 1]];  	data [offset] = transform [data [offset]' kb];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i += 1024' offset += 1024) {  	int blockLen = Math.Min (1024' count - i);  	if (blockLen == 1) {  		data [offset] = transform [data [offset]' kb];  		continue;  	}  	for (int j = 0; j < blockLen - 1; j++)  		data [offset + j] = transform [data [offset + j]' data [offset + j + 1]];  	data [offset + blockLen - 1] = transform [data [offset + blockLen - 1]' kb ^ 0x55];  	for (int j = blockLen - 1; j > 0; j--)  		data [offset + j] = transform [data [offset + j]' data [offset + j - 1]];  	data [offset] = transform [data [offset]' kb];  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,Decrypt,The following statement contains a magic number: i += 1024
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,Decrypt,The following statement contains a magic number: offset += 1024
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,Unpack,The following statement contains a magic number: if (isNet1x)  	inflatedData = DeobUtils.Inflate (encryptedData' false);  else {  	int inflatedSize = BitConverter.ToInt32 (encryptedData' 0);  	inflatedData = new byte[inflatedSize];  	var inflater = new Inflater (false);  	inflater.SetInput (encryptedData' 4' encryptedData.Length - 4);  	int count = inflater.Inflate (inflatedData);  	if (count != inflatedSize)  		return null;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,Unpack,The following statement contains a magic number: if (isNet1x)  	inflatedData = DeobUtils.Inflate (encryptedData' false);  else {  	int inflatedSize = BitConverter.ToInt32 (encryptedData' 0);  	inflatedData = new byte[inflatedSize];  	var inflater = new Inflater (false);  	inflater.SetInput (encryptedData' 4' encryptedData.Length - 4);  	int count = inflater.Inflate (inflatedData);  	if (count != inflatedSize)  		return null;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,Unpack,The following statement contains a magic number: inflater.SetInput (encryptedData' 4' encryptedData.Length - 4);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,Unpack,The following statement contains a magic number: inflater.SetInput (encryptedData' 4' encryptedData.Length - 4);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,GetKeyData,The following statement contains a magic number: if (DeobUtils.IsCode (startMethodNet1xPattern' net1xCode)) {  	isNet1x = true;  	return new byte[6] {  		0x34'  		0x38'  		0x63'  		0x65'  		0x7A'  		0x35  	};  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,GetKeyData,The following statement contains a magic number: return new byte[6] {  	0x34'  	0x38'  	0x63'  	0x65'  	0x7A'  	0x35  };  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,GetKeyData,The following statement contains a magic number: return new byte[6] {  	peImage.OffsetReadByte (baseOffset + 5)'  	peImage.OffsetReadByte (baseOffset + 0xF)'  	peImage.OffsetReadByte (baseOffset + 0x58)'  	peImage.OffsetReadByte (baseOffset + 0x6D)'  	peImage.OffsetReadByte (baseOffset + 0x98)'  	peImage.OffsetReadByte (baseOffset + 0xA6)'  };  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,GetKeyData,The following statement contains a magic number: return new byte[6] {  	peImage.OffsetReadByte (baseOffset + 5)'  	peImage.OffsetReadByte (baseOffset + 0xF)'  	peImage.OffsetReadByte (baseOffset + 0x58)'  	peImage.OffsetReadByte (baseOffset + 0x6D)'  	peImage.OffsetReadByte (baseOffset + 0x98)'  	peImage.OffsetReadByte (baseOffset + 0xA6)'  };  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,CheckFields,The following statement contains a magic number: if (fields.Count != 3 && fields.Count != 4)  	return false;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,CheckFields,The following statement contains a magic number: if (fields.Count != 3 && fields.Count != 4)  	return false;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,CheckFields,The following statement contains a magic number: if (fieldTypes.Count ("System.Object") == 2)  	return true;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,The following statement contains a magic number: foreach (var calledMethod in DotNetUtils.GetCalledMethods (module' method)) {  	if (calledMethod.DeclaringType != method.DeclaringType)  		continue;  	if (calledMethod.MethodSig.GetRetType ().GetFullName () != "System.Byte[]")  		continue;  	var localTypes = new LocalTypes (calledMethod);  	if (!localTypes.All (requiredTypes))  		continue;  	var instructions = calledMethod.Body.Instructions;  	byte[] newKey = null' newIv = null;  	for (int i = 0; i < instructions.Count && (newKey == null || newIv == null); i++) {  		var instr = instructions [i];  		if (instr.OpCode.Code != Code.Ldtoken)  			continue;  		var field = instr.Operand as FieldDef;  		if (field == null)  			continue;  		if (field.InitialValue == null)  			continue;  		if (field.InitialValue.Length == 32)  			newKey = field.InitialValue;  		else if (field.InitialValue.Length == 16)  			newIv = field.InitialValue;  	}  	if (newKey == null || newIv == null)  		continue;  	InitializeStringDecrypterVersion (method);  	key = newKey;  	iv = newIv;  	return;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,The following statement contains a magic number: foreach (var calledMethod in DotNetUtils.GetCalledMethods (module' method)) {  	if (calledMethod.DeclaringType != method.DeclaringType)  		continue;  	if (calledMethod.MethodSig.GetRetType ().GetFullName () != "System.Byte[]")  		continue;  	var localTypes = new LocalTypes (calledMethod);  	if (!localTypes.All (requiredTypes))  		continue;  	var instructions = calledMethod.Body.Instructions;  	byte[] newKey = null' newIv = null;  	for (int i = 0; i < instructions.Count && (newKey == null || newIv == null); i++) {  		var instr = instructions [i];  		if (instr.OpCode.Code != Code.Ldtoken)  			continue;  		var field = instr.Operand as FieldDef;  		if (field == null)  			continue;  		if (field.InitialValue == null)  			continue;  		if (field.InitialValue.Length == 32)  			newKey = field.InitialValue;  		else if (field.InitialValue.Length == 16)  			newIv = field.InitialValue;  	}  	if (newKey == null || newIv == null)  		continue;  	InitializeStringDecrypterVersion (method);  	key = newKey;  	iv = newIv;  	return;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,The following statement contains a magic number: for (int i = 0; i < instructions.Count && (newKey == null || newIv == null); i++) {  	var instr = instructions [i];  	if (instr.OpCode.Code != Code.Ldtoken)  		continue;  	var field = instr.Operand as FieldDef;  	if (field == null)  		continue;  	if (field.InitialValue == null)  		continue;  	if (field.InitialValue.Length == 32)  		newKey = field.InitialValue;  	else if (field.InitialValue.Length == 16)  		newIv = field.InitialValue;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,The following statement contains a magic number: for (int i = 0; i < instructions.Count && (newKey == null || newIv == null); i++) {  	var instr = instructions [i];  	if (instr.OpCode.Code != Code.Ldtoken)  		continue;  	var field = instr.Operand as FieldDef;  	if (field == null)  		continue;  	if (field.InitialValue == null)  		continue;  	if (field.InitialValue.Length == 32)  		newKey = field.InitialValue;  	else if (field.InitialValue.Length == 16)  		newIv = field.InitialValue;  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,The following statement contains a magic number: if (field.InitialValue.Length == 32)  	newKey = field.InitialValue;  else if (field.InitialValue.Length == 16)  	newIv = field.InitialValue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,The following statement contains a magic number: if (field.InitialValue.Length == 32)  	newKey = field.InitialValue;  else if (field.InitialValue.Length == 16)  	newIv = field.InitialValue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,FindKeyIv,The following statement contains a magic number: if (field.InitialValue.Length == 16)  	newIv = field.InitialValue;  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (info.key == null) {  	int length = BitConverter.ToInt32 (decryptedData' offset);  	return Encoding.Unicode.GetString (decryptedData' offset + 4' length);  } else {  	byte[] encryptedStringData;  	if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  		int fileOffset = BitConverter.ToInt32 (decryptedData' offset);  		int length = BitConverter.ToInt32 (fileData' fileOffset);  		encryptedStringData = new byte[length];  		Array.Copy (fileData' fileOffset + 4' encryptedStringData' 0' length);  	} else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  		uint rva = BitConverter.ToUInt32 (decryptedData' offset);  		int length = peImage.ReadInt32 (rva);  		encryptedStringData = peImage.ReadBytes (rva + 4' length);  	} else  		throw new ApplicationException ("Unknown string decrypter version");  	return Encoding.Unicode.GetString (DeobUtils.AesDecrypt (encryptedStringData' info.key' info.iv));  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (info.key == null) {  	int length = BitConverter.ToInt32 (decryptedData' offset);  	return Encoding.Unicode.GetString (decryptedData' offset + 4' length);  } else {  	byte[] encryptedStringData;  	if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  		int fileOffset = BitConverter.ToInt32 (decryptedData' offset);  		int length = BitConverter.ToInt32 (fileData' fileOffset);  		encryptedStringData = new byte[length];  		Array.Copy (fileData' fileOffset + 4' encryptedStringData' 0' length);  	} else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  		uint rva = BitConverter.ToUInt32 (decryptedData' offset);  		int length = peImage.ReadInt32 (rva);  		encryptedStringData = peImage.ReadBytes (rva + 4' length);  	} else  		throw new ApplicationException ("Unknown string decrypter version");  	return Encoding.Unicode.GetString (DeobUtils.AesDecrypt (encryptedStringData' info.key' info.iv));  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (info.key == null) {  	int length = BitConverter.ToInt32 (decryptedData' offset);  	return Encoding.Unicode.GetString (decryptedData' offset + 4' length);  } else {  	byte[] encryptedStringData;  	if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  		int fileOffset = BitConverter.ToInt32 (decryptedData' offset);  		int length = BitConverter.ToInt32 (fileData' fileOffset);  		encryptedStringData = new byte[length];  		Array.Copy (fileData' fileOffset + 4' encryptedStringData' 0' length);  	} else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  		uint rva = BitConverter.ToUInt32 (decryptedData' offset);  		int length = peImage.ReadInt32 (rva);  		encryptedStringData = peImage.ReadBytes (rva + 4' length);  	} else  		throw new ApplicationException ("Unknown string decrypter version");  	return Encoding.Unicode.GetString (DeobUtils.AesDecrypt (encryptedStringData' info.key' info.iv));  }  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: return Encoding.Unicode.GetString (decryptedData' offset + 4' length);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  	int fileOffset = BitConverter.ToInt32 (decryptedData' offset);  	int length = BitConverter.ToInt32 (fileData' fileOffset);  	encryptedStringData = new byte[length];  	Array.Copy (fileData' fileOffset + 4' encryptedStringData' 0' length);  } else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  	uint rva = BitConverter.ToUInt32 (decryptedData' offset);  	int length = peImage.ReadInt32 (rva);  	encryptedStringData = peImage.ReadBytes (rva + 4' length);  } else  	throw new ApplicationException ("Unknown string decrypter version");  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  	int fileOffset = BitConverter.ToInt32 (decryptedData' offset);  	int length = BitConverter.ToInt32 (fileData' fileOffset);  	encryptedStringData = new byte[length];  	Array.Copy (fileData' fileOffset + 4' encryptedStringData' 0' length);  } else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  	uint rva = BitConverter.ToUInt32 (decryptedData' offset);  	int length = peImage.ReadInt32 (rva);  	encryptedStringData = peImage.ReadBytes (rva + 4' length);  } else  	throw new ApplicationException ("Unknown string decrypter version");  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: Array.Copy (fileData' fileOffset + 4' encryptedStringData' 0' length);  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  	uint rva = BitConverter.ToUInt32 (decryptedData' offset);  	int length = peImage.ReadInt32 (rva);  	encryptedStringData = peImage.ReadBytes (rva + 4' length);  } else  	throw new ApplicationException ("Unknown string decrypter version");  
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,Decrypt,The following statement contains a magic number: encryptedStringData = peImage.ReadBytes (rva + 4' length);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CheckInitMethodSilverlight,The following statement contains a magic number: if (type.NestedTypes.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CheckInitMethod,The following statement contains a magic number: if (type.NestedTypes.Count < 2 || type.NestedTypes.Count > 6)  	return false;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CheckInitMethod,The following statement contains a magic number: if (type.NestedTypes.Count < 2 || type.NestedTypes.Count > 6)  	return false;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,GetDecryptMethod,The following statement contains a magic number: foreach (var method in resolverType.Methods) {  	if (!method.IsStatic || method.Body == null)  		continue;  	if (!DotNetUtils.IsMethod (method' "System.Byte[]"' "(System.Byte[])"))  		continue;  	if (!DeobUtils.HasInteger (method' 32) || !DeobUtils.HasInteger (method' 121))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,GetDecryptMethod,The following statement contains a magic number: foreach (var method in resolverType.Methods) {  	if (!method.IsStatic || method.Body == null)  		continue;  	if (!DotNetUtils.IsMethod (method' "System.Byte[]"' "(System.Byte[])"))  		continue;  	if (!DeobUtils.HasInteger (method' 32) || !DeobUtils.HasInteger (method' 121))  		continue;  	return method;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,GetDecryptMethod,The following statement contains a magic number: if (!DeobUtils.HasInteger (method' 32) || !DeobUtils.HasInteger (method' 121))  	continue;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,GetDecryptMethod,The following statement contains a magic number: if (!DeobUtils.HasInteger (method' 32) || !DeobUtils.HasInteger (method' 121))  	continue;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.GetCodeStrings (decryptMethod)) {  	decryptKey = DecodeBase64 (s);  	if (decryptKey == null || decryptKey.Length == 0)  		continue;  	if (decrypterType.Detected) {  		var data = new byte[8];  		ulong magic = decrypterType.GetMagic ();  		data [0] = (byte)magic;  		data [7] = (byte)(magic >> 8);  		data [6] = (byte)(magic >> 16);  		data [5] = (byte)(magic >> 24);  		data [4] = (byte)(magic >> 32);  		data [1] = (byte)(magic >> 40);  		data [3] = (byte)(magic >> 48);  		data [2] = (byte)(magic >> 56);  		for (int i = 0; i < decryptKey.Length; i++)  			decryptKey [i] ^= (byte)(i + data [i % data.Length]);  	}  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: if (decrypterType.Detected) {  	var data = new byte[8];  	ulong magic = decrypterType.GetMagic ();  	data [0] = (byte)magic;  	data [7] = (byte)(magic >> 8);  	data [6] = (byte)(magic >> 16);  	data [5] = (byte)(magic >> 24);  	data [4] = (byte)(magic >> 32);  	data [1] = (byte)(magic >> 40);  	data [3] = (byte)(magic >> 48);  	data [2] = (byte)(magic >> 56);  	for (int i = 0; i < decryptKey.Length; i++)  		decryptKey [i] ^= (byte)(i + data [i % data.Length]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [7] = (byte)(magic >> 8);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [7] = (byte)(magic >> 8);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [6] = (byte)(magic >> 16);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [6] = (byte)(magic >> 16);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [5] = (byte)(magic >> 24);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [5] = (byte)(magic >> 24);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [4] = (byte)(magic >> 32);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [4] = (byte)(magic >> 32);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [1] = (byte)(magic >> 40);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [3] = (byte)(magic >> 48);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [3] = (byte)(magic >> 48);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [2] = (byte)(magic >> 56);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,CreateDecryptKey,The following statement contains a magic number: data [2] = (byte)(magic >> 56);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,TryCreateAssemblyInfos,The following statement contains a magic number: for (int i = 0; i < ary.Length; i += numElements) {  	var info = new AssemblyInfo ();  	info.AssemblyFullName = Encoding.UTF8.GetString (Convert.FromBase64String (ary [i]));  	info.ResourceName = ary [i + 1];  	if (numElements >= 3)  		info.Filename = Encoding.UTF8.GetString (Convert.FromBase64String (ary [i + 2]));  	else  		info.Filename = Utils.GetAssemblySimpleName (info.AssemblyFullName) + ".dll";  	int index = info.ResourceName.IndexOf ('|');  	if (index >= 0) {  		var flags = info.ResourceName.Substring (0' index);  		info.ResourceName = info.ResourceName.Substring (index + 1);  		info.IsEncrypted = flags.IndexOf ('a') >= 0;  		info.IsCompressed = flags.IndexOf ('b') >= 0;  	}  	infos.Add (info);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,TryCreateAssemblyInfos,The following statement contains a magic number: for (int i = 0; i < ary.Length; i += numElements) {  	var info = new AssemblyInfo ();  	info.AssemblyFullName = Encoding.UTF8.GetString (Convert.FromBase64String (ary [i]));  	info.ResourceName = ary [i + 1];  	if (numElements >= 3)  		info.Filename = Encoding.UTF8.GetString (Convert.FromBase64String (ary [i + 2]));  	else  		info.Filename = Utils.GetAssemblySimpleName (info.AssemblyFullName) + ".dll";  	int index = info.ResourceName.IndexOf ('|');  	if (index >= 0) {  		var flags = info.ResourceName.Substring (0' index);  		info.ResourceName = info.ResourceName.Substring (index + 1);  		info.IsEncrypted = flags.IndexOf ('a') >= 0;  		info.IsCompressed = flags.IndexOf ('b') >= 0;  	}  	infos.Add (info);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,TryCreateAssemblyInfos,The following statement contains a magic number: if (numElements >= 3)  	info.Filename = Encoding.UTF8.GetString (Convert.FromBase64String (ary [i + 2]));  else  	info.Filename = Utils.GetAssemblySimpleName (info.AssemblyFullName) + ".dll";  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,TryCreateAssemblyInfos,The following statement contains a magic number: if (numElements >= 3)  	info.Filename = Encoding.UTF8.GetString (Convert.FromBase64String (ary [i + 2]));  else  	info.Filename = Utils.GetAssemblySimpleName (info.AssemblyFullName) + ".dll";  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,TryCreateAssemblyInfos,The following statement contains a magic number: info.Filename = Encoding.UTF8.GetString (Convert.FromBase64String (ary [i + 2]));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < encryptedData.Length; i++) {  	if ((i & 0x1F) == 0) {  		i2 += indexes [++i1];  		Swap (indexes' i1' i2);  		val = indexes [(byte)(indexes [i1] + indexes [i2])];  	}  	encryptedData [i] ^= (byte)(val ^ key2 [(i >> 2) & 3] ^ key2 [(i + 1) & 3]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < encryptedData.Length; i++) {  	if ((i & 0x1F) == 0) {  		i2 += indexes [++i1];  		Swap (indexes' i1' i2);  		val = indexes [(byte)(indexes [i1] + indexes [i2])];  	}  	encryptedData [i] ^= (byte)(val ^ key2 [(i >> 2) & 3] ^ key2 [(i + 1) & 3]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < encryptedData.Length; i++) {  	if ((i & 0x1F) == 0) {  		i2 += indexes [++i1];  		Swap (indexes' i1' i2);  		val = indexes [(byte)(indexes [i1] + indexes [i2])];  	}  	encryptedData [i] ^= (byte)(val ^ key2 [(i >> 2) & 3] ^ key2 [(i + 1) & 3]);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decrypt,The following statement contains a magic number: encryptedData [i] ^= (byte)(val ^ key2 [(i >> 2) & 3] ^ key2 [(i + 1) & 3]);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decrypt,The following statement contains a magic number: encryptedData [i] ^= (byte)(val ^ key2 [(i >> 2) & 3] ^ key2 [(i + 1) & 3]);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decrypt,The following statement contains a magic number: encryptedData [i] ^= (byte)(val ^ key2 [(i >> 2) & 3] ^ key2 [(i + 1) & 3]);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decompress,The following statement contains a magic number: return DeobUtils.Inflate (compressedData' 8' compressedData.Length - 8' true);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,Decompress,The following statement contains a magic number: return DeobUtils.Inflate (compressedData' 8' compressedData.Length - 8' true);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods = new MethodDef[6];  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods [5] = FindEfConstMethodCall (efConstMethods [0]);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods [4] = FindEfConstMethodCall (efConstMethods [5]);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods [4] = FindEfConstMethodCall (efConstMethods [5]);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: if (calls.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: if (GetNumberOfTypeofs (calls [0]) == 3) {  	efConstMethods [2] = calls [0];  	efConstMethods [1] = calls [1];  } else {  	efConstMethods [2] = calls [0];  	efConstMethods [1] = calls [1];  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: if (GetNumberOfTypeofs (calls [0]) == 3) {  	efConstMethods [2] = calls [0];  	efConstMethods [1] = calls [1];  } else {  	efConstMethods [2] = calls [0];  	efConstMethods [1] = calls [1];  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: if (GetNumberOfTypeofs (calls [0]) == 3) {  	efConstMethods [2] = calls [0];  	efConstMethods [1] = calls [1];  } else {  	efConstMethods [2] = calls [0];  	efConstMethods [1] = calls [1];  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods [2] = calls [0];  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods [2] = calls [0];  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,InitializeEfConstMethods,The following statement contains a magic number: efConstMethods [3] = FindEfConstMethodCall (efConstMethods [1]);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindInt1And2,The following statement contains a magic number: if (consts.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindMethodInts,The following statement contains a magic number: foreach (var nestedType in type.NestedTypes) {  	var methods = GetBinaryIntMethods (nestedType);  	if (methods.Count < 3)  		continue;  	foreach (var m in methods)  		simpleDeobfuscator.Deobfuscate (m);  	if (!FindMethod1Int (methods))  		continue;  	if (!FindMethod2Int (methods))  		continue;  	if (!FindMethod3Int (methods))  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindMethodInts,The following statement contains a magic number: if (methods.Count < 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindMethod2Int,The following statement contains a magic number: foreach (var method in methods) {  	var constants = GetConstants (method);  	if (constants.Count != 2)  		continue;  	m2_i1 = constants [0];  	m2_i2 = constants [1];  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindMethod2Int,The following statement contains a magic number: if (constants.Count != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindMethod3Int,The following statement contains a magic number: foreach (var method in methods) {  	if (CountInstructions (method' Code.Ldarg_0) != 2)  		continue;  	var constants = GetConstants (method);  	if (constants.Count != 1)  		continue;  	m3_i1 = constants [0];  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,FindMethod3Int,The following statement contains a magic number: if (CountInstructions (method' Code.Ldarg_0) != 2)  	continue;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod1,The following statement contains a magic number: return BinOp3 (BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [0].DeclaringType.MDToken.ToInt32 ()' efConstMethods [4].DeclaringType.MDToken.ToInt32 ()))' ConstMethod6 ());  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod2,The following statement contains a magic number: return BinOp1 (efConstMethods [2].DeclaringType.MDToken.ToInt32 ()' efConstMethods [3].DeclaringType.MDToken.ToInt32 () ^ BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' ConstMethod4 ())));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod2,The following statement contains a magic number: return BinOp1 (efConstMethods [2].DeclaringType.MDToken.ToInt32 ()' efConstMethods [3].DeclaringType.MDToken.ToInt32 () ^ BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' ConstMethod4 ())));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod2,The following statement contains a magic number: return BinOp1 (efConstMethods [2].DeclaringType.MDToken.ToInt32 ()' efConstMethods [3].DeclaringType.MDToken.ToInt32 () ^ BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' ConstMethod4 ())));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod3,The following statement contains a magic number: return BinOp3 (BinOp1 (ConstMethod2 () ^ i1' efConstMethods [3].DeclaringType.MDToken.ToInt32 ())' BinOp2 (efConstMethods [0].DeclaringType.MDToken.ToInt32 () ^ efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' i2));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod3,The following statement contains a magic number: return BinOp3 (BinOp1 (ConstMethod2 () ^ i1' efConstMethods [3].DeclaringType.MDToken.ToInt32 ())' BinOp2 (efConstMethods [0].DeclaringType.MDToken.ToInt32 () ^ efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' i2));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod4,The following statement contains a magic number: return BinOp3 (efConstMethods [3].DeclaringType.MDToken.ToInt32 ()' BinOp1 (efConstMethods [0].DeclaringType.MDToken.ToInt32 ()' BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [2].DeclaringType.MDToken.ToInt32 ()' BinOp1 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' efConstMethods [5].DeclaringType.MDToken.ToInt32 ())))));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod4,The following statement contains a magic number: return BinOp3 (efConstMethods [3].DeclaringType.MDToken.ToInt32 ()' BinOp1 (efConstMethods [0].DeclaringType.MDToken.ToInt32 ()' BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [2].DeclaringType.MDToken.ToInt32 ()' BinOp1 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' efConstMethods [5].DeclaringType.MDToken.ToInt32 ())))));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod4,The following statement contains a magic number: return BinOp3 (efConstMethods [3].DeclaringType.MDToken.ToInt32 ()' BinOp1 (efConstMethods [0].DeclaringType.MDToken.ToInt32 ()' BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [2].DeclaringType.MDToken.ToInt32 ()' BinOp1 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' efConstMethods [5].DeclaringType.MDToken.ToInt32 ())))));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod4,The following statement contains a magic number: return BinOp3 (efConstMethods [3].DeclaringType.MDToken.ToInt32 ()' BinOp1 (efConstMethods [0].DeclaringType.MDToken.ToInt32 ()' BinOp2 (efConstMethods [1].DeclaringType.MDToken.ToInt32 ()' BinOp3 (efConstMethods [2].DeclaringType.MDToken.ToInt32 ()' BinOp1 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' efConstMethods [5].DeclaringType.MDToken.ToInt32 ())))));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod5,The following statement contains a magic number: return BinOp2 (BinOp2 (ConstMethod3 ()' BinOp1 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' ConstMethod2 ()))' efConstMethods [5].DeclaringType.MDToken.ToInt32 ());  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod5,The following statement contains a magic number: return BinOp2 (BinOp2 (ConstMethod3 ()' BinOp1 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' ConstMethod2 ()))' efConstMethods [5].DeclaringType.MDToken.ToInt32 ());  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod6,The following statement contains a magic number: return BinOp1 (efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' BinOp3 (BinOp2 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' efConstMethods [0].DeclaringType.MDToken.ToInt32 ())' BinOp3 (efConstMethods [2].DeclaringType.MDToken.ToInt32 () ^ i3' ConstMethod5 ())));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod6,The following statement contains a magic number: return BinOp1 (efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' BinOp3 (BinOp2 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' efConstMethods [0].DeclaringType.MDToken.ToInt32 ())' BinOp3 (efConstMethods [2].DeclaringType.MDToken.ToInt32 () ^ i3' ConstMethod5 ())));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,ConstMethod6,The following statement contains a magic number: return BinOp1 (efConstMethods [5].DeclaringType.MDToken.ToInt32 ()' BinOp3 (BinOp2 (efConstMethods [4].DeclaringType.MDToken.ToInt32 ()' efConstMethods [0].DeclaringType.MDToken.ToInt32 ())' BinOp3 (efConstMethods [2].DeclaringType.MDToken.ToInt32 () ^ i3' ConstMethod5 ())));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add ((byte)(num2 >> shiftConsts [2]));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add ((byte)(num3 >> shiftConsts [3]));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add ((byte)(num2 >> shiftConsts [4]));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add ((byte)(num3 >> shiftConsts [5]));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add ((byte)(num2 >> shiftConsts [6]));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: bytes.Add ((byte)(num3 >> shiftConsts [7]));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: foreach (var b in bytes) {  	magic += b;  	magic += magic << 20;  	magic ^= magic >> 12;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: foreach (var b in bytes) {  	magic += b;  	magic += magic << 20;  	magic ^= magic >> 12;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: magic += magic << 20;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: magic ^= magic >> 12;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: magic += magic << 6;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: magic ^= magic >> 22;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,GetMagic,The following statement contains a magic number: magic += magic << 30;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (detectedVersion)  	val += 10;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 10;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,EfConstantsReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\EfConstantsReader.cs,FindConstants,The following statement contains a magic number: if (localsValuesInt32.Count != 2)  	localsValuesInt32.Clear ();  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,CheckIfV32OrLater,The following statement contains a magic number: return numInts >= 2;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,CheckType,The following statement contains a magic number: if (type.NestedTypes.Count == 0) {  	return DotNetUtils.FindFieldType (type' "System.IO.BinaryReader"' true) != null && DotNetUtils.FindFieldType (type' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' true) != null;  } else if (type.NestedTypes.Count == 3) {  	streamHelperType = FindStreamHelperType (type);  	return streamHelperType != null;  } else if (type.NestedTypes.Count == 1) {  	return type.NestedTypes [0].IsEnum;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,CheckType,The following statement contains a magic number: if (type.NestedTypes.Count == 3) {  	streamHelperType = FindStreamHelperType (type);  	return streamHelperType != null;  } else if (type.NestedTypes.Count == 1) {  	return type.NestedTypes [0].IsEnum;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,CheckIfHelperMethod,The following statement contains a magic number: return method.DeclaringType.Methods.Count == 4 && !method.IsAssembly;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: checkMinus2 = isV32OrLater || DeobUtils.HasInteger (stringMethod' -2);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (isV32OrLater) {  	bool initializedAll;  	int index = FindInitIntsIndex (stringMethod' out initializedAll);  	var cctor = stringType.FindStaticConstructor ();  	if (!initializedAll && cctor != null) {  		simpleDeobfuscator.Deobfuscate (cctor);  		if (!FindIntsCctor (cctor))  			return false;  	}  	if (decrypterType.Detected && !decrypterType.Initialize ())  		return false;  	if (!isV50OrLater) {  		decrypterType.ShiftConsts = new List<int> {  			24'  			16'  			8'  			0'  			16'  			8'  			0'  			24  		};  	} else {  		List<int> shiftConsts;  		if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  			return false;  		decrypterType.ShiftConsts = shiftConsts;  	}  	if (!FindInts (index))  		return false;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (isV32OrLater) {  	bool initializedAll;  	int index = FindInitIntsIndex (stringMethod' out initializedAll);  	var cctor = stringType.FindStaticConstructor ();  	if (!initializedAll && cctor != null) {  		simpleDeobfuscator.Deobfuscate (cctor);  		if (!FindIntsCctor (cctor))  			return false;  	}  	if (decrypterType.Detected && !decrypterType.Initialize ())  		return false;  	if (!isV50OrLater) {  		decrypterType.ShiftConsts = new List<int> {  			24'  			16'  			8'  			0'  			16'  			8'  			0'  			24  		};  	} else {  		List<int> shiftConsts;  		if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  			return false;  		decrypterType.ShiftConsts = shiftConsts;  	}  	if (!FindInts (index))  		return false;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (isV32OrLater) {  	bool initializedAll;  	int index = FindInitIntsIndex (stringMethod' out initializedAll);  	var cctor = stringType.FindStaticConstructor ();  	if (!initializedAll && cctor != null) {  		simpleDeobfuscator.Deobfuscate (cctor);  		if (!FindIntsCctor (cctor))  			return false;  	}  	if (decrypterType.Detected && !decrypterType.Initialize ())  		return false;  	if (!isV50OrLater) {  		decrypterType.ShiftConsts = new List<int> {  			24'  			16'  			8'  			0'  			16'  			8'  			0'  			24  		};  	} else {  		List<int> shiftConsts;  		if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  			return false;  		decrypterType.ShiftConsts = shiftConsts;  	}  	if (!FindInts (index))  		return false;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (isV32OrLater) {  	bool initializedAll;  	int index = FindInitIntsIndex (stringMethod' out initializedAll);  	var cctor = stringType.FindStaticConstructor ();  	if (!initializedAll && cctor != null) {  		simpleDeobfuscator.Deobfuscate (cctor);  		if (!FindIntsCctor (cctor))  			return false;  	}  	if (decrypterType.Detected && !decrypterType.Initialize ())  		return false;  	if (!isV50OrLater) {  		decrypterType.ShiftConsts = new List<int> {  			24'  			16'  			8'  			0'  			16'  			8'  			0'  			24  		};  	} else {  		List<int> shiftConsts;  		if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  			return false;  		decrypterType.ShiftConsts = shiftConsts;  	}  	if (!FindInts (index))  		return false;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (isV32OrLater) {  	bool initializedAll;  	int index = FindInitIntsIndex (stringMethod' out initializedAll);  	var cctor = stringType.FindStaticConstructor ();  	if (!initializedAll && cctor != null) {  		simpleDeobfuscator.Deobfuscate (cctor);  		if (!FindIntsCctor (cctor))  			return false;  	}  	if (decrypterType.Detected && !decrypterType.Initialize ())  		return false;  	if (!isV50OrLater) {  		decrypterType.ShiftConsts = new List<int> {  			24'  			16'  			8'  			0'  			16'  			8'  			0'  			24  		};  	} else {  		List<int> shiftConsts;  		if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  			return false;  		decrypterType.ShiftConsts = shiftConsts;  	}  	if (!FindInts (index))  		return false;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (isV32OrLater) {  	bool initializedAll;  	int index = FindInitIntsIndex (stringMethod' out initializedAll);  	var cctor = stringType.FindStaticConstructor ();  	if (!initializedAll && cctor != null) {  		simpleDeobfuscator.Deobfuscate (cctor);  		if (!FindIntsCctor (cctor))  			return false;  	}  	if (decrypterType.Detected && !decrypterType.Initialize ())  		return false;  	if (!isV50OrLater) {  		decrypterType.ShiftConsts = new List<int> {  			24'  			16'  			8'  			0'  			16'  			8'  			0'  			24  		};  	} else {  		List<int> shiftConsts;  		if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  			return false;  		decrypterType.ShiftConsts = shiftConsts;  	}  	if (!FindInts (index))  		return false;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (!isV50OrLater) {  	decrypterType.ShiftConsts = new List<int> {  		24'  		16'  		8'  		0'  		16'  		8'  		0'  		24  	};  } else {  	List<int> shiftConsts;  	if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  		return false;  	decrypterType.ShiftConsts = shiftConsts;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (!isV50OrLater) {  	decrypterType.ShiftConsts = new List<int> {  		24'  		16'  		8'  		0'  		16'  		8'  		0'  		24  	};  } else {  	List<int> shiftConsts;  	if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  		return false;  	decrypterType.ShiftConsts = shiftConsts;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (!isV50OrLater) {  	decrypterType.ShiftConsts = new List<int> {  		24'  		16'  		8'  		0'  		16'  		8'  		0'  		24  	};  } else {  	List<int> shiftConsts;  	if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  		return false;  	decrypterType.ShiftConsts = shiftConsts;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (!isV50OrLater) {  	decrypterType.ShiftConsts = new List<int> {  		24'  		16'  		8'  		0'  		16'  		8'  		0'  		24  	};  } else {  	List<int> shiftConsts;  	if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  		return false;  	decrypterType.ShiftConsts = shiftConsts;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (!isV50OrLater) {  	decrypterType.ShiftConsts = new List<int> {  		24'  		16'  		8'  		0'  		16'  		8'  		0'  		24  	};  } else {  	List<int> shiftConsts;  	if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  		return false;  	decrypterType.ShiftConsts = shiftConsts;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: if (!isV50OrLater) {  	decrypterType.ShiftConsts = new List<int> {  		24'  		16'  		8'  		0'  		16'  		8'  		0'  		24  	};  } else {  	List<int> shiftConsts;  	if (!FindShiftInts (decrypterType.Int64Method' out shiftConsts))  		return false;  	decrypterType.ShiftConsts = shiftConsts;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: decrypterType.ShiftConsts = new List<int> {  	24'  	16'  	8'  	0'  	16'  	8'  	0'  	24  };  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: decrypterType.ShiftConsts = new List<int> {  	24'  	16'  	8'  	0'  	16'  	8'  	0'  	24  };  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: decrypterType.ShiftConsts = new List<int> {  	24'  	16'  	8'  	0'  	16'  	8'  	0'  	24  };  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: decrypterType.ShiftConsts = new List<int> {  	24'  	16'  	8'  	0'  	16'  	8'  	0'  	24  };  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: decrypterType.ShiftConsts = new List<int> {  	24'  	16'  	8'  	0'  	16'  	8'  	0'  	24  };  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindConstants,The following statement contains a magic number: decrypterType.ShiftConsts = new List<int> {  	24'  	16'  	8'  	0'  	16'  	8'  	0'  	24  };  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindFlags2,The following statement contains a magic number: for (int i = index - 1; i >= 0; i--) {  	var instr = stringMethod.Body.Instructions [i];  	if (instr.OpCode.FlowControl != FlowControl.Next)  		break;  	if (!stringMethodConsts.IsLoadConstantInt32 (instr))  		continue;  	int index2 = i' value;  	if (!stringMethodConsts.GetInt32 (ref index2' out value))  		continue;  	if ((uint)value != 0x80000000 && value != 0x40000000 && value != 0x20000000)  		continue;  	var local = GetFlagsLocal (stringMethod' index2);  	if (local == null)  		continue;  	int offset = GetFlagsOffset (stringMethod' index2' local);  	if (offset < 0)  		continue;  	flags.Add (new FlagsInfo (local' (uint)value' offset));  	if (flags.Count != 3)  		continue;  	return flags;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindFlags2,The following statement contains a magic number: if (flags.Count != 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,GetFlagsLocalOld,The following statement contains a magic number: if (index + 5 >= instrs.Count)  	return null;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,GetFlagsLocalNew,The following statement contains a magic number: if (index + 5 >= instrs.Count)  	return null;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: while (true) {  	int offset = magic1 ^ i3 ^ val ^ i6;  	reader.BaseStream.Position = offset;  	byte[] tmpKey;  	if (theKey == null) {  		tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  		if (isV32OrLater) {  			for (int i = 0; i < tmpKey.Length; i++)  				tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  		}  	} else  		tmpKey = theKey;  	int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32 ();  	if (checkMinus2 && flags == -2) {  		var ary2 = reader.ReadBytes (4);  		val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  		continue;  	}  	var bytes = reader.ReadBytes (flags & 0x1FFFFFFF);  	Decrypt1 (bytes' tmpKey);  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKey);  	if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < bytes.Length; i++)  			bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  	}  	if ((flags & rldFlag) != 0)  		bytes = rld (bytes);  	if ((flags & bytesFlag) != 0) {  		var sb = new StringBuilder (bytes.Length);  		foreach (var b in bytes)  			sb.Append ((char)b);  		return sb.ToString ();  	} else  		return Encoding.Unicode.GetString (bytes);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (theKey == null) {  	tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  	if (isV32OrLater) {  		for (int i = 0; i < tmpKey.Length; i++)  			tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  	}  } else  	tmpKey = theKey;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (theKey == null) {  	tmpKey = reader.ReadBytes (keyLen == -1 ? (short)(reader.ReadInt16 () ^ s3 ^ offset) : keyLen);  	if (isV32OrLater) {  		for (int i = 0; i < tmpKey.Length; i++)  			tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  	}  } else  	tmpKey = theKey;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (isV32OrLater) {  	for (int i = 0; i < tmpKey.Length; i++)  		tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (isV32OrLater) {  	for (int i = 0; i < tmpKey.Length; i++)  		tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < tmpKey.Length; i++)  	tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < tmpKey.Length; i++)  	tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: tmpKey [i] ^= (byte)(magic1 >> ((i & 3) << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (checkMinus2 && flags == -2) {  	var ary2 = reader.ReadBytes (4);  	val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (checkMinus2 && flags == -2) {  	var ary2 = reader.ReadBytes (4);  	val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (checkMinus2 && flags == -2) {  	var ary2 = reader.ReadBytes (4);  	val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (checkMinus2 && flags == -2) {  	var ary2 = reader.ReadBytes (4);  	val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (checkMinus2 && flags == -2) {  	var ary2 = reader.ReadBytes (4);  	val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (checkMinus2 && flags == -2) {  	var ary2 = reader.ReadBytes (4);  	val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (checkMinus2 && flags == -2) {  	var ary2 = reader.ReadBytes (4);  	val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: val = -(magic1 ^ i5) ^ (ary2 [2] | (ary2 [0] << 8) | (ary2 [3] << 16) | (ary2 [1] << 24));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  	for (int i = 0; i < bytes.Length; i++)  		bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  	for (int i = 0; i < bytes.Length; i++)  		bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  	for (int i = 0; i < bytes.Length; i++)  		bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2 (pkt)) {  	for (int i = 0; i < bytes.Length; i++)  		bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++)  	bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++)  	bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++)  	bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++)  	bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt,The following statement contains a magic number: bytes [i] ^= (byte)((pkt.Data [i & 7] >> 5) + (pkt.Data [i & 7] << 3));  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  	bit <<= 1;  	if (bit == 256) {  		bit = 1;  		flags = src [srcIndex++];  	}  	if ((flags & bit) == 0) {  		dst [dstIndex++] = src [srcIndex++];  		continue;  	}  	int numBytes = (src [srcIndex] >> 2) + 3;  	int copyIndex = dstIndex - ((src [srcIndex + 1] + (src [srcIndex] << 8)) & 0x3FF);  	if (copyIndex < 0)  		break;  	while (dstIndex < dst.Length && numBytes-- > 0)  		dst [dstIndex++] = dst [copyIndex++];  	srcIndex += 2;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  	bit <<= 1;  	if (bit == 256) {  		bit = 1;  		flags = src [srcIndex++];  	}  	if ((flags & bit) == 0) {  		dst [dstIndex++] = src [srcIndex++];  		continue;  	}  	int numBytes = (src [srcIndex] >> 2) + 3;  	int copyIndex = dstIndex - ((src [srcIndex + 1] + (src [srcIndex] << 8)) & 0x3FF);  	if (copyIndex < 0)  		break;  	while (dstIndex < dst.Length && numBytes-- > 0)  		dst [dstIndex++] = dst [copyIndex++];  	srcIndex += 2;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  	bit <<= 1;  	if (bit == 256) {  		bit = 1;  		flags = src [srcIndex++];  	}  	if ((flags & bit) == 0) {  		dst [dstIndex++] = src [srcIndex++];  		continue;  	}  	int numBytes = (src [srcIndex] >> 2) + 3;  	int copyIndex = dstIndex - ((src [srcIndex + 1] + (src [srcIndex] << 8)) & 0x3FF);  	if (copyIndex < 0)  		break;  	while (dstIndex < dst.Length && numBytes-- > 0)  		dst [dstIndex++] = dst [copyIndex++];  	srcIndex += 2;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  	bit <<= 1;  	if (bit == 256) {  		bit = 1;  		flags = src [srcIndex++];  	}  	if ((flags & bit) == 0) {  		dst [dstIndex++] = src [srcIndex++];  		continue;  	}  	int numBytes = (src [srcIndex] >> 2) + 3;  	int copyIndex = dstIndex - ((src [srcIndex + 1] + (src [srcIndex] << 8)) & 0x3FF);  	if (copyIndex < 0)  		break;  	while (dstIndex < dst.Length && numBytes-- > 0)  		dst [dstIndex++] = dst [copyIndex++];  	srcIndex += 2;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  	bit <<= 1;  	if (bit == 256) {  		bit = 1;  		flags = src [srcIndex++];  	}  	if ((flags & bit) == 0) {  		dst [dstIndex++] = src [srcIndex++];  		continue;  	}  	int numBytes = (src [srcIndex] >> 2) + 3;  	int copyIndex = dstIndex - ((src [srcIndex + 1] + (src [srcIndex] << 8)) & 0x3FF);  	if (copyIndex < 0)  		break;  	while (dstIndex < dst.Length && numBytes-- > 0)  		dst [dstIndex++] = dst [copyIndex++];  	srcIndex += 2;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: if (bit == 256) {  	bit = 1;  	flags = src [srcIndex++];  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: srcIndex += 2;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: b += 3;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: for (int i = 0; i < dest.Length; i++) {  	if ((i & 1) == 0) {  		lcg = LcgNext (lcg);  		xn = (ushort)(lcg >> 16);  	}  	byte tmp = dest [i];  	dest [i] ^= (byte)(key [1] ^ xn ^ b);  	b = (byte)(tmp + 3);  	xn >>= 8;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: for (int i = 0; i < dest.Length; i++) {  	if ((i & 1) == 0) {  		lcg = LcgNext (lcg);  		xn = (ushort)(lcg >> 16);  	}  	byte tmp = dest [i];  	dest [i] ^= (byte)(key [1] ^ xn ^ b);  	b = (byte)(tmp + 3);  	xn >>= 8;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: for (int i = 0; i < dest.Length; i++) {  	if ((i & 1) == 0) {  		lcg = LcgNext (lcg);  		xn = (ushort)(lcg >> 16);  	}  	byte tmp = dest [i];  	dest [i] ^= (byte)(key [1] ^ xn ^ b);  	b = (byte)(tmp + 3);  	xn >>= 8;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: if ((i & 1) == 0) {  	lcg = LcgNext (lcg);  	xn = (ushort)(lcg >> 16);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: xn = (ushort)(lcg >> 16);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: b = (byte)(tmp + 3);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,Decrypt1,The following statement contains a magic number: xn >>= 8;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,LcgNext,The following statement contains a magic number: return lcg * 214013 + 2531011;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,LcgNext,The following statement contains a magic number: return lcg * 214013 + 2531011;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindShiftInts,The following statement contains a magic number: bytes = new List<int> (8);  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindShiftInts,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (bytes.Count >= 8)  		return true;  	var ldloc1 = instrs [i];  	if (ldloc1.OpCode.Code != Code.Ldloc_1)  		continue;  	var ldlocs = instrs [i + 1];  	if (ldlocs.OpCode.Code != Code.Ldloc_S)  		continue;  	var maybe = instrs [i + 2];  	if (maybe.OpCode.Code == Code.Conv_U1) {  		var callvirt = instrs [i + 3];  		if (callvirt.OpCode.Code != Code.Callvirt)  			return false;  		bytes.Add (0);  		continue;  	}  	var shr = instrs [i + 3];  	if (shr.OpCode.Code != Code.Shr)  		return false;  	var convu1 = instrs [i + 4];  	if (convu1.OpCode.Code != Code.Conv_U1)  		return false;  	int constant;  	int index = i + 2;  	if (!constantsReader.GetInt32 (ref index' out constant))  		return false;  	bytes.Add (constant);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindShiftInts,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (bytes.Count >= 8)  		return true;  	var ldloc1 = instrs [i];  	if (ldloc1.OpCode.Code != Code.Ldloc_1)  		continue;  	var ldlocs = instrs [i + 1];  	if (ldlocs.OpCode.Code != Code.Ldloc_S)  		continue;  	var maybe = instrs [i + 2];  	if (maybe.OpCode.Code == Code.Conv_U1) {  		var callvirt = instrs [i + 3];  		if (callvirt.OpCode.Code != Code.Callvirt)  			return false;  		bytes.Add (0);  		continue;  	}  	var shr = instrs [i + 3];  	if (shr.OpCode.Code != Code.Shr)  		return false;  	var convu1 = instrs [i + 4];  	if (convu1.OpCode.Code != Code.Conv_U1)  		return false;  	int constant;  	int index = i + 2;  	if (!constantsReader.GetInt32 (ref index' out constant))  		return false;  	bytes.Add (constant);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindShiftInts,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (bytes.Count >= 8)  		return true;  	var ldloc1 = instrs [i];  	if (ldloc1.OpCode.Code != Code.Ldloc_1)  		continue;  	var ldlocs = instrs [i + 1];  	if (ldlocs.OpCode.Code != Code.Ldloc_S)  		continue;  	var maybe = instrs [i + 2];  	if (maybe.OpCode.Code == Code.Conv_U1) {  		var callvirt = instrs [i + 3];  		if (callvirt.OpCode.Code != Code.Callvirt)  			return false;  		bytes.Add (0);  		continue;  	}  	var shr = instrs [i + 3];  	if (shr.OpCode.Code != Code.Shr)  		return false;  	var convu1 = instrs [i + 4];  	if (convu1.OpCode.Code != Code.Conv_U1)  		return false;  	int constant;  	int index = i + 2;  	if (!constantsReader.GetInt32 (ref index' out constant))  		return false;  	bytes.Add (constant);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindShiftInts,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (bytes.Count >= 8)  		return true;  	var ldloc1 = instrs [i];  	if (ldloc1.OpCode.Code != Code.Ldloc_1)  		continue;  	var ldlocs = instrs [i + 1];  	if (ldlocs.OpCode.Code != Code.Ldloc_S)  		continue;  	var maybe = instrs [i + 2];  	if (maybe.OpCode.Code == Code.Conv_U1) {  		var callvirt = instrs [i + 3];  		if (callvirt.OpCode.Code != Code.Callvirt)  			return false;  		bytes.Add (0);  		continue;  	}  	var shr = instrs [i + 3];  	if (shr.OpCode.Code != Code.Shr)  		return false;  	var convu1 = instrs [i + 4];  	if (convu1.OpCode.Code != Code.Conv_U1)  		return false;  	int constant;  	int index = i + 2;  	if (!constantsReader.GetInt32 (ref index' out constant))  		return false;  	bytes.Add (constant);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindShiftInts,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (bytes.Count >= 8)  		return true;  	var ldloc1 = instrs [i];  	if (ldloc1.OpCode.Code != Code.Ldloc_1)  		continue;  	var ldlocs = instrs [i + 1];  	if (ldlocs.OpCode.Code != Code.Ldloc_S)  		continue;  	var maybe = instrs [i + 2];  	if (maybe.OpCode.Code == Code.Conv_U1) {  		var callvirt = instrs [i + 3];  		if (callvirt.OpCode.Code != Code.Callvirt)  			return false;  		bytes.Add (0);  		continue;  	}  	var shr = instrs [i + 3];  	if (shr.OpCode.Code != Code.Shr)  		return false;  	var convu1 = instrs [i + 4];  	if (convu1.OpCode.Code != Code.Conv_U1)  		return false;  	int constant;  	int index = i + 2;  	if (!constantsReader.GetInt32 (ref index' out constant))  		return false;  	bytes.Add (constant);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindShiftInts,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (bytes.Count >= 8)  		return true;  	var ldloc1 = instrs [i];  	if (ldloc1.OpCode.Code != Code.Ldloc_1)  		continue;  	var ldlocs = instrs [i + 1];  	if (ldlocs.OpCode.Code != Code.Ldloc_S)  		continue;  	var maybe = instrs [i + 2];  	if (maybe.OpCode.Code == Code.Conv_U1) {  		var callvirt = instrs [i + 3];  		if (callvirt.OpCode.Code != Code.Callvirt)  			return false;  		bytes.Add (0);  		continue;  	}  	var shr = instrs [i + 3];  	if (shr.OpCode.Code != Code.Shr)  		return false;  	var convu1 = instrs [i + 4];  	if (convu1.OpCode.Code != Code.Conv_U1)  		return false;  	int constant;  	int index = i + 2;  	if (!constantsReader.GetInt32 (ref index' out constant))  		return false;  	bytes.Add (constant);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindShiftInts,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	if (bytes.Count >= 8)  		return true;  	var ldloc1 = instrs [i];  	if (ldloc1.OpCode.Code != Code.Ldloc_1)  		continue;  	var ldlocs = instrs [i + 1];  	if (ldlocs.OpCode.Code != Code.Ldloc_S)  		continue;  	var maybe = instrs [i + 2];  	if (maybe.OpCode.Code == Code.Conv_U1) {  		var callvirt = instrs [i + 3];  		if (callvirt.OpCode.Code != Code.Callvirt)  			return false;  		bytes.Add (0);  		continue;  	}  	var shr = instrs [i + 3];  	if (shr.OpCode.Code != Code.Shr)  		return false;  	var convu1 = instrs [i + 4];  	if (convu1.OpCode.Code != Code.Conv_U1)  		return false;  	int constant;  	int index = i + 2;  	if (!constantsReader.GetInt32 (ref index' out constant))  		return false;  	bytes.Add (constant);  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindShiftInts,The following statement contains a magic number: if (bytes.Count >= 8)  	return true;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindShiftInts,The following statement contains a magic number: if (maybe.OpCode.Code == Code.Conv_U1) {  	var callvirt = instrs [i + 3];  	if (callvirt.OpCode.Code != Code.Callvirt)  		return false;  	bytes.Add (0);  	continue;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInts,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  	var instr = instrs [i];  	FieldDef field;  	switch (instr.OpCode.Code) {  	case Code.Ldsfld:  		field = instr.Operand as FieldDef;  		if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType () != ElementType.I4)  			goto default;  		fields [field] = null;  		emu.Push (new Int32Value (i1));  		break;  	case Code.Stsfld:  		field = instr.Operand as FieldDef;  		if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType () != ElementType.I4)  			goto default;  		if (fields.ContainsKey (field) && fields [field] == null)  			goto default;  		var val = emu.Pop () as Int32Value;  		if (val == null || !val.AllBitsValid ())  			fields [field] = null;  		else  			fields [field] = val.Value;  		break;  	case Code.Call:  		var method = instr.Operand as MethodDef;  		if (!decrypterType.Detected || method != decrypterType.Int64Method)  			goto done;  		emu.Push (new Int64Value ((long)decrypterType.GetMagic ()));  		break;  	case Code.Newobj:  		if (!EmulateDynocode (emu' ref i))  			goto default;  		break;  	default:  		if (instr.OpCode.FlowControl != FlowControl.Next)  			goto done;  		emu.Emulate (instr);  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,EmulateDynocodeOld,The following statement contains a magic number: if (index + 4 >= instrs.Count)  	return false;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,EmulateDynocodeNew,The following statement contains a magic number: if (index + 4 >= instrs.Count)  	return false;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInitIntsIndex,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	var ldnull = instrs [i];  	if (ldnull.OpCode.Code != Code.Ldnull)  		continue;  	var stsfld = instrs [i + 1];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	var storeField = stsfld.Operand as FieldDef;  	if (storeField == null || storeField.FieldType.FullName != "System.Byte[]")  		continue;  	var instr = instrs [i + 2];  	if (instr.OpCode.Code == Code.Ldsfld) {  		var loadField = instr.Operand as FieldDef;  		if (loadField == null || loadField.FieldType.GetElementType () != ElementType.I4)  			continue;  	} else if (instr.IsLdcI4 ()) {  		initializedAll = true;  	} else  		continue;  	return i;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInt3Old,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldarg0 = instrs [i];  	if (ldarg0.OpCode.Code != Code.Ldarg_0)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	int index = i + 1;  	int value;  	if (!stringMethodConsts.GetInt32 (ref index' out value))  		continue;  	if (index >= instrs.Count)  		continue;  	if (instrs [index].OpCode.Code != Code.Xor)  		continue;  	i3 = value;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInt3New,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	int index = i;  	var ldarg0 = instrs [index++];  	if (ldarg0.OpCode.Code != Code.Ldarg_0)  		continue;  	int value;  	if (!stringMethodConsts.GetInt32 (ref index' out value))  		continue;  	if (index + 3 >= instrs.Count)  		break;  	if (instrs [index++].OpCode.Code != Code.Xor)  		continue;  	if (!instrs [index++].IsLdloc ())  		continue;  	if (instrs [index++].OpCode.Code != Code.Xor)  		continue;  	i3 = value;  	if (!FindInt6 (index++))  		return false;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInt3New,The following statement contains a magic number: if (index + 3 >= instrs.Count)  	break;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInt5,The following statement contains a magic number: while (true) {  	index++;  	if (!FindCallReadBytes (ref index))  		return false;  	if (index <= 0)  		continue;  	var ldci4 = stringMethod.Body.Instructions [index - 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	if (ldci4.GetLdcI4Value () != 4)  		continue;  	if (!stringMethodConsts.GetNextInt32 (ref index' out i5))  		return false;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,FindInt5,The following statement contains a magic number: if (ldci4.GetLdcI4Value () != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 35 && decryptStringMethod.Body.MaxStack <= 50 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals11) && CheckTypeFields (fields11)) {  	return "1.1 - 1.2";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 35 && decryptStringMethod.Body.MaxStack <= 50 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals11) && CheckTypeFields (fields11)) {  	return "1.1 - 1.2";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 35 && decryptStringMethod.Body.MaxStack <= 50 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals13) && CheckTypeFields (fields13)) {  	return "1.3";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 35 && decryptStringMethod.Body.MaxStack <= 50 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals13) && CheckTypeFields (fields13)) {  	return "1.3";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 150 && decryptStringMethod.Body.MaxStack <= 200 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals14) && CheckTypeFields (fields14)) {  	return "1.4 - 2.3";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 150 && decryptStringMethod.Body.MaxStack <= 200 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals14) && CheckTypeFields (fields14)) {  	return "1.4 - 2.3";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 0 && new LocalTypes (decryptStringMethod).Exactly (locals24) && CheckTypeFields (fields24)) {  	return "2.4 - 2.5";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && !decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).Exactly (locals26) && CheckTypeFields (fields26)) {  	return "2.6";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsPublic && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).Exactly (locals27) && CheckTypeFields (fields27)) {  	return "2.7";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).Exactly (locals28) && CheckTypeFields (fields28)) {  	return "2.8";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals29) && CheckTypeFields (fields29)) {  	return "2.9";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 0 && decryptStringType.NestedTypes.Count == 0 && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals29) && CheckTypeFields (fields29)) {  	return "2.9";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals30) && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals30) && CheckTypeFields (fields30)) {  	return "3.0";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals30) && !hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals30) && CheckTypeFields (fields30)) {  	return "3.0";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals31) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals31) && CheckTypeFields (fields31)) {  	return "3.1";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals31) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals31) && CheckTypeFields (fields31)) {  	return "3.1";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals32) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals32) && CheckTypeFields (fields32)) {  	return "3.2";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 0 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals32) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals32) && CheckTypeFields (fields32)) {  	return "3.2";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 1) {  	var fields33 = new string[] {  		"System.Collections.Generic.Dictionary`2<System.Int32'System.String>"'  		"System.IO.BinaryReader"'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		decryptStringType.NestedTypes [0].FullName'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 1 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3.29 - 3.3.57 (BETA)";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 1) {  	var fields33 = new string[] {  		"System.Collections.Generic.Dictionary`2<System.Int32'System.String>"'  		"System.IO.BinaryReader"'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		decryptStringType.NestedTypes [0].FullName'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 1 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3.29 - 3.3.57 (BETA)";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 1 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  	return "3.3.29 - 3.3.57 (BETA)";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 1 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && hasConstantM2 && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  	return "3.3.29 - 3.3.57 (BETA)";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  	var fields33 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Type");  	var olocals33 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  		return "3.3";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields33_149 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals33_149 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals33_149 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  		return "3.3.149 - 3.4";  		// 3.3.149+ (but not SL or CF)  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields35 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals35 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' "System.Collections.Generic.IEnumerator`1<System.Int32>"' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals35 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  		return "3.5 - 4.2";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields43 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals43 = CreateLocalsArray ("System.Boolean"' "System.Byte"' "System.Byte[]"' "System.Char[]"' FindEnumeratorName (decryptStringMethod)' GetNestedTypeName (0)' "System.Diagnostics.StackFrame"' "System.Diagnostics.StackTrace"' "System.Int16"' "System.Int32"' "System.Int64"' "System.IO.Stream"' "System.Reflection.Assembly"' "System.Reflection.AssemblyName"' "System.Reflection.MethodBase"' "System.String"' "System.Text.StringBuilder"' "System.Type");  	var olocals43 = CreateLocalsArray ("System.Int32");  	if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  		return "4.3 - 4.9";  	}  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	/////////////////////////////////////////////////////////////////  	var fields50 = new string[] {  		GetNestedTypeName (0)'  		GetNestedTypeName (1)'  		"System.Byte[]"'  		"System.Int16"'  		"System.Int32"'  		"System.Byte[]"'  		"System.Int32"'  		"System.Int32"'  		GetNestedTypeName (2)'  	};  	var locals50 = CreateLocalsArray (// GetNestedTypeName(2) // One of the nested types is the first local (non-enum type)  	"System.String"' "System.String");  	var otherMethod50 = otherMethods.Find (m => {  		return DotNetUtils.IsMethod (m' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])");  	});  	decryptStringMethod = stringDecrypter.RealMethod;  	if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  		foreach (var inst in stringDecrypter.Method.Body.Instructions) {  			if (inst.OpCode.Code == Code.Cgt_Un)  				return "5.1";  		}  		return "5.0";  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  	return "3.3";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  	return "3.3";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33) && CheckTypeFields (fields33)) {  	return "3.3";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  	return "3.3.149 - 3.4";  	// 3.3.149+ (but not SL or CF)  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  	return "3.3.149 - 3.4";  	// 3.3.149+ (but not SL or CF)  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals33_149) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && (decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) && new LocalTypes (decryptStringMethod).Exactly (locals33_149) && CheckTypeFields2 (fields33_149)) {  	return "3.3.149 - 3.4";  	// 3.3.149+ (but not SL or CF)  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  	return "3.5 - 4.2";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  	return "3.5 - 4.2";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals35) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals35) && CheckTypeFields2 (fields35)) {  	return "3.5 - 4.2";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  	return "4.3 - 4.9";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  	return "4.3 - 4.9";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (otherMethods.Count == 1 && decryptStringType.NestedTypes.Count == 3 && DotNetUtils.IsMethod (otherMethods [0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") && otherMethods [0].IsPrivate && otherMethods [0].IsStatic && new LocalTypes (otherMethods [0]).Exactly (olocals43) && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count >= 2 && new LocalTypes (decryptStringMethod).All (locals43) && CheckTypeFields2 (fields43)) {  	return "4.3 - 4.9";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  	foreach (var inst in stringDecrypter.Method.Body.Instructions) {  		if (inst.OpCode.Code == Code.Cgt_Un)  			return "5.1";  	}  	return "5.0";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  	foreach (var inst in stringDecrypter.Method.Body.Instructions) {  		if (inst.OpCode.Code == Code.Cgt_Un)  			return "5.1";  	}  	return "5.0";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,Detect,The following statement contains a magic number: if (stringDecrypter.HasRealMethod && otherMethods.Count == 2 && otherMethod50 != null && decryptStringType.NestedTypes.Count == 3 && otherMethod50.IsPrivate && otherMethod50.IsStatic && decryptStringMethod.IsNoInlining && decryptStringMethod.IsAssembly && !decryptStringMethod.IsSynchronized && decryptStringMethod.Body.MaxStack >= 1 && decryptStringMethod.Body.MaxStack <= 8 && decryptStringMethod.Body.ExceptionHandlers.Count == 1 && new LocalTypes (decryptStringMethod).All (locals50) && CheckTypeFields2 (fields50)) {  	foreach (var inst in stringDecrypter.Method.Body.Instructions) {  		if (inst.OpCode.Code == Code.Cgt_Un)  			return "5.1";  	}  	return "5.0";  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,GetNestedType,The following statement contains a magic number: if (n == 0) {  	foreach (var nested in type.NestedTypes) {  		if (nested.NestedTypes.Count == 1)  			return nested;  	}  } else if (n == 1) {  	foreach (var nested in type.NestedTypes) {  		if (nested.IsEnum)  			continue;  		if (nested.NestedTypes.Count != 0)  			continue;  		return nested;  	}  } else if (n == 2) {  	foreach (var nested in type.NestedTypes) {  		if (nested.IsEnum)  			return nested;  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,GetNestedType,The following statement contains a magic number: if (n == 1) {  	foreach (var nested in type.NestedTypes) {  		if (nested.IsEnum)  			continue;  		if (nested.NestedTypes.Count != 0)  			continue;  		return nested;  	}  } else if (n == 2) {  	foreach (var nested in type.NestedTypes) {  		if (nested.IsEnum)  			return nested;  	}  }  
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,GetNestedType,The following statement contains a magic number: if (n == 2) {  	foreach (var nested in type.NestedTypes) {  		if (nested.IsEnum)  			return nested;  	}  }  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Find,The following statement contains a magic number: foreach (var tmp in module.Resources) {  	var resource = tmp as EmbeddedResource;  	if (resource == null)  		continue;  	if (!resource.Name.String.EndsWith (".resources"' StringComparison.Ordinal))  		continue;  	string ns' name;  	SplitTypeName (resource.Name.String.Substring (0' resource.Name.String.Length - 10)' out ns' out name);  	var type = new TypeRefUser (module' ns' name' module).Resolve ();  	if (type == null)  		continue;  	if (!CheckDecrypterType (type))  		continue;  	encryptedResource = resource;  	decrypterType = type;  	break;  }  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Find,The following statement contains a magic number: SplitTypeName (resource.Name.String.Substring (0' resource.Name.String.Length - 10)' out ns' out name);  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Decrypt,The following statement contains a magic number: if (pkt == null || pkt.Length == 0)  	pkt = new byte[8];  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Decrypt,The following statement contains a magic number: pkt = new byte[8];  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Decrypt,The following statement contains a magic number: for (int i = 0' j = 0' ki = 0; i < decryptedData.Length; i++) {  	ki = (ki + 1) % (KEY_LEN - 1);  	j = (j + encryptedData [ki] + pkt [i % 8]) % (KEY_LEN - 1);  	var tmp = encryptedData [j];  	encryptedData [j] = encryptedData [ki];  	encryptedData [ki] = tmp;  	decryptedData [i] = (byte)(encryptedData [KEY_LEN + i] ^ encryptedData [(encryptedData [j] + encryptedData [ki]) % (KEY_LEN - 1)]);  }  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,Decrypt,The following statement contains a magic number: j = (j + encryptedData [ki] + pkt [i % 8]) % (KEY_LEN - 1);  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundGoliathAttribute)  	val += 10;  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 10;  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: if (val.Groups.Count < 2)  	return;  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\ProxyCallFixer.cs,CheckProxyMethod,The following statement contains a magic number: if (instrs.Count < 7)  	return false;  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\ProxyCallFixer.cs,CheckProxyMethod,The following statement contains a magic number: if (index + 2 > instrs.Count)  	return false;  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\StringDecrypter.cs,CheckDecrypterType,The following statement contains a magic number: if (fields.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\StringDecrypter.cs,CheckDecrypterType,The following statement contains a magic number: if (dict == null || dict.GenericArguments.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 2; i++) {  		var ldtoken = instrs [i];  		if (ldtoken.OpCode.Code != Code.Ldtoken)  			continue;  		var call1 = instrs [i + 1];  		if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  			continue;  		if (!DotNetUtils.IsMethod (call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  			continue;  		var call2 = instrs [i + 2];  		if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  			continue;  		if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (call2.Operand as IMethod' strongNameCheckMethod))  			continue;  		block.Remove (i' 3);  		return true;  	}  }  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 2; i++) {  		var ldtoken = instrs [i];  		if (ldtoken.OpCode.Code != Code.Ldtoken)  			continue;  		var call1 = instrs [i + 1];  		if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  			continue;  		if (!DotNetUtils.IsMethod (call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  			continue;  		var call2 = instrs [i + 2];  		if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  			continue;  		if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (call2.Operand as IMethod' strongNameCheckMethod))  			continue;  		block.Remove (i' 3);  		return true;  	}  }  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 2; i++) {  		var ldtoken = instrs [i];  		if (ldtoken.OpCode.Code != Code.Ldtoken)  			continue;  		var call1 = instrs [i + 1];  		if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  			continue;  		if (!DotNetUtils.IsMethod (call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  			continue;  		var call2 = instrs [i + 2];  		if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  			continue;  		if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (call2.Operand as IMethod' strongNameCheckMethod))  			continue;  		block.Remove (i' 3);  		return true;  	}  }  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldtoken = instrs [i];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var call1 = instrs [i + 1];  	if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  		continue;  	if (!DotNetUtils.IsMethod (call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  		continue;  	var call2 = instrs [i + 2];  	if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  		continue;  	if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (call2.Operand as IMethod' strongNameCheckMethod))  		continue;  	block.Remove (i' 3);  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldtoken = instrs [i];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var call1 = instrs [i + 1];  	if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  		continue;  	if (!DotNetUtils.IsMethod (call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  		continue;  	var call2 = instrs [i + 2];  	if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  		continue;  	if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (call2.Operand as IMethod' strongNameCheckMethod))  		continue;  	block.Remove (i' 3);  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldtoken = instrs [i];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var call1 = instrs [i + 1];  	if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  		continue;  	if (!DotNetUtils.IsMethod (call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  		continue;  	var call2 = instrs [i + 2];  	if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  		continue;  	if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (call2.Operand as IMethod' strongNameCheckMethod))  		continue;  	block.Remove (i' 3);  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,Deobfuscate,The following statement contains a magic number: block.Remove (i' 3);  
Magic Number,de4dot.code.deobfuscators.ILProtector,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: return mainType.Detected ? 150 : 0;  
Magic Number,de4dot.code.deobfuscators.ILProtector,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\Deobfuscator.cs,DeobfuscateBegin,The following statement contains a magic number: if (mainType.Detected) {  	if (staticMethodsDecrypter.Detected) {  		staticMethodsDecrypter.Decrypt ();  		RemoveObfuscatorJunk (staticMethodsDecrypter);  	} else if (dynamicMethodsRestorer != null) {  		Logger.v ("Runtime file versions:");  		Logger.Instance.Indent ();  		bool emailMe = false;  		foreach (var info in mainType.RuntimeFileInfos) {  			var version = info.GetVersion ();  			emailMe |= version != null && version == new Version (1' 0' 7' 0);  			Logger.v ("Version: {0} ({1})"' version == null ? "UNKNOWN" : version.ToString ()' info.PathName);  		}  		Logger.Instance.DeIndent ();  		if (emailMe)  			Logger.n ("**** Email me this program! de4dot@gmail.com");  		dynamicMethodsRestorer.Decrypt ();  		RemoveObfuscatorJunk (dynamicMethodsRestorer);  	} else  		Logger.w ("New ILProtector version. Can't decrypt methods (yet)");  }  
Magic Number,de4dot.code.deobfuscators.ILProtector,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\Deobfuscator.cs,DeobfuscateBegin,The following statement contains a magic number: if (staticMethodsDecrypter.Detected) {  	staticMethodsDecrypter.Decrypt ();  	RemoveObfuscatorJunk (staticMethodsDecrypter);  } else if (dynamicMethodsRestorer != null) {  	Logger.v ("Runtime file versions:");  	Logger.Instance.Indent ();  	bool emailMe = false;  	foreach (var info in mainType.RuntimeFileInfos) {  		var version = info.GetVersion ();  		emailMe |= version != null && version == new Version (1' 0' 7' 0);  		Logger.v ("Version: {0} ({1})"' version == null ? "UNKNOWN" : version.ToString ()' info.PathName);  	}  	Logger.Instance.DeIndent ();  	if (emailMe)  		Logger.n ("**** Email me this program! de4dot@gmail.com");  	dynamicMethodsRestorer.Decrypt ();  	RemoveObfuscatorJunk (dynamicMethodsRestorer);  } else  	Logger.w ("New ILProtector version. Can't decrypt methods (yet)");  
Magic Number,de4dot.code.deobfuscators.ILProtector,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\Deobfuscator.cs,DeobfuscateBegin,The following statement contains a magic number: if (dynamicMethodsRestorer != null) {  	Logger.v ("Runtime file versions:");  	Logger.Instance.Indent ();  	bool emailMe = false;  	foreach (var info in mainType.RuntimeFileInfos) {  		var version = info.GetVersion ();  		emailMe |= version != null && version == new Version (1' 0' 7' 0);  		Logger.v ("Version: {0} ({1})"' version == null ? "UNKNOWN" : version.ToString ()' info.PathName);  	}  	Logger.Instance.DeIndent ();  	if (emailMe)  		Logger.n ("**** Email me this program! de4dot@gmail.com");  	dynamicMethodsRestorer.Decrypt ();  	RemoveObfuscatorJunk (dynamicMethodsRestorer);  } else  	Logger.w ("New ILProtector version. Can't decrypt methods (yet)");  
Magic Number,de4dot.code.deobfuscators.ILProtector,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\Deobfuscator.cs,DeobfuscateBegin,The following statement contains a magic number: foreach (var info in mainType.RuntimeFileInfos) {  	var version = info.GetVersion ();  	emailMe |= version != null && version == new Version (1' 0' 7' 0);  	Logger.v ("Version: {0} ({1})"' version == null ? "UNKNOWN" : version.ToString ()' info.PathName);  }  
Magic Number,de4dot.code.deobfuscators.ILProtector,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\Deobfuscator.cs,DeobfuscateBegin,The following statement contains a magic number: emailMe |= version != null && version == new Version (1' 0' 7' 0);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (reflectionProtectModule.Assembly.GetName ().Version < new Version (2' 0' 12' 0)) {  	return CreateDecrypterV1_0_7_0 () ?? CreateDecrypterV2_0_0_0 () ?? CreateDecrypterV2_0_8_0 () ?? CreateDecrypterV2_0_8_5 () ?? CreateDecrypterV2_0_9_0 ();  }  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (reflectionProtectModule.Assembly.GetName ().Version < new Version (2' 0' 12' 0)) {  	return CreateDecrypterV1_0_7_0 () ?? CreateDecrypterV2_0_0_0 () ?? CreateDecrypterV2_0_8_0 () ?? CreateDecrypterV2_0_8_5 () ?? CreateDecrypterV2_0_9_0 ();  }  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version < new Version (2' 0' 12' 3))  	return new DecrypterV2_0_12_0 (this);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version < new Version (2' 0' 12' 3))  	return new DecrypterV2_0_12_0 (this);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version < new Version (2' 0' 12' 3))  	return new DecrypterV2_0_12_0 (this);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version (2' 0' 12' 3))  	return new DecrypterV2_0_12_3 (this);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version (2' 0' 12' 3))  	return new DecrypterV2_0_12_3 (this);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version (2' 0' 12' 3))  	return new DecrypterV2_0_12_3 (this);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version (2' 0' 13' 0))  	return new DecrypterV2_0_13_0 (this);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version (2' 0' 13' 0))  	return new DecrypterV2_0_13_0 (this);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version (2' 0' 13' 1))  	return new DecrypterV2_0_13_1 (this);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypter.cs,CreateDecrypter,The following statement contains a magic number: if (version == new Version (2' 0' 13' 1))  	return new DecrypterV2_0_13_1 (this);  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypterService,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypterService.cs,DecryptMethods,The following statement contains a magic number: using (var decrypter = new DynamicMethodsDecrypter (obfModule' reflObfModule)) {  	decrypter.Initialize ();  	var infos = new List<DecryptedMethodInfo> ();  	for (int i = 0; i < methodIds.Count; i += 2)  		infos.Add (decrypter.Decrypt (methodIds [i]' (uint)methodIds [i + 1]));  	hasDelegateTypeFlag = decrypter.MethodReaderHasDelegateTypeFlag;  	return infos;  }  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypterService,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypterService.cs,DecryptMethods,The following statement contains a magic number: for (int i = 0; i < methodIds.Count; i += 2)  	infos.Add (decrypter.Decrypt (methodIds [i]' (uint)methodIds [i + 1]));  
Magic Number,de4dot.code.deobfuscators.ILProtector,DynamicMethodsDecrypterService,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\DynamicMethodsDecrypterService.cs,DecryptMethods,The following statement contains a magic number: i += 2
Magic Number,de4dot.code.deobfuscators.ILProtector,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MainType.cs,CheckMethod,The following statement contains a magic number: if (methods.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.ILProtector,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MainType.cs,CheckMethod,The following statement contains a magic number: if (type.Fields.Count < 1 || type.Fields.Count > 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  case 0:  	return 0x02000000 + (int)(token >> 2);  case 1:  	return 0x01000000 + (int)(token >> 2);  case 2:  	return 0x1B000000 + (int)(token >> 2);  default:  	throw new ApplicationException ("Invalid token");  }  
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  case 0:  	return 0x02000000 + (int)(token >> 2);  case 1:  	return 0x01000000 + (int)(token >> 2);  case 2:  	return 0x1B000000 + (int)(token >> 2);  default:  	throw new ApplicationException ("Invalid token");  }  
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  case 0:  	return 0x02000000 + (int)(token >> 2);  case 1:  	return 0x01000000 + (int)(token >> 2);  case 2:  	return 0x1B000000 + (int)(token >> 2);  default:  	throw new ApplicationException ("Invalid token");  }  
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  case 0:  	return 0x02000000 + (int)(token >> 2);  case 1:  	return 0x01000000 + (int)(token >> 2);  case 2:  	return 0x1B000000 + (int)(token >> 2);  default:  	throw new ApplicationException ("Invalid token");  }  
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  case 0:  	return 0x02000000 + (int)(token >> 2);  case 1:  	return 0x01000000 + (int)(token >> 2);  case 2:  	return 0x1B000000 + (int)(token >> 2);  default:  	throw new ApplicationException ("Invalid token");  }  
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: return 0x02000000 + (int)(token >> 2);  
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: return 0x01000000 + (int)(token >> 2);  
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,GetTypeDefOrRefToken,The following statement contains a magic number: return 0x1B000000 + (int)(token >> 2);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CryptDecrypter,The following statement contains a magic number: if (key.Length <= 8)  	throw new ArgumentException ("Invalid size"' "key");  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (encrypted.Length % 8 != 0)  	throw new ArgumentException ("encrypted");  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	var buf = new byte[8];  	Array.Copy (encrypted' i * 8' buf' 0' buf.Length);  	buf = Decrypt (buf' key1' true);  	buf = Decrypt (buf' key2' false);  	buf = Decrypt (buf' key1' true);  	Array.Copy (buf' 0' decrypted' i * 8' buf.Length);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	var buf = new byte[8];  	Array.Copy (encrypted' i * 8' buf' 0' buf.Length);  	buf = Decrypt (buf' key1' true);  	buf = Decrypt (buf' key2' false);  	buf = Decrypt (buf' key1' true);  	Array.Copy (buf' 0' decrypted' i * 8' buf.Length);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	var buf = new byte[8];  	Array.Copy (encrypted' i * 8' buf' 0' buf.Length);  	buf = Decrypt (buf' key1' true);  	buf = Decrypt (buf' key2' false);  	buf = Decrypt (buf' key1' true);  	Array.Copy (buf' 0' decrypted' i * 8' buf.Length);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: Array.Copy (encrypted' i * 8' buf' 0' buf.Length);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: Array.Copy (buf' 0' decrypted' i * 8' buf.Length);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: if (flag) {  	for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  		var oldBits = bits.Extract (0' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (32' 32));  		bits.Set (32' oldBits);  		bits.Set (0' tmp);  	}  } else {  	for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  		var oldBits = bits.Extract (32' 32);  		var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  		tmp.Xor (bits.Extract (0' 32));  		bits.Set (0' oldBits);  		bits.Set (32' tmp);  	}  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  	var oldBits = bits.Extract (0' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (32' 32));  	bits.Set (32' oldBits);  	bits.Set (0' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  	var oldBits = bits.Extract (0' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (32' 32));  	bits.Set (32' oldBits);  	bits.Set (0' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  	var oldBits = bits.Extract (0' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (32' 32));  	bits.Set (32' oldBits);  	bits.Set (0' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  	var oldBits = bits.Extract (0' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (32' 32));  	bits.Set (32' oldBits);  	bits.Set (0' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  	var oldBits = bits.Extract (0' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (32' 32));  	bits.Set (32' oldBits);  	bits.Set (0' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  	var oldBits = bits.Extract (0' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (32' 32));  	bits.Set (32' oldBits);  	bits.Set (0' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  	var oldBits = bits.Extract (0' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (32' 32));  	bits.Set (32' oldBits);  	bits.Set (0' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  	var oldBits = bits.Extract (0' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (32' 32));  	bits.Set (32' oldBits);  	bits.Set (0' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: ki -= 48
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: tmp.Xor (bits.Extract (32' 32));  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: tmp.Xor (bits.Extract (32' 32));  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: bits.Set (32' oldBits);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  	var oldBits = bits.Extract (32' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (0' 32));  	bits.Set (0' oldBits);  	bits.Set (32' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  	var oldBits = bits.Extract (32' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (0' 32));  	bits.Set (0' oldBits);  	bits.Set (32' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  	var oldBits = bits.Extract (32' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (0' 32));  	bits.Set (0' oldBits);  	bits.Set (32' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  	var oldBits = bits.Extract (32' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (0' 32));  	bits.Set (0' oldBits);  	bits.Set (32' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  	var oldBits = bits.Extract (32' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (0' 32));  	bits.Set (0' oldBits);  	bits.Set (32' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  	var oldBits = bits.Extract (32' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (0' 32));  	bits.Set (0' oldBits);  	bits.Set (32' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  	var oldBits = bits.Extract (32' 32);  	var tmp = Decrypt (oldBits.Clone ()' key.Extract (ki' 48));  	tmp.Xor (bits.Extract (0' 32));  	bits.Set (0' oldBits);  	bits.Set (32' tmp);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: ki += 48
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: tmp.Xor (bits.Extract (0' 32));  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,Decrypt,The following statement contains a magic number: bits.Set (32' tmp);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int di = i * 6;  	int index = (data [di + 0] << 5) + (data [di + 5] << 4) + (data [di + 1] << 3) + (data [di + 2] << 2) + (data [di + 3] << 1) + data [di + 4] + i * 64;  	Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,GetSbox,The following statement contains a magic number: Bits.FromBytes (sbox' index' 4).CopyTo (sboxByteBits' i * 4);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKey,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	int rolCount = rots [i];  	key1.Rol (rolCount);  	key2.Rol (rolCount);  	Bits.FromByteBits (key1.ByteBits' key2.ByteBits).Transpose (pc2).ToBits (newKey' i * 6);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKey,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	int rolCount = rots [i];  	key1.Rol (rolCount);  	key2.Rol (rolCount);  	Bits.FromByteBits (key1.ByteBits' key2.ByteBits).Transpose (pc2).ToBits (newKey' i * 6);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKey,The following statement contains a magic number: Bits.FromByteBits (key1.ByteBits' key2.ByteBits).Transpose (pc2).ToBits (newKey' i * 6);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKeys,The following statement contains a magic number: key1 = Bits.FromByteBits (bits.ByteBits' 0' 28);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKeys,The following statement contains a magic number: key2 = Bits.FromByteBits (bits.ByteBits' 28' 28);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CreateKeys,The following statement contains a magic number: key2 = Bits.FromByteBits (bits.ByteBits' 28' 28);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypter6,The following statement contains a magic number: if (key.Length != 32)  	throw new ArgumentException ("Invalid key size"' "key");  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypter6,The following statement contains a magic number: this.key = new uint[8];  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: if ((encrypted.Length & 7) != 0)  	throw new ArgumentException ("Invalid data length"' "encrypted");  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	uint x' y;  	Decrypt (BitConverter.ToUInt32 (encrypted' i * 8)' BitConverter.ToUInt32 (encrypted' i * 8 + 4)' out x' out y);  	for (int j = 1; j < 100; j++)  		Decrypt (x' y' out x' out y);  	WriteUInt32 (decrypted' i * 8' x);  	WriteUInt32 (decrypted' i * 8 + 4' y);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	uint x' y;  	Decrypt (BitConverter.ToUInt32 (encrypted' i * 8)' BitConverter.ToUInt32 (encrypted' i * 8 + 4)' out x' out y);  	for (int j = 1; j < 100; j++)  		Decrypt (x' y' out x' out y);  	WriteUInt32 (decrypted' i * 8' x);  	WriteUInt32 (decrypted' i * 8 + 4' y);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	uint x' y;  	Decrypt (BitConverter.ToUInt32 (encrypted' i * 8)' BitConverter.ToUInt32 (encrypted' i * 8 + 4)' out x' out y);  	for (int j = 1; j < 100; j++)  		Decrypt (x' y' out x' out y);  	WriteUInt32 (decrypted' i * 8' x);  	WriteUInt32 (decrypted' i * 8 + 4' y);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	uint x' y;  	Decrypt (BitConverter.ToUInt32 (encrypted' i * 8)' BitConverter.ToUInt32 (encrypted' i * 8 + 4)' out x' out y);  	for (int j = 1; j < 100; j++)  		Decrypt (x' y' out x' out y);  	WriteUInt32 (decrypted' i * 8' x);  	WriteUInt32 (decrypted' i * 8 + 4' y);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	uint x' y;  	Decrypt (BitConverter.ToUInt32 (encrypted' i * 8)' BitConverter.ToUInt32 (encrypted' i * 8 + 4)' out x' out y);  	for (int j = 1; j < 100; j++)  		Decrypt (x' y' out x' out y);  	WriteUInt32 (decrypted' i * 8' x);  	WriteUInt32 (decrypted' i * 8 + 4' y);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	uint x' y;  	Decrypt (BitConverter.ToUInt32 (encrypted' i * 8)' BitConverter.ToUInt32 (encrypted' i * 8 + 4)' out x' out y);  	for (int j = 1; j < 100; j++)  		Decrypt (x' y' out x' out y);  	WriteUInt32 (decrypted' i * 8' x);  	WriteUInt32 (decrypted' i * 8 + 4' y);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	uint x' y;  	Decrypt (BitConverter.ToUInt32 (encrypted' i * 8)' BitConverter.ToUInt32 (encrypted' i * 8 + 4)' out x' out y);  	for (int j = 1; j < 100; j++)  		Decrypt (x' y' out x' out y);  	WriteUInt32 (decrypted' i * 8' x);  	WriteUInt32 (decrypted' i * 8 + 4' y);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: Decrypt (BitConverter.ToUInt32 (encrypted' i * 8)' BitConverter.ToUInt32 (encrypted' i * 8 + 4)' out x' out y);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: Decrypt (BitConverter.ToUInt32 (encrypted' i * 8)' BitConverter.ToUInt32 (encrypted' i * 8 + 4)' out x' out y);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: Decrypt (BitConverter.ToUInt32 (encrypted' i * 8)' BitConverter.ToUInt32 (encrypted' i * 8 + 4)' out x' out y);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int j = 1; j < 100; j++)  	Decrypt (x' y' out x' out y);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: WriteUInt32 (decrypted' i * 8' x);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: WriteUInt32 (decrypted' i * 8 + 4' y);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: WriteUInt32 (decrypted' i * 8 + 4' y);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,WriteUInt32,The following statement contains a magic number: data [index + 1] = (byte)(value >> 8);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,WriteUInt32,The following statement contains a magic number: data [index + 2] = (byte)(value >> 16);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,WriteUInt32,The following statement contains a magic number: data [index + 2] = (byte)(value >> 16);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,WriteUInt32,The following statement contains a magic number: data [index + 3] = (byte)(value >> 24);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,WriteUInt32,The following statement contains a magic number: data [index + 3] = (byte)(value >> 24);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  	gen1 [i] = (byte)((d1h [i / 16] << 4) | d1l [i & 0x0F]);  	gen2 [i] = (byte)((d2h [i / 16] << 4) | d2l [i & 0x0F]);  	gen3 [i] = (byte)((d3h [i / 16] << 4) | d3l [i & 0x0F]);  	gen4 [i] = (byte)((d4h [i / 16] << 4) | d4l [i & 0x0F]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  	gen1 [i] = (byte)((d1h [i / 16] << 4) | d1l [i & 0x0F]);  	gen2 [i] = (byte)((d2h [i / 16] << 4) | d2l [i & 0x0F]);  	gen3 [i] = (byte)((d3h [i / 16] << 4) | d3l [i & 0x0F]);  	gen4 [i] = (byte)((d4h [i / 16] << 4) | d4l [i & 0x0F]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  	gen1 [i] = (byte)((d1h [i / 16] << 4) | d1l [i & 0x0F]);  	gen2 [i] = (byte)((d2h [i / 16] << 4) | d2l [i & 0x0F]);  	gen3 [i] = (byte)((d3h [i / 16] << 4) | d3l [i & 0x0F]);  	gen4 [i] = (byte)((d4h [i / 16] << 4) | d4l [i & 0x0F]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  	gen1 [i] = (byte)((d1h [i / 16] << 4) | d1l [i & 0x0F]);  	gen2 [i] = (byte)((d2h [i / 16] << 4) | d2l [i & 0x0F]);  	gen3 [i] = (byte)((d3h [i / 16] << 4) | d3l [i & 0x0F]);  	gen4 [i] = (byte)((d4h [i / 16] << 4) | d4l [i & 0x0F]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  	gen1 [i] = (byte)((d1h [i / 16] << 4) | d1l [i & 0x0F]);  	gen2 [i] = (byte)((d2h [i / 16] << 4) | d2l [i & 0x0F]);  	gen3 [i] = (byte)((d3h [i / 16] << 4) | d3l [i & 0x0F]);  	gen4 [i] = (byte)((d4h [i / 16] << 4) | d4l [i & 0x0F]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  	gen1 [i] = (byte)((d1h [i / 16] << 4) | d1l [i & 0x0F]);  	gen2 [i] = (byte)((d2h [i / 16] << 4) | d2l [i & 0x0F]);  	gen3 [i] = (byte)((d3h [i / 16] << 4) | d3l [i & 0x0F]);  	gen4 [i] = (byte)((d4h [i / 16] << 4) | d4l [i & 0x0F]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  	gen1 [i] = (byte)((d1h [i / 16] << 4) | d1l [i & 0x0F]);  	gen2 [i] = (byte)((d2h [i / 16] << 4) | d2l [i & 0x0F]);  	gen3 [i] = (byte)((d3h [i / 16] << 4) | d3l [i & 0x0F]);  	gen4 [i] = (byte)((d4h [i / 16] << 4) | d4l [i & 0x0F]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  	gen1 [i] = (byte)((d1h [i / 16] << 4) | d1l [i & 0x0F]);  	gen2 [i] = (byte)((d2h [i / 16] << 4) | d2l [i & 0x0F]);  	gen3 [i] = (byte)((d3h [i / 16] << 4) | d3l [i & 0x0F]);  	gen4 [i] = (byte)((d4h [i / 16] << 4) | d4l [i & 0x0F]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: gen1 [i] = (byte)((d1h [i / 16] << 4) | d1l [i & 0x0F]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: gen1 [i] = (byte)((d1h [i / 16] << 4) | d1l [i & 0x0F]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: gen2 [i] = (byte)((d2h [i / 16] << 4) | d2l [i & 0x0F]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: gen2 [i] = (byte)((d2h [i / 16] << 4) | d2l [i & 0x0F]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: gen3 [i] = (byte)((d3h [i / 16] << 4) | d3l [i & 0x0F]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: gen3 [i] = (byte)((d3h [i / 16] << 4) | d3l [i & 0x0F]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: gen4 [i] = (byte)((d4h [i / 16] << 4) | d4l [i & 0x0F]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Initialize,The following statement contains a magic number: gen4 [i] = (byte)((d4h [i / 16] << 4) | d4l [i & 0x0F]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: y ^= Decrypt (x + key [2]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: x ^= Decrypt (y + key [3]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: y ^= Decrypt (x + key [4]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: x ^= Decrypt (y + key [5]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: y ^= Decrypt (x + key [6]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: x ^= Decrypt (y + key [7]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	y ^= Decrypt (x + key [7]);  	x ^= Decrypt (y + key [6]);  	y ^= Decrypt (x + key [5]);  	x ^= Decrypt (y + key [4]);  	y ^= Decrypt (x + key [3]);  	x ^= Decrypt (y + key [2]);  	y ^= Decrypt (x + key [1]);  	x ^= Decrypt (y + key [0]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	y ^= Decrypt (x + key [7]);  	x ^= Decrypt (y + key [6]);  	y ^= Decrypt (x + key [5]);  	x ^= Decrypt (y + key [4]);  	y ^= Decrypt (x + key [3]);  	x ^= Decrypt (y + key [2]);  	y ^= Decrypt (x + key [1]);  	x ^= Decrypt (y + key [0]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	y ^= Decrypt (x + key [7]);  	x ^= Decrypt (y + key [6]);  	y ^= Decrypt (x + key [5]);  	x ^= Decrypt (y + key [4]);  	y ^= Decrypt (x + key [3]);  	x ^= Decrypt (y + key [2]);  	y ^= Decrypt (x + key [1]);  	x ^= Decrypt (y + key [0]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	y ^= Decrypt (x + key [7]);  	x ^= Decrypt (y + key [6]);  	y ^= Decrypt (x + key [5]);  	x ^= Decrypt (y + key [4]);  	y ^= Decrypt (x + key [3]);  	x ^= Decrypt (y + key [2]);  	y ^= Decrypt (x + key [1]);  	x ^= Decrypt (y + key [0]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	y ^= Decrypt (x + key [7]);  	x ^= Decrypt (y + key [6]);  	y ^= Decrypt (x + key [5]);  	x ^= Decrypt (y + key [4]);  	y ^= Decrypt (x + key [3]);  	x ^= Decrypt (y + key [2]);  	y ^= Decrypt (x + key [1]);  	x ^= Decrypt (y + key [0]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	y ^= Decrypt (x + key [7]);  	x ^= Decrypt (y + key [6]);  	y ^= Decrypt (x + key [5]);  	x ^= Decrypt (y + key [4]);  	y ^= Decrypt (x + key [3]);  	x ^= Decrypt (y + key [2]);  	y ^= Decrypt (x + key [1]);  	x ^= Decrypt (y + key [0]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	y ^= Decrypt (x + key [7]);  	x ^= Decrypt (y + key [6]);  	y ^= Decrypt (x + key [5]);  	x ^= Decrypt (y + key [4]);  	y ^= Decrypt (x + key [3]);  	x ^= Decrypt (y + key [2]);  	y ^= Decrypt (x + key [1]);  	x ^= Decrypt (y + key [0]);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: y ^= Decrypt (x + key [7]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: x ^= Decrypt (y + key [6]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: y ^= Decrypt (x + key [5]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: x ^= Decrypt (y + key [4]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: y ^= Decrypt (x + key [3]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: x ^= Decrypt (y + key [2]);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypt,The following statement contains a magic number: return Ror (x' 21);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Ror,The following statement contains a magic number: return (val << (32 - n)) + (val >> n);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,DeobfuscatorInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Deobfuscator.cs,DeobfuscatorInfo,The following statement contains a magic number: stringCodePage = new IntOption (null' MakeArgName ("cp")' "String code page"' 936);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (mainType.Detected)  	val = 150;  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val = 150;  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MainType.cs,Find,The following statement contains a magic number: foreach (var cctor in DeobUtils.GetInitCctors (module' 3)) {  	if (CheckCctor (cctor))  		break;  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MainType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MainType.cs,GetPinvokeList,The following statement contains a magic number: if (list.Count != 2)  	return null;  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptStrings,The following statement contains a magic number: while (usHeapOffset < usHeapEnd) {  	if (fileData [usHeapOffset] == 0 || fileData [usHeapOffset] == 1) {  		usHeapOffset++;  		continue;  	}  	int usHeapOffsetOrig = usHeapOffset;  	int stringDataLength = DeobUtils.ReadVariableLengthInt32 (fileData' ref usHeapOffset);  	int usHeapOffsetString = usHeapOffset;  	int encryptedLength = stringDataLength - (usHeapOffset - usHeapOffsetOrig == 1 ? 1 : 2);  	for (int i = 0; i < encryptedLength; i++) {  		byte k = mcKey.ReadByte (mcKeyOffset++ % 0x2000);  		fileData [usHeapOffset] = Rolb ((byte)(fileData [usHeapOffset] ^ k)' 3);  		usHeapOffset++;  	}  	try {  		Logger.v ("Decrypted string: {0}"' Utils.ToCsharpString (Encoding.Unicode.GetString (fileData' usHeapOffsetString' stringDataLength - 1)));  	} catch {  		Logger.v ("Could not decrypt string at offset {0:X8}"' usHeapOffsetOrig);  	}  	usHeapOffset++;  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptStrings,The following statement contains a magic number: while (usHeapOffset < usHeapEnd) {  	if (fileData [usHeapOffset] == 0 || fileData [usHeapOffset] == 1) {  		usHeapOffset++;  		continue;  	}  	int usHeapOffsetOrig = usHeapOffset;  	int stringDataLength = DeobUtils.ReadVariableLengthInt32 (fileData' ref usHeapOffset);  	int usHeapOffsetString = usHeapOffset;  	int encryptedLength = stringDataLength - (usHeapOffset - usHeapOffsetOrig == 1 ? 1 : 2);  	for (int i = 0; i < encryptedLength; i++) {  		byte k = mcKey.ReadByte (mcKeyOffset++ % 0x2000);  		fileData [usHeapOffset] = Rolb ((byte)(fileData [usHeapOffset] ^ k)' 3);  		usHeapOffset++;  	}  	try {  		Logger.v ("Decrypted string: {0}"' Utils.ToCsharpString (Encoding.Unicode.GetString (fileData' usHeapOffsetString' stringDataLength - 1)));  	} catch {  		Logger.v ("Could not decrypt string at offset {0:X8}"' usHeapOffsetOrig);  	}  	usHeapOffset++;  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptStrings,The following statement contains a magic number: for (int i = 0; i < encryptedLength; i++) {  	byte k = mcKey.ReadByte (mcKeyOffset++ % 0x2000);  	fileData [usHeapOffset] = Rolb ((byte)(fileData [usHeapOffset] ^ k)' 3);  	usHeapOffset++;  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,DecryptStrings,The following statement contains a magic number: fileData [usHeapOffset] = Rolb ((byte)(fileData [usHeapOffset] ^ k)' 3);  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,Rolb,The following statement contains a magic number: return (byte)((b << n) | (b >> (8 - n)));  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,InitializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  	int stringLen = BitConverter.ToInt32 (fileData' soffs) ^ (int)mcKey.ReadUInt32 (ki);  	ki += 2;  	if (ki >= 0x1FF0)  		ki = 0;  	soffs += 4;  	var bytes = new byte[stringLen];  	for (int j = 0; j < stringLen; j++' soffs++) {  		byte b = (byte)(fileData [soffs] ^ mcKey.ReadByte (ki));  		ki = Add (ki' 1);  		bytes [j] = b;  	}  	decryptedStrings [i] = Decode (bytes);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,InitializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  	int stringLen = BitConverter.ToInt32 (fileData' soffs) ^ (int)mcKey.ReadUInt32 (ki);  	ki += 2;  	if (ki >= 0x1FF0)  		ki = 0;  	soffs += 4;  	var bytes = new byte[stringLen];  	for (int j = 0; j < stringLen; j++' soffs++) {  		byte b = (byte)(fileData [soffs] ^ mcKey.ReadByte (ki));  		ki = Add (ki' 1);  		bytes [j] = b;  	}  	decryptedStrings [i] = Decode (bytes);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,InitializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  	int stringLen = BitConverter.ToInt32 (fileData' soffs) ^ (int)mcKey.ReadUInt32 (ki);  	ki += 2;  	if (ki >= 0x1FF0)  		ki = 0;  	soffs += 4;  	var bytes = new byte[stringLen];  	for (int j = 0; j < stringLen; j++' soffs++) {  		byte b = (byte)(fileData [soffs] ^ mcKey.ReadByte (ki));  		ki = Add (ki' 1);  		bytes [j] = b;  	}  	decryptedStrings [i] = Decode (bytes);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,InitializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  	int stringLen = BitConverter.ToInt32 (fileData' soffs) ^ (int)mcKey.ReadUInt32 (ki);  	ki += 2;  	if (ki >= 0x1FF0)  		ki = 0;  	soffs += 4;  	var bytes = new byte[stringLen];  	for (int j = 0; j < stringLen; j++' soffs++) {  		byte b = (byte)(fileData [soffs] ^ mcKey.ReadByte (ki));  		ki = Add (ki' 1);  		bytes [j] = b;  	}  	decryptedStrings [i] = Decode (bytes);  }  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,InitializeStrings,The following statement contains a magic number: ki += 2;  
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,InitializeStrings,The following statement contains a magic number: soffs += 4;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (version != Version.Unknown)  	val += 100;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,DetectVersion,The following statement contains a magic number: if (module.Types.Count != 2)  	return Version.Unknown;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: using (var peImage = new MyPEImage (fileData)) {  	var section = peImage.Sections [peImage.Sections.Count - 1];  	var offset = section.PointerToRawData;  	offset += 16;  	byte[] compressed;  	int compressedLen;  	switch (version) {  	case Version.V0x:  		compressedLen = fileData.Length - (int)offset;  		compressed = peImage.OffsetReadBytes (offset' compressedLen);  		decompressed = Lzmat.DecompressOld (compressed);  		if (decompressed == null)  			throw new ApplicationException ("LZMAT decompression failed");  		break;  	case Version.V1x_217:  	case Version.V218:  		if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  			offset = section.PointerToRawData + section.VirtualSize;  		int decompressedLen = (int)peImage.OffsetReadUInt32 (offset);  		compressedLen = fileData.Length - (int)offset - 4;  		compressed = peImage.OffsetReadBytes (offset + 4' compressedLen);  		decompressed = new byte[decompressedLen];  		uint decompressedLen2;  		if (Lzmat.Decompress (decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  			throw new ApplicationException ("LZMAT decompression failed");  		break;  	default:  		throw new ApplicationException ("Unknown MPRESS version");  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: using (var peImage = new MyPEImage (fileData)) {  	var section = peImage.Sections [peImage.Sections.Count - 1];  	var offset = section.PointerToRawData;  	offset += 16;  	byte[] compressed;  	int compressedLen;  	switch (version) {  	case Version.V0x:  		compressedLen = fileData.Length - (int)offset;  		compressed = peImage.OffsetReadBytes (offset' compressedLen);  		decompressed = Lzmat.DecompressOld (compressed);  		if (decompressed == null)  			throw new ApplicationException ("LZMAT decompression failed");  		break;  	case Version.V1x_217:  	case Version.V218:  		if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  			offset = section.PointerToRawData + section.VirtualSize;  		int decompressedLen = (int)peImage.OffsetReadUInt32 (offset);  		compressedLen = fileData.Length - (int)offset - 4;  		compressed = peImage.OffsetReadBytes (offset + 4' compressedLen);  		decompressed = new byte[decompressedLen];  		uint decompressedLen2;  		if (Lzmat.Decompress (decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  			throw new ApplicationException ("LZMAT decompression failed");  		break;  	default:  		throw new ApplicationException ("Unknown MPRESS version");  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: using (var peImage = new MyPEImage (fileData)) {  	var section = peImage.Sections [peImage.Sections.Count - 1];  	var offset = section.PointerToRawData;  	offset += 16;  	byte[] compressed;  	int compressedLen;  	switch (version) {  	case Version.V0x:  		compressedLen = fileData.Length - (int)offset;  		compressed = peImage.OffsetReadBytes (offset' compressedLen);  		decompressed = Lzmat.DecompressOld (compressed);  		if (decompressed == null)  			throw new ApplicationException ("LZMAT decompression failed");  		break;  	case Version.V1x_217:  	case Version.V218:  		if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  			offset = section.PointerToRawData + section.VirtualSize;  		int decompressedLen = (int)peImage.OffsetReadUInt32 (offset);  		compressedLen = fileData.Length - (int)offset - 4;  		compressed = peImage.OffsetReadBytes (offset + 4' compressedLen);  		decompressed = new byte[decompressedLen];  		uint decompressedLen2;  		if (Lzmat.Decompress (decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  			throw new ApplicationException ("LZMAT decompression failed");  		break;  	default:  		throw new ApplicationException ("Unknown MPRESS version");  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: offset += 16;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: switch (version) {  case Version.V0x:  	compressedLen = fileData.Length - (int)offset;  	compressed = peImage.OffsetReadBytes (offset' compressedLen);  	decompressed = Lzmat.DecompressOld (compressed);  	if (decompressed == null)  		throw new ApplicationException ("LZMAT decompression failed");  	break;  case Version.V1x_217:  case Version.V218:  	if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  		offset = section.PointerToRawData + section.VirtualSize;  	int decompressedLen = (int)peImage.OffsetReadUInt32 (offset);  	compressedLen = fileData.Length - (int)offset - 4;  	compressed = peImage.OffsetReadBytes (offset + 4' compressedLen);  	decompressed = new byte[decompressedLen];  	uint decompressedLen2;  	if (Lzmat.Decompress (decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  		throw new ApplicationException ("LZMAT decompression failed");  	break;  default:  	throw new ApplicationException ("Unknown MPRESS version");  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: switch (version) {  case Version.V0x:  	compressedLen = fileData.Length - (int)offset;  	compressed = peImage.OffsetReadBytes (offset' compressedLen);  	decompressed = Lzmat.DecompressOld (compressed);  	if (decompressed == null)  		throw new ApplicationException ("LZMAT decompression failed");  	break;  case Version.V1x_217:  case Version.V218:  	if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  		offset = section.PointerToRawData + section.VirtualSize;  	int decompressedLen = (int)peImage.OffsetReadUInt32 (offset);  	compressedLen = fileData.Length - (int)offset - 4;  	compressed = peImage.OffsetReadBytes (offset + 4' compressedLen);  	decompressed = new byte[decompressedLen];  	uint decompressedLen2;  	if (Lzmat.Decompress (decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  		throw new ApplicationException ("LZMAT decompression failed");  	break;  default:  	throw new ApplicationException ("Unknown MPRESS version");  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: compressedLen = fileData.Length - (int)offset - 4;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,GetDecryptedModule,The following statement contains a magic number: compressed = peImage.OffsetReadBytes (offset + 4' compressedLen);  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  	var hash = new SHA1Managed ().ComputeHash (Encoding.UTF8.GetBytes (module.ToString ()));  	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]);  	Logger.v ("Updating MVID: {0}"' guid.ToString ("B"));  	module.Mvid = guid;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  	var hash = new SHA1Managed ().ComputeHash (Encoding.UTF8.GetBytes (module.ToString ()));  	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]);  	Logger.v ("Updating MVID: {0}"' guid.ToString ("B"));  	module.Mvid = guid;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  	var hash = new SHA1Managed ().ComputeHash (Encoding.UTF8.GetBytes (module.ToString ()));  	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]);  	Logger.v ("Updating MVID: {0}"' guid.ToString ("B"));  	module.Mvid = guid;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  	var hash = new SHA1Managed ().ComputeHash (Encoding.UTF8.GetBytes (module.ToString ()));  	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]);  	Logger.v ("Updating MVID: {0}"' guid.ToString ("B"));  	module.Mvid = guid;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  	var hash = new SHA1Managed ().ComputeHash (Encoding.UTF8.GetBytes (module.ToString ()));  	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]);  	Logger.v ("Updating MVID: {0}"' guid.ToString ("B"));  	module.Mvid = guid;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  	var hash = new SHA1Managed ().ComputeHash (Encoding.UTF8.GetBytes (module.ToString ()));  	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]);  	Logger.v ("Updating MVID: {0}"' guid.ToString ("B"));  	module.Mvid = guid;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  	var hash = new SHA1Managed ().ComputeHash (Encoding.UTF8.GetBytes (module.ToString ()));  	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]);  	Logger.v ("Updating MVID: {0}"' guid.ToString ("B"));  	module.Mvid = guid;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  	var hash = new SHA1Managed ().ComputeHash (Encoding.UTF8.GetBytes (module.ToString ()));  	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]);  	Logger.v ("Updating MVID: {0}"' guid.ToString ("B"));  	module.Mvid = guid;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  	var hash = new SHA1Managed ().ComputeHash (Encoding.UTF8.GetBytes (module.ToString ()));  	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]);  	Logger.v ("Updating MVID: {0}"' guid.ToString ("B"));  	module.Mvid = guid;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,FixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  	var hash = new SHA1Managed ().ComputeHash (Encoding.UTF8.GetBytes (module.ToString ()));  	var guid = new Guid (BitConverter.ToInt32 (hash' 0)' BitConverter.ToInt16 (hash' 4)' BitConverter.ToInt16 (hash' 6)' hash [8]' hash [9]' hash [10]' hash [11]' hash [12]' hash [13]' hash [14]' hash [15]);  	Logger.v ("Updating MVID: {0}"' guid.ToString ("B"));  	module.Mvid = guid;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_U4,The following statement contains a magic number: return (_n_ ^= 1) != 0 ? (uint)(_p_ [_i_] & 0xF) : (uint)(_p_ [_i_++] >> 4);  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_U8,The following statement contains a magic number: return (byte)(((_n_) != 0 ? ((_p_ [_i_] >> 4) | (_p_ [_i_ + 1] << 4)) : _p_ [_i_]));  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_U8,The following statement contains a magic number: return (byte)(((_n_) != 0 ? ((_p_ [_i_] >> 4) | (_p_ [_i_ + 1] << 4)) : _p_ [_i_]));  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_LE16,The following statement contains a magic number: return (ushort)((_n_) != 0 ? ((_p_ [_i_] >> 4) | ((ushort)(GET_LE16 (_p_' _i_ + 1)) << 4)) : GET_LE16 (_p_' _i_));  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_LE16,The following statement contains a magic number: return (ushort)((_n_) != 0 ? ((_p_ [_i_] >> 4) | ((ushort)(GET_LE16 (_p_' _i_ + 1)) << 4)) : GET_LE16 (_p_' _i_));  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (inPos = 1' outPos = 1' cur_nib = 0; inPos < (cbIn - cur_nib);) {  	int bc;  	byte tag;  	tag = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0)// gamma  		 {  			uint r_pos' r_cnt' dist;  			//#define cflag	r_cnt  			r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  			inPos++;  			if (outPos > MAX_LZMAT_SHORT_DIST1) {  				dist = r_cnt >> 2;  				switch (r_cnt & 3) {  				case 0:  					dist = (dist & LZMAT_DIST_MSK0) + 1;  					break;  				case 1:  					inPos += cur_nib;  					dist = (dist & LZMAT_DIST_MSK1) + 0x41;  					cur_nib ^= 1;  					break;  				case 2:  					inPos++;  					dist += 0x441;  					break;  				case 3:  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 1;  					inPos++;  					dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  					break;  				}  			} else {  				dist = r_cnt >> 1;  				if ((r_cnt & 1) != 0) {  					inPos += cur_nib;  					dist = (dist & 0x7FF) + 0x81;  					cur_nib ^= 1;  				} else  					dist = (dist & 0x7F) + 1;  			}  			//#undef cflag  			r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  			if (r_cnt != 0xF) {  				r_cnt += 3;  			} else {  				if ((inPos + 1 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 2;  				r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  				inPos++;  				if (r_cnt != 0xFF) {  					r_cnt += LZMAT_DEFAULT_CNT;  				} else {  					if ((inPos + 2 + cur_nib) > cbIn)  						return LzmatStatus.INTEGRITY_FAILURE + 3;  					r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  					inPos += 2;  					if (r_cnt == LZMAT_2BYTE_CNT) {  						// copy chunk  						if (cur_nib != 0) {  							r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  							inPos++;  							cur_nib = 0;  						} else {  							r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  						}  						r_cnt += (uint)((tag & 0x7F) + 4);  						r_cnt <<= 1;  						if ((outPos + (r_cnt << 2)) > cbOutBuf)  							return LzmatStatus.BUFFER_TOO_SMALL;  						while (r_cnt-- != 0 && outPos < cbOutBuf) {  							pbOut [outPos] = pbIn [inPos];  							pbOut [outPos + 1] = pbIn [inPos + 1];  							pbOut [outPos + 2] = pbIn [inPos + 2];  							pbOut [outPos + 3] = pbIn [inPos + 3];  							inPos += 4;  							outPos += 4;  						}  						break;  					}  				}  			}  			if (outPos < dist)  				return LzmatStatus.INTEGRITY_FAILURE + 4;  			if ((outPos + r_cnt) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL + 1;  			r_pos = outPos - dist;  			while (r_cnt-- != 0 && outPos < cbOutBuf)  				pbOut [outPos++] = pbOut [r_pos++];  		} else {  			pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: for (bc = 0; bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0)// gamma  	 {  		uint r_pos' r_cnt' dist;  		//#define cflag	r_cnt  		r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  		inPos++;  		if (outPos > MAX_LZMAT_SHORT_DIST1) {  			dist = r_cnt >> 2;  			switch (r_cnt & 3) {  			case 0:  				dist = (dist & LZMAT_DIST_MSK0) + 1;  				break;  			case 1:  				inPos += cur_nib;  				dist = (dist & LZMAT_DIST_MSK1) + 0x41;  				cur_nib ^= 1;  				break;  			case 2:  				inPos++;  				dist += 0x441;  				break;  			case 3:  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 1;  				inPos++;  				dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  				break;  			}  		} else {  			dist = r_cnt >> 1;  			if ((r_cnt & 1) != 0) {  				inPos += cur_nib;  				dist = (dist & 0x7FF) + 0x81;  				cur_nib ^= 1;  			} else  				dist = (dist & 0x7F) + 1;  		}  		//#undef cflag  		r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  		if (r_cnt != 0xF) {  			r_cnt += 3;  		} else {  			if ((inPos + 1 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 2;  			r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  			inPos++;  			if (r_cnt != 0xFF) {  				r_cnt += LZMAT_DEFAULT_CNT;  			} else {  				if ((inPos + 2 + cur_nib) > cbIn)  					return LzmatStatus.INTEGRITY_FAILURE + 3;  				r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  				inPos += 2;  				if (r_cnt == LZMAT_2BYTE_CNT) {  					// copy chunk  					if (cur_nib != 0) {  						r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  						inPos++;  						cur_nib = 0;  					} else {  						r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  					}  					r_cnt += (uint)((tag & 0x7F) + 4);  					r_cnt <<= 1;  					if ((outPos + (r_cnt << 2)) > cbOutBuf)  						return LzmatStatus.BUFFER_TOO_SMALL;  					while (r_cnt-- != 0 && outPos < cbOutBuf) {  						pbOut [outPos] = pbIn [inPos];  						pbOut [outPos + 1] = pbIn [inPos + 1];  						pbOut [outPos + 2] = pbIn [inPos + 2];  						pbOut [outPos + 3] = pbIn [inPos + 3];  						inPos += 4;  						outPos += 4;  					}  					break;  				}  			}  		}  		if (outPos < dist)  			return LzmatStatus.INTEGRITY_FAILURE + 4;  		if ((outPos + r_cnt) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL + 1;  		r_pos = outPos - dist;  		while (r_cnt-- != 0 && outPos < cbOutBuf)  			pbOut [outPos++] = pbOut [r_pos++];  	} else {  		pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((tag & 0x80) != 0)// gamma   {  	uint r_pos' r_cnt' dist;  	//#define cflag	r_cnt  	r_cnt = LZMAT_GET_LE16 (pbIn' inPos' cur_nib);  	inPos++;  	if (outPos > MAX_LZMAT_SHORT_DIST1) {  		dist = r_cnt >> 2;  		switch (r_cnt & 3) {  		case 0:  			dist = (dist & LZMAT_DIST_MSK0) + 1;  			break;  		case 1:  			inPos += cur_nib;  			dist = (dist & LZMAT_DIST_MSK1) + 0x41;  			cur_nib ^= 1;  			break;  		case 2:  			inPos++;  			dist += 0x441;  			break;  		case 3:  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 1;  			inPos++;  			dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  			break;  		}  	} else {  		dist = r_cnt >> 1;  		if ((r_cnt & 1) != 0) {  			inPos += cur_nib;  			dist = (dist & 0x7FF) + 0x81;  			cur_nib ^= 1;  		} else  			dist = (dist & 0x7F) + 1;  	}  	//#undef cflag  	r_cnt = LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib);  	if (r_cnt != 0xF) {  		r_cnt += 3;  	} else {  		if ((inPos + 1 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 2;  		r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  		inPos++;  		if (r_cnt != 0xFF) {  			r_cnt += LZMAT_DEFAULT_CNT;  		} else {  			if ((inPos + 2 + cur_nib) > cbIn)  				return LzmatStatus.INTEGRITY_FAILURE + 3;  			r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  			inPos += 2;  			if (r_cnt == LZMAT_2BYTE_CNT) {  				// copy chunk  				if (cur_nib != 0) {  					r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  					inPos++;  					cur_nib = 0;  				} else {  					r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  				}  				r_cnt += (uint)((tag & 0x7F) + 4);  				r_cnt <<= 1;  				if ((outPos + (r_cnt << 2)) > cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL;  				while (r_cnt-- != 0 && outPos < cbOutBuf) {  					pbOut [outPos] = pbIn [inPos];  					pbOut [outPos + 1] = pbIn [inPos + 1];  					pbOut [outPos + 2] = pbIn [inPos + 2];  					pbOut [outPos + 3] = pbIn [inPos + 3];  					inPos += 4;  					outPos += 4;  				}  				break;  			}  		}  	}  	if (outPos < dist)  		return LzmatStatus.INTEGRITY_FAILURE + 4;  	if ((outPos + r_cnt) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL + 1;  	r_pos = outPos - dist;  	while (r_cnt-- != 0 && outPos < cbOutBuf)  		pbOut [outPos++] = pbOut [r_pos++];  } else {  	pbOut [outPos++] = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (outPos > MAX_LZMAT_SHORT_DIST1) {  	dist = r_cnt >> 2;  	switch (r_cnt & 3) {  	case 0:  		dist = (dist & LZMAT_DIST_MSK0) + 1;  		break;  	case 1:  		inPos += cur_nib;  		dist = (dist & LZMAT_DIST_MSK1) + 0x41;  		cur_nib ^= 1;  		break;  	case 2:  		inPos++;  		dist += 0x441;  		break;  	case 3:  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 1;  		inPos++;  		dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  		break;  	}  } else {  	dist = r_cnt >> 1;  	if ((r_cnt & 1) != 0) {  		inPos += cur_nib;  		dist = (dist & 0x7FF) + 0x81;  		cur_nib ^= 1;  	} else  		dist = (dist & 0x7F) + 1;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (outPos > MAX_LZMAT_SHORT_DIST1) {  	dist = r_cnt >> 2;  	switch (r_cnt & 3) {  	case 0:  		dist = (dist & LZMAT_DIST_MSK0) + 1;  		break;  	case 1:  		inPos += cur_nib;  		dist = (dist & LZMAT_DIST_MSK1) + 0x41;  		cur_nib ^= 1;  		break;  	case 2:  		inPos++;  		dist += 0x441;  		break;  	case 3:  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 1;  		inPos++;  		dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  		break;  	}  } else {  	dist = r_cnt >> 1;  	if ((r_cnt & 1) != 0) {  		inPos += cur_nib;  		dist = (dist & 0x7FF) + 0x81;  		cur_nib ^= 1;  	} else  		dist = (dist & 0x7F) + 1;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (outPos > MAX_LZMAT_SHORT_DIST1) {  	dist = r_cnt >> 2;  	switch (r_cnt & 3) {  	case 0:  		dist = (dist & LZMAT_DIST_MSK0) + 1;  		break;  	case 1:  		inPos += cur_nib;  		dist = (dist & LZMAT_DIST_MSK1) + 0x41;  		cur_nib ^= 1;  		break;  	case 2:  		inPos++;  		dist += 0x441;  		break;  	case 3:  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 1;  		inPos++;  		dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  		break;  	}  } else {  	dist = r_cnt >> 1;  	if ((r_cnt & 1) != 0) {  		inPos += cur_nib;  		dist = (dist & 0x7FF) + 0x81;  		cur_nib ^= 1;  	} else  		dist = (dist & 0x7F) + 1;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (outPos > MAX_LZMAT_SHORT_DIST1) {  	dist = r_cnt >> 2;  	switch (r_cnt & 3) {  	case 0:  		dist = (dist & LZMAT_DIST_MSK0) + 1;  		break;  	case 1:  		inPos += cur_nib;  		dist = (dist & LZMAT_DIST_MSK1) + 0x41;  		cur_nib ^= 1;  		break;  	case 2:  		inPos++;  		dist += 0x441;  		break;  	case 3:  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 1;  		inPos++;  		dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  		break;  	}  } else {  	dist = r_cnt >> 1;  	if ((r_cnt & 1) != 0) {  		inPos += cur_nib;  		dist = (dist & 0x7FF) + 0x81;  		cur_nib ^= 1;  	} else  		dist = (dist & 0x7F) + 1;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (outPos > MAX_LZMAT_SHORT_DIST1) {  	dist = r_cnt >> 2;  	switch (r_cnt & 3) {  	case 0:  		dist = (dist & LZMAT_DIST_MSK0) + 1;  		break;  	case 1:  		inPos += cur_nib;  		dist = (dist & LZMAT_DIST_MSK1) + 0x41;  		cur_nib ^= 1;  		break;  	case 2:  		inPos++;  		dist += 0x441;  		break;  	case 3:  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 1;  		inPos++;  		dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  		break;  	}  } else {  	dist = r_cnt >> 1;  	if ((r_cnt & 1) != 0) {  		inPos += cur_nib;  		dist = (dist & 0x7FF) + 0x81;  		cur_nib ^= 1;  	} else  		dist = (dist & 0x7F) + 1;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (outPos > MAX_LZMAT_SHORT_DIST1) {  	dist = r_cnt >> 2;  	switch (r_cnt & 3) {  	case 0:  		dist = (dist & LZMAT_DIST_MSK0) + 1;  		break;  	case 1:  		inPos += cur_nib;  		dist = (dist & LZMAT_DIST_MSK1) + 0x41;  		cur_nib ^= 1;  		break;  	case 2:  		inPos++;  		dist += 0x441;  		break;  	case 3:  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 1;  		inPos++;  		dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  		break;  	}  } else {  	dist = r_cnt >> 1;  	if ((r_cnt & 1) != 0) {  		inPos += cur_nib;  		dist = (dist & 0x7FF) + 0x81;  		cur_nib ^= 1;  	} else  		dist = (dist & 0x7F) + 1;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: dist = r_cnt >> 2;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: switch (r_cnt & 3) {  case 0:  	dist = (dist & LZMAT_DIST_MSK0) + 1;  	break;  case 1:  	inPos += cur_nib;  	dist = (dist & LZMAT_DIST_MSK1) + 0x41;  	cur_nib ^= 1;  	break;  case 2:  	inPos++;  	dist += 0x441;  	break;  case 3:  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 1;  	inPos++;  	dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: switch (r_cnt & 3) {  case 0:  	dist = (dist & LZMAT_DIST_MSK0) + 1;  	break;  case 1:  	inPos += cur_nib;  	dist = (dist & LZMAT_DIST_MSK1) + 0x41;  	cur_nib ^= 1;  	break;  case 2:  	inPos++;  	dist += 0x441;  	break;  case 3:  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 1;  	inPos++;  	dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: switch (r_cnt & 3) {  case 0:  	dist = (dist & LZMAT_DIST_MSK0) + 1;  	break;  case 1:  	inPos += cur_nib;  	dist = (dist & LZMAT_DIST_MSK1) + 0x41;  	cur_nib ^= 1;  	break;  case 2:  	inPos++;  	dist += 0x441;  	break;  case 3:  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 1;  	inPos++;  	dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: switch (r_cnt & 3) {  case 0:  	dist = (dist & LZMAT_DIST_MSK0) + 1;  	break;  case 1:  	inPos += cur_nib;  	dist = (dist & LZMAT_DIST_MSK1) + 0x41;  	cur_nib ^= 1;  	break;  case 2:  	inPos++;  	dist += 0x441;  	break;  case 3:  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 1;  	inPos++;  	dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: switch (r_cnt & 3) {  case 0:  	dist = (dist & LZMAT_DIST_MSK0) + 1;  	break;  case 1:  	inPos += cur_nib;  	dist = (dist & LZMAT_DIST_MSK1) + 0x41;  	cur_nib ^= 1;  	break;  case 2:  	inPos++;  	dist += 0x441;  	break;  case 3:  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 1;  	inPos++;  	dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((inPos + 2 + cur_nib) > cbIn)  	return LzmatStatus.INTEGRITY_FAILURE + 1;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xF) {  	r_cnt += 3;  } else {  	if ((inPos + 1 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 2;  	r_cnt = LZMAT_GET_U8 (pbIn' inPos' cur_nib);  	inPos++;  	if (r_cnt != 0xFF) {  		r_cnt += LZMAT_DEFAULT_CNT;  	} else {  		if ((inPos + 2 + cur_nib) > cbIn)  			return LzmatStatus.INTEGRITY_FAILURE + 3;  		r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  		inPos += 2;  		if (r_cnt == LZMAT_2BYTE_CNT) {  			// copy chunk  			if (cur_nib != 0) {  				r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  				inPos++;  				cur_nib = 0;  			} else {  				r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  			}  			r_cnt += (uint)((tag & 0x7F) + 4);  			r_cnt <<= 1;  			if ((outPos + (r_cnt << 2)) > cbOutBuf)  				return LzmatStatus.BUFFER_TOO_SMALL;  			while (r_cnt-- != 0 && outPos < cbOutBuf) {  				pbOut [outPos] = pbIn [inPos];  				pbOut [outPos + 1] = pbIn [inPos + 1];  				pbOut [outPos + 2] = pbIn [inPos + 2];  				pbOut [outPos + 3] = pbIn [inPos + 3];  				inPos += 4;  				outPos += 4;  			}  			break;  		}  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: r_cnt += 3;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((inPos + 1 + cur_nib) > cbIn)  	return LzmatStatus.INTEGRITY_FAILURE + 2;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: return LzmatStatus.INTEGRITY_FAILURE + 2;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt != 0xFF) {  	r_cnt += LZMAT_DEFAULT_CNT;  } else {  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 3;  	r_cnt = (uint)(LZMAT_GET_LE16 (pbIn' inPos' cur_nib) + LZMAT_1BYTE_CNT);  	inPos += 2;  	if (r_cnt == LZMAT_2BYTE_CNT) {  		// copy chunk  		if (cur_nib != 0) {  			r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  			inPos++;  			cur_nib = 0;  		} else {  			r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  		}  		r_cnt += (uint)((tag & 0x7F) + 4);  		r_cnt <<= 1;  		if ((outPos + (r_cnt << 2)) > cbOutBuf)  			return LzmatStatus.BUFFER_TOO_SMALL;  		while (r_cnt-- != 0 && outPos < cbOutBuf) {  			pbOut [outPos] = pbIn [inPos];  			pbOut [outPos + 1] = pbIn [inPos + 1];  			pbOut [outPos + 2] = pbIn [inPos + 2];  			pbOut [outPos + 3] = pbIn [inPos + 3];  			inPos += 4;  			outPos += 4;  		}  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((inPos + 2 + cur_nib) > cbIn)  	return LzmatStatus.INTEGRITY_FAILURE + 3;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((inPos + 2 + cur_nib) > cbIn)  	return LzmatStatus.INTEGRITY_FAILURE + 3;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: return LzmatStatus.INTEGRITY_FAILURE + 3;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: inPos += 2;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (r_cnt == LZMAT_2BYTE_CNT) {  	// copy chunk  	if (cur_nib != 0) {  		r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  		inPos++;  		cur_nib = 0;  	} else {  		r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  	}  	r_cnt += (uint)((tag & 0x7F) + 4);  	r_cnt <<= 1;  	if ((outPos + (r_cnt << 2)) > cbOutBuf)  		return LzmatStatus.BUFFER_TOO_SMALL;  	while (r_cnt-- != 0 && outPos < cbOutBuf) {  		pbOut [outPos] = pbIn [inPos];  		pbOut [outPos + 1] = pbIn [inPos + 1];  		pbOut [outPos + 2] = pbIn [inPos + 2];  		pbOut [outPos + 3] = pbIn [inPos + 3];  		inPos += 4;  		outPos += 4;  	}  	break;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (cur_nib != 0) {  	r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  	inPos++;  	cur_nib = 0;  } else {  	r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (cur_nib != 0) {  	r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  	inPos++;  	cur_nib = 0;  } else {  	r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (cur_nib != 0) {  	r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  	inPos++;  	cur_nib = 0;  } else {  	r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: r_cnt = ((uint)pbIn [inPos - 4] & 0xFC) << 5;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: r_cnt = (uint)((GET_LE16 (pbIn' inPos - 5) & 0xFC0) << 1);  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: r_cnt += (uint)((tag & 0x7F) + 4);  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if ((outPos + (r_cnt << 2)) > cbOutBuf)  	return LzmatStatus.BUFFER_TOO_SMALL;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: while (r_cnt-- != 0 && outPos < cbOutBuf) {  	pbOut [outPos] = pbIn [inPos];  	pbOut [outPos + 1] = pbIn [inPos + 1];  	pbOut [outPos + 2] = pbIn [inPos + 2];  	pbOut [outPos + 3] = pbIn [inPos + 3];  	inPos += 4;  	outPos += 4;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: while (r_cnt-- != 0 && outPos < cbOutBuf) {  	pbOut [outPos] = pbIn [inPos];  	pbOut [outPos + 1] = pbIn [inPos + 1];  	pbOut [outPos + 2] = pbIn [inPos + 2];  	pbOut [outPos + 3] = pbIn [inPos + 3];  	inPos += 4;  	outPos += 4;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: while (r_cnt-- != 0 && outPos < cbOutBuf) {  	pbOut [outPos] = pbIn [inPos];  	pbOut [outPos + 1] = pbIn [inPos + 1];  	pbOut [outPos + 2] = pbIn [inPos + 2];  	pbOut [outPos + 3] = pbIn [inPos + 3];  	inPos += 4;  	outPos += 4;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: while (r_cnt-- != 0 && outPos < cbOutBuf) {  	pbOut [outPos] = pbIn [inPos];  	pbOut [outPos + 1] = pbIn [inPos + 1];  	pbOut [outPos + 2] = pbIn [inPos + 2];  	pbOut [outPos + 3] = pbIn [inPos + 3];  	inPos += 4;  	outPos += 4;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: while (r_cnt-- != 0 && outPos < cbOutBuf) {  	pbOut [outPos] = pbIn [inPos];  	pbOut [outPos + 1] = pbIn [inPos + 1];  	pbOut [outPos + 2] = pbIn [inPos + 2];  	pbOut [outPos + 3] = pbIn [inPos + 3];  	inPos += 4;  	outPos += 4;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: while (r_cnt-- != 0 && outPos < cbOutBuf) {  	pbOut [outPos] = pbIn [inPos];  	pbOut [outPos + 1] = pbIn [inPos + 1];  	pbOut [outPos + 2] = pbIn [inPos + 2];  	pbOut [outPos + 3] = pbIn [inPos + 3];  	inPos += 4;  	outPos += 4;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: pbOut [outPos + 2] = pbIn [inPos + 2];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: pbOut [outPos + 2] = pbIn [inPos + 2];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: pbOut [outPos + 3] = pbIn [inPos + 3];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: pbOut [outPos + 3] = pbIn [inPos + 3];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: inPos += 4;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: outPos += 4;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: if (outPos < dist)  	return LzmatStatus.INTEGRITY_FAILURE + 4;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following statement contains a magic number: return LzmatStatus.INTEGRITY_FAILURE + 4;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,DecompressOld,The following statement contains a magic number: while (dstIndex < decompressedLen) {  	int partLen = compressed [srcIndex++] + (compressed [srcIndex++] << 8) + (compressed [srcIndex++] << 16);  	if (partLen < 0x800000) {  		Array.Copy (compressed' srcIndex' decompressed' dstIndex' partLen);  		srcIndex += partLen;  		dstIndex += partLen;  	} else {  		partLen &= 0x7FFFFF;  		int decompressedLen2 = lzmat_old (decompressed' dstIndex' decompressedLen - dstIndex' compressed' srcIndex' partLen);  		if (decompressedLen2 == 0)  			return null;  		dstIndex += decompressedLen2;  		srcIndex += partLen;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,DecompressOld,The following statement contains a magic number: while (dstIndex < decompressedLen) {  	int partLen = compressed [srcIndex++] + (compressed [srcIndex++] << 8) + (compressed [srcIndex++] << 16);  	if (partLen < 0x800000) {  		Array.Copy (compressed' srcIndex' decompressed' dstIndex' partLen);  		srcIndex += partLen;  		dstIndex += partLen;  	} else {  		partLen &= 0x7FFFFF;  		int decompressedLen2 = lzmat_old (decompressed' dstIndex' decompressedLen - dstIndex' compressed' srcIndex' partLen);  		if (decompressedLen2 == 0)  			return null;  		dstIndex += decompressedLen2;  		srcIndex += partLen;  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  	byte tag = inBuf [inIndex + inPos++];  	for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0) {  			ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  			inPos++;  			int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  			if (outPosDispl == 0)  				outPosDispl = 0x1000;  			if (outPosDispl > outPos)  				return 0;  			if (r_cnt == 18) {  				if (inPos >= inLen)  					return 0;  				r_cnt = inBuf [inIndex + inPos++] + 18;  			}  			if (r_cnt == 0x111) {  				if (inPos + 2 > inLen)  					return 0;  				r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  				inPos += 2;  			}  			int outPos2 = outPos - outPosDispl;  			while (r_cnt-- > 0 && outPos < outLen)  				outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  		} else  			outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  	byte tag = inBuf [inIndex + inPos++];  	for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0) {  			ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  			inPos++;  			int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  			if (outPosDispl == 0)  				outPosDispl = 0x1000;  			if (outPosDispl > outPos)  				return 0;  			if (r_cnt == 18) {  				if (inPos >= inLen)  					return 0;  				r_cnt = inBuf [inIndex + inPos++] + 18;  			}  			if (r_cnt == 0x111) {  				if (inPos + 2 > inLen)  					return 0;  				r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  				inPos += 2;  			}  			int outPos2 = outPos - outPosDispl;  			while (r_cnt-- > 0 && outPos < outLen)  				outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  		} else  			outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  	byte tag = inBuf [inIndex + inPos++];  	for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0) {  			ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  			inPos++;  			int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  			if (outPosDispl == 0)  				outPosDispl = 0x1000;  			if (outPosDispl > outPos)  				return 0;  			if (r_cnt == 18) {  				if (inPos >= inLen)  					return 0;  				r_cnt = inBuf [inIndex + inPos++] + 18;  			}  			if (r_cnt == 0x111) {  				if (inPos + 2 > inLen)  					return 0;  				r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  				inPos += 2;  			}  			int outPos2 = outPos - outPosDispl;  			while (r_cnt-- > 0 && outPos < outLen)  				outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  		} else  			outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  	byte tag = inBuf [inIndex + inPos++];  	for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0) {  			ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  			inPos++;  			int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  			if (outPosDispl == 0)  				outPosDispl = 0x1000;  			if (outPosDispl > outPos)  				return 0;  			if (r_cnt == 18) {  				if (inPos >= inLen)  					return 0;  				r_cnt = inBuf [inIndex + inPos++] + 18;  			}  			if (r_cnt == 0x111) {  				if (inPos + 2 > inLen)  					return 0;  				r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  				inPos += 2;  			}  			int outPos2 = outPos - outPosDispl;  			while (r_cnt-- > 0 && outPos < outLen)  				outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  		} else  			outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  	byte tag = inBuf [inIndex + inPos++];  	for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0) {  			ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  			inPos++;  			int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  			if (outPosDispl == 0)  				outPosDispl = 0x1000;  			if (outPosDispl > outPos)  				return 0;  			if (r_cnt == 18) {  				if (inPos >= inLen)  					return 0;  				r_cnt = inBuf [inIndex + inPos++] + 18;  			}  			if (r_cnt == 0x111) {  				if (inPos + 2 > inLen)  					return 0;  				r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  				inPos += 2;  			}  			int outPos2 = outPos - outPosDispl;  			while (r_cnt-- > 0 && outPos < outLen)  				outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  		} else  			outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  	byte tag = inBuf [inIndex + inPos++];  	for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0) {  			ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  			inPos++;  			int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  			if (outPosDispl == 0)  				outPosDispl = 0x1000;  			if (outPosDispl > outPos)  				return 0;  			if (r_cnt == 18) {  				if (inPos >= inLen)  					return 0;  				r_cnt = inBuf [inIndex + inPos++] + 18;  			}  			if (r_cnt == 0x111) {  				if (inPos + 2 > inLen)  					return 0;  				r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  				inPos += 2;  			}  			int outPos2 = outPos - outPosDispl;  			while (r_cnt-- > 0 && outPos < outLen)  				outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  		} else  			outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  	byte tag = inBuf [inIndex + inPos++];  	for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0) {  			ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  			inPos++;  			int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  			if (outPosDispl == 0)  				outPosDispl = 0x1000;  			if (outPosDispl > outPos)  				return 0;  			if (r_cnt == 18) {  				if (inPos >= inLen)  					return 0;  				r_cnt = inBuf [inIndex + inPos++] + 18;  			}  			if (r_cnt == 0x111) {  				if (inPos + 2 > inLen)  					return 0;  				r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  				inPos += 2;  			}  			int outPos2 = outPos - outPosDispl;  			while (r_cnt-- > 0 && outPos < outLen)  				outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  		} else  			outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  	byte tag = inBuf [inIndex + inPos++];  	for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0) {  			ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  			inPos++;  			int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  			if (outPosDispl == 0)  				outPosDispl = 0x1000;  			if (outPosDispl > outPos)  				return 0;  			if (r_cnt == 18) {  				if (inPos >= inLen)  					return 0;  				r_cnt = inBuf [inIndex + inPos++] + 18;  			}  			if (r_cnt == 0x111) {  				if (inPos + 2 > inLen)  					return 0;  				r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  				inPos += 2;  			}  			int outPos2 = outPos - outPosDispl;  			while (r_cnt-- > 0 && outPos < outLen)  				outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  		} else  			outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  	byte tag = inBuf [inIndex + inPos++];  	for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  		if ((tag & 0x80) != 0) {  			ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  			inPos++;  			int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  			if (outPosDispl == 0)  				outPosDispl = 0x1000;  			if (outPosDispl > outPos)  				return 0;  			if (r_cnt == 18) {  				if (inPos >= inLen)  					return 0;  				r_cnt = inBuf [inIndex + inPos++] + 18;  			}  			if (r_cnt == 0x111) {  				if (inPos + 2 > inLen)  					return 0;  				r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  				inPos += 2;  			}  			int outPos2 = outPos - outPosDispl;  			while (r_cnt-- > 0 && outPos < outLen)  				outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  		} else  			outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  	}  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0) {  		ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  		inPos++;  		int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  		if (outPosDispl == 0)  			outPosDispl = 0x1000;  		if (outPosDispl > outPos)  			return 0;  		if (r_cnt == 18) {  			if (inPos >= inLen)  				return 0;  			r_cnt = inBuf [inIndex + inPos++] + 18;  		}  		if (r_cnt == 0x111) {  			if (inPos + 2 > inLen)  				return 0;  			r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  			inPos += 2;  		}  		int outPos2 = outPos - outPosDispl;  		while (r_cnt-- > 0 && outPos < outLen)  			outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  	} else  		outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0) {  		ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  		inPos++;  		int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  		if (outPosDispl == 0)  			outPosDispl = 0x1000;  		if (outPosDispl > outPos)  			return 0;  		if (r_cnt == 18) {  			if (inPos >= inLen)  				return 0;  			r_cnt = inBuf [inIndex + inPos++] + 18;  		}  		if (r_cnt == 0x111) {  			if (inPos + 2 > inLen)  				return 0;  			r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  			inPos += 2;  		}  		int outPos2 = outPos - outPosDispl;  		while (r_cnt-- > 0 && outPos < outLen)  			outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  	} else  		outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0) {  		ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  		inPos++;  		int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  		if (outPosDispl == 0)  			outPosDispl = 0x1000;  		if (outPosDispl > outPos)  			return 0;  		if (r_cnt == 18) {  			if (inPos >= inLen)  				return 0;  			r_cnt = inBuf [inIndex + inPos++] + 18;  		}  		if (r_cnt == 0x111) {  			if (inPos + 2 > inLen)  				return 0;  			r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  			inPos += 2;  		}  		int outPos2 = outPos - outPosDispl;  		while (r_cnt-- > 0 && outPos < outLen)  			outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  	} else  		outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0) {  		ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  		inPos++;  		int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  		if (outPosDispl == 0)  			outPosDispl = 0x1000;  		if (outPosDispl > outPos)  			return 0;  		if (r_cnt == 18) {  			if (inPos >= inLen)  				return 0;  			r_cnt = inBuf [inIndex + inPos++] + 18;  		}  		if (r_cnt == 0x111) {  			if (inPos + 2 > inLen)  				return 0;  			r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  			inPos += 2;  		}  		int outPos2 = outPos - outPosDispl;  		while (r_cnt-- > 0 && outPos < outLen)  			outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  	} else  		outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0) {  		ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  		inPos++;  		int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  		if (outPosDispl == 0)  			outPosDispl = 0x1000;  		if (outPosDispl > outPos)  			return 0;  		if (r_cnt == 18) {  			if (inPos >= inLen)  				return 0;  			r_cnt = inBuf [inIndex + inPos++] + 18;  		}  		if (r_cnt == 0x111) {  			if (inPos + 2 > inLen)  				return 0;  			r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  			inPos += 2;  		}  		int outPos2 = outPos - outPosDispl;  		while (r_cnt-- > 0 && outPos < outLen)  			outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  	} else  		outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0) {  		ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  		inPos++;  		int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  		if (outPosDispl == 0)  			outPosDispl = 0x1000;  		if (outPosDispl > outPos)  			return 0;  		if (r_cnt == 18) {  			if (inPos >= inLen)  				return 0;  			r_cnt = inBuf [inIndex + inPos++] + 18;  		}  		if (r_cnt == 0x111) {  			if (inPos + 2 > inLen)  				return 0;  			r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  			inPos += 2;  		}  		int outPos2 = outPos - outPosDispl;  		while (r_cnt-- > 0 && outPos < outLen)  			outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  	} else  		outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0) {  		ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  		inPos++;  		int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  		if (outPosDispl == 0)  			outPosDispl = 0x1000;  		if (outPosDispl > outPos)  			return 0;  		if (r_cnt == 18) {  			if (inPos >= inLen)  				return 0;  			r_cnt = inBuf [inIndex + inPos++] + 18;  		}  		if (r_cnt == 0x111) {  			if (inPos + 2 > inLen)  				return 0;  			r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  			inPos += 2;  		}  		int outPos2 = outPos - outPosDispl;  		while (r_cnt-- > 0 && outPos < outLen)  			outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  	} else  		outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0) {  		ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  		inPos++;  		int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  		if (outPosDispl == 0)  			outPosDispl = 0x1000;  		if (outPosDispl > outPos)  			return 0;  		if (r_cnt == 18) {  			if (inPos >= inLen)  				return 0;  			r_cnt = inBuf [inIndex + inPos++] + 18;  		}  		if (r_cnt == 0x111) {  			if (inPos + 2 > inLen)  				return 0;  			r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  			inPos += 2;  		}  		int outPos2 = outPos - outPosDispl;  		while (r_cnt-- > 0 && outPos < outLen)  			outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  	} else  		outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  	if ((tag & 0x80) != 0) {  		ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  		inPos++;  		int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  		if (outPosDispl == 0)  			outPosDispl = 0x1000;  		if (outPosDispl > outPos)  			return 0;  		if (r_cnt == 18) {  			if (inPos >= inLen)  				return 0;  			r_cnt = inBuf [inIndex + inPos++] + 18;  		}  		if (r_cnt == 0x111) {  			if (inPos + 2 > inLen)  				return 0;  			r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  			inPos += 2;  		}  		int outPos2 = outPos - outPosDispl;  		while (r_cnt-- > 0 && outPos < outLen)  			outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  	} else  		outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if ((tag & 0x80) != 0) {  	ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  	inPos++;  	int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  	if (outPosDispl == 0)  		outPosDispl = 0x1000;  	if (outPosDispl > outPos)  		return 0;  	if (r_cnt == 18) {  		if (inPos >= inLen)  			return 0;  		r_cnt = inBuf [inIndex + inPos++] + 18;  	}  	if (r_cnt == 0x111) {  		if (inPos + 2 > inLen)  			return 0;  		r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  		inPos += 2;  	}  	int outPos2 = outPos - outPosDispl;  	while (r_cnt-- > 0 && outPos < outLen)  		outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  } else  	outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if ((tag & 0x80) != 0) {  	ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  	inPos++;  	int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  	if (outPosDispl == 0)  		outPosDispl = 0x1000;  	if (outPosDispl > outPos)  		return 0;  	if (r_cnt == 18) {  		if (inPos >= inLen)  			return 0;  		r_cnt = inBuf [inIndex + inPos++] + 18;  	}  	if (r_cnt == 0x111) {  		if (inPos + 2 > inLen)  			return 0;  		r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  		inPos += 2;  	}  	int outPos2 = outPos - outPosDispl;  	while (r_cnt-- > 0 && outPos < outLen)  		outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  } else  	outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if ((tag & 0x80) != 0) {  	ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  	inPos++;  	int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  	if (outPosDispl == 0)  		outPosDispl = 0x1000;  	if (outPosDispl > outPos)  		return 0;  	if (r_cnt == 18) {  		if (inPos >= inLen)  			return 0;  		r_cnt = inBuf [inIndex + inPos++] + 18;  	}  	if (r_cnt == 0x111) {  		if (inPos + 2 > inLen)  			return 0;  		r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  		inPos += 2;  	}  	int outPos2 = outPos - outPosDispl;  	while (r_cnt-- > 0 && outPos < outLen)  		outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  } else  	outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if ((tag & 0x80) != 0) {  	ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  	inPos++;  	int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  	if (outPosDispl == 0)  		outPosDispl = 0x1000;  	if (outPosDispl > outPos)  		return 0;  	if (r_cnt == 18) {  		if (inPos >= inLen)  			return 0;  		r_cnt = inBuf [inIndex + inPos++] + 18;  	}  	if (r_cnt == 0x111) {  		if (inPos + 2 > inLen)  			return 0;  		r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  		inPos += 2;  	}  	int outPos2 = outPos - outPosDispl;  	while (r_cnt-- > 0 && outPos < outLen)  		outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  } else  	outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if ((tag & 0x80) != 0) {  	ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  	inPos++;  	int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  	if (outPosDispl == 0)  		outPosDispl = 0x1000;  	if (outPosDispl > outPos)  		return 0;  	if (r_cnt == 18) {  		if (inPos >= inLen)  			return 0;  		r_cnt = inBuf [inIndex + inPos++] + 18;  	}  	if (r_cnt == 0x111) {  		if (inPos + 2 > inLen)  			return 0;  		r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  		inPos += 2;  	}  	int outPos2 = outPos - outPosDispl;  	while (r_cnt-- > 0 && outPos < outLen)  		outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  } else  	outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if ((tag & 0x80) != 0) {  	ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  	inPos++;  	int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  	if (outPosDispl == 0)  		outPosDispl = 0x1000;  	if (outPosDispl > outPos)  		return 0;  	if (r_cnt == 18) {  		if (inPos >= inLen)  			return 0;  		r_cnt = inBuf [inIndex + inPos++] + 18;  	}  	if (r_cnt == 0x111) {  		if (inPos + 2 > inLen)  			return 0;  		r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  		inPos += 2;  	}  	int outPos2 = outPos - outPosDispl;  	while (r_cnt-- > 0 && outPos < outLen)  		outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  } else  	outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if ((tag & 0x80) != 0) {  	ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  	inPos++;  	int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  	if (outPosDispl == 0)  		outPosDispl = 0x1000;  	if (outPosDispl > outPos)  		return 0;  	if (r_cnt == 18) {  		if (inPos >= inLen)  			return 0;  		r_cnt = inBuf [inIndex + inPos++] + 18;  	}  	if (r_cnt == 0x111) {  		if (inPos + 2 > inLen)  			return 0;  		r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  		inPos += 2;  	}  	int outPos2 = outPos - outPosDispl;  	while (r_cnt-- > 0 && outPos < outLen)  		outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  } else  	outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if ((tag & 0x80) != 0) {  	ushort outPosDispl = (ushort)((((inBuf [inIndex + inPos + 1]) & 0xF) << 8) + inBuf [inIndex + inPos]);  	inPos++;  	int r_cnt = (inBuf [inIndex + inPos++] >> 4) + 3;  	if (outPosDispl == 0)  		outPosDispl = 0x1000;  	if (outPosDispl > outPos)  		return 0;  	if (r_cnt == 18) {  		if (inPos >= inLen)  			return 0;  		r_cnt = inBuf [inIndex + inPos++] + 18;  	}  	if (r_cnt == 0x111) {  		if (inPos + 2 > inLen)  			return 0;  		r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  		inPos += 2;  	}  	int outPos2 = outPos - outPosDispl;  	while (r_cnt-- > 0 && outPos < outLen)  		outBuf [outIndex + outPos++] = outBuf [outIndex + outPos2++];  } else  	outBuf [outIndex + outPos++] = inBuf [inIndex + inPos++];  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if (r_cnt == 18) {  	if (inPos >= inLen)  		return 0;  	r_cnt = inBuf [inIndex + inPos++] + 18;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if (r_cnt == 18) {  	if (inPos >= inLen)  		return 0;  	r_cnt = inBuf [inIndex + inPos++] + 18;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: r_cnt = inBuf [inIndex + inPos++] + 18;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if (r_cnt == 0x111) {  	if (inPos + 2 > inLen)  		return 0;  	r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  	inPos += 2;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if (r_cnt == 0x111) {  	if (inPos + 2 > inLen)  		return 0;  	r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  	inPos += 2;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if (r_cnt == 0x111) {  	if (inPos + 2 > inLen)  		return 0;  	r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  	inPos += 2;  }  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: if (inPos + 2 > inLen)  	return 0;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: r_cnt = (inBuf [inIndex + inPos + 1] << 8) + inBuf [inIndex + inPos] + 0x111;  
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: inPos += 2;  
Magic Number,de4dot.code.deobfuscators.Rummage,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Rummage\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Rummage,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Rummage\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Rummage,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Rummage\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Rummage,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Rummage\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Rummage,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetStringInfo,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	int stringId = ldci4.GetLdcI4Value ();  	var call = instrs [i + 1];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (decrypter.Method' calledMethod))  		continue;  	var stsfld = instrs [i + 2];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	var field = stsfld.Operand as FieldDef;  	if (field == null)  		continue;  	return new StringInfo (field' stringId);  }  
Magic Number,de4dot.code.deobfuscators.Rummage,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,GetStringInfo,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldci4 = instrs [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	int stringId = ldci4.GetLdcI4Value ();  	var call = instrs [i + 1];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (decrypter.Method' calledMethod))  		continue;  	var stsfld = instrs [i + 2];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	var field = stsfld.Operand as FieldDef;  	if (field == null)  		continue;  	return new StringInfo (field' stringId);  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (stringDecrypter.Detected)  	val += 100;  
Magic Number,de4dot.code.deobfuscators.Skater_NET,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100;  
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 2; i++) {  		var ldsfld = instrs [i];  		if (ldsfld.OpCode.Code != Code.Ldsfld)  			continue;  		var ldci4 = instrs [i + 1];  		if (!ldci4.IsLdcI4 ())  			continue;  		var stfld = instrs [i + 2];  		if (stfld.OpCode.Code != Code.Stfld)  			continue;  		var field = stfld.Operand as IField;  		if (!FieldEqualityComparer.CompareDeclaringTypes.Equals (enumField' field))  			continue;  		block.Remove (i' 3);  		i--;  	}  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 2; i++) {  		var ldsfld = instrs [i];  		if (ldsfld.OpCode.Code != Code.Ldsfld)  			continue;  		var ldci4 = instrs [i + 1];  		if (!ldci4.IsLdcI4 ())  			continue;  		var stfld = instrs [i + 2];  		if (stfld.OpCode.Code != Code.Stfld)  			continue;  		var field = stfld.Operand as IField;  		if (!FieldEqualityComparer.CompareDeclaringTypes.Equals (enumField' field))  			continue;  		block.Remove (i' 3);  		i--;  	}  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instrs = block.Instructions;  	for (int i = 0; i < instrs.Count - 2; i++) {  		var ldsfld = instrs [i];  		if (ldsfld.OpCode.Code != Code.Ldsfld)  			continue;  		var ldci4 = instrs [i + 1];  		if (!ldci4.IsLdcI4 ())  			continue;  		var stfld = instrs [i + 2];  		if (stfld.OpCode.Code != Code.Stfld)  			continue;  		var field = stfld.Operand as IField;  		if (!FieldEqualityComparer.CompareDeclaringTypes.Equals (enumField' field))  			continue;  		block.Remove (i' 3);  		i--;  	}  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Deobfuscate,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldsfld = instrs [i];  	if (ldsfld.OpCode.Code != Code.Ldsfld)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	var stfld = instrs [i + 2];  	if (stfld.OpCode.Code != Code.Stfld)  		continue;  	var field = stfld.Operand as IField;  	if (!FieldEqualityComparer.CompareDeclaringTypes.Equals (enumField' field))  		continue;  	block.Remove (i' 3);  	i--;  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Deobfuscate,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldsfld = instrs [i];  	if (ldsfld.OpCode.Code != Code.Ldsfld)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	var stfld = instrs [i + 2];  	if (stfld.OpCode.Code != Code.Stfld)  		continue;  	var field = stfld.Operand as IField;  	if (!FieldEqualityComparer.CompareDeclaringTypes.Equals (enumField' field))  		continue;  	block.Remove (i' 3);  	i--;  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Deobfuscate,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  	var ldsfld = instrs [i];  	if (ldsfld.OpCode.Code != Code.Ldsfld)  		continue;  	var ldci4 = instrs [i + 1];  	if (!ldci4.IsLdcI4 ())  		continue;  	var stfld = instrs [i + 2];  	if (stfld.OpCode.Code != Code.Stfld)  		continue;  	var field = stfld.Operand as IField;  	if (!FieldEqualityComparer.CompareDeclaringTypes.Equals (enumField' field))  		continue;  	block.Remove (i' 3);  	i--;  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,Deobfuscate,The following statement contains a magic number: block.Remove (i' 3);  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldstr = instrs [i];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var encryptedString = ldstr.Operand as string;  	if (encryptedString == null)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Stsfld)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldsfld)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Call)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Stsfld)  		continue;  	var field = instrs [i + 4].Operand as FieldDef;  	if (field == null)  		continue;  	if (!new SigComparer ().Equals (field.DeclaringType' decrypterType))  		continue;  	fieldToDecryptedString.Add (field' decrypter.Decrypt (encryptedString));  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldstr = instrs [i];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var encryptedString = ldstr.Operand as string;  	if (encryptedString == null)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Stsfld)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldsfld)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Call)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Stsfld)  		continue;  	var field = instrs [i + 4].Operand as FieldDef;  	if (field == null)  		continue;  	if (!new SigComparer ().Equals (field.DeclaringType' decrypterType))  		continue;  	fieldToDecryptedString.Add (field' decrypter.Decrypt (encryptedString));  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldstr = instrs [i];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var encryptedString = ldstr.Operand as string;  	if (encryptedString == null)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Stsfld)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldsfld)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Call)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Stsfld)  		continue;  	var field = instrs [i + 4].Operand as FieldDef;  	if (field == null)  		continue;  	if (!new SigComparer ().Equals (field.DeclaringType' decrypterType))  		continue;  	fieldToDecryptedString.Add (field' decrypter.Decrypt (encryptedString));  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldstr = instrs [i];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var encryptedString = ldstr.Operand as string;  	if (encryptedString == null)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Stsfld)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldsfld)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Call)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Stsfld)  		continue;  	var field = instrs [i + 4].Operand as FieldDef;  	if (field == null)  		continue;  	if (!new SigComparer ().Equals (field.DeclaringType' decrypterType))  		continue;  	fieldToDecryptedString.Add (field' decrypter.Decrypt (encryptedString));  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  	var ldstr = instrs [i];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var encryptedString = ldstr.Operand as string;  	if (encryptedString == null)  		continue;  	if (instrs [i + 1].OpCode.Code != Code.Stsfld)  		continue;  	if (instrs [i + 2].OpCode.Code != Code.Ldsfld)  		continue;  	if (instrs [i + 3].OpCode.Code != Code.Call)  		continue;  	if (instrs [i + 4].OpCode.Code != Code.Stsfld)  		continue;  	var field = instrs [i + 4].Operand as FieldDef;  	if (field == null)  		continue;  	if (!new SigComparer ().Equals (field.DeclaringType' decrypterType))  		continue;  	fieldToDecryptedString.Add (field' decrypter.Decrypt (encryptedString));  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: if (instrs [i + 2].OpCode.Code != Code.Ldsfld)  	continue;  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: if (instrs [i + 3].OpCode.Code != Code.Call)  	continue;  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,Initialize,The following statement contains a magic number: if (instrs [i + 4].OpCode.Code != Code.Stsfld)  	continue;  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  	return null;  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  	return null;  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  	return null;  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  	return null;  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: for (int i = 0; i < saltAry.Length; i++) {  	int result;  	if (!int.TryParse (s2.Substring (i * 2' 2)' NumberStyles.AllowHexSpecifier' null' out result))  		return null;  	saltAry [i] = (byte)result;  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: for (int i = 0; i < saltAry.Length; i++) {  	int result;  	if (!int.TryParse (s2.Substring (i * 2' 2)' NumberStyles.AllowHexSpecifier' null' out result))  		return null;  	saltAry [i] = (byte)result;  }  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: if (!int.TryParse (s2.Substring (i * 2' 2)' NumberStyles.AllowHexSpecifier' null' out result))  	return null;  
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,FixSalt,The following statement contains a magic number: if (!int.TryParse (s2.Substring (i * 2' 2)' NumberStyles.AllowHexSpecifier' null' out result))  	return null;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolverInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolverInfo.cs,InitInfos,The following statement contains a magic number: if (strings.Length % 2 == 1)  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolverInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolverInfo.cs,InitInfos,The following statement contains a magic number: for (int i = 0; i < strings.Length; i += 2) {  	var info = EmbeddedAssemblyInfo.Create (module' strings [i]' strings [i + 1]);  	if (info == null)  		return false;  	list.Add (info);  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolverInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolverInfo.cs,InitInfos,The following statement contains a magic number: i += 2
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Object[]" && type1 == "System.Exception")  		return true;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else if (rtype == "System.Exception") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Int32" && type1 == "System.Exception")  		index = 2;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Object[]" && type1 == "System.Exception")  		return true;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else if (rtype == "System.Exception") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Int32" && type1 == "System.Exception")  		index = 2;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Object[]" && type1 == "System.Exception")  		return true;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else if (rtype == "System.Exception") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Int32" && type1 == "System.Exception")  		index = 2;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Object[]" && type1 == "System.Exception")  		return true;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else if (rtype == "System.Exception") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Int32" && type1 == "System.Exception")  		index = 2;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Object[]" && type1 == "System.Exception")  		return true;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else if (rtype == "System.Exception") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Int32" && type1 == "System.Exception")  		index = 2;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (type0 == "System.Exception" && type1 == "System.Int32")  	index = 2;  else if (type0 == "System.Object[]" && type1 == "System.Exception")  	return true;  else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  	return true;  else if (type0 == "System.Exception")  	index = 1;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (type0 == "System.Exception" && type1 == "System.Int32")  	index = 2;  else if (type0 == "System.Object[]" && type1 == "System.Exception")  	return true;  else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  	return true;  else if (type0 == "System.Exception")  	index = 1;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: index = 2;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (type0 == "System.Object[]" && type1 == "System.Exception")  	return true;  else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  	return true;  else if (type0 == "System.Exception")  	index = 1;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  	return true;  else if (type0 == "System.Exception")  	index = 1;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Exception") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Int32" && type1 == "System.Exception")  		index = 2;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Exception") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Int32" && type1 == "System.Exception")  		index = 2;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Exception") {  	if (type0 == "System.Exception" && type1 == "System.Int32")  		index = 2;  	else if (type0 == "System.Int32" && type1 == "System.Exception")  		index = 2;  	else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  		return true;  	else if (type0 == "System.Exception")  		index = 1;  	else  		return false;  } else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (type0 == "System.Exception" && type1 == "System.Int32")  	index = 2;  else if (type0 == "System.Int32" && type1 == "System.Exception")  	index = 2;  else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  	return true;  else if (type0 == "System.Exception")  	index = 1;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (type0 == "System.Exception" && type1 == "System.Int32")  	index = 2;  else if (type0 == "System.Int32" && type1 == "System.Exception")  	index = 2;  else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  	return true;  else if (type0 == "System.Exception")  	index = 1;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (type0 == "System.Exception" && type1 == "System.Int32")  	index = 2;  else if (type0 == "System.Int32" && type1 == "System.Exception")  	index = 2;  else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  	return true;  else if (type0 == "System.Exception")  	index = 1;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: index = 2;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (type0 == "System.Int32" && type1 == "System.Exception")  	index = 2;  else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  	return true;  else if (type0 == "System.Exception")  	index = 1;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (type0 == "System.Int32" && type1 == "System.Exception")  	index = 2;  else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  	return true;  else if (type0 == "System.Exception")  	index = 1;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: index = 2;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,IsExceptionLoggerMethod,The following statement contains a magic number: if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  	return true;  else if (type0 == "System.Exception")  	index = 1;  else  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (memoryManagerInfo.Detected)  	val += 100;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundSmartAssemblyAttribute)  	val += 10;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 10;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: if (val.Groups.Count < 6)  	return;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: approxVersion = new Version (int.Parse (val.Groups [2].ToString ())' int.Parse (val.Groups [3].ToString ())' int.Parse (val.Groups [4].ToString ())' int.Parse (val.Groups [5].ToString ()));  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: approxVersion = new Version (int.Parse (val.Groups [2].ToString ())' int.Parse (val.Groups [3].ToString ())' int.Parse (val.Groups [4].ToString ())' int.Parse (val.Groups [5].ToString ()));  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: approxVersion = new Version (int.Parse (val.Groups [2].ToString ())' int.Parse (val.Groups [3].ToString ())' int.Parse (val.Groups [4].ToString ())' int.Parse (val.Groups [5].ToString ()));  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitializeVersion,The following statement contains a magic number: approxVersion = new Version (int.Parse (val.Groups [2].ToString ())' int.Parse (val.Groups [3].ToString ())' int.Parse (val.Groups [4].ToString ())' int.Parse (val.Groups [5].ToString ()));  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by SmartAssembly") {  	ObfuscatorName = "SmartAssembly 5.0/5.1";  	approxVersion = new Version (5' 0' 0' 0);  	return;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: approxVersion = new Version (5' 0' 0' 0);  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  	// It's SA 1.x - 4.x  	if (proxyCallFixer.Detected || HasEmptyClassesInEveryNamespace ()) {  		ObfuscatorName = "SmartAssembly 4.x";  		approxVersion = new Version (4' 0' 0' 0);  		return;  	}  	int ver = CheckTypeIdAttribute ();  	if (ver == 2) {  		ObfuscatorName = "SmartAssembly 2.x";  		approxVersion = new Version (2' 0' 0' 0);  		return;  	}  	if (ver == 1) {  		ObfuscatorName = "SmartAssembly 1.x-2.x";  		approxVersion = new Version (1' 0' 0' 0);  		return;  	}  	if (HasModuleCctor ()) {  		ObfuscatorName = "SmartAssembly 3.x";  		approxVersion = new Version (3' 0' 0' 0);  		return;  	}  	ObfuscatorName = "SmartAssembly 1.x-4.x";  	approxVersion = new Version (1' 0' 0' 0);  	return;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  	// It's SA 1.x - 4.x  	if (proxyCallFixer.Detected || HasEmptyClassesInEveryNamespace ()) {  		ObfuscatorName = "SmartAssembly 4.x";  		approxVersion = new Version (4' 0' 0' 0);  		return;  	}  	int ver = CheckTypeIdAttribute ();  	if (ver == 2) {  		ObfuscatorName = "SmartAssembly 2.x";  		approxVersion = new Version (2' 0' 0' 0);  		return;  	}  	if (ver == 1) {  		ObfuscatorName = "SmartAssembly 1.x-2.x";  		approxVersion = new Version (1' 0' 0' 0);  		return;  	}  	if (HasModuleCctor ()) {  		ObfuscatorName = "SmartAssembly 3.x";  		approxVersion = new Version (3' 0' 0' 0);  		return;  	}  	ObfuscatorName = "SmartAssembly 1.x-4.x";  	approxVersion = new Version (1' 0' 0' 0);  	return;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  	// It's SA 1.x - 4.x  	if (proxyCallFixer.Detected || HasEmptyClassesInEveryNamespace ()) {  		ObfuscatorName = "SmartAssembly 4.x";  		approxVersion = new Version (4' 0' 0' 0);  		return;  	}  	int ver = CheckTypeIdAttribute ();  	if (ver == 2) {  		ObfuscatorName = "SmartAssembly 2.x";  		approxVersion = new Version (2' 0' 0' 0);  		return;  	}  	if (ver == 1) {  		ObfuscatorName = "SmartAssembly 1.x-2.x";  		approxVersion = new Version (1' 0' 0' 0);  		return;  	}  	if (HasModuleCctor ()) {  		ObfuscatorName = "SmartAssembly 3.x";  		approxVersion = new Version (3' 0' 0' 0);  		return;  	}  	ObfuscatorName = "SmartAssembly 1.x-4.x";  	approxVersion = new Version (1' 0' 0' 0);  	return;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  	// It's SA 1.x - 4.x  	if (proxyCallFixer.Detected || HasEmptyClassesInEveryNamespace ()) {  		ObfuscatorName = "SmartAssembly 4.x";  		approxVersion = new Version (4' 0' 0' 0);  		return;  	}  	int ver = CheckTypeIdAttribute ();  	if (ver == 2) {  		ObfuscatorName = "SmartAssembly 2.x";  		approxVersion = new Version (2' 0' 0' 0);  		return;  	}  	if (ver == 1) {  		ObfuscatorName = "SmartAssembly 1.x-2.x";  		approxVersion = new Version (1' 0' 0' 0);  		return;  	}  	if (HasModuleCctor ()) {  		ObfuscatorName = "SmartAssembly 3.x";  		approxVersion = new Version (3' 0' 0' 0);  		return;  	}  	ObfuscatorName = "SmartAssembly 1.x-4.x";  	approxVersion = new Version (1' 0' 0' 0);  	return;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (proxyCallFixer.Detected || HasEmptyClassesInEveryNamespace ()) {  	ObfuscatorName = "SmartAssembly 4.x";  	approxVersion = new Version (4' 0' 0' 0);  	return;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: approxVersion = new Version (4' 0' 0' 0);  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (ver == 2) {  	ObfuscatorName = "SmartAssembly 2.x";  	approxVersion = new Version (2' 0' 0' 0);  	return;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (ver == 2) {  	ObfuscatorName = "SmartAssembly 2.x";  	approxVersion = new Version (2' 0' 0' 0);  	return;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: approxVersion = new Version (2' 0' 0' 0);  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: if (HasModuleCctor ()) {  	ObfuscatorName = "SmartAssembly 3.x";  	approxVersion = new Version (3' 0' 0' 0);  	return;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GuessVersion,The following statement contains a magic number: approxVersion = new Version (3' 0' 0' 0);  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,CheckTypeIdAttribute,The following statement contains a magic number: if (fields.Count == 2)  	return 2;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,CheckTypeIdAttribute,The following statement contains a magic number: if (fields.Count == 2)  	return 2;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,CheckTypeIdAttribute,The following statement contains a magic number: return 2;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GetTypeIdAttribute,The following statement contains a magic number: foreach (var type in module.GetTypes ()) {  	counter++;  	var cattrs = type.CustomAttributes;  	if (cattrs.Count == 0)  		return null;  	var attrs2 = new Dictionary<TypeDef' bool> ();  	foreach (var cattr in cattrs) {  		if (!DotNetUtils.IsMethod (cattr.Constructor' "System.Void"' "(System.Int32)"))  			continue;  		var attrType = cattr.AttributeType as TypeDef;  		if (attrType == null)  			continue;  		if (attrs != null && !attrs.ContainsKey (attrType))  			continue;  		attrs2 [attrType] = true;  	}  	attrs = attrs2;  	if (attrs.Count == 0)  		return null;  	if (attrs.Count == 1 && counter >= 30)  		break;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,GetTypeIdAttribute,The following statement contains a magic number: if (attrs.Count == 1 && counter >= 30)  	break;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitStringDecrypterInfos,The following statement contains a magic number: while (initd.Count != stringDecrypterInfos.Count) {  	StringDecrypterInfo initdInfo = null;  	for (int i = 0; i < 2; i++) {  		foreach (var info in stringDecrypterInfos) {  			if (initd.ContainsKey (info))  				continue;  			if (info.Initialize (this' DeobfuscatedFile)) {  				resourceDecrypterInfo.SetSimpleZipType (info.SimpleZipTypeMethod' DeobfuscatedFile);  				initdInfo = info;  				break;  			}  		}  		if (initdInfo != null)  			break;  		assemblyResolverInfo.FindTypes ();  		resourceResolverInfo.FindTypes ();  		DecryptResources ();  	}  	if (initdInfo == null)  		break;  	initd [initdInfo] = true;  	InitStringDecrypter (initdInfo);  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,InitStringDecrypterInfos,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	foreach (var info in stringDecrypterInfos) {  		if (initd.ContainsKey (info))  			continue;  		if (info.Initialize (this' DeobfuscatedFile)) {  			resourceDecrypterInfo.SetSimpleZipType (info.SimpleZipTypeMethod' DeobfuscatedFile);  			initdInfo = info;  			break;  		}  	}  	if (initdInfo != null)  		break;  	assemblyResolverInfo.FindTypes ();  	resourceResolverInfo.FindTypes ();  	DecryptResources ();  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,FindBigType,The following statement contains a magic number: if (approxVersion <= new Version (6' 5' 3' 53))  	return null;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,FindBigType,The following statement contains a magic number: if (approxVersion <= new Version (6' 5' 3' 53))  	return null;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,FindBigType,The following statement contains a magic number: if (approxVersion <= new Version (6' 5' 3' 53))  	return null;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,FindBigType,The following statement contains a magic number: if (approxVersion <= new Version (6' 5' 3' 53))  	return null;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,IsBigType,The following statement contains a magic number: if (type.Methods.Count < 50)  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,IsBigType,The following statement contains a magic number: if (type.Fields.Count > 3)  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,MemoryManagerInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\MemoryManagerInfo.cs,CheckMemoryManagerType,The following statement contains a magic number: if (fields != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs.Count > 10)  	return null;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs.Count != 3)  	simpleDeobfuscator.Deobfuscate (cctor);  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs.Count != 3)  	return null;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,CheckCctor,The following statement contains a magic number: if (instrs [2].OpCode != OpCodes.Ret)  	return null;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,GetResolverHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt);  	if (instrs == null)  		continue;  	var call = instrs [0];  	if (!DotNetUtils.IsMethod (call.Operand as IMethod' "System.AppDomain"' "()"))  		continue;  	var ldftn = instrs [2];  	var handlerDef = DotNetUtils.GetMethod (module' ldftn.Operand as IMethod);  	if (handlerDef == null)  		continue;  	var newobj = instrs [3];  	if (!DotNetUtils.IsMethod (newobj.Operand as IMethod' "System.Void"' "(System.Object'System.IntPtr)"))  		continue;  	var callvirt = instrs [4];  	if (!DotNetUtils.IsMethod (callvirt.Operand as IMethod' "System.Void"' "(System.ResolveEventHandler)"))  		continue;  	numHandlers++;  	yield return handlerDef;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,GetResolverHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt);  	if (instrs == null)  		continue;  	var call = instrs [0];  	if (!DotNetUtils.IsMethod (call.Operand as IMethod' "System.AppDomain"' "()"))  		continue;  	var ldftn = instrs [2];  	var handlerDef = DotNetUtils.GetMethod (module' ldftn.Operand as IMethod);  	if (handlerDef == null)  		continue;  	var newobj = instrs [3];  	if (!DotNetUtils.IsMethod (newobj.Operand as IMethod' "System.Void"' "(System.Object'System.IntPtr)"))  		continue;  	var callvirt = instrs [4];  	if (!DotNetUtils.IsMethod (callvirt.Operand as IMethod' "System.Void"' "(System.ResolveEventHandler)"))  		continue;  	numHandlers++;  	yield return handlerDef;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,GetResolverHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var instrs = DotNetUtils.GetInstructions (instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt);  	if (instrs == null)  		continue;  	var call = instrs [0];  	if (!DotNetUtils.IsMethod (call.Operand as IMethod' "System.AppDomain"' "()"))  		continue;  	var ldftn = instrs [2];  	var handlerDef = DotNetUtils.GetMethod (module' ldftn.Operand as IMethod);  	if (handlerDef == null)  		continue;  	var newobj = instrs [3];  	if (!DotNetUtils.IsMethod (newobj.Operand as IMethod' "System.Void"' "(System.Object'System.IntPtr)"))  		continue;  	var callvirt = instrs [4];  	if (!DotNetUtils.IsMethod (callvirt.Operand as IMethod' "System.Void"' "(System.ResolveEventHandler)"))  		continue;  	numHandlers++;  	yield return handlerDef;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  case 1:  	int totalInflatedLength = reader.ReadInt32 ();  	if (totalInflatedLength < 0)  		throw new ApplicationException ("Invalid length");  	var inflatedBytes = new byte[totalInflatedLength];  	int partInflatedLength;  	for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  		int partLength = reader.ReadInt32 ();  		partInflatedLength = reader.ReadInt32 ();  		if (partLength < 0 || partInflatedLength < 0)  			throw new ApplicationException ("Invalid length");  		var inflater = new Inflater (true);  		inflater.SetInput (encryptedData' checked((int)reader.BaseStream.Position)' partLength);  		reader.BaseStream.Seek (partLength' SeekOrigin.Current);  		int realInflatedLen = inflater.Inflate (inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  		if (realInflatedLen != partInflatedLength)  			throw new ApplicationException ("Could not inflate");  	}  	return inflatedBytes;  case 2:  	if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  		throw new ApplicationException ("DES key / iv have not been set yet");  	using (var provider = new DESCryptoServiceProvider ()) {  		provider.Key = resourceDecrypterInfo.DES_Key;  		provider.IV = resourceDecrypterInfo.DES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  case 3:  	if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  		throw new ApplicationException ("AES key / iv have not been set yet");  	using (var provider = new RijndaelManaged ()) {  		provider.Key = resourceDecrypterInfo.AES_Key;  		provider.IV = resourceDecrypterInfo.AES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  default:  	throw new ApplicationException (string.Format ("Unknown encryption type 0x{0:X2}"' encryption));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  case 1:  	int totalInflatedLength = reader.ReadInt32 ();  	if (totalInflatedLength < 0)  		throw new ApplicationException ("Invalid length");  	var inflatedBytes = new byte[totalInflatedLength];  	int partInflatedLength;  	for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  		int partLength = reader.ReadInt32 ();  		partInflatedLength = reader.ReadInt32 ();  		if (partLength < 0 || partInflatedLength < 0)  			throw new ApplicationException ("Invalid length");  		var inflater = new Inflater (true);  		inflater.SetInput (encryptedData' checked((int)reader.BaseStream.Position)' partLength);  		reader.BaseStream.Seek (partLength' SeekOrigin.Current);  		int realInflatedLen = inflater.Inflate (inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  		if (realInflatedLen != partInflatedLength)  			throw new ApplicationException ("Could not inflate");  	}  	return inflatedBytes;  case 2:  	if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  		throw new ApplicationException ("DES key / iv have not been set yet");  	using (var provider = new DESCryptoServiceProvider ()) {  		provider.Key = resourceDecrypterInfo.DES_Key;  		provider.IV = resourceDecrypterInfo.DES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  case 3:  	if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  		throw new ApplicationException ("AES key / iv have not been set yet");  	using (var provider = new RijndaelManaged ()) {  		provider.Key = resourceDecrypterInfo.AES_Key;  		provider.IV = resourceDecrypterInfo.AES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  default:  	throw new ApplicationException (string.Format ("Unknown encryption type 0x{0:X2}"' encryption));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  case 1:  	int totalInflatedLength = reader.ReadInt32 ();  	if (totalInflatedLength < 0)  		throw new ApplicationException ("Invalid length");  	var inflatedBytes = new byte[totalInflatedLength];  	int partInflatedLength;  	for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  		int partLength = reader.ReadInt32 ();  		partInflatedLength = reader.ReadInt32 ();  		if (partLength < 0 || partInflatedLength < 0)  			throw new ApplicationException ("Invalid length");  		var inflater = new Inflater (true);  		inflater.SetInput (encryptedData' checked((int)reader.BaseStream.Position)' partLength);  		reader.BaseStream.Seek (partLength' SeekOrigin.Current);  		int realInflatedLen = inflater.Inflate (inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  		if (realInflatedLen != partInflatedLength)  			throw new ApplicationException ("Could not inflate");  	}  	return inflatedBytes;  case 2:  	if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  		throw new ApplicationException ("DES key / iv have not been set yet");  	using (var provider = new DESCryptoServiceProvider ()) {  		provider.Key = resourceDecrypterInfo.DES_Key;  		provider.IV = resourceDecrypterInfo.DES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  case 3:  	if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  		throw new ApplicationException ("AES key / iv have not been set yet");  	using (var provider = new RijndaelManaged ()) {  		provider.Key = resourceDecrypterInfo.AES_Key;  		provider.IV = resourceDecrypterInfo.AES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  default:  	throw new ApplicationException (string.Format ("Unknown encryption type 0x{0:X2}"' encryption));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  case 1:  	int totalInflatedLength = reader.ReadInt32 ();  	if (totalInflatedLength < 0)  		throw new ApplicationException ("Invalid length");  	var inflatedBytes = new byte[totalInflatedLength];  	int partInflatedLength;  	for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  		int partLength = reader.ReadInt32 ();  		partInflatedLength = reader.ReadInt32 ();  		if (partLength < 0 || partInflatedLength < 0)  			throw new ApplicationException ("Invalid length");  		var inflater = new Inflater (true);  		inflater.SetInput (encryptedData' checked((int)reader.BaseStream.Position)' partLength);  		reader.BaseStream.Seek (partLength' SeekOrigin.Current);  		int realInflatedLen = inflater.Inflate (inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  		if (realInflatedLen != partInflatedLength)  			throw new ApplicationException ("Could not inflate");  	}  	return inflatedBytes;  case 2:  	if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  		throw new ApplicationException ("DES key / iv have not been set yet");  	using (var provider = new DESCryptoServiceProvider ()) {  		provider.Key = resourceDecrypterInfo.DES_Key;  		provider.IV = resourceDecrypterInfo.DES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  case 3:  	if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  		throw new ApplicationException ("AES key / iv have not been set yet");  	using (var provider = new RijndaelManaged ()) {  		provider.Key = resourceDecrypterInfo.AES_Key;  		provider.IV = resourceDecrypterInfo.AES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  default:  	throw new ApplicationException (string.Format ("Unknown encryption type 0x{0:X2}"' encryption));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  case 1:  	int totalInflatedLength = reader.ReadInt32 ();  	if (totalInflatedLength < 0)  		throw new ApplicationException ("Invalid length");  	var inflatedBytes = new byte[totalInflatedLength];  	int partInflatedLength;  	for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  		int partLength = reader.ReadInt32 ();  		partInflatedLength = reader.ReadInt32 ();  		if (partLength < 0 || partInflatedLength < 0)  			throw new ApplicationException ("Invalid length");  		var inflater = new Inflater (true);  		inflater.SetInput (encryptedData' checked((int)reader.BaseStream.Position)' partLength);  		reader.BaseStream.Seek (partLength' SeekOrigin.Current);  		int realInflatedLen = inflater.Inflate (inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  		if (realInflatedLen != partInflatedLength)  			throw new ApplicationException ("Could not inflate");  	}  	return inflatedBytes;  case 2:  	if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  		throw new ApplicationException ("DES key / iv have not been set yet");  	using (var provider = new DESCryptoServiceProvider ()) {  		provider.Key = resourceDecrypterInfo.DES_Key;  		provider.IV = resourceDecrypterInfo.DES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  case 3:  	if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  		throw new ApplicationException ("AES key / iv have not been set yet");  	using (var provider = new RijndaelManaged ()) {  		provider.Key = resourceDecrypterInfo.AES_Key;  		provider.IV = resourceDecrypterInfo.AES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  default:  	throw new ApplicationException (string.Format ("Unknown encryption type 0x{0:X2}"' encryption));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: switch (encryption) {  case 1:  	int totalInflatedLength = reader.ReadInt32 ();  	if (totalInflatedLength < 0)  		throw new ApplicationException ("Invalid length");  	var inflatedBytes = new byte[totalInflatedLength];  	int partInflatedLength;  	for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  		int partLength = reader.ReadInt32 ();  		partInflatedLength = reader.ReadInt32 ();  		if (partLength < 0 || partInflatedLength < 0)  			throw new ApplicationException ("Invalid length");  		var inflater = new Inflater (true);  		inflater.SetInput (encryptedData' checked((int)reader.BaseStream.Position)' partLength);  		reader.BaseStream.Seek (partLength' SeekOrigin.Current);  		int realInflatedLen = inflater.Inflate (inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  		if (realInflatedLen != partInflatedLength)  			throw new ApplicationException ("Could not inflate");  	}  	return inflatedBytes;  case 2:  	if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  		throw new ApplicationException ("DES key / iv have not been set yet");  	using (var provider = new DESCryptoServiceProvider ()) {  		provider.Key = resourceDecrypterInfo.DES_Key;  		provider.IV = resourceDecrypterInfo.DES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  case 3:  	if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  		throw new ApplicationException ("AES key / iv have not been set yet");  	using (var provider = new RijndaelManaged ()) {  		provider.Key = resourceDecrypterInfo.AES_Key;  		provider.IV = resourceDecrypterInfo.AES_IV;  		using (var transform = provider.CreateDecryptor ()) {  			return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  		}  	}  default:  	throw new ApplicationException (string.Format ("Unknown encryption type 0x{0:X2}"' encryption));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: using (var provider = new DESCryptoServiceProvider ()) {  	provider.Key = resourceDecrypterInfo.DES_Key;  	provider.IV = resourceDecrypterInfo.DES_IV;  	using (var transform = provider.CreateDecryptor ()) {  		return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: using (var provider = new DESCryptoServiceProvider ()) {  	provider.Key = resourceDecrypterInfo.DES_Key;  	provider.IV = resourceDecrypterInfo.DES_IV;  	using (var transform = provider.CreateDecryptor ()) {  		return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: using (var transform = provider.CreateDecryptor ()) {  	return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: using (var transform = provider.CreateDecryptor ()) {  	return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: using (var provider = new RijndaelManaged ()) {  	provider.Key = resourceDecrypterInfo.AES_Key;  	provider.IV = resourceDecrypterInfo.AES_IV;  	using (var transform = provider.CreateDecryptor ()) {  		return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: using (var provider = new RijndaelManaged ()) {  	provider.Key = resourceDecrypterInfo.AES_Key;  	provider.IV = resourceDecrypterInfo.AES_IV;  	using (var transform = provider.CreateDecryptor ()) {  		return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: using (var transform = provider.CreateDecryptor ()) {  	return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: using (var transform = provider.CreateDecryptor ()) {  	return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,Decrypt,The following statement contains a magic number: return Decrypt (transform.TransformFinalBlock (encryptedData' 4' encryptedData.Length - 4));  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  	var ldtoken = instructions [i];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var field = DotNetUtils.GetField (module' ldtoken.Operand as IField);  	if (field == null)  		continue;  	if (field.InitialValue == null)  		continue;  	var call = instructions [i + 1];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (!DotNetUtils.IsMethod (calledMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  		continue;  	if (field.InitialValue.Length == 8)  		desList.Add (field.InitialValue);  	else if (field.InitialValue.Length == 16)  		aesList.Add (field.InitialValue);  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  	var ldtoken = instructions [i];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var field = DotNetUtils.GetField (module' ldtoken.Operand as IField);  	if (field == null)  		continue;  	if (field.InitialValue == null)  		continue;  	var call = instructions [i + 1];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (!DotNetUtils.IsMethod (calledMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  		continue;  	if (field.InitialValue.Length == 8)  		desList.Add (field.InitialValue);  	else if (field.InitialValue.Length == 16)  		aesList.Add (field.InitialValue);  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  	var ldtoken = instructions [i];  	if (ldtoken.OpCode.Code != Code.Ldtoken)  		continue;  	var field = DotNetUtils.GetField (module' ldtoken.Operand as IField);  	if (field == null)  		continue;  	if (field.InitialValue == null)  		continue;  	var call = instructions [i + 1];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (!DotNetUtils.IsMethod (calledMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  		continue;  	if (field.InitialValue.Length == 8)  		desList.Add (field.InitialValue);  	else if (field.InitialValue.Length == 16)  		aesList.Add (field.InitialValue);  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (field.InitialValue.Length == 8)  	desList.Add (field.InitialValue);  else if (field.InitialValue.Length == 16)  	aesList.Add (field.InitialValue);  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (field.InitialValue.Length == 8)  	desList.Add (field.InitialValue);  else if (field.InitialValue.Length == 16)  	aesList.Add (field.InitialValue);  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (field.InitialValue.Length == 16)  	aesList.Add (field.InitialValue);  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (desList.Count >= 2) {  	DES_Key = desList [desList.Count - 2];  	DES_IV = desList [desList.Count - 1];  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (desList.Count >= 2) {  	DES_Key = desList [desList.Count - 2];  	DES_IV = desList [desList.Count - 1];  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: DES_Key = desList [desList.Count - 2];  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (aesList.Count >= 2) {  	AES_Key = aesList [aesList.Count - 2];  	AES_IV = aesList [aesList.Count - 1];  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (aesList.Count >= 2) {  	AES_Key = aesList [aesList.Count - 2];  	AES_IV = aesList [aesList.Count - 1];  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,Initialize,The following statement contains a magic number: AES_Key = aesList [aesList.Count - 2];  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypter.cs,Decrypt,The following statement contains a magic number: switch (StringDecrypterInfo.DecrypterVersion) {  case StringDecrypterVersion.V1:  	// Some weird problem with 1.x decrypted strings. They all have a \x01 char at the end.  	var buf = Convert.FromBase64String (Encoding.ASCII.GetString (decryptedData' index' len));  	if (buf.Length % 2 != 0)  		Array.Resize (ref buf' buf.Length - 1);  	return Encoding.Unicode.GetString (buf);  case StringDecrypterVersion.V2:  	return Encoding.UTF8.GetString (Convert.FromBase64String (Encoding.ASCII.GetString (decryptedData' index' len)));  default:  	return Encoding.UTF8.GetString (Convert.FromBase64String (Encoding.UTF8.GetString (decryptedData' index' len)));  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypter.cs,Decrypt,The following statement contains a magic number: if (buf.Length % 2 != 0)  	Array.Resize (ref buf' buf.Length - 1);  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (decrypterVersion <= StringDecrypterVersion.V3) {  	MethodDef initMethod;  	if (decrypterVersion == StringDecrypterVersion.V3)  		initMethod = cctor;  	else if (decrypterVersion == StringDecrypterVersion.V2)  		initMethod = stringDecrypterMethod;  	else  		initMethod = stringDecrypterMethod;  	stringOffset = 0;  	if (decrypterVersion != StringDecrypterVersion.V1) {  		if (CallsGetPublicKeyToken (initMethod)) {  			var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKeyToken);  			if (!PublicKeyBase.IsNullOrEmpty2 (pkt)) {  				for (int i = 0; i < pkt.Data.Length - 1; i += 2)  					stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  			}  		}  		if (DeobUtils.HasInteger (initMethod' 0xFFFFFF) && DeobUtils.HasInteger (initMethod' 0xFFFF)) {  			stringOffset ^= ((stringDecrypterMethod.MDToken.ToInt32 () & 0xFFFFFF) - 1) % 0xFFFF;  		}  	}  } else {  	var offsetVal = FindOffsetValue (cctor);  	if (offsetVal == null)  		throw new ApplicationException ("Could not find string offset");  	stringOffset = offsetVal.Value;  	decrypterVersion = StringDecrypterVersion.V4;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (decrypterVersion <= StringDecrypterVersion.V3) {  	MethodDef initMethod;  	if (decrypterVersion == StringDecrypterVersion.V3)  		initMethod = cctor;  	else if (decrypterVersion == StringDecrypterVersion.V2)  		initMethod = stringDecrypterMethod;  	else  		initMethod = stringDecrypterMethod;  	stringOffset = 0;  	if (decrypterVersion != StringDecrypterVersion.V1) {  		if (CallsGetPublicKeyToken (initMethod)) {  			var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKeyToken);  			if (!PublicKeyBase.IsNullOrEmpty2 (pkt)) {  				for (int i = 0; i < pkt.Data.Length - 1; i += 2)  					stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  			}  		}  		if (DeobUtils.HasInteger (initMethod' 0xFFFFFF) && DeobUtils.HasInteger (initMethod' 0xFFFF)) {  			stringOffset ^= ((stringDecrypterMethod.MDToken.ToInt32 () & 0xFFFFFF) - 1) % 0xFFFF;  		}  	}  } else {  	var offsetVal = FindOffsetValue (cctor);  	if (offsetVal == null)  		throw new ApplicationException ("Could not find string offset");  	stringOffset = offsetVal.Value;  	decrypterVersion = StringDecrypterVersion.V4;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (decrypterVersion != StringDecrypterVersion.V1) {  	if (CallsGetPublicKeyToken (initMethod)) {  		var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKeyToken);  		if (!PublicKeyBase.IsNullOrEmpty2 (pkt)) {  			for (int i = 0; i < pkt.Data.Length - 1; i += 2)  				stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  		}  	}  	if (DeobUtils.HasInteger (initMethod' 0xFFFFFF) && DeobUtils.HasInteger (initMethod' 0xFFFF)) {  		stringOffset ^= ((stringDecrypterMethod.MDToken.ToInt32 () & 0xFFFFFF) - 1) % 0xFFFF;  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (decrypterVersion != StringDecrypterVersion.V1) {  	if (CallsGetPublicKeyToken (initMethod)) {  		var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKeyToken);  		if (!PublicKeyBase.IsNullOrEmpty2 (pkt)) {  			for (int i = 0; i < pkt.Data.Length - 1; i += 2)  				stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  		}  	}  	if (DeobUtils.HasInteger (initMethod' 0xFFFFFF) && DeobUtils.HasInteger (initMethod' 0xFFFF)) {  		stringOffset ^= ((stringDecrypterMethod.MDToken.ToInt32 () & 0xFFFFFF) - 1) % 0xFFFF;  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (CallsGetPublicKeyToken (initMethod)) {  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKeyToken);  	if (!PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < pkt.Data.Length - 1; i += 2)  			stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (CallsGetPublicKeyToken (initMethod)) {  	var pkt = PublicKeyBase.ToPublicKeyToken (module.Assembly.PublicKeyToken);  	if (!PublicKeyBase.IsNullOrEmpty2 (pkt)) {  		for (int i = 0; i < pkt.Data.Length - 1; i += 2)  			stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (!PublicKeyBase.IsNullOrEmpty2 (pkt)) {  	for (int i = 0; i < pkt.Data.Length - 1; i += 2)  		stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: if (!PublicKeyBase.IsNullOrEmpty2 (pkt)) {  	for (int i = 0; i < pkt.Data.Length - 1; i += 2)  		stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < pkt.Data.Length - 1; i += 2)  	stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < pkt.Data.Length - 1; i += 2)  	stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: i += 2
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,Initialize,The following statement contains a magic number: stringOffset ^= ((int)pkt.Data [i] << 8) + pkt.Data [i + 1];  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindOffsetField,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  	var ldsfld = instructions [i];  	if (ldsfld.OpCode.Code != Code.Ldsfld)  		continue;  	var field = ldsfld.Operand as IField;  	if (field == null || field.FieldSig.GetFieldType ().GetElementType () != ElementType.String)  		continue;  	if (!new SigComparer ().Equals (stringsEncodingClass' field.DeclaringType))  		continue;  	var call = instructions [i + 1];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (!DotNetUtils.IsMethod (calledMethod' "System.Int32"' "(System.String)"))  		continue;  	return field;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindOffsetValue,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  	var ldstr = instructions [i];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var stringVal = ldstr.Operand as string;  	if (stringVal == null)  		continue;  	var stsfld = instructions [i + 1];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	var field = stsfld.Operand as IField;  	if (field == null || fields.Find (field) != offsetField)  		continue;  	int value;  	if (!int.TryParse (stringVal' System.Globalization.NumberStyles.Integer' null' out value))  		continue;  	return value;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,FindSimpleZipTypeMethod,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  	var call = instructions [i];  	if (call.OpCode.Code != Code.Call)  		continue;  	var calledMethod = call.Operand as MethodDef;  	if (calledMethod == null)  		continue;  	if (!DotNetUtils.IsMethod (calledMethod' "System.Byte[]"' "(System.Byte[])"))  		continue;  	var stsfld = instructions [i + 1];  	if (stsfld.OpCode.Code != Code.Stsfld)  		continue;  	var field = stsfld.Operand as IField;  	if (field == null || field.FieldSig.GetFieldType ().GetFullName () != "System.Byte[]")  		continue;  	if (!new SigComparer ().Equals (stringsEncodingClass' field.DeclaringType))  		continue;  	return calledMethod;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instructions = block.Instructions;  	for (int i = 0; i <= instructions.Count - 3; i++) {  		var ldtoken = instructions [i];  		if (ldtoken.OpCode != OpCodes.Ldtoken)  			continue;  		if (!new SigComparer ().Equals (blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  			continue;  		var call1 = instructions [i + 1];  		if (call1.OpCode != OpCodes.Call)  			continue;  		var method1 = call1.Operand as IMethod;  		if (method1 == null || method1.ToString () != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  			continue;  		var call2 = instructions [i + 2];  		if (call2.OpCode != OpCodes.Call)  			continue;  		var method2 = call2.Operand as IMethod;  		if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (method2' CreateStringDelegateMethod))  			continue;  		block.Remove (i' 3);  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instructions = block.Instructions;  	for (int i = 0; i <= instructions.Count - 3; i++) {  		var ldtoken = instructions [i];  		if (ldtoken.OpCode != OpCodes.Ldtoken)  			continue;  		if (!new SigComparer ().Equals (blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  			continue;  		var call1 = instructions [i + 1];  		if (call1.OpCode != OpCodes.Call)  			continue;  		var method1 = call1.Operand as IMethod;  		if (method1 == null || method1.ToString () != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  			continue;  		var call2 = instructions [i + 2];  		if (call2.OpCode != OpCodes.Call)  			continue;  		var method2 = call2.Operand as IMethod;  		if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (method2' CreateStringDelegateMethod))  			continue;  		block.Remove (i' 3);  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.GetAllBlocks ()) {  	var instructions = block.Instructions;  	for (int i = 0; i <= instructions.Count - 3; i++) {  		var ldtoken = instructions [i];  		if (ldtoken.OpCode != OpCodes.Ldtoken)  			continue;  		if (!new SigComparer ().Equals (blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  			continue;  		var call1 = instructions [i + 1];  		if (call1.OpCode != OpCodes.Call)  			continue;  		var method1 = call1.Operand as IMethod;  		if (method1 == null || method1.ToString () != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  			continue;  		var call2 = instructions [i + 2];  		if (call2.OpCode != OpCodes.Call)  			continue;  		var method2 = call2.Operand as IMethod;  		if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (method2' CreateStringDelegateMethod))  			continue;  		block.Remove (i' 3);  		break;  	}  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 3; i++) {  	var ldtoken = instructions [i];  	if (ldtoken.OpCode != OpCodes.Ldtoken)  		continue;  	if (!new SigComparer ().Equals (blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  		continue;  	var call1 = instructions [i + 1];  	if (call1.OpCode != OpCodes.Call)  		continue;  	var method1 = call1.Operand as IMethod;  	if (method1 == null || method1.ToString () != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  		continue;  	var call2 = instructions [i + 2];  	if (call2.OpCode != OpCodes.Call)  		continue;  	var method2 = call2.Operand as IMethod;  	if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (method2' CreateStringDelegateMethod))  		continue;  	block.Remove (i' 3);  	break;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 3; i++) {  	var ldtoken = instructions [i];  	if (ldtoken.OpCode != OpCodes.Ldtoken)  		continue;  	if (!new SigComparer ().Equals (blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  		continue;  	var call1 = instructions [i + 1];  	if (call1.OpCode != OpCodes.Call)  		continue;  	var method1 = call1.Operand as IMethod;  	if (method1 == null || method1.ToString () != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  		continue;  	var call2 = instructions [i + 2];  	if (call2.OpCode != OpCodes.Call)  		continue;  	var method2 = call2.Operand as IMethod;  	if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (method2' CreateStringDelegateMethod))  		continue;  	block.Remove (i' 3);  	break;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 3; i++) {  	var ldtoken = instructions [i];  	if (ldtoken.OpCode != OpCodes.Ldtoken)  		continue;  	if (!new SigComparer ().Equals (blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  		continue;  	var call1 = instructions [i + 1];  	if (call1.OpCode != OpCodes.Call)  		continue;  	var method1 = call1.Operand as IMethod;  	if (method1 == null || method1.ToString () != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  		continue;  	var call2 = instructions [i + 2];  	if (call2.OpCode != OpCodes.Call)  		continue;  	var method2 = call2.Operand as IMethod;  	if (!MethodEqualityComparer.CompareDeclaringTypes.Equals (method2' CreateStringDelegateMethod))  		continue;  	block.Remove (i' 3);  	break;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,RemoveInitCode_v2,The following statement contains a magic number: block.Remove (i' 3);  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindFirstBlocks,The following statement contains a magic number: if (!instrs [index].IsBrfalse ()) {  	if (instrs [index].OpCode.Code != Code.Pop)  		return false;  	instr = instrs [index + 1];  	if (!instr.IsLdloc () || Instr.GetLocalVar (locals' instr) != loc0)  		return false;  	if (!instrs [index + 2].IsBrfalse ())  		return false;  	tamperBlocks.type = Type.V1;  	tamperBlocks.first = new BlockInfo {  		Block = block'  		Start = start'  		End = end'  	};  } else {  	tamperBlocks.type = Type.V2;  	tamperBlocks.first = new BlockInfo {  		Block = block'  		Start = start'  		End = end'  	};  	block = block.FallThrough;  	if (block == null)  		return false;  	instrs = block.Instructions;  	index = 0;  	instr = instrs [index];  	if (!instr.IsLdloc () || Instr.GetLocalVar (locals' instr) != loc0)  		return false;  	if (!instrs [index + 1].IsBrfalse ())  		return false;  }  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindFirstBlocks,The following statement contains a magic number: if (!instrs [index + 2].IsBrfalse ())  	return false;  
Magic Number,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,FindBadBlock,The following statement contains a magic number: if (instrs.Count != 3)  	return null;  
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (sum > 0)  	val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100 + 10 * (sum - 1);  
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundSpicesAttribute)  	val += 10;  
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 10;  
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: if ((data [0] & 2) != 0) {  	headerLength = 9;  	/*compressedLength = (int)*/Read32 (data' 1);  	decompressedLength = (int)Read32 (data' 5);  } else {  	headerLength = 3;  	//compressedLength = data[1];  	decompressedLength = data [2];  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: if ((data [0] & 2) != 0) {  	headerLength = 9;  	/*compressedLength = (int)*/Read32 (data' 1);  	decompressedLength = (int)Read32 (data' 5);  } else {  	headerLength = 3;  	//compressedLength = data[1];  	decompressedLength = data [2];  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: if ((data [0] & 2) != 0) {  	headerLength = 9;  	/*compressedLength = (int)*/Read32 (data' 1);  	decompressedLength = (int)Read32 (data' 5);  } else {  	headerLength = 3;  	//compressedLength = data[1];  	decompressedLength = data [2];  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: if ((data [0] & 2) != 0) {  	headerLength = 9;  	/*compressedLength = (int)*/Read32 (data' 1);  	decompressedLength = (int)Read32 (data' 5);  } else {  	headerLength = 3;  	//compressedLength = data[1];  	decompressedLength = data [2];  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: if ((data [0] & 2) != 0) {  	headerLength = 9;  	/*compressedLength = (int)*/Read32 (data' 1);  	decompressedLength = (int)Read32 (data' 5);  } else {  	headerLength = 3;  	//compressedLength = data[1];  	decompressedLength = data [2];  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: headerLength = 9;  
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: decompressedLength = (int)Read32 (data' 5);  
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: headerLength = 3;  
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,Decompress,The following statement contains a magic number: decompressedLength = data [2];  
Magic Number,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,IsWinFormType,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  	var baseType = type.BaseType;  	if (baseType == null)  		break;  	if (baseType.FullName == "System.Object" || baseType.FullName == "System.ValueType")  		return false;  	// Speed up common cases  	if (baseType.FullName == "System.Windows.Forms.Control" || baseType.FullName == "System.Windows.Forms.Form" || baseType.FullName == "System.Windows.Forms.UserControl")  		return true;  	var resolvedBaseType = baseType.ResolveTypeDef ();  	if (resolvedBaseType == null)  		break;  	type = resolvedBaseType;  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,Ror,The following statement contains a magic number: return (val << (32 - n)) + (val >> n);  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Find,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.HasNestedTypes || type.HasInterfaces)  		continue;  	if (type.HasEvents || type.HasProperties)  		continue;  	if (type.Fields.Count < 2 || type.Fields.Count > 3)  		continue;  	if ((type.Attributes & ~TypeAttributes.Sealed) != 0)  		continue;  	if (type.BaseType == null || type.BaseType.FullName != "System.Object")  		continue;  	if (HasInstanceMethods (type))  		continue;  	var cctor = type.FindStaticConstructor ();  	if (cctor == null)  		continue;  	FieldDef encryptedDataFieldTmp;  	StringDataFlags stringDataFlagsTmp;  	if (!CheckCctor (cctor' out encryptedDataFieldTmp' out stringDataFlagsTmp))  		continue;  	if (!InitializeDecrypterInfos (type))  		continue;  	encryptedDataField = encryptedDataFieldTmp;  	stringDataFlags = stringDataFlagsTmp;  	decrypterType = type;  	return;  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Find,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.HasNestedTypes || type.HasInterfaces)  		continue;  	if (type.HasEvents || type.HasProperties)  		continue;  	if (type.Fields.Count < 2 || type.Fields.Count > 3)  		continue;  	if ((type.Attributes & ~TypeAttributes.Sealed) != 0)  		continue;  	if (type.BaseType == null || type.BaseType.FullName != "System.Object")  		continue;  	if (HasInstanceMethods (type))  		continue;  	var cctor = type.FindStaticConstructor ();  	if (cctor == null)  		continue;  	FieldDef encryptedDataFieldTmp;  	StringDataFlags stringDataFlagsTmp;  	if (!CheckCctor (cctor' out encryptedDataFieldTmp' out stringDataFlagsTmp))  		continue;  	if (!InitializeDecrypterInfos (type))  		continue;  	encryptedDataField = encryptedDataFieldTmp;  	stringDataFlags = stringDataFlagsTmp;  	decrypterType = type;  	return;  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Find,The following statement contains a magic number: if (type.Fields.Count < 2 || type.Fields.Count > 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Find,The following statement contains a magic number: if (type.Fields.Count < 2 || type.Fields.Count > 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CheckCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  	var ldci4 = instructions [i];  	if (!ldci4.IsLdcI4 ())  		continue;  	var instrs = DotNetUtils.GetInstructions (instructions' i + 1' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call);  	if (instrs == null)  		continue;  	var newarr = instrs [0];  	if (newarr.Operand.ToString () != "System.Byte")  		continue;  	var field = instrs [2].Operand as FieldDef;  	if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)  		continue;  	int index = i + 1 + instrs.Count;  	if (index < instructions.Count && instructions [index].OpCode.Code == Code.Call)  		flags = GetStringDataFlags (instructions [index].Operand as MethodDef);  	compressedDataField = field;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,Get3DesKeyIv,The following statement contains a magic number: if (arrays.Count != 1 && arrays.Count != 2)  	return false;  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,The following statement contains a magic number: foreach (var instr in method.Body.Instructions) {  	if (instr.OpCode.Code != Code.Call)  		continue;  	var called = instr.Operand as MethodDef;  	if (called == null)  		continue;  	var sig = called.MethodSig;  	if (sig == null)  		continue;  	if (sig.RetType.GetElementType () != ElementType.I4)  		continue;  	var parameters = sig.Params;  	if (parameters.Count != 4)  		continue;  	if (!CheckClass (parameters [0]' "System.Byte[]"))  		continue;  	if (parameters [1].GetElementType () != ElementType.I4)  		continue;  	if (!CheckClass (parameters [2]' "System.Byte[]"))  		continue;  	if (parameters [3].GetElementType () != ElementType.I4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,The following statement contains a magic number: foreach (var instr in method.Body.Instructions) {  	if (instr.OpCode.Code != Code.Call)  		continue;  	var called = instr.Operand as MethodDef;  	if (called == null)  		continue;  	var sig = called.MethodSig;  	if (sig == null)  		continue;  	if (sig.RetType.GetElementType () != ElementType.I4)  		continue;  	var parameters = sig.Params;  	if (parameters.Count != 4)  		continue;  	if (!CheckClass (parameters [0]' "System.Byte[]"))  		continue;  	if (parameters [1].GetElementType () != ElementType.I4)  		continue;  	if (!CheckClass (parameters [2]' "System.Byte[]"))  		continue;  	if (parameters [3].GetElementType () != ElementType.I4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,The following statement contains a magic number: foreach (var instr in method.Body.Instructions) {  	if (instr.OpCode.Code != Code.Call)  		continue;  	var called = instr.Operand as MethodDef;  	if (called == null)  		continue;  	var sig = called.MethodSig;  	if (sig == null)  		continue;  	if (sig.RetType.GetElementType () != ElementType.I4)  		continue;  	var parameters = sig.Params;  	if (parameters.Count != 4)  		continue;  	if (!CheckClass (parameters [0]' "System.Byte[]"))  		continue;  	if (parameters [1].GetElementType () != ElementType.I4)  		continue;  	if (!CheckClass (parameters [2]' "System.Byte[]"))  		continue;  	if (parameters [3].GetElementType () != ElementType.I4)  		continue;  	return true;  }  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,The following statement contains a magic number: if (parameters.Count != 4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,The following statement contains a magic number: if (!CheckClass (parameters [2]' "System.Byte[]"))  	continue;  
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,CallsDecompressor,The following statement contains a magic number: if (parameters [3].GetElementType () != ElementType.I4)  	continue;  
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (stringDecrypter.Detected)  	val += 100;  
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 100;  
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: if (foundXenocodeAttribute)  	val += 10;  
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,DetectInternal,The following statement contains a magic number: val += 10;  
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,IsTypeWithThousandsOfMethods,The following statement contains a magic number: if (type.Methods.Count < 100)  	return false;  
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Find,The following statement contains a magic number: foreach (var type in module.Types) {  	if (type.HasFields)  		continue;  	if (type.Methods.Count < 1 || type.Methods.Count > 3)  		continue;  	if (type.HasProperties || type.HasEvents)  		continue;  	MethodDef method = null;  	foreach (var m in type.Methods) {  		if (m.Name == ".ctor" || m.Name == ".cctor")  			continue;  		if (DotNetUtils.IsMethod (m' "System.String"' "(System.String'System.Int32)")) {  			method = m;  			continue;  		}  		method = null;  		break;  	}  	if (method == null || method.Body == null)  		continue;  	bool foundConstant = false;  	foreach (var instr in method.Body.Instructions) {  		if (instr.IsLdcI4 () && instr.GetLdcI4Value () == STRING_DECRYPTER_KEY_CONST) {  			foundConstant = true;  			break;  		}  	}  	if (!foundConstant)  		continue;  	stringDecrypterType = type;  	stringDecrypterMethod = method;  	break;  }  
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Find,The following statement contains a magic number: if (type.Methods.Count < 1 || type.Methods.Count > 3)  	continue;  
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  	char c = (char)((es [i] - 'a') + ((es [i + 1] - 'a') << 4) + ((es [i + 2] - 'a') << 8) + ((es [i + 3] - 'a') << 12) - magic);  	magic += STRING_DECRYPTER_KEY_CONST;  	sb.Append (c);  }  
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  	char c = (char)((es [i] - 'a') + ((es [i + 1] - 'a') << 4) + ((es [i + 2] - 'a') << 8) + ((es [i + 3] - 'a') << 12) - magic);  	magic += STRING_DECRYPTER_KEY_CONST;  	sb.Append (c);  }  
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  	char c = (char)((es [i] - 'a') + ((es [i + 1] - 'a') << 4) + ((es [i + 2] - 'a') << 8) + ((es [i + 3] - 'a') << 12) - magic);  	magic += STRING_DECRYPTER_KEY_CONST;  	sb.Append (c);  }  
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  	char c = (char)((es [i] - 'a') + ((es [i + 1] - 'a') << 4) + ((es [i + 2] - 'a') << 8) + ((es [i + 3] - 'a') << 12) - magic);  	magic += STRING_DECRYPTER_KEY_CONST;  	sb.Append (c);  }  
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  	char c = (char)((es [i] - 'a') + ((es [i + 1] - 'a') << 4) + ((es [i + 2] - 'a') << 8) + ((es [i + 3] - 'a') << 12) - magic);  	magic += STRING_DECRYPTER_KEY_CONST;  	sb.Append (c);  }  
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  	char c = (char)((es [i] - 'a') + ((es [i + 1] - 'a') << 4) + ((es [i + 2] - 'a') << 8) + ((es [i + 3] - 'a') << 12) - magic);  	magic += STRING_DECRYPTER_KEY_CONST;  	sb.Append (c);  }  
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  	char c = (char)((es [i] - 'a') + ((es [i + 1] - 'a') << 4) + ((es [i + 2] - 'a') << 8) + ((es [i + 3] - 'a') << 12) - magic);  	magic += STRING_DECRYPTER_KEY_CONST;  	sb.Append (c);  }  
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,Decrypt,The following statement contains a magic number: i += 4
Magic Number,de4dot.code.renamer.asmmodules,MPropertyDef,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\asmmodules\PropertyDef.cs,IsItemProperty,The following statement contains a magic number: if (SetMethod != null && SetMethod.VisibleParameterCount >= 2)  	return true;  
Magic Number,de4dot.code.renamer,DerivedFrom,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\DerivedFrom.cs,Check,The following statement contains a magic number: if (recurseCount >= 100)  	return false;  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: foreach (var group in allGroups) {  	var groupMethod = group.Methods [0];  	var methodName = groupMethod.MethodDef.Name.String;  	bool onlyRenamableMethods = !group.HasNonRenamableMethod ();  	if (Utils.StartsWith (methodName' "get_"' StringComparison.Ordinal)) {  		var propName = methodName.Substring (4);  		foreach (var method in group.Methods) {  			if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidPropertyName (propName))  				continue;  			CreatePropertyGetter (propName' method);  		}  	} else if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal)) {  		var propName = methodName.Substring (4);  		foreach (var method in group.Methods) {  			if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidPropertyName (propName))  				continue;  			CreatePropertySetter (propName' method);  		}  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: foreach (var group in allGroups) {  	var groupMethod = group.Methods [0];  	var methodName = groupMethod.MethodDef.Name.String;  	bool onlyRenamableMethods = !group.HasNonRenamableMethod ();  	if (Utils.StartsWith (methodName' "get_"' StringComparison.Ordinal)) {  		var propName = methodName.Substring (4);  		foreach (var method in group.Methods) {  			if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidPropertyName (propName))  				continue;  			CreatePropertyGetter (propName' method);  		}  	} else if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal)) {  		var propName = methodName.Substring (4);  		foreach (var method in group.Methods) {  			if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidPropertyName (propName))  				continue;  			CreatePropertySetter (propName' method);  		}  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "get_"' StringComparison.Ordinal)) {  	var propName = methodName.Substring (4);  	foreach (var method in group.Methods) {  		if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidPropertyName (propName))  			continue;  		CreatePropertyGetter (propName' method);  	}  } else if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal)) {  	var propName = methodName.Substring (4);  	foreach (var method in group.Methods) {  		if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidPropertyName (propName))  			continue;  		CreatePropertySetter (propName' method);  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "get_"' StringComparison.Ordinal)) {  	var propName = methodName.Substring (4);  	foreach (var method in group.Methods) {  		if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidPropertyName (propName))  			continue;  		CreatePropertyGetter (propName' method);  	}  } else if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal)) {  	var propName = methodName.Substring (4);  	foreach (var method in group.Methods) {  		if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidPropertyName (propName))  			continue;  		CreatePropertySetter (propName' method);  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal)) {  	var propName = methodName.Substring (4);  	foreach (var method in group.Methods) {  		if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidPropertyName (propName))  			continue;  		CreatePropertySetter (propName' method);  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  	foreach (var method in type.AllMethodsSorted) {  		if (method.IsVirtual ())  			continue;  		// Virtual methods are in allGroups' so already fixed above  		if (method.Property != null)  			continue;  		var methodName = method.MethodDef.Name.String;  		if (Utils.StartsWith (methodName' "get_"' StringComparison.Ordinal))  			CreatePropertyGetter (methodName.Substring (4)' method);  		else if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal))  			CreatePropertySetter (methodName.Substring (4)' method);  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  	foreach (var method in type.AllMethodsSorted) {  		if (method.IsVirtual ())  			continue;  		// Virtual methods are in allGroups' so already fixed above  		if (method.Property != null)  			continue;  		var methodName = method.MethodDef.Name.String;  		if (Utils.StartsWith (methodName' "get_"' StringComparison.Ordinal))  			CreatePropertyGetter (methodName.Substring (4)' method);  		else if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal))  			CreatePropertySetter (methodName.Substring (4)' method);  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: foreach (var method in type.AllMethodsSorted) {  	if (method.IsVirtual ())  		continue;  	// Virtual methods are in allGroups' so already fixed above  	if (method.Property != null)  		continue;  	var methodName = method.MethodDef.Name.String;  	if (Utils.StartsWith (methodName' "get_"' StringComparison.Ordinal))  		CreatePropertyGetter (methodName.Substring (4)' method);  	else if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal))  		CreatePropertySetter (methodName.Substring (4)' method);  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: foreach (var method in type.AllMethodsSorted) {  	if (method.IsVirtual ())  		continue;  	// Virtual methods are in allGroups' so already fixed above  	if (method.Property != null)  		continue;  	var methodName = method.MethodDef.Name.String;  	if (Utils.StartsWith (methodName' "get_"' StringComparison.Ordinal))  		CreatePropertyGetter (methodName.Substring (4)' method);  	else if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal))  		CreatePropertySetter (methodName.Substring (4)' method);  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "get_"' StringComparison.Ordinal))  	CreatePropertyGetter (methodName.Substring (4)' method);  else if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal))  	CreatePropertySetter (methodName.Substring (4)' method);  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "get_"' StringComparison.Ordinal))  	CreatePropertyGetter (methodName.Substring (4)' method);  else if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal))  	CreatePropertySetter (methodName.Substring (4)' method);  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: CreatePropertyGetter (methodName.Substring (4)' method);  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "set_"' StringComparison.Ordinal))  	CreatePropertySetter (methodName.Substring (4)' method);  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestorePropertiesFromNames2,The following statement contains a magic number: CreatePropertySetter (methodName.Substring (4)' method);  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: foreach (var group in allGroups) {  	var groupMethod = group.Methods [0];  	var methodName = groupMethod.MethodDef.Name.String;  	bool onlyRenamableMethods = !group.HasNonRenamableMethod ();  	if (Utils.StartsWith (methodName' "add_"' StringComparison.Ordinal)) {  		var eventName = methodName.Substring (4);  		foreach (var method in group.Methods) {  			if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidEventName (eventName))  				continue;  			CreateEventAdder (eventName' method);  		}  	} else if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal)) {  		var eventName = methodName.Substring (7);  		foreach (var method in group.Methods) {  			if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidEventName (eventName))  				continue;  			CreateEventRemover (eventName' method);  		}  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: foreach (var group in allGroups) {  	var groupMethod = group.Methods [0];  	var methodName = groupMethod.MethodDef.Name.String;  	bool onlyRenamableMethods = !group.HasNonRenamableMethod ();  	if (Utils.StartsWith (methodName' "add_"' StringComparison.Ordinal)) {  		var eventName = methodName.Substring (4);  		foreach (var method in group.Methods) {  			if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidEventName (eventName))  				continue;  			CreateEventAdder (eventName' method);  		}  	} else if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal)) {  		var eventName = methodName.Substring (7);  		foreach (var method in group.Methods) {  			if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidEventName (eventName))  				continue;  			CreateEventRemover (eventName' method);  		}  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "add_"' StringComparison.Ordinal)) {  	var eventName = methodName.Substring (4);  	foreach (var method in group.Methods) {  		if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidEventName (eventName))  			continue;  		CreateEventAdder (eventName' method);  	}  } else if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal)) {  	var eventName = methodName.Substring (7);  	foreach (var method in group.Methods) {  		if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidEventName (eventName))  			continue;  		CreateEventRemover (eventName' method);  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "add_"' StringComparison.Ordinal)) {  	var eventName = methodName.Substring (4);  	foreach (var method in group.Methods) {  		if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidEventName (eventName))  			continue;  		CreateEventAdder (eventName' method);  	}  } else if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal)) {  	var eventName = methodName.Substring (7);  	foreach (var method in group.Methods) {  		if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidEventName (eventName))  			continue;  		CreateEventRemover (eventName' method);  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal)) {  	var eventName = methodName.Substring (7);  	foreach (var method in group.Methods) {  		if (onlyRenamableMethods && !memberInfos.Type (method.Owner).NameChecker.IsValidEventName (eventName))  			continue;  		CreateEventRemover (eventName' method);  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  	foreach (var method in type.AllMethodsSorted) {  		if (method.IsVirtual ())  			continue;  		// Virtual methods are in allGroups' so already fixed above  		if (method.Event != null)  			continue;  		var methodName = method.MethodDef.Name.String;  		if (Utils.StartsWith (methodName' "add_"' StringComparison.Ordinal))  			CreateEventAdder (methodName.Substring (4)' method);  		else if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal))  			CreateEventRemover (methodName.Substring (7)' method);  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  	foreach (var method in type.AllMethodsSorted) {  		if (method.IsVirtual ())  			continue;  		// Virtual methods are in allGroups' so already fixed above  		if (method.Event != null)  			continue;  		var methodName = method.MethodDef.Name.String;  		if (Utils.StartsWith (methodName' "add_"' StringComparison.Ordinal))  			CreateEventAdder (methodName.Substring (4)' method);  		else if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal))  			CreateEventRemover (methodName.Substring (7)' method);  	}  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: foreach (var method in type.AllMethodsSorted) {  	if (method.IsVirtual ())  		continue;  	// Virtual methods are in allGroups' so already fixed above  	if (method.Event != null)  		continue;  	var methodName = method.MethodDef.Name.String;  	if (Utils.StartsWith (methodName' "add_"' StringComparison.Ordinal))  		CreateEventAdder (methodName.Substring (4)' method);  	else if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal))  		CreateEventRemover (methodName.Substring (7)' method);  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: foreach (var method in type.AllMethodsSorted) {  	if (method.IsVirtual ())  		continue;  	// Virtual methods are in allGroups' so already fixed above  	if (method.Event != null)  		continue;  	var methodName = method.MethodDef.Name.String;  	if (Utils.StartsWith (methodName' "add_"' StringComparison.Ordinal))  		CreateEventAdder (methodName.Substring (4)' method);  	else if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal))  		CreateEventRemover (methodName.Substring (7)' method);  }  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "add_"' StringComparison.Ordinal))  	CreateEventAdder (methodName.Substring (4)' method);  else if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal))  	CreateEventRemover (methodName.Substring (7)' method);  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "add_"' StringComparison.Ordinal))  	CreateEventAdder (methodName.Substring (4)' method);  else if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal))  	CreateEventRemover (methodName.Substring (7)' method);  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: CreateEventAdder (methodName.Substring (4)' method);  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: if (Utils.StartsWith (methodName' "remove_"' StringComparison.Ordinal))  	CreateEventRemover (methodName.Substring (7)' method);  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,RestoreEventsFromNames2,The following statement contains a magic number: CreateEventRemover (methodName.Substring (7)' method);  
Magic Number,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,GetScopeType,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  	var nls = typeSig as NonLeafSig;  	if (nls == null)  		break;  	typeSig = nls.Next;  }  
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,The following statement contains a magic number: foreach (var method in type.Methods) {  	if (method.Body == null)  		continue;  	var instrs = method.Body.Instructions;  	for (int i = 0; i < instrs.Count; i++) {  		var call = instrs [i];  		if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  			continue;  		var calledMethod = call.Operand as IMethod;  		if (calledMethod == null)  			continue;  		int ldstrIndex;  		switch (calledMethod.FullName) {  		case "System.String System.Resources.ResourceManager::GetString(System.String'System.Globalization.CultureInfo)":  		case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String'System.Globalization.CultureInfo)":  		case "System.Object System.Resources.ResourceManager::GetObject(System.String'System.Globalization.CultureInfo)":  			ldstrIndex = i - 2;  			break;  		case "System.String System.Resources.ResourceManager::GetString(System.String)":  		case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String)":  		case "System.Object System.Resources.ResourceManager::GetObject(System.String)":  			ldstrIndex = i - 1;  			break;  		default:  			continue;  		}  		Instruction ldstr = null;  		string name = null;  		if (ldstrIndex >= 0)  			ldstr = instrs [ldstrIndex];  		if (ldstr == null || (name = ldstr.Operand as string) == null) {  			Logger.w ("Could not find string argument to method {0}"' calledMethod);  			continue;  		}  		RenameInfo info;  		if (!nameToInfo.TryGetValue (name' out info))  			continue;  		// should not be renamed  		ldstr.Operand = info.newName;  		Logger.v ("Renamed resource key {0} => {1}"' Utils.ToCsharpString (info.element.Name)' Utils.ToCsharpString (info.newName));  		info.element.Name = info.newName;  		info.foundInCode = true;  	}  }  
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  	var call = instrs [i];  	if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  		continue;  	var calledMethod = call.Operand as IMethod;  	if (calledMethod == null)  		continue;  	int ldstrIndex;  	switch (calledMethod.FullName) {  	case "System.String System.Resources.ResourceManager::GetString(System.String'System.Globalization.CultureInfo)":  	case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String'System.Globalization.CultureInfo)":  	case "System.Object System.Resources.ResourceManager::GetObject(System.String'System.Globalization.CultureInfo)":  		ldstrIndex = i - 2;  		break;  	case "System.String System.Resources.ResourceManager::GetString(System.String)":  	case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String)":  	case "System.Object System.Resources.ResourceManager::GetObject(System.String)":  		ldstrIndex = i - 1;  		break;  	default:  		continue;  	}  	Instruction ldstr = null;  	string name = null;  	if (ldstrIndex >= 0)  		ldstr = instrs [ldstrIndex];  	if (ldstr == null || (name = ldstr.Operand as string) == null) {  		Logger.w ("Could not find string argument to method {0}"' calledMethod);  		continue;  	}  	RenameInfo info;  	if (!nameToInfo.TryGetValue (name' out info))  		continue;  	// should not be renamed  	ldstr.Operand = info.newName;  	Logger.v ("Renamed resource key {0} => {1}"' Utils.ToCsharpString (info.element.Name)' Utils.ToCsharpString (info.newName));  	info.element.Name = info.newName;  	info.foundInCode = true;  }  
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,The following statement contains a magic number: switch (calledMethod.FullName) {  case "System.String System.Resources.ResourceManager::GetString(System.String'System.Globalization.CultureInfo)":  case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String'System.Globalization.CultureInfo)":  case "System.Object System.Resources.ResourceManager::GetObject(System.String'System.Globalization.CultureInfo)":  	ldstrIndex = i - 2;  	break;  case "System.String System.Resources.ResourceManager::GetString(System.String)":  case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String)":  case "System.Object System.Resources.ResourceManager::GetObject(System.String)":  	ldstrIndex = i - 1;  	break;  default:  	continue;  }  
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,Rename,The following statement contains a magic number: ldstrIndex = i - 2;  
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,CreatePrefixFromStringData,The following statement contains a magic number: data = data.Substring (0' Math.Min (data.Length' 100));  
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,CreatePrefixFromStringData,The following statement contains a magic number: if (sb.Length <= 3)  	return CreateDefaultName ();  
Magic Number,de4dot.code.renamer,ResourceRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceRenamer.cs,Rename,The following statement contains a magic number: nameToResource = new Dictionary<string' Resource> (module.ModuleDefMD.Resources.Count * 3' StringComparer.Ordinal);  
Magic Number,de4dot.code.renamer,ResourceRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceRenamer.cs,Rename,The following statement contains a magic number: foreach (var resource in module.ModuleDefMD.Resources) {  	var name = resource.Name.String;  	nameToResource [name] = resource;  	if (name.EndsWith (".g.resources"))  		nameToResource [name.Substring (0' name.Length - 12)] = resource;  	int index = name.LastIndexOf ('.');  	if (index > 0)  		nameToResource [name.Substring (0' index)] = resource;  }  
Magic Number,de4dot.code.renamer,ResourceRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceRenamer.cs,Rename,The following statement contains a magic number: if (name.EndsWith (".g.resources"))  	nameToResource [name.Substring (0' name.Length - 12)] = resource;  
Magic Number,de4dot.code.renamer,ResourceRenamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\ResourceRenamer.cs,Rename,The following statement contains a magic number: nameToResource [name.Substring (0' name.Length - 12)] = resource;  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,IsEventHandler,The following statement contains a magic number: if (sig == null || sig.Params.Count != 2)  	return false;  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitializeWindowsFormsFieldsAndProps,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  	if (methodDef.MethodDef.Body == null)  		continue;  	if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  		continue;  	var instructions = methodDef.MethodDef.Body.Instructions;  	for (int i = 2; i < instructions.Count; i++) {  		var call = instructions [i];  		if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  			continue;  		if (!IsWindowsFormsSetNameMethod (call.Operand as IMethod))  			continue;  		var ldstr = instructions [i - 1];  		if (ldstr.OpCode.Code != Code.Ldstr)  			continue;  		var fieldName = ldstr.Operand as string;  		if (fieldName == null || !checker.IsValidFieldName (fieldName))  			continue;  		var instr = instructions [i - 2];  		IField fieldRef = null;  		if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {  			var calledMethod = instr.Operand as IMethod;  			if (calledMethod == null)  				continue;  			var calledMethodDef = ourMethods.Find (calledMethod);  			if (calledMethodDef == null)  				continue;  			fieldRef = GetFieldRef (calledMethodDef.MethodDef);  			var propDef = calledMethodDef.Property;  			if (propDef == null)  				continue;  			memberInfos.Property (propDef).suggestedName = fieldName;  			fieldName = "_" + fieldName;  		} else if (instr.OpCode.Code == Code.Ldfld) {  			fieldRef = instr.Operand as IField;  		}  		if (fieldRef == null)  			continue;  		var fieldDef = ourFields.Find (fieldRef);  		if (fieldDef == null)  			continue;  		var fieldInfo = memberInfos.Field (fieldDef);  		if (fieldInfo.renamed)  			continue;  		fieldInfo.suggestedName = variableNameState.GetNewFieldName (fieldInfo.oldName' new NameCreator2 (fieldName));  	}  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitializeWindowsFormsFieldsAndProps,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  	if (methodDef.MethodDef.Body == null)  		continue;  	if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  		continue;  	var instructions = methodDef.MethodDef.Body.Instructions;  	for (int i = 2; i < instructions.Count; i++) {  		var call = instructions [i];  		if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  			continue;  		if (!IsWindowsFormsSetNameMethod (call.Operand as IMethod))  			continue;  		var ldstr = instructions [i - 1];  		if (ldstr.OpCode.Code != Code.Ldstr)  			continue;  		var fieldName = ldstr.Operand as string;  		if (fieldName == null || !checker.IsValidFieldName (fieldName))  			continue;  		var instr = instructions [i - 2];  		IField fieldRef = null;  		if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {  			var calledMethod = instr.Operand as IMethod;  			if (calledMethod == null)  				continue;  			var calledMethodDef = ourMethods.Find (calledMethod);  			if (calledMethodDef == null)  				continue;  			fieldRef = GetFieldRef (calledMethodDef.MethodDef);  			var propDef = calledMethodDef.Property;  			if (propDef == null)  				continue;  			memberInfos.Property (propDef).suggestedName = fieldName;  			fieldName = "_" + fieldName;  		} else if (instr.OpCode.Code == Code.Ldfld) {  			fieldRef = instr.Operand as IField;  		}  		if (fieldRef == null)  			continue;  		var fieldDef = ourFields.Find (fieldRef);  		if (fieldDef == null)  			continue;  		var fieldInfo = memberInfos.Field (fieldDef);  		if (fieldInfo.renamed)  			continue;  		fieldInfo.suggestedName = variableNameState.GetNewFieldName (fieldInfo.oldName' new NameCreator2 (fieldName));  	}  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitializeWindowsFormsFieldsAndProps,The following statement contains a magic number: for (int i = 2; i < instructions.Count; i++) {  	var call = instructions [i];  	if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  		continue;  	if (!IsWindowsFormsSetNameMethod (call.Operand as IMethod))  		continue;  	var ldstr = instructions [i - 1];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var fieldName = ldstr.Operand as string;  	if (fieldName == null || !checker.IsValidFieldName (fieldName))  		continue;  	var instr = instructions [i - 2];  	IField fieldRef = null;  	if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {  		var calledMethod = instr.Operand as IMethod;  		if (calledMethod == null)  			continue;  		var calledMethodDef = ourMethods.Find (calledMethod);  		if (calledMethodDef == null)  			continue;  		fieldRef = GetFieldRef (calledMethodDef.MethodDef);  		var propDef = calledMethodDef.Property;  		if (propDef == null)  			continue;  		memberInfos.Property (propDef).suggestedName = fieldName;  		fieldName = "_" + fieldName;  	} else if (instr.OpCode.Code == Code.Ldfld) {  		fieldRef = instr.Operand as IField;  	}  	if (fieldRef == null)  		continue;  	var fieldDef = ourFields.Find (fieldRef);  	if (fieldDef == null)  		continue;  	var fieldInfo = memberInfos.Field (fieldDef);  	if (fieldInfo.renamed)  		continue;  	fieldInfo.suggestedName = variableNameState.GetNewFieldName (fieldInfo.oldName' new NameCreator2 (fieldName));  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitializeWindowsFormsFieldsAndProps,The following statement contains a magic number: for (int i = 2; i < instructions.Count; i++) {  	var call = instructions [i];  	if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  		continue;  	if (!IsWindowsFormsSetNameMethod (call.Operand as IMethod))  		continue;  	var ldstr = instructions [i - 1];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var fieldName = ldstr.Operand as string;  	if (fieldName == null || !checker.IsValidFieldName (fieldName))  		continue;  	var instr = instructions [i - 2];  	IField fieldRef = null;  	if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {  		var calledMethod = instr.Operand as IMethod;  		if (calledMethod == null)  			continue;  		var calledMethodDef = ourMethods.Find (calledMethod);  		if (calledMethodDef == null)  			continue;  		fieldRef = GetFieldRef (calledMethodDef.MethodDef);  		var propDef = calledMethodDef.Property;  		if (propDef == null)  			continue;  		memberInfos.Property (propDef).suggestedName = fieldName;  		fieldName = "_" + fieldName;  	} else if (instr.OpCode.Code == Code.Ldfld) {  		fieldRef = instr.Operand as IField;  	}  	if (fieldRef == null)  		continue;  	var fieldDef = ourFields.Find (fieldRef);  	if (fieldDef == null)  		continue;  	var fieldInfo = memberInfos.Field (fieldDef);  	if (fieldInfo.renamed)  		continue;  	fieldInfo.suggestedName = variableNameState.GetNewFieldName (fieldInfo.oldName' new NameCreator2 (fieldName));  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,GetVbHandler,The following statement contains a magic number: eventName = addMethod.Name.String.Substring (4);  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,GetVbHandler,The following statement contains a magic number: if (eventName != removeMethod.Name.String.Substring (7))  	return null;  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,FindEventCall,The following statement contains a magic number: if (callvirt < 2)  	return false;  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitFieldEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  	if (methodDef.MethodDef.Body == null)  		continue;  	if (methodDef.MethodDef.IsStatic)  		continue;  	var instructions = methodDef.MethodDef.Body.Instructions;  	for (int i = 0; i < instructions.Count - 6; i++) {  		// We're looking for this code pattern:  		//	ldarg.0  		//	ldfld field  		//	ldarg.0  		//	ldftn method / ldarg.0 + ldvirtftn  		//	newobj event_handler_ctor  		//	callvirt add_SomeEvent  		if (instructions [i].GetParameterIndex () != 0)  			continue;  		int index = i + 1;  		var ldfld = instructions [index++];  		if (ldfld.OpCode.Code != Code.Ldfld)  			continue;  		var fieldRef = ldfld.Operand as IField;  		if (fieldRef == null)  			continue;  		var fieldDef = ourFields.Find (fieldRef);  		if (fieldDef == null)  			continue;  		if (instructions [index++].GetParameterIndex () != 0)  			continue;  		IMethod methodRef;  		var instr = instructions [index + 1];  		if (instr.OpCode.Code == Code.Ldvirtftn) {  			if (!IsThisOrDup (instructions [index++]))  				continue;  			var ldvirtftn = instructions [index++];  			methodRef = ldvirtftn.Operand as IMethod;  		} else {  			var ldftn = instructions [index++];  			if (ldftn.OpCode.Code != Code.Ldftn)  				continue;  			methodRef = ldftn.Operand as IMethod;  		}  		if (methodRef == null)  			continue;  		var handlerMethod = ourMethods.Find (methodRef);  		if (handlerMethod == null)  			continue;  		var newobj = instructions [index++];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		if (!IsEventHandlerCtor (newobj.Operand as IMethod))  			continue;  		var call = instructions [index++];  		if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  			continue;  		var addHandler = call.Operand as IMethod;  		if (addHandler == null)  			continue;  		if (!Utils.StartsWith (addHandler.Name.String' "add_"' StringComparison.Ordinal))  			continue;  		var eventName = addHandler.Name.String.Substring (4);  		if (!checker.IsValidEventName (eventName))  			continue;  		memberInfos.Method (handlerMethod).suggestedName = string.Format ("{0}_{1}"' memberInfos.Field (fieldDef).newName' eventName);  	}  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitFieldEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  	if (methodDef.MethodDef.Body == null)  		continue;  	if (methodDef.MethodDef.IsStatic)  		continue;  	var instructions = methodDef.MethodDef.Body.Instructions;  	for (int i = 0; i < instructions.Count - 6; i++) {  		// We're looking for this code pattern:  		//	ldarg.0  		//	ldfld field  		//	ldarg.0  		//	ldftn method / ldarg.0 + ldvirtftn  		//	newobj event_handler_ctor  		//	callvirt add_SomeEvent  		if (instructions [i].GetParameterIndex () != 0)  			continue;  		int index = i + 1;  		var ldfld = instructions [index++];  		if (ldfld.OpCode.Code != Code.Ldfld)  			continue;  		var fieldRef = ldfld.Operand as IField;  		if (fieldRef == null)  			continue;  		var fieldDef = ourFields.Find (fieldRef);  		if (fieldDef == null)  			continue;  		if (instructions [index++].GetParameterIndex () != 0)  			continue;  		IMethod methodRef;  		var instr = instructions [index + 1];  		if (instr.OpCode.Code == Code.Ldvirtftn) {  			if (!IsThisOrDup (instructions [index++]))  				continue;  			var ldvirtftn = instructions [index++];  			methodRef = ldvirtftn.Operand as IMethod;  		} else {  			var ldftn = instructions [index++];  			if (ldftn.OpCode.Code != Code.Ldftn)  				continue;  			methodRef = ldftn.Operand as IMethod;  		}  		if (methodRef == null)  			continue;  		var handlerMethod = ourMethods.Find (methodRef);  		if (handlerMethod == null)  			continue;  		var newobj = instructions [index++];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		if (!IsEventHandlerCtor (newobj.Operand as IMethod))  			continue;  		var call = instructions [index++];  		if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  			continue;  		var addHandler = call.Operand as IMethod;  		if (addHandler == null)  			continue;  		if (!Utils.StartsWith (addHandler.Name.String' "add_"' StringComparison.Ordinal))  			continue;  		var eventName = addHandler.Name.String.Substring (4);  		if (!checker.IsValidEventName (eventName))  			continue;  		memberInfos.Method (handlerMethod).suggestedName = string.Format ("{0}_{1}"' memberInfos.Field (fieldDef).newName' eventName);  	}  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitFieldEventHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count - 6; i++) {  	// We're looking for this code pattern:  	//	ldarg.0  	//	ldfld field  	//	ldarg.0  	//	ldftn method / ldarg.0 + ldvirtftn  	//	newobj event_handler_ctor  	//	callvirt add_SomeEvent  	if (instructions [i].GetParameterIndex () != 0)  		continue;  	int index = i + 1;  	var ldfld = instructions [index++];  	if (ldfld.OpCode.Code != Code.Ldfld)  		continue;  	var fieldRef = ldfld.Operand as IField;  	if (fieldRef == null)  		continue;  	var fieldDef = ourFields.Find (fieldRef);  	if (fieldDef == null)  		continue;  	if (instructions [index++].GetParameterIndex () != 0)  		continue;  	IMethod methodRef;  	var instr = instructions [index + 1];  	if (instr.OpCode.Code == Code.Ldvirtftn) {  		if (!IsThisOrDup (instructions [index++]))  			continue;  		var ldvirtftn = instructions [index++];  		methodRef = ldvirtftn.Operand as IMethod;  	} else {  		var ldftn = instructions [index++];  		if (ldftn.OpCode.Code != Code.Ldftn)  			continue;  		methodRef = ldftn.Operand as IMethod;  	}  	if (methodRef == null)  		continue;  	var handlerMethod = ourMethods.Find (methodRef);  	if (handlerMethod == null)  		continue;  	var newobj = instructions [index++];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	if (!IsEventHandlerCtor (newobj.Operand as IMethod))  		continue;  	var call = instructions [index++];  	if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  		continue;  	var addHandler = call.Operand as IMethod;  	if (addHandler == null)  		continue;  	if (!Utils.StartsWith (addHandler.Name.String' "add_"' StringComparison.Ordinal))  		continue;  	var eventName = addHandler.Name.String.Substring (4);  	if (!checker.IsValidEventName (eventName))  		continue;  	memberInfos.Method (handlerMethod).suggestedName = string.Format ("{0}_{1}"' memberInfos.Field (fieldDef).newName' eventName);  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitFieldEventHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count - 6; i++) {  	// We're looking for this code pattern:  	//	ldarg.0  	//	ldfld field  	//	ldarg.0  	//	ldftn method / ldarg.0 + ldvirtftn  	//	newobj event_handler_ctor  	//	callvirt add_SomeEvent  	if (instructions [i].GetParameterIndex () != 0)  		continue;  	int index = i + 1;  	var ldfld = instructions [index++];  	if (ldfld.OpCode.Code != Code.Ldfld)  		continue;  	var fieldRef = ldfld.Operand as IField;  	if (fieldRef == null)  		continue;  	var fieldDef = ourFields.Find (fieldRef);  	if (fieldDef == null)  		continue;  	if (instructions [index++].GetParameterIndex () != 0)  		continue;  	IMethod methodRef;  	var instr = instructions [index + 1];  	if (instr.OpCode.Code == Code.Ldvirtftn) {  		if (!IsThisOrDup (instructions [index++]))  			continue;  		var ldvirtftn = instructions [index++];  		methodRef = ldvirtftn.Operand as IMethod;  	} else {  		var ldftn = instructions [index++];  		if (ldftn.OpCode.Code != Code.Ldftn)  			continue;  		methodRef = ldftn.Operand as IMethod;  	}  	if (methodRef == null)  		continue;  	var handlerMethod = ourMethods.Find (methodRef);  	if (handlerMethod == null)  		continue;  	var newobj = instructions [index++];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	if (!IsEventHandlerCtor (newobj.Operand as IMethod))  		continue;  	var call = instructions [index++];  	if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  		continue;  	var addHandler = call.Operand as IMethod;  	if (addHandler == null)  		continue;  	if (!Utils.StartsWith (addHandler.Name.String' "add_"' StringComparison.Ordinal))  		continue;  	var eventName = addHandler.Name.String.Substring (4);  	if (!checker.IsValidEventName (eventName))  		continue;  	memberInfos.Method (handlerMethod).suggestedName = string.Format ("{0}_{1}"' memberInfos.Field (fieldDef).newName' eventName);  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitTypeEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  	if (methodDef.MethodDef.Body == null)  		continue;  	if (methodDef.MethodDef.IsStatic)  		continue;  	var method = methodDef.MethodDef;  	var instructions = method.Body.Instructions;  	for (int i = 0; i < instructions.Count - 5; i++) {  		// ldarg.0  		// ldarg.0 / dup  		// ldarg.0 / dup  		// ldvirtftn handler  		// newobj event handler ctor  		// call add_Xyz  		if (instructions [i].GetParameterIndex () != 0)  			continue;  		int index = i + 1;  		if (!IsThisOrDup (instructions [index++]))  			continue;  		IMethod handler;  		if (instructions [index].OpCode.Code == Code.Ldftn) {  			handler = instructions [index++].Operand as IMethod;  		} else {  			if (!IsThisOrDup (instructions [index++]))  				continue;  			var instr = instructions [index++];  			if (instr.OpCode.Code != Code.Ldvirtftn)  				continue;  			handler = instr.Operand as IMethod;  		}  		if (handler == null)  			continue;  		var handlerDef = ourMethods.Find (handler);  		if (handlerDef == null)  			continue;  		var newobj = instructions [index++];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		if (!IsEventHandlerCtor (newobj.Operand as IMethod))  			continue;  		var call = instructions [index++];  		if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  			continue;  		var addMethod = call.Operand as IMethod;  		if (addMethod == null)  			continue;  		if (!Utils.StartsWith (addMethod.Name.String' "add_"' StringComparison.Ordinal))  			continue;  		var eventName = addMethod.Name.String.Substring (4);  		if (!checker.IsValidEventName (eventName))  			continue;  		memberInfos.Method (handlerDef).suggestedName = string.Format ("{0}_{1}"' newName' eventName);  	}  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitTypeEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  	if (methodDef.MethodDef.Body == null)  		continue;  	if (methodDef.MethodDef.IsStatic)  		continue;  	var method = methodDef.MethodDef;  	var instructions = method.Body.Instructions;  	for (int i = 0; i < instructions.Count - 5; i++) {  		// ldarg.0  		// ldarg.0 / dup  		// ldarg.0 / dup  		// ldvirtftn handler  		// newobj event handler ctor  		// call add_Xyz  		if (instructions [i].GetParameterIndex () != 0)  			continue;  		int index = i + 1;  		if (!IsThisOrDup (instructions [index++]))  			continue;  		IMethod handler;  		if (instructions [index].OpCode.Code == Code.Ldftn) {  			handler = instructions [index++].Operand as IMethod;  		} else {  			if (!IsThisOrDup (instructions [index++]))  				continue;  			var instr = instructions [index++];  			if (instr.OpCode.Code != Code.Ldvirtftn)  				continue;  			handler = instr.Operand as IMethod;  		}  		if (handler == null)  			continue;  		var handlerDef = ourMethods.Find (handler);  		if (handlerDef == null)  			continue;  		var newobj = instructions [index++];  		if (newobj.OpCode.Code != Code.Newobj)  			continue;  		if (!IsEventHandlerCtor (newobj.Operand as IMethod))  			continue;  		var call = instructions [index++];  		if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  			continue;  		var addMethod = call.Operand as IMethod;  		if (addMethod == null)  			continue;  		if (!Utils.StartsWith (addMethod.Name.String' "add_"' StringComparison.Ordinal))  			continue;  		var eventName = addMethod.Name.String.Substring (4);  		if (!checker.IsValidEventName (eventName))  			continue;  		memberInfos.Method (handlerDef).suggestedName = string.Format ("{0}_{1}"' newName' eventName);  	}  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitTypeEventHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count - 5; i++) {  	// ldarg.0  	// ldarg.0 / dup  	// ldarg.0 / dup  	// ldvirtftn handler  	// newobj event handler ctor  	// call add_Xyz  	if (instructions [i].GetParameterIndex () != 0)  		continue;  	int index = i + 1;  	if (!IsThisOrDup (instructions [index++]))  		continue;  	IMethod handler;  	if (instructions [index].OpCode.Code == Code.Ldftn) {  		handler = instructions [index++].Operand as IMethod;  	} else {  		if (!IsThisOrDup (instructions [index++]))  			continue;  		var instr = instructions [index++];  		if (instr.OpCode.Code != Code.Ldvirtftn)  			continue;  		handler = instr.Operand as IMethod;  	}  	if (handler == null)  		continue;  	var handlerDef = ourMethods.Find (handler);  	if (handlerDef == null)  		continue;  	var newobj = instructions [index++];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	if (!IsEventHandlerCtor (newobj.Operand as IMethod))  		continue;  	var call = instructions [index++];  	if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  		continue;  	var addMethod = call.Operand as IMethod;  	if (addMethod == null)  		continue;  	if (!Utils.StartsWith (addMethod.Name.String' "add_"' StringComparison.Ordinal))  		continue;  	var eventName = addMethod.Name.String.Substring (4);  	if (!checker.IsValidEventName (eventName))  		continue;  	memberInfos.Method (handlerDef).suggestedName = string.Format ("{0}_{1}"' newName' eventName);  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,InitTypeEventHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count - 5; i++) {  	// ldarg.0  	// ldarg.0 / dup  	// ldarg.0 / dup  	// ldvirtftn handler  	// newobj event handler ctor  	// call add_Xyz  	if (instructions [i].GetParameterIndex () != 0)  		continue;  	int index = i + 1;  	if (!IsThisOrDup (instructions [index++]))  		continue;  	IMethod handler;  	if (instructions [index].OpCode.Code == Code.Ldftn) {  		handler = instructions [index++].Operand as IMethod;  	} else {  		if (!IsThisOrDup (instructions [index++]))  			continue;  		var instr = instructions [index++];  		if (instr.OpCode.Code != Code.Ldvirtftn)  			continue;  		handler = instr.Operand as IMethod;  	}  	if (handler == null)  		continue;  	var handlerDef = ourMethods.Find (handler);  	if (handlerDef == null)  		continue;  	var newobj = instructions [index++];  	if (newobj.OpCode.Code != Code.Newobj)  		continue;  	if (!IsEventHandlerCtor (newobj.Operand as IMethod))  		continue;  	var call = instructions [index++];  	if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  		continue;  	var addMethod = call.Operand as IMethod;  	if (addMethod == null)  		continue;  	if (!Utils.StartsWith (addMethod.Name.String' "add_"' StringComparison.Ordinal))  		continue;  	var eventName = addMethod.Name.String.Substring (4);  	if (!checker.IsValidEventName (eventName))  		continue;  	memberInfos.Method (handlerDef).suggestedName = string.Format ("{0}_{1}"' newName' eventName);  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,FindWindowsFormsClassName,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  	if (methodDef.MethodDef.Body == null)  		continue;  	if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  		continue;  	var instructions = methodDef.MethodDef.Body.Instructions;  	for (int i = 2; i < instructions.Count; i++) {  		var call = instructions [i];  		if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  			continue;  		if (!IsWindowsFormsSetNameMethod (call.Operand as IMethod))  			continue;  		var ldstr = instructions [i - 1];  		if (ldstr.OpCode.Code != Code.Ldstr)  			continue;  		var className = ldstr.Operand as string;  		if (className == null)  			continue;  		if (instructions [i - 2].GetParameterIndex () != 0)  			continue;  		FindInitializeComponentMethod (type' methodDef);  		return className;  	}  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,FindWindowsFormsClassName,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  	if (methodDef.MethodDef.Body == null)  		continue;  	if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  		continue;  	var instructions = methodDef.MethodDef.Body.Instructions;  	for (int i = 2; i < instructions.Count; i++) {  		var call = instructions [i];  		if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  			continue;  		if (!IsWindowsFormsSetNameMethod (call.Operand as IMethod))  			continue;  		var ldstr = instructions [i - 1];  		if (ldstr.OpCode.Code != Code.Ldstr)  			continue;  		var className = ldstr.Operand as string;  		if (className == null)  			continue;  		if (instructions [i - 2].GetParameterIndex () != 0)  			continue;  		FindInitializeComponentMethod (type' methodDef);  		return className;  	}  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,FindWindowsFormsClassName,The following statement contains a magic number: for (int i = 2; i < instructions.Count; i++) {  	var call = instructions [i];  	if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  		continue;  	if (!IsWindowsFormsSetNameMethod (call.Operand as IMethod))  		continue;  	var ldstr = instructions [i - 1];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var className = ldstr.Operand as string;  	if (className == null)  		continue;  	if (instructions [i - 2].GetParameterIndex () != 0)  		continue;  	FindInitializeComponentMethod (type' methodDef);  	return className;  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,FindWindowsFormsClassName,The following statement contains a magic number: for (int i = 2; i < instructions.Count; i++) {  	var call = instructions [i];  	if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  		continue;  	if (!IsWindowsFormsSetNameMethod (call.Operand as IMethod))  		continue;  	var ldstr = instructions [i - 1];  	if (ldstr.OpCode.Code != Code.Ldstr)  		continue;  	var className = ldstr.Operand as string;  	if (className == null)  		continue;  	if (instructions [i - 2].GetParameterIndex () != 0)  		continue;  	FindInitializeComponentMethod (type' methodDef);  	return className;  }  
Magic Number,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,FindWindowsFormsClassName,The following statement contains a magic number: if (instructions [i - 2].GetParameterIndex () != 0)  	continue;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (count > 0) {  	// We can defer the modulo operation:  	// s1 maximally grows from 65521 to 65521 + 255 * 3800  	// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  	int n = 3800;  	if (n > count) {  		n = count;  	}  	count -= n;  	while (--n >= 0) {  		s1 = s1 + (uint)(buffer [offset++] & 0xff);  		s2 = s2 + s1;  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  	throw new SharpZipBaseException ("Header checksum illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (DEFLATED << 8)) {  	throw new SharpZipBaseException ("Compression Method unknown");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) {  	// Dictionary flag?  	mode = DECODE_BLOCKS;  } else {  	mode = DECODE_DICT;  	neededBits = 32;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: neededBits = 32;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: input.DropBits (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: readAdler = (readAdler << 8) | dictByte;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: neededBits -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			} else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			} else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			} else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			} else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			} else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		} else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		} else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		} else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		} else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  	outputWindow.Write (symbol);  	if (--free < 258) {  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (--free < 258) {  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (symbol < 257) {  	if (symbol < 0) {  		return false;  	} else {  		// symbol == 256: end of block  		distTree = null;  		litlenTree = null;  		mode = DECODE_BLOCKS;  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  } catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  } catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: repLength = CPLENS [symbol - 257];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: neededBits = CPLEXT [symbol - 257];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: input.DropBits (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: readAdler = (readAdler << 8) | chkByte;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: neededBits -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		} else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int blockType;  	if (!ReadHeader (ref isLastBlock' out blockType)) {  		return false;  	}  	switch (blockType) {  	case STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + blockType);  	}  	return true;  case DECODE_STORED_LEN1:  	if (!DecodeStoredLength ()) {  		return false;  	}  	mode = DECODE_STORED;  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (isLastBlock) {  	if (noHeader) {  		mode = FINISHED;  		return false;  	} else {  		input.SkipToByteBoundary ();  		neededBits = 32;  		mode = DECODE_CHKSUM;  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (noHeader) {  	mode = FINISHED;  	return false;  } else {  	input.SkipToByteBoundary ();  	neededBits = 32;  	mode = DECODE_CHKSUM;  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: neededBits = 32;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,ReadHeader,The following statement contains a magic number: input.DropBits (3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: if ((uncomprLen = input.PeekBits (16)) < 0) {  	return false;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum = input.PeekBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum += 257;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: dnum = input.PeekBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum = input.PeekBits (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blLens = new byte[19];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  	/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  	litdistLens [ptr++] = lastLen = (byte)symbol;  	if (ptr == num) {  		/* Finished */return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: if (symbol >= 17) {  	/* repeat zero *///  		  System.err.println("repeating zero");  	lastLen = 0;  } else {  	if (ptr == 0) {  		throw new SharpZipBaseException ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: repSymbol = symbol - 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 9;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths = new byte[32];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 5;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code += blCount [bits] << (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treeSize += (end - start) >> (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code -= blCount [bits] << (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: i += 1 << 7
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [BitReverse (i)] = (short)((-treePtr << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treePtr += 1 << (bits - 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  } while (revcode < 512);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  } while (revcode < 512);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [revcode] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: subTree = -(subTree >> 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  } while (revcode < treeLen);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  } while (revcode < treeLen);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: nextCode [bits] = code + (1 << (16 - bits));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  	if (windowStart_ == windowEnd_) {  		return -1;  		// ok  	}  	buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  	bitsInBuffer_ += 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  	if (windowStart_ == windowEnd_) {  		return -1;  		// ok  	}  	buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  	bitsInBuffer_ += 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: bitsInBuffer_ += 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0) {  	// bits_in_buffer may only be 0 or a multiple of 8  	throw new InvalidOperationException ("Bit buffer is not byte aligned!");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  	output [offset++] = (byte)buffer_;  	buffer_ >>= 8;  	bitsInBuffer_ -= 8;  	length--;  	count++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  	output [offset++] = (byte)buffer_;  	buffer_ >>= 8;  	bitsInBuffer_ -= 8;  	length--;  	count++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: buffer_ >>= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0) {  	// We always want an even number of bytes in input' see peekBits  	buffer_ = (uint)(window_ [windowStart_++] & 0xff);  	bitsInBuffer_ = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0) {  	// We always want an even number of bytes in input' see PeekBits  	buffer_ |= (uint)((buffer [offset++] & 0xff) << bitsInBuffer_);  	bitsInBuffer_ += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: bitsInBuffer_ += 8;  
Missing Default,de4dot.code,MethodPrinter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodPrinter.cs,InitTargets,The following switch statement is missing a default case: switch (instr.OpCode.OperandType) {  case OperandType.ShortInlineBrTarget:  case OperandType.InlineBrTarget:  	SetTarget (instr.Operand as Instruction);  	break;  case OperandType.InlineSwitch:  	foreach (var targetInstr in (Instruction[])instr.Operand)  		SetTarget (targetInstr);  	break;  }  
Missing Default,de4dot.code,MethodReturnValueInliner,F:\newReposMay17\0xd4d_de4dot\de4dot.code\MethodReturnValueInliner.cs,FixIntArg,The following switch statement is missing a default case: switch (type.ElementType) {  case ElementType.Boolean:  	return value != 0;  case ElementType.Char:  	return (char)value;  case ElementType.I1:  	return (sbyte)value;  case ElementType.U1:  	return (byte)value;  case ElementType.I2:  	return (short)value;  case ElementType.U2:  	return (ushort)value;  case ElementType.I4:  	return (int)value;  case ElementType.U4:  	return (uint)value;  case ElementType.I8:  	return (long)value;  case ElementType.U8:  	return (ulong)value;  }  
Missing Default,de4dot.code.deobfuscators,ArrayFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,GetInitializedArray,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  case Code.Newarr:  case Code.Newobj:  	goto done;  case Code.Stloc:  case Code.Stloc_S:  case Code.Stloc_0:  case Code.Stloc_1:  case Code.Stloc_2:  case Code.Stloc_3:  case Code.Starg:  case Code.Starg_S:  case Code.Stsfld:  case Code.Stfld:  	if (emulator.Peek () == theArray && i != newarrIndex + 1 && i != newarrIndex + 2)  		goto done;  	break;  }  
Missing Default,de4dot.code.deobfuscators,ExceptionLoggerRemover,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\ExceptionLoggerRemover.cs,Find,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  case Code.Call:  case Code.Calli:  case Code.Callvirt:  	calls++;  	callInstr = instr;  	break;  }  
Missing Default,de4dot.code.deobfuscators,InlinedMethodsFinder,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,IsCallMethod,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  case Code.Ldarg:  case Code.Ldarg_S:  case Code.Ldarg_0:  case Code.Ldarg_1:  case Code.Ldarg_2:  case Code.Ldarg_3:  case Code.Ldarga:  case Code.Ldarga_S:  	if (instr.GetParameterIndex () != loadIndex)  		return false;  	loadIndex++;  	continue;  }  
Missing Default,de4dot.code.deobfuscators,RandomNameChecker,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,HasVowel,The following switch statement is missing a default case: switch (c) {  case 'A':  case 'a':  case 'E':  case 'e':  case 'I':  case 'i':  case 'O':  case 'o':  case 'U':  case 'u':  case 'Y':  case 'y':  	return true;  }  
Missing Default,de4dot.code.deobfuscators.CodeWall,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,DetectVersion,The following switch statement is missing a default case: switch (stringDecrypter.TheVersion) {  case StringDecrypter.Version.V30:  	return "v3.0 - v3.5";  case StringDecrypter.Version.V36:  	return "v3.6 - v4.1";  }  
Missing Default,de4dot.code.deobfuscators.Confuser,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Confuser\ProxyCallFixer.cs,GetProxyCreatorTypeV1,The following switch statement is missing a default case: switch (field.FullName) {  case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Call":  case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Callvirt":  	return ProxyCreatorType.CallOrCallvirt;  case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Newobj":  	return ProxyCreatorType.Newobj;  }  
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,GetProxyCreatorType,The following switch statement is missing a default case: switch (field.FullName) {  case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Call":  	numCalls++;  	break;  case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Callvirt":  	numCallvirts++;  	break;  case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Newobj":  	numNewobjs++;  	break;  }  
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,Find,The following switch statement is missing a default case: switch (frameworkType) {  case FrameworkType.Silverlight:  	FindSilverlight ();  	break;  case FrameworkType.Desktop:  case FrameworkType.CompactFramework:  	if (!module.IsClr1x) {  		if (FindDesktopOrCompactFramework ())  			break;  	}  	FindDesktopOrCompactFrameworkV1 ();  	break;  }  
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,UpdateFlags,The following switch statement is missing a default case: switch (frameworkType) {  case FrameworkType.Desktop:  	if (!module.IsClr1x) {  		if (constants.Count == 2) {  			desEncryptedFlag = (byte)constants [0];  			deflatedFlag = (byte)constants [1];  			return true;  		}  	}  	if (constants.Count == 1) {  		desEncryptedFlag = (byte)constants [0];  		return true;  	}  	break;  case FrameworkType.Silverlight:  	if (constants.Count == 1) {  		bitwiseNotEncryptedFlag = (byte)constants [0];  		return true;  	}  	break;  case FrameworkType.CompactFramework:  	if (constants.Count == 1) {  		desEncryptedFlag = (byte)constants [0];  		return true;  	}  	break;  }  
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,Find,The following switch statement is missing a default case: switch (frameworkType) {  case FrameworkType.Desktop:  	result = FindDesktop (method);  	break;  case FrameworkType.Silverlight:  	result = FindSilverlight (method);  	break;  case FrameworkType.CompactFramework:  	result = FindCompactFramework (method);  	break;  }  
Missing Default,de4dot.code.deobfuscators.DeepSea,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,DetectVersion,The following switch statement is missing a default case: switch (stringDecrypter.Version) {  case StringDecrypter.DecrypterVersion.V1_3:  	if (DetectMethodProxyObfuscation ())  		return DeobfuscatorInfo.THE_NAME + " 3.5";  	return DeobfuscatorInfo.THE_NAME + " 1.x-3.x";  case StringDecrypter.DecrypterVersion.V4_0:  	return DeobfuscatorInfo.THE_NAME + " 4.0";  case StringDecrypter.DecrypterVersion.V4_1:  	return DeobfuscatorInfo.THE_NAME + " 4.1";  }  
Missing Default,de4dot.code.deobfuscators.DeepSea,StringDecrypter,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,CheckFields,The following switch statement is missing a default case: switch (field.FieldSig.GetFieldType ().GetFullName ()) {  case "System.Char[]":  	foundCharAry = true;  	break;  case "System.String[]":  	foundStringAry = true;  	break;  }  
Missing Default,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,UpdateModuleRefs,The following switch statement is missing a default case: switch (method.ImplMap.Name.String) {  case "nr_nli":  case "nr_startup":  	moduleRefs.Add (method.ImplMap.Module);  	break;  }  
Missing Default,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following switch statement is missing a default case: switch (numIntPtrSizeCompares) {  case 7:  case 9:  	return DeobfuscatorInfo.THE_NAME + " 4.5";  case 10:  	if (!hasSymmetricAlgorithm)  		return DeobfuscatorInfo.THE_NAME + " 4.6";  	if (hasCatchString)  		return DeobfuscatorInfo.THE_NAME + " 4.7";  	return DeobfuscatorInfo.THE_NAME + " 4.8";  }  
Missing Default,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,DetectVersion,The following switch statement is missing a default case: switch (numIntPtrSizeCompares) {  case 6:  case 8:  	return DeobfuscatorInfo.THE_NAME + " 4.5";  case 9:  	if (!hasSymmetricAlgorithm)  		return DeobfuscatorInfo.THE_NAME + " 4.6";  	if (hasCatchString)  		return DeobfuscatorInfo.THE_NAME + " 4.7";  	return DeobfuscatorInfo.THE_NAME + " 4.8";  }  
Missing Default,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,OnWriterEvent,The following switch statement is missing a default case: switch (evt) {  case ModuleWriterEvent.Begin:  	// The decrypter assumes RVAs are unique so don't share any method bodies  	writer.TheOptions.ShareMethodBodies = false;  	break;  case ModuleWriterEvent.MDBeginAddResources:  	methodsDecrypter.PrepareEncryptNativeMethods (writer);  	break;  case ModuleWriterEvent.BeginWriteChunks:  	methodsDecrypter.EncryptNativeMethods (writer);  	break;  }  
Missing Default,de4dot.code.deobfuscators.Eazfuscator_NET,EfUtils,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\EfUtils.cs,GetNextStore,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  case Code.Starg:  case Code.Starg_S:  case Code.Stelem:  case Code.Stelem_I:  case Code.Stelem_I1:  case Code.Stelem_I2:  case Code.Stelem_I4:  case Code.Stelem_I8:  case Code.Stelem_R4:  case Code.Stelem_R8:  case Code.Stelem_Ref:  case Code.Stfld:  case Code.Stind_I:  case Code.Stind_I1:  case Code.Stind_I2:  case Code.Stind_I4:  case Code.Stind_I8:  case Code.Stind_R4:  case Code.Stind_R8:  case Code.Stind_Ref:  case Code.Stloc:  case Code.Stloc_0:  case Code.Stloc_1:  case Code.Stloc_2:  case Code.Stloc_3:  case Code.Stloc_S:  case Code.Stobj:  case Code.Stsfld:  	return instr;  }  
Missing Default,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,CreateLocalsArray,The following switch statement is missing a default case: switch (frameworkType) {  case FrameworkType.CompactFramework:  	removeLocals = removeLocals_cf;  	break;  }  
Missing Default,de4dot.code.deobfuscators.MPRESS,Lzmat,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,Decompress,The following switch statement is missing a default case: switch (r_cnt & 3) {  case 0:  	dist = (dist & LZMAT_DIST_MSK0) + 1;  	break;  case 1:  	inPos += cur_nib;  	dist = (dist & LZMAT_DIST_MSK1) + 0x41;  	cur_nib ^= 1;  	break;  case 2:  	inPos++;  	dist += 0x441;  	break;  case 3:  	if ((inPos + 2 + cur_nib) > cbIn)  		return LzmatStatus.INTEGRITY_FAILURE + 1;  	inPos++;  	dist = (dist + ((uint)LZMAT_GET_U4 (pbIn' ref inPos' ref cur_nib) << 14)) + 0x4441;  	break;  }  
Missing Default,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,FindSpicesAttributes,The following switch statement is missing a default case: switch (type.FullName) {  case "NineRays.Decompiler.NotDecompile":  case "NineRays.Obfuscator.Evaluation":  case "NineRays.Obfuscator.SoftwareWatermarkAttribute":  	AddAttributeToBeRemoved (type' "Obfuscator attribute");  	foundSpicesAttribute = true;  	break;  }  
Missing Default,de4dot.code.deobfuscators.Xenocode,Deobfuscator,F:\newReposMay17\0xd4d_de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,FindXenocodeAttribute,The following switch statement is missing a default case: switch (type.FullName) {  case "Xenocode.Client.Attributes.AssemblyAttributes.ProcessedByXenocode":  case "Xenocode.Client.Attributes.AssemblyAttributes.SuppressDisassembly":  case "Xenocode.User.Attributes.AssemblyAttributes.ProcessedByXenoCode":  case "Xenocode.User.Attributes.AssemblyAttributes.SuppressDisassembly":  	AddAttributeToBeRemoved (type' "Obfuscator attribute");  	foundXenocodeAttribute = true;  	break;  }  
Missing Default,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,CreateEvent,The following switch statement is missing a default case: switch (methodType) {  case EventMethodType.Adder:  	CreateEventAdder (newEventName' methodDef);  	break;  case EventMethodType.Remover:  	CreateEventRemover (newEventName' methodDef);  	break;  }  
Missing Default,de4dot.code.renamer,Renamer,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\Renamer.cs,PrepareRenameVirtualMethods,The following switch statement is missing a default case: switch (group.Methods [0].MethodDef.Name.String) {  case "Invoke":  case "BeginInvoke":  case "EndInvoke":  	return;  }  
Missing Default,de4dot.code.renamer,TypeInfo,F:\newReposMay17\0xd4d_de4dot\de4dot.code\renamer\TypeInfo.cs,CanRenameMethod,The following switch statement is missing a default case: switch (methodInfo.oldName) {  case "BeginInvoke":  case "EndInvoke":  case "Invoke":  	return false;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,F:\newReposMay17\0xd4d_de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
