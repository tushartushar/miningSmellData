Implementation smell,Namespace,Class,File,Method,Description
Long Method,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetEffectCategories,The method has 162 lines of code.
Long Method,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The method has 118 lines of code.
Long Method,BiM.Behaviors.Game.Stats,PlayerStats,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Stats\PlayerStats.cs,PlayerStats,The method has 240 lines of code.
Long Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The method has 227 lines of code.
Long Method,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The method has 107 lines of code.
Complex Method,BiM.Behaviors.Data.D2O,XmlDumper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\D2O\XmlDumper.cs,SpellsDumper,Cyclomatic complexity of the method is 8
Complex Method,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,Update,Cyclomatic complexity of the method is 30
Complex Method,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,Cyclomatic complexity of the method is 8
Complex Method,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,GetBoostableStatPoints,Cyclomatic complexity of the method is 8
Complex Method,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,CheckCriteria,Cyclomatic complexity of the method is 24
Complex Method,BiM.Behaviors.Game.Breeds,Breed,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Breeds\Breed.cs,GetThresholds,Cyclomatic complexity of the method is 8
Complex Method,BiM.Behaviors.Game.Fights,FightTeam,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\FightTeam.cs,Update,Cyclomatic complexity of the method is 15
Complex Method,BiM.Behaviors.Game.Fights,TimeLine,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\TimeLine.cs,RefreshTimeLine,Cyclomatic complexity of the method is 8
Complex Method,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,AllSkills,Cyclomatic complexity of the method is 9
Complex Method,BiM.Behaviors.Game.Spells.Shapes,Cone,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Cone.cs,GetCells,Cyclomatic complexity of the method is 18
Complex Method,BiM.Behaviors.Game.Spells.Shapes,Cross,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Cross.cs,GetCells,Cyclomatic complexity of the method is 26
Complex Method,BiM.Behaviors.Game.Spells.Shapes,HalfLozenge,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\HalfLozenge.cs,GetCells,Cyclomatic complexity of the method is 18
Complex Method,BiM.Behaviors.Game.Spells.Shapes,Line,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Line.cs,GetCells,Cyclomatic complexity of the method is 25
Complex Method,BiM.Behaviors.Game.Spells.Shapes,Zone,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Zone.cs,InitializeShape,Cyclomatic complexity of the method is 54
Complex Method,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetEffectCategories,Cyclomatic complexity of the method is 140
Complex Method,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,Cyclomatic complexity of the method is 27
Complex Method,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,Cyclomatic complexity of the method is 36
Complex Method,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,Cyclomatic complexity of the method is 10
Complex Method,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,Cyclomatic complexity of the method is 19
Complex Method,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,OrientationToAdjacent,Cyclomatic complexity of the method is 9
Complex Method,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,GetCellInDirection,Cyclomatic complexity of the method is 18
Complex Method,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,GetAdjacentCells,Cyclomatic complexity of the method is 10
Complex Method,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,GetAllCellsInRange,Cyclomatic complexity of the method is 8
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,CellInfo,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\CellInfo.cs,getValue,Cyclomatic complexity of the method is 11
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,ClearLogic,Cyclomatic complexity of the method is 13
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,Cyclomatic complexity of the method is 45
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,ValidMoves,Cyclomatic complexity of the method is 10
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindCellsAround,Cyclomatic complexity of the method is 10
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindCellsInLine,Cyclomatic complexity of the method is 10
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindFishingSpot,Cyclomatic complexity of the method is 9
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,Neighbours,Cyclomatic complexity of the method is 11
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,SubMapProcessor,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\SubMapProcessor.cs,ValidMoves,Cyclomatic complexity of the method is 10
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldPathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldPathFinder.cs,FindPath,Cyclomatic complexity of the method is 19
Complex Method,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldPoint,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldPoint.cs,Move,Cyclomatic complexity of the method is 12
Complex Method,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,Cyclomatic complexity of the method is 23
Complex Method,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,Cyclomatic complexity of the method is 9
Long Parameter List,BiM.Behaviors.Game.Actors.Fighters,PlayedFighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\PlayedFighter.AI.cs,Move,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,MoveIfNeededThenAction,The method has 6 parameters.
Long Parameter List,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,Move,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,Move,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.Effects,EffectBase,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectBase.AI.cs,EffectBase,The method has 12 parameters.
Long Parameter List,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,EffectDate,The method has 7 parameters.
Long Parameter List,BiM.Behaviors.Game.Effects,EffectDice,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDice.cs,EffectDice,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.Effects,EffectDuration,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDuration.cs,EffectDuration,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.Effects,EffectMount,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMount.cs,EffectMount,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.Movements,TimedPath,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Movements\TimedPath.cs,Create,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.Movements,TimedPathElement,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Movements\TimedPathElement.cs,TimedPathElement,The method has 6 parameters.
Long Parameter List,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The method has 10 parameters.
Long Parameter List,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The method has 6 parameters.
Long Parameter List,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.World,MapContext,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapContext.cs,TooCloseFromSegment,The method has 6 parameters.
Long Parameter List,BiM.Behaviors.Game.World.MapTraveling,SubMapBinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\SubMapBinder.cs,SubMapBinder,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindConnectedCells,The method has 6 parameters.
Long Parameter List,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The method has 5 parameters.
Long Parameter List,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The method has 6 parameters.
Long Parameter List,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The method has 6 parameters.
Long Parameter List,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The method has 6 parameters.
Long Parameter List,BiM.Behaviors.Game.World.Pathfinding,IAdvancedPathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\IAdvancedPathFinder.cs,FindPath,The method has 6 parameters.
Long Parameter List,BiM.Behaviors.Game.World.Pathfinding,IAdvancedPathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\IAdvancedPathFinder.cs,FindPath,The method has 6 parameters.
Long Parameter List,BiM.Behaviors.Game.World.Pathfinding,IAdvancedPathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\IAdvancedPathFinder.cs,FindPath,The method has 6 parameters.
Long Identifier,BiM.Behaviors.Game.Actors.RolePlay,Mutant,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\Mutant.cs,Mutant,The length of the parameter gameRolePlayMutantInformations is 30.
Long Identifier,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,AddEffect,The length of the parameter abstractFightDispellableEffect is 30.
Long Statement,BiM.Behaviors.Authentification,ClientInformations,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Authentification\ClientInformations.cs,IsClientUpToDate,The length of the statement  "	return RequieredVersion == null || (Version != null && RequieredVersion.major == Version.major && RequieredVersion.minor == Version.minor && RequieredVersion.release == Version.release && RequieredVersion.revision == Version.revision && RequieredVersion.patch == Version.patch); " is 278.
Long Statement,BiM.Behaviors.Authentification,ClientInformations,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Authentification\ClientInformations.cs,Update,The length of the statement  "	VisibleBreeds = Enum.GetValues (typeof(PlayableBreedEnum)).Cast<PlayableBreedEnum> ().Where (entry => ((msg.breedsVisible >> (int)entry - 1) & 1) == 1).ToArray (); " is 163.
Long Statement,BiM.Behaviors.Authentification,ClientInformations,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Authentification\ClientInformations.cs,Update,The length of the statement  "	AvailableBreeds = Enum.GetValues (typeof(PlayableBreedEnum)).Cast<PlayableBreedEnum> ().Where (entry => ((msg.breedsAvailable >> (int)entry - 1) & 1) == 1).ToArray (); " is 167.
Long Statement,BiM.Behaviors,Bot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Bot.cs,Send,The length of the statement  "		logger.Warn ("Warning' enqueue {0} but the bot is stopped' the message will be processed once the bot {1} restart"' message' this); " is 131.
Long Statement,BiM.Behaviors,Bot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Bot.cs,SendLocal,The length of the statement  "		logger.Warn ("Warning' enqueue {0} but the bot is stopped' the message will be processed once the bot {1} restart"' message' this); " is 131.
Long Statement,BiM.Behaviors.Data.D2O,XmlDumper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\D2O\XmlDumper.cs,cleanXML,The length of the statement  "			string result = new StringBuilder (contents).Replace (" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""' "").Replace (" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\""' "").ToString (); " is 194.
Long Statement,BiM.Behaviors.Data.D2O,XmlDumper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\D2O\XmlDumper.cs,cleanXML,The length of the statement  "			result = Regex.Replace (Regex.Replace (Regex.Replace (Regex.Replace (result' pattern1' match => "<description>" + I18NDataManager.Instance.ReadText (int.Parse (match.Groups [1].Value)) + "</description>")' pattern7' match => "<longName>" + I18NDataManager.Instance.ReadText (int.Parse (match.Groups [1].Value)) + "</longName>")' pattern8' match => "<shortName>" + I18NDataManager.Instance.ReadText (int.Parse (match.Groups [1].Value)) + "</shortName>")' pattern2' match => "<name>" + I18NDataManager.Instance.ReadText (int.Parse (match.Groups [1].Value)) + "</name>"); " is 568.
Long Statement,BiM.Behaviors.Data.D2O,XmlDumper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\D2O\XmlDumper.cs,cleanXML,The length of the statement  "				result = Regex.Replace (Regex.Replace (Regex.Replace (Regex.Replace (result' pattern3' "")' pattern4' match => "<targetId>" + ((SpellTargetType)int.Parse (match.Groups [1].Value)).ToString () + "</targetId>")' pattern5' match => "<rawZone>" + string.Format ("{0} ({1} cells)"' match.Groups [1].Value' new Zone (match.Groups [1].Value).Surface) + "</rawZone>")' pattern6' match => { " is 381.
Long Statement,BiM.Behaviors.Data.D2O,XmlDumper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\D2O\XmlDumper.cs,cleanXML,The length of the statement  "					return "<effectId>" + ((EffectsEnum)effectId).ToString () + "</effectId>" + " <description>" + I18NDataManager.Instance.ReadText (template.descriptionId) + "</description>"; " is 173.
Long Statement,BiM.Behaviors.Data.D2O,XmlDumper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\D2O\XmlDumper.cs,SimpleDumper,The length of the statement  "		// asm.GetTypes().Where(entry => entry.Namespace != null && entry.GetConstructor(System.Type.EmptyTypes) != null && entry.Namespace.StartsWith("BiM.Protocol.Data")).ToArray<Type>(); " is 181.
Long Statement,BiM.Behaviors.Data.D2O,XmlDumper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\D2O\XmlDumper.cs,SpellsDumper,The length of the statement  "	foreach (SpellType type in ObjectDataManager.Instance.EnumerateObjects<SpellType> ())//foreach (BreedEnum breed in Enum.GetValues(typeof(BreedEnum))) " is 149.
Long Statement,BiM.Behaviors.Data.D2O,XmlDumper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\D2O\XmlDumper.cs,SpellsDumper,The length of the statement  "			// asm.GetTypes().Where(entry => entry.Namespace != null && entry.GetConstructor(System.Type.EmptyTypes) != null && entry.Namespace.StartsWith("BiM.Protocol.Data")).ToArray<Type>(); " is 181.
Long Statement,BiM.Behaviors.Data.D2O,ObjectDataManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\D2O\ObjectDataManager.cs,EnumerateObjects,The length of the statement  "	return reader.Indexes.Select (index => reader.ReadObject (index.Key' true)).Where (obj => obj.GetType ().Name == type.Name); " is 124.
Long Statement,BiM.Behaviors.Data.I18N,I18NDataManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\I18N\I18NDataManager.cs,EnsureLanguageIsLoaded,The length of the statement  "	foreach (var d2iFile in Directory.EnumerateFiles (m_d2IPath).Where (entry => entry.EndsWith (".d2i")).Where (path => GetLanguageOfFile (path) == language)) { " is 157.
Long Statement,BiM.Behaviors.Data.I18N,I18NDataManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\I18N\I18NDataManager.cs,EnsureLanguageIsLoaded,The length of the statement  "		throw new Exception (string.Format ("Language {0} not found in the d2i files' check the path of these files and that the file exist ({1})"' language' m_d2IPath)); " is 162.
Long Statement,BiM.Behaviors.Data.Maps,MapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsManager.cs,Initialize,The length of the statement  "		logger.Info ("{0} outdated (file version :{1}' expected version {2})"' MapsDataFile' m_fileVersion' CurrentMapsFileVersion); " is 124.
Long Statement,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,Initialize,The length of the statement  "		if (!client.ContainsKey (REDIS_VERSION) || !client.ContainsKey (REDIS_KEY) || client.Get<int> (REDIS_VERSION) != VERSION) " is 121.
Long Statement,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,FindMapNeighbour,The length of the statement  "	int? bySubArea = map.SubAreaId != null ? m_subAreaMaps.GetBestMap (map.SubAreaId.Value' map.X + deltaX' map.Y + deltaY) : null; " is 127.
Long Statement,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,FindMapNeighbour,The length of the statement  "	int? byArea = map.AreaId != null ? m_areaChildrens.GetBestMap (map.AreaId.Value' map.X + deltaX' map.Y + deltaY) : null; " is 120.
Long Statement,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,FindMapNeighbour,The length of the statement  "	int? bySuperArea = map.SuperAreaId != null ? m_superAreaChildrens.GetBestMap (map.SuperAreaId.Value' map.X + deltaX' map.Y + deltaY) : null; " is 140.
Long Statement,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,FindMapNeighbour,The length of the statement  "	int? byWorldMap = map.WorldMapId != null ? m_worldMapsChildrens.GetBestMap (map.WorldMapId.Value' map.X + deltaX' map.Y + deltaY) : null; " is 137.
Long Statement,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The length of the statement  "							short[] links = submap.ChangeCells.Where (x => (x.MapChangeData & mapChangeData) != 0 && submap1.ChangeCells.Any (y => y.Id == x.Id + cellChangement)).Select (x => x.Id).ToArray (); " is 181.
Long Statement,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The length of the statement  "										submap.SubMap.Neighbours.Add (new SubMapNeighbour (neighbourSubmap.SubMap.GlobalId' new MovementTransition (neighbour' links))); " is 128.
Long Statement,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The length of the statement  "										neighbourSubmap.SubMap.Neighbours.Add (new SubMapNeighbour (submap.SubMap.GlobalId' new MovementTransition (opposite' links.Select (x => (short)(x + cellChangement)).ToArray ()))); " is 180.
Long Statement,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The length of the statement  "		typedClient1.SetRangeInHash (typedClient1.GetHash<long> (REDIS_KEY)' m_submaps.Values.SelectMany (x => x).ToDictionary (x => x.SubMap.GlobalId' x => x.SubMap)); " is 160.
Long Statement,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The length of the statement  "		typedClient2.SetRangeInHash (typedClient2.GetHash<int> (REDIS_MAPS)' m_submaps.ToDictionary (x => x.Key' x => x.Value.Select (y => y.SubMap.GlobalId).ToArray ())); " is 163.
Long Statement,BiM.Behaviors.Game.Actors,ContextActor,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\ContextActor.cs,NotifyStartMoving,The length of the statement  "		logger.Warn ("Actor start cell incorrect for this moving path Position={0}' StartPath={1}' Path={2}"' Cell' Movement.StartCell' String.Join<World.Cell> ("'"' Movement.MovementPath.Cells)); " is 188.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,Update,The length of the statement  "		//  (this as PlayedFighter).Character.SendMessage(String.Format("{3} => AP of {0} : {1} => {2}"' Name' Stats.CurrentAP' Stats.CurrentAP + message.delta' (ActionIdEnum)(message.actionId))); " is 188.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,Update,The length of the statement  "		//  (this as PlayedFighter).Character.SendMessage(String.Format("{3} => MP of {0} : {1} => {2}"' Name' Stats.CurrentMP' Stats.CurrentMP + message.delta' (ActionIdEnum)(message.actionId))); " is 188.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,GetAllEffects,The length of the statement  "	return Fight.Effects.Values.SelectMany (effectList => effectList.Where (effectT => effectT.Item1.targetId == Id && (actionId == null || effectT.Item2 == actionId)).Select (effectT => effectT.Item1)); " is 199.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,GetAllBoostEffects,The length of the statement  "	return GetAllEffects (actionId).Where (effect => effect is FightTemporaryBoostEffect).Select (effect => effect as FightTemporaryBoostEffect); " is 141.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,GetFightTriggeredEffects,The length of the statement  "	return GetAllEffects (actionId).Where (effect => effect is FightTriggeredEffect).Select (effect => effect as FightTriggeredEffect); " is 131.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,GetSpellImmunityEffects,The length of the statement  "	return GetAllEffects (actionId).Where (effect => effect is FightTemporarySpellImmunityEffect).Select (effect => effect as FightTemporarySpellImmunityEffect); " is 157.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,GetSpellBoostEffects,The length of the statement  "	return GetAllEffects (actionId).Where (effect => effect is FightTemporarySpellBoostEffect).Select (effect => effect as FightTemporarySpellBoostEffect); " is 151.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,GetBoostStateEffects,The length of the statement  "	return GetAllEffects (actionId).Where (effect => effect is FightTemporaryBoostStateEffect).Select (effect => effect as FightTemporaryBoostStateEffect); " is 151.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,GetBoostWeaponDamagesEffects,The length of the statement  "	return GetAllEffects (actionId).Where (effect => effect is FightTemporaryBoostWeaponDamagesEffect).Select (effect => effect as FightTemporaryBoostWeaponDamagesEffect); " is 167.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,PlayedFighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\PlayedFighter.AI.cs,GetOrderListOfInvocationSpells,The length of the statement  "	IEnumerable<Spells.Spell> spells = Character.SpellsBook.Spells.Where (spell => (Stats.CurrentAP >= spell.LevelTemplate.apCost) && spell.IsAvailable (null' BiM.Behaviors.Game.Spells.Spell.SpellCategory.Invocation) && CanCastSpell (spell' (Cell)null' true) && spell.LevelTemplate.needFreeCell).OrderByDescending (spell => spell.Level).ThenByDescending (spell => spell.LevelTemplate.minPlayerLevel); " is 396.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,PlayedFighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\PlayedFighter.AI.cs,GetPossibleMoves,The length of the statement  "	List<Cell> cells = pathFinder.FindConnectedCells (Cell' true' cautious' cell => cell.DistanceSteps <= Stats.CurrentMP' null' Stats.CurrentMP).ToList (); " is 152.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,PlayedFighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\PlayedFighter.AI.cs,FindMostEfficientAttackSpell,The length of the statement  "		return Character.SpellsBook.Spells.Where (spell => ((spell.Categories & BiM.Behaviors.Game.Spells.Spell.SpellCategory.Damages) != 0) && spell.IsAvailable (null' null)).OrderByDescending (spell => spell.Level).ThenByDescending (spell => spell.LevelTemplate.minPlayerLevel).FirstOrDefault (); " is 290.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,PlayedFighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\PlayedFighter.AI.cs,GetStates,The length of the statement  "	return GetBoostStateEffects ().Select (effect => ObjectDataManager.Instance.Get<Protocol.Data.SpellState> (effect.stateId)); " is 124.
Long Statement,BiM.Behaviors.Game.Actors.Fighters,PlayedFighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\PlayedFighter.AI.cs,Move,The length of the statement  "	//Character.SendMessage(String.Format("Move {0} => {1} ({3} PM): {2}"' Cell' cell' String.Join<Cell>("'"' path.Cells)' mp)); " is 124.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,Humanoid,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\Humanoid.cs,HandleOption,The length of the statement  "		m_followingCharactersLook = new ObservableCollectionMT<IndexedEntityLook> (((HumanOptionFollowers)option).followingCharactersLook); " is 131.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The length of the statement  "				Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom (); " is 152.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The length of the statement  "					SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour); " is 129.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The length of the statement  "					SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell); " is 138.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The length of the statement  "		SendWarning ("InternalChangeMap : Move from {0} to {1} succeeded. When move is complete' should go from map {2} to map {3}. "' Cell' Map.Cells [_pivotLeaderCell]' Map.ToString ()' new Map (_dstLeaderMap)); " is 205.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,ChangeMap,The length of the statement  "	Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom (); " is 152.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,ChangeMap,The length of the statement  "		SendMessage (String.Format ("Moving at the {2} of map {0} to map {1} (direct)"' this' m_nextMap' neighbour)' Color.Pink); " is 121.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,ChangeMap,The length of the statement  "		Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0 && cellSelector (cell)).GetRandom (); " is 175.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,SendTextInformation,The length of the statement  "	Bot.SendToClient (new TextInformationMessage ((sbyte)type' id' parameters.Select (entry => entry.ToString ()).ToArray ())); " is 123.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,GetBoostAmountWithPoints,The length of the statement  "		if (nextThreshold != null && (pointsToSpend / (double)threshold.PointsPerBoost) > (nextThreshold.PointsThreshold - currentPoints)) { " is 132.
Long Statement,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,UseInteractiveObject,The length of the statement  "		var cell = skill.Interactive.Cell.GetAdjacentCells (x => Map.CanStopOnCell (x)).OrderBy (x => x.ManhattanDistanceTo (Cell)).FirstOrDefault (); " is 142.
Long Statement,BiM.Behaviors.Game.Chat,BotChatMessageServer,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Chat\BotChatMessageServer.cs,TryGetSender,The length of the statement  "	return context.Actors.FirstOrDefault (entry => (entry is INamed && (entry as INamed).Name == SenderName) || entry.Id == SenderId); " is 130.
Long Statement,BiM.Behaviors.Game.Effects,EffectBase,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectBase.AI.cs,canAffectTarget,The length of the statement  "	if (spell.LevelTemplate.spellBreed == (uint)BreedEnum.Eniripsa && spell.Categories == Spell.SpellCategory.Healing && caster.HasState (76)) " is 138.
Long Statement,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,Equals,The length of the statement  "	return base.Equals (other) && other.m_day == m_day && other.m_hour == m_hour && other.m_minute == m_minute && other.m_month == m_month && other.m_year == m_year; " is 161.
Long Statement,BiM.Behaviors.Game.Effects,EffectDice,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDice.cs,ToString,The length of the statement  "	return String.Format ("{0} {1}-{2}' Targets: {3}' Area:{4} - {5}"' (EffectsEnum)Id' DiceNum' DiceFace' Targets' AreaDesc ()' Description); " is 138.
Long Statement,BiM.Behaviors.Game.Effects,EffectMount,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMount.cs,Equals,The length of the statement  "	return base.Equals (other) && other.m_date.Equals (m_date) && other.m_modelId == m_modelId && other.m_mountId == m_mountId; " is 123.
Long Statement,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,SetTrap,The length of the statement  "	SortedSet<short> newSet = new SortedSet<short> (Cells [CellId].GetAllCellsInRange (0' radius' false' null).Select (cell => cell.Id)); " is 133.
Long Statement,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,EndSequence,The length of the statement  "	//    throw new InvalidOperationException(string.Format("EndSequence authorId {0} is not current Player {1}"' message.authorId' fighter.Id)); " is 141.
Long Statement,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,EndSequence,The length of the statement  "	//    (CurrentPlayer as PlayedFighter).Character.SendMessage(String.Format("EndSequence : of fighter {0}' CurrentPlayer {1}' TimeLine.CurrentPlayer {2}"' fighter' CurrentPlayer' TimeLine.CurrentPlayer)' Color.Gray); " is 215.
Long Statement,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,AddEffect,The length of the statement  "			Effects [TimeLine.CurrentPlayer].Add (new Tuple<AbstractFightDispellableEffect' short> (abstractFightDispellableEffect' actionId)); " is 131.
Long Statement,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelEffect,The length of the statement  "					playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable); " is 171.
Long Statement,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelTarget,The length of the statement  "					playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable); " is 171.
Long Statement,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelSpell,The length of the statement  "					playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable); " is 171.
Long Statement,BiM.Behaviors.Game.Fights,FightTeam,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\FightTeam.cs,Update,The length of the statement  "	m_placementCells = (Id == FightTeamColor.Red ? msg.positionsForChallengers : msg.positionsForDefenders).Select (entry => Fight.Map.Cells [entry]).ToArray (); " is 157.
Long Statement,BiM.Behaviors.Game.Fights,TimeLine,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\TimeLine.cs,RefreshTimeLine,The length of the statement  "	bool redFighterFirst = !(Fight.RedTeam.Fighters.Count == 0 || Fight.BlueTeam.Fighters.Count == 0) && GetRealInitiative (redFighters.First ()) > GetRealInitiative (blueFighters.First ()); " is 186.
Long Statement,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,NotifyInteractiveUsed,The length of the statement  "	var skill = EnabledSkills.Concat (DisabledSkills).FirstOrDefault (x => x.JobSkill != null && x.JobSkill.id == message.skillId); " is 127.
Long Statement,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,IsForJob,The length of the statement  "	return m_disabledSkills.Any (skill => skill.JobSkill.parentJobId == jobId) || m_enabledSkills.Any (skill => skill.JobSkill.parentJobId == jobId); " is 145.
Long Statement,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,IsFish,The length of the statement  "	return m_disabledSkills.Any (skill => skill.JobSkill.parentJobId == 36) || m_enabledSkills.Any (skill => skill.JobSkill.parentJobId == 36); " is 139.
Long Statement,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,IsAdjacentTo,The length of the statement  "		return Map.CanStopOnCell (cell) && cell.ManhattanDistanceTo (Cell) < 4 && cell.X == Cell.X && cell.Y == Cell.Y && Map.CanStopOnCell (cell); " is 139.
Long Statement,BiM.Behaviors.Game.Items,Inventory,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Items\Inventory.AI.cs,FixInventoryOverloadIfNeeded,The length of the statement  "		foreach (Item item in Items.Where (item => item.IsAutomaticallyDeletable).OrderBy (item => item.Template.price / item.UnityWeight)) { " is 133.
Long Statement,BiM.Behaviors.Game.Items,Inventory,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Items\Inventory.AI.cs,EquipBestWeaponIfNeeded,The length of the statement  "	BiM.Behaviors.Game.Items.Item equipped = GetEquippedItem (BiM.Protocol.Enums.CharacterInventoryPositionEnum.ACCESSORY_POSITION_WEAPON); " is 135.
Long Statement,BiM.Behaviors.Game.Items,Inventory,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Items\Inventory.AI.cs,EquipBestWeaponIfNeeded,The length of the statement  "	foreach (BiM.Behaviors.Game.Items.Item item in GetItems (ItemSuperTypeEnum.SUPERTYPE_WEAPON).Union (GetItems (ItemSuperTypeEnum.SUPERTYPE_WEAPON_7)).OrderByDescending (item => item.Level * 10 + item.PowerRate)) { " is 212.
Long Statement,BiM.Behaviors.Game.Items,Inventory,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Items\Inventory.AI.cs,GetEquippedWeapon,The length of the statement  "	BiM.Behaviors.Game.Items.Item item = Items.FirstOrDefault (x => x.Position == CharacterInventoryPositionEnum.ACCESSORY_POSITION_WEAPON); " is 136.
Long Statement,BiM.Behaviors.Game.Items,Inventory,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Items\Inventory.AI.cs,CanMove,The length of the statement  "		//logger.Error("Cannot move item {0} because the moved quantity ({1}) is greater than the actual item quantity"' item.Name' quantity' item.Quantity); " is 149.
Long Statement,BiM.Behaviors.Game.Items,Inventory,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Items\Inventory.AI.cs,CanMove,The length of the statement  "	if (position != CharacterInventoryPositionEnum.INVENTORY_POSITION_NOT_EQUIPED && m_itemsPositioningRules.ContainsKey (item.SuperType) && !m_itemsPositioningRules [item.SuperType].Contains (position)) { " is 201.
Long Statement,BiM.Behaviors.Game.Items,Inventory,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Items\Inventory.AI.cs,CanMove,The length of the statement  "		//logger.Error("Cannot equip item {0} to {1} because the excepted position is {2}"' item.Name' position' m_itemsPositioningRules[item.SuperType][0]); " is 149.
Long Statement,BiM.Behaviors.Game.Items,Inventory,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Items\Inventory.AI.cs,Equip,The length of the statement  "		logger.Error ("Cannot equip item {0} because the super type {1} has no position associated"' item.Name' item.SuperType); " is 120.
Long Statement,BiM.Behaviors.Game.Items,Inventory,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Items\Inventory.AI.cs,Equip,The length of the statement  "	var position = availablePositions.Length == 0 ? m_itemsPositioningRules [item.SuperType].First () : availablePositions.First (); " is 128.
Long Statement,BiM.Behaviors.Game.Movements,MovementBehavior,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Movements\MovementBehavior.cs,Start,The length of the statement  "	TimedPath = TimedPath.Create (MovementPath' VelocityConfiguration.HorizontalVelocity' VelocityConfiguration.VerticalVelocity' VelocityConfiguration.LinearVelocity' StartTime); " is 175.
Long Statement,BiM.Behaviors.Game.Movements,TimedPath,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Movements\TimedPath.cs,ToString,The length of the statement  "	return string.Join ("' "' m_path.Select (entry => entry.CurrentCell.Id + "@" + entry.StartTime.ToString ("mm:ss.FFFF"))); " is 121.
Long Statement,BiM.Behaviors.Game.Movements,TimedPath,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Movements\TimedPath.cs,Create,The length of the statement  "		result.Add (new TimedPathElement (cells [i]' i + 1 < cells.Length ? cells [i + 1] : null' lastCellTime' end' velocity' (DirectionsEnum)direction)); " is 147.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,InitAI,The length of the statement  "		if (eff.zoneShape == (uint)SpellShapeEnum.L || eff.zoneShape == (uint)SpellShapeEnum.T || eff.zoneShape == (uint)SpellShapeEnum.D || eff.zoneShape == (uint)SpellShapeEnum.V || eff.zoneShape == (uint)SpellShapeEnum.slash || eff.zoneShape == (uint)SpellShapeEnum.U) " is 263.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The length of the statement  "	minDamage = (DamageType)(((minDamage * (1 + (addDamagePercent / 100.0)) + addDamage) - reduceDamage) * (1 - (reduceDamagePercent / 100.0)) * chanceToHappen); " is 157.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The length of the statement  "	maxDamage = (DamageType)(((maxDamage * (1 + (addDamagePercent / 100.0)) + addDamage) - reduceDamage) * (1 - (reduceDamagePercent / 100.0)) * chanceToHappen); " is 157.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The length of the statement  "	// When chances to happen is under 100%' then we reduce spellImpact accordingly' for simplicity' but after having apply damage bonus & reduction.  " is 145.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The length of the statement  "		AdjustDamage (result' spellException != null ? spellException.MinNeutral : effect.diceNum' spellException != null ? spellException.MaxNeutral : effect.diceSide' SpellCategory.DamagesNeutral' chanceToHappen' GetSafetotal (caster' Stats.PlayerField.NeutralDamageBonus) + GetSafetotal (caster' Stats.PlayerField.DamageBonus) + GetSafetotal (caster' Stats.PlayerField.PhysicalDamage)' GetSafetotal (caster' Stats.PlayerField.DamageBonusPercent) + GetSafetotal (caster' Stats.PlayerField.Strength)' target == null ? 0 : target.Stats.NeutralElementReduction' target == null ? 0 : target.Stats.NeutralResistPercent' isFriend); " is 619.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The length of the statement  "		AdjustDamage (result' spellException != null ? spellException.MinFire : effect.diceNum' spellException != null ? spellException.MaxFire : effect.diceSide' SpellCategory.DamagesFire' chanceToHappen' GetSafetotal (caster' Stats.PlayerField.FireDamageBonus) + GetSafetotal (caster' Stats.PlayerField.DamageBonus) + GetSafetotal (caster' Stats.PlayerField.MagicDamage)' GetSafetotal (caster' Stats.PlayerField.DamageBonusPercent) + GetSafetotal (caster' Stats.PlayerField.Intelligence)' target == null ? 0 : target.Stats.FireElementReduction' target == null ? 0 : target.Stats.FireResistPercent' isFriend); " is 602.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The length of the statement  "		AdjustDamage (result' spellException != null ? spellException.MinAir : effect.diceNum' spellException != null ? spellException.MaxAir : effect.diceSide' SpellCategory.DamagesAir' chanceToHappen' GetSafetotal (caster' Stats.PlayerField.AirDamageBonus) + GetSafetotal (caster' Stats.PlayerField.DamageBonus) + GetSafetotal (caster' Stats.PlayerField.MagicDamage)' GetSafetotal (caster' Stats.PlayerField.DamageBonusPercent) + GetSafetotal (caster' Stats.PlayerField.Agility)' target == null ? 0 : target.Stats.AirElementReduction' target == null ? 0 : target.Stats.AirResistPercent' isFriend); " is 591.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The length of the statement  "		AdjustDamage (result' spellException != null ? spellException.MinWater : effect.diceNum' spellException != null ? spellException.MaxWater : effect.diceSide' SpellCategory.DamagesWater' chanceToHappen' GetSafetotal (caster' Stats.PlayerField.WaterDamageBonus) + GetSafetotal (caster' Stats.PlayerField.DamageBonus) + GetSafetotal (caster' Stats.PlayerField.MagicDamage)' GetSafetotal (caster' Stats.PlayerField.DamageBonusPercent) + GetSafetotal (caster' Stats.PlayerField.Chance)' target == null ? 0 : target.Stats.WaterElementReduction' target == null ? 0 : target.Stats.WaterResistPercent' isFriend); " is 602.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The length of the statement  "		AdjustDamage (result' spellException != null ? spellException.MinEarth : effect.diceNum' spellException != null ? spellException.MaxEarth : effect.diceSide' SpellCategory.DamagesEarth' chanceToHappen' GetSafetotal (caster' Stats.PlayerField.EarthDamageBonus) + GetSafetotal (caster' Stats.PlayerField.DamageBonus) + GetSafetotal (caster' Stats.PlayerField.MagicDamage)' GetSafetotal (caster' Stats.PlayerField.DamageBonusPercent) + GetSafetotal (caster' Stats.PlayerField.Strength)' target == null ? 0 : target.Stats.EarthElementReduction' target == null ? 0 : target.Stats.EarthResistPercent' isFriend); " is 604.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The length of the statement  "				AdjustDamage (result' Math.Min (effect.diceNum' hptoHeal)' Math.Min (effect.diceSide' hptoHeal)' SpellCategory.Healing' chanceToHappen' GetSafetotal (caster' Stats.PlayerField.HealBonus)' GetSafetotal (caster' Stats.PlayerField.Intelligence)' 0' 0' isFriend); " is 259.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The length of the statement  "	if (!isFriend && ((category & SpellCategory.Damages) > 0) && result.MinDamage > target.Stats.Health)// Enough damage to kill the target => affect an arbitrary 50% of max heal (with at least current health)' so strong spells are not favored anymore.  " is 248.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The length of the statement  "			foreach (var actor in actors.Where (act => cells.Contains (act.Cell)))// All actors within the area covered by the spell " is 120.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The length of the statement  "			//    pc.Character.SendWarning("Spell {0} : {1} targets affected for {2} damage - {3}"' this' nbAffectedTargets' spellImpact.Damage' comment); " is 142.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The length of the statement  "		comment += string.Format (" - special \"Mot d'altruisme\" processing : hpLeftOnFoes = {0}' efficiency = {1}"' hpLeftOnFoes' (int)spellImpact.Damage); " is 149.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetCellsAtSpellRange,The length of the statement  "			if (!(LevelTemplate.castInLine && (casterCell.X == cell.X || casterCell.Y == cell.Y) || LevelTemplate.castInDiagonal && (Math.Abs (casterCell.X - cell.X) == Math.Abs (casterCell.Y - cell.Y)))) " is 192.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetCellsAtSpellRange,The length of the statement  "			if (!(cell.Walkable && !cell.NonWalkableDuringFight && cell != casterCell && !actors.Any (actor => actor.Cell != null && actor.Cell.Id == cell.Id))) " is 148.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,The length of the statement  "			pc.Character.SendWarning ("Spell {0} skipped : statesForbidden {1}"' this' string.Join ("'"' LevelTemplate.statesForbidden)); " is 125.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,The length of the statement  "			pc.Character.SendWarning ("Spell {0} skipped : statesRequired {1}"' this' string.Join ("'"' LevelTemplate.statesForbidden)); " is 124.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetLevelTemplate,The length of the statement  "		lv.effects [0].targetId = (int)(SpellTargetType.ALLIES_NON_SUMMON | SpellTargetType.ENEMIES_NON_SUMMON | SpellTargetType.SELF); " is 127.
Long Statement,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullDescription,The length of the statement  "	string result = String.Format ("{0}#{1} ({2})#{3} - cat {4} - {5}\r\n"' Name' Template.id' Level' LevelTemplate.id' Categories' Description); " is 141.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FightStart,The length of the statement  "		//Character.SendMessage(String.Format("Spell {0} : initialCooldown {1}' maxCastPerTurn {2}' maxCastPerTarget {3}' maxStack {4}' GlobalCoolDown {5}' minCastInterval {6}"' spell' spell.LevelTemplate.initialCooldown' spell.LevelTemplate.maxCastPerTurn' spell.LevelTemplate.maxCastPerTarget' spell.LevelTemplate.maxStack' spell.LevelTemplate.globalCooldown' spell.LevelTemplate.minCastInterval)' Color.Aquamarine);  " is 410.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,CastAt,The length of the statement  "		throw new ArgumentException (String.Format ("Spell Id {0} do not exists in the SpellsBook of {1}' with {2} entries"' msg.spellId' Character.Name' m_spells.Count)); " is 163.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,CastAt,The length of the statement  "	//Character.SendMessage(string.Format("Spell {0} cast at actor Id {1}. Still available : {2}"' spell' msg.targetId' spell.IsAvailable(msg.targetId))); " is 150.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The length of the statement  "	IEnumerable<Cell> sourceCells = possiblePlacement == null ? pc.GetPossibleMoves (true' true' pathFinder) : possiblePlacement; " is 125.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The length of the statement  "			if (spell.IsAvailable (null) && ((spellId != 0 && pc.CanCastSpells) || (spellId == 0 && pc.CanFight)) && spell.LevelTemplate.apCost <= pc.Stats.CurrentAP && pc.CanCastSpell (spellId)) " is 183.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The length of the statement  "	IEnumerable<Cell> sourceCells = possiblePlacement == null ? pc.GetPossibleMoves (true' true' pathFinder) : possiblePlacement; " is 125.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The length of the statement  "	//logger.Debug("***FindBestUsage {0}' {1} spells in book. {2} PA. {3}/{4} HP ***"' category' spells.Count' pc.PCStats.CurrentAP' pc.PCStats.Health' pc.PCStats.MaxHealth); " is 170.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The length of the statement  "			if (spell.IsAvailable (null) && ((spellId != 0 && pc.CanCastSpells) || (spellId == 0 && pc.CanFight)) && spell.LevelTemplate.apCost <= pc.Stats.CurrentAP && pc.CanCastSpell (spellId)) { " is 185.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The length of the statement  "					//    logger.Debug("efficiency {0} = {1} ({2})"' lastSpellTarget.Spell' lastSpellTarget.Efficiency' lastSpellTarget.Comment); " is 125.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The length of the statement  "					//                                  logger.Debug("efficiency {0} = {1} ({2})"' lastSpellTarget.Spell' lastSpellTarget.Efficiency' lastSpellTarget.Comment); " is 155.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The length of the statement  "				//                          logger.Info("{0} skipped : available={1} ({6})' canUse={2}' ApCost={3}' CanCast({4})={5}"' spell' spell.IsAvailable(null)' ((spellId != 0 && pc.CanCastSpells) || (spellId == 0 && pc.CanFight))' spell.LevelTemplate.apCost <= pc.Stats.CurrentAP' spellId' pc.CanCastSpell(spellId)' spell.AvailabilityExplainString(null)); " is 346.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The length of the statement  "	//pc.Character.SendInformation("Spell {0} selected - efficientcy : {1} - comment = {2}"' spellTarget.Spell' spellTarget.Efficiency' spellTarget.Comment); " is 153.
Long Statement,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FullDump,The length of the statement  "			logger.Error ("       Effect {0} : {1} - {2} {3:P}"' effect.Description' effectdice.diceNum <= effectdice.diceSide ? effectdice.diceNum : effectdice.diceSide' effectdice.diceNum > effectdice.diceSide ? effectdice.diceNum : effectdice.diceSide' effectdice.random == 0 ? 1.0 : effectdice.random / 100.0); " is 302.
Long Statement,BiM.Behaviors.Game.Spells,WeaponSpell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\WeaponSpell.cs,GetLevelTemplate,The length of the statement  "	// We only take effects with a duration or damage or healing effect into considération. Others are probably constant effects on the caster when holding the weapon.  " is 163.
Long Statement,BiM.Behaviors.Game.Spells,WeaponSpell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\WeaponSpell.cs,GetLevelTemplate,The length of the statement  "	LevelTemplate.effects = _weapon.possibleEffects.OfType<EffectInstanceDice> ().Where (effect => (effect.duration != 0) || ((GetEffectCategories (effect.effectId' 0) & (SpellCategory.Damages | SpellCategory.Healing)) > 0)).ToList (); " is 231.
Long Statement,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,GetAllCellsInRectangle,The length of the statement  "	int x1 = Math.Min (oppositeCell.X' X)' y1 = Math.Min (oppositeCell.Y' Y)' x2 = Math.Max (oppositeCell.X' X)' y2 = Math.Max (oppositeCell.Y' Y); " is 143.
Long Statement,BiM.Behaviors.Game.World,Map,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Map.cs,GetFilteredInteractives,The length of the statement  "	return m_interactives.Where (interactive => interactive.Action == interactiveCategory && (state == null || interactive.State == state) && (skills == null || (activeSkills != true && interactive.DisabledSkills.Select (skill => (short)skill.JobSkill.id).Intersect (skills).Any ()) || (activeSkills != false && interactive.EnabledSkills.Select (skill => (short)skill.JobSkill.id).Intersect (skills).Any ()))).ToArray (); " is 417.
Long Statement,BiM.Behaviors.Game.World,Map,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Map.cs,GetFilteredInteractives,The length of the statement  "	return m_interactives.Where (interactive => interactive.DisabledSkills.Any (skill => skill.JobSkill.parentJobId == jobId) || interactive.EnabledSkills.Any (skill => skill.JobSkill.parentJobId == jobId) && (state == null || interactive.State == state)).ToArray (); " is 263.
Long Statement,BiM.Behaviors.Game.World,MapContext,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapContext.cs,TooCloseFromSegment,The length of the statement  "	// Distance computing is inspired by Philip Nicoletti algorithm - http://forums.codeguru.com/printthread.php?t=194400&pp=15&page=2      " is 130.
Long Statement,BiM.Behaviors.Game.World,MapContext,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapContext.cs,IsCellWalkable,The length of the statement  "		if (cell.MoveZone != previousCell.MoveZone || cell.MoveZone == previousCell.MoveZone && cell.MoveZone == 0 && floorDiff > Map.ElevationTolerance) " is 145.
Long Statement,BiM.Behaviors.Game.World.MapTraveling,SubMapBuilder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\SubMapBuilder.cs,GetAdjacentCells,The length of the statement  "	if ((cellId = Cell.GetCellFromPoint (pos.X + 1' pos.Y + 0)) != null && predicate1 (cellId) && predicate2 (adjacent = cellList [cellId.Value])) " is 142.
Long Statement,BiM.Behaviors.Game.World.MapTraveling,SubMapBuilder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\SubMapBuilder.cs,GetAdjacentCells,The length of the statement  "	if ((cellId = Cell.GetCellFromPoint (pos.X + 0' pos.Y + 1)) != null && predicate1 (cellId) && predicate2 (adjacent = cellList [cellId.Value])) " is 142.
Long Statement,BiM.Behaviors.Game.World.MapTraveling,SubMapBuilder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\SubMapBuilder.cs,GetAdjacentCells,The length of the statement  "	if ((cellId = Cell.GetCellFromPoint (pos.X - 1' pos.Y + 0)) != null && predicate1 (cellId) && predicate2 (adjacent = cellList [cellId.Value])) " is 142.
Long Statement,BiM.Behaviors.Game.World.MapTraveling,SubMapBuilder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\SubMapBuilder.cs,GetAdjacentCells,The length of the statement  "	if ((cellId = Cell.GetCellFromPoint (pos.X + 0' pos.Y - 1)) != null && predicate1 (cellId) && predicate2 (adjacent = cellList [cellId.Value])) " is 142.
Long Statement,BiM.Behaviors.Game.World.MapTraveling,SubMapBuilder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\SubMapBuilder.cs,GenerateBinders,The length of the statement  "		results.Add (new AdjacentSubMap (new SubMapBinder (map.Id' ++submapid' map.X' map.Y' new List<SubMapNeighbour> ())' borderCells)); " is 130.
Long Statement,BiM.Behaviors.Game.World.MapTraveling,SubMapBuilder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\SubMapBuilder.cs,IsCellWalkable,The length of the statement  "		if (cell.MoveZone != previousCell.MoveZone || cell.MoveZone == previousCell.MoveZone && cell.MoveZone == 0 && floorDiff > World.Map.ElevationTolerance) " is 151.
Long Statement,BiM.Behaviors.Game.World.MapTraveling,SubMapBuilder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\SubMapBuilder.cs,GetConnectedCells,The length of the statement  "	foreach (var adjacent in GetAdjacentCells (cell' map.Cells' x => !m_treatedCells.Contains (x.Value)' x => IsCellWalkable (map' x' cell))) { " is 139.
Long Statement,BiM.Behaviors.Game.World.MapTraveling.Transitions,MovementTransition,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\Transitions\MovementTransition.cs,BeginTransition,The length of the statement  "	if (!character.ChangeMap (MapNeighbour' cell => Cells == null || Cells.Length == 0 || Array.IndexOf (Cells' cell.CellId) != -1)) { " is 130.
Long Statement,BiM.Behaviors.Game.World.MapTraveling.Transitions,MovementTransition,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\Transitions\MovementTransition.cs,BeginTransition,The length of the statement  "		logger.Error ("Cannot proceed transition : cannot reach {0} map from {1} (submap:{2} to {3})"' MapNeighbour' character.Map.Id' @from.GlobalId' to.GlobalId); " is 156.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetClosestTransitionCell,The length of the statement  "	return map.Cells.Where (cell => (cell.MapChangeData & MapChangeMask) != 0).OrderBy (cell => cell.DistanceTo (startingCell)).FirstOrDefault (); " is 142.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapMovement,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapMovement.cs,PackPath,The length of the statement  "		if (NoCell == 1 || (Orientation != PreviousOrientation) || NoCell == (path.Length - 1))// Odd' but first step is always packed " is 126.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,ClearLogic,The length of the statement  "			foreach (var cellid in enemyCells.Where (cell => cell != null).SelectMany (cell => cell.GetAdjacentCells ()).Select (cell => cell.Id)) " is 134.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindConnectedCells,The length of the statement  "	return _cells.Where (cell => cell != null && cell.DistanceSteps <= maxDistance && (filter == null || filter (cell)) && /*(_map.IsTrapped(startingCell.Id) || */!_map.IsTrapped (cell.CellId)/*)*/).OrderBy (cell => (sorter == null ? cell.DistanceSteps : sorter (cell))/*+ (_map.IsTrapped(cell.CellId)?100:0)*/).Select (cell => cell.Cell); " is 335.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The length of the statement  "			if ((selectFartherCells && _cells [cell].DistanceSteps > MinDist) || (!selectFartherCells && _cells [cell].DistanceSteps < MinDist)) { " is 134.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The length of the statement  "	//Debug.WriteLine("PathFinding from {0} ({1}) to {2} ({3})"' _cells[startingCells[0]].cell' _cells[startingCells[0]].distanceSteps' _cells[ExitCell].cell' _cells[ExitCell].distanceSteps); " is 187.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The length of the statement  "                        Debug.Assert(false' "Distance shouldn't be higher than DEFAULT_DISTANCE"' "Distance = {0} > Max = {1}"' distance' CellInfo.DEFAULT_DISTANCE);" is 141.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The length of the statement  "		//Debug.Assert(_cells[lowestPoint].IsInPath == false' "Point already in path"' "CurrentCell : {0}' Lowest : {1} - distance : {2}' path : {3}"' _cells[CurrentCell].Cell' _cells[lowestPoint].Cell' lowest' string.Join("'"' _cells.Where(stCell => stCell.IsInPath))); " is 262.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,SquareOpen,The length of the statement  "			cell.IsOpen = cell.IsCombatWalkable && _map.IsCellWalkable (cell.Cell' false' originCell == null ? null : originCell.Cell)/* && !cell.IsCloseToEnemy*/; " is 151.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,SquareOpen,The length of the statement  "			cell.IsOpen = _map.IsCellWalkable (cell.Cell' !_isCautious' originCell == null ? null : originCell.Cell)/* && (!_isCautious || !cell.IsCloseToEnemy)*/; " is 151.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,SubMapProcessor,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\SubMapProcessor.cs,SubMapFiller,The length of the statement  "	if ((startingCell == null) || !_map.IsCellWalkable (startingCell.Cell' true' null) || !(!_isInFight || startingCell.IsCombatWalkable) || (startingCell.SubMapId == RegionNb)) " is 173.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,SubMapProcessor,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\SubMapProcessor.cs,SubMapFiller,The length of the statement  "				if (newCell.SubMapId != RegionNb && _map.IsCellWalkable (newCell.Cell' true' null) && (!_isInFight || newCell.IsCombatWalkable)) { " is 130.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldMap,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldMap.cs,GetWorldMapConnections,The length of the statement  "	//MapDataManager mapDataManager = new MapDataManager(pathToMapsData' StoredInMap); // Gets only Headers' except if checking cell content is needed " is 146.
Long Statement,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldPathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldPathFinder.cs,GetNextSubMapIdToReachTheDestination,The length of the statement  "		} else if ((cells [NextSubMap].distanceSteps == BestChoiceDistance) && (RandomPath) && (rnd.Next (2) == 0))// If 2 possible cells have same value' choose randomly " is 162.
Long Statement,BiM.Behaviors.Game.World.Pathfinding,Path,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Path.cs,BuildCompletePath,The length of the statement  "		while ((nextPoint = nextPoint.GetNearestCellInDirection (m_compressedPath [i].Direction)) != null && nextPoint.Id != m_compressedPath [i + 1].Cell.Id) { " is 152.
Long Statement,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The length of the statement  "	IOpenList openList = m_useLogNodeSearch ? (IOpenList)new LogOpenList (new ComparePfNodeMatrix (matrix)) : new LinearOpenList (new ComparePfNodeMatrix (matrix)); " is 160.
Long Statement,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The length of the statement  "				bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y; " is 135.
Long Statement,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The length of the statement  "				bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y; " is 145.
Long Statement,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The length of the statement  "				if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) { " is 243.
Long Statement,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The length of the statement  "		if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) { " is 172.
Long Statement,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The length of the statement  "			var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d)); " is 154.
Long Statement,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The length of the statement  "			if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) { " is 275.
Long Statement,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The length of the statement  "			} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) { " is 156.
Long Statement,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The length of the statement  "			} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) { " is 156.
Long Statement,BiM.Behaviors.Handlers.Context,FightHandler,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Handlers\Context\FightHandler.cs,HandleGameActionFightLifePointsLostMessage,The length of the statement  "		logger.Error ("Fighter {0} has lost {2} HP cast but doesn't exist' or is it {1} ?"' message.targetId' message.sourceId' message.loss); " is 134.
Long Statement,BiM.Behaviors.Handlers.Context,FightHandler,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Handlers\Context\FightHandler.cs,HandleGameActionFightLifePointsGainMessage,The length of the statement  "		logger.Error ("Fighter {0} has gain {2} HP cast but doesn't exist' or is it {1} ?"' message.targetId' message.sourceId' message.delta); " is 135.
Long Statement,BiM.Behaviors.Handlers.Context,FightHandler,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Handlers\Context\FightHandler.cs,HandleGameActionFightPointsVariationMessage,The length of the statement  "		logger.Error ("Fighter {0} has lost {2} ?P points but doesn't exist' or is it {1} ?"' message.sourceId' message.targetId' -message.delta); " is 138.
Long Statement,BiM.Behaviors.Handlers.Context,MapMovementHandler,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Handlers\Context\MapMovementHandler.cs,HandleGameMapMovementCancelMessage,The length of the statement  "		TimedPathElement clientCell = bot.Character.Movement.TimedPath.Elements.First (entry => entry.CurrentCell.Id == message.cellId); " is 128.
Long Statement,BiM.Behaviors.Handlers.Context,MapMovementHandler,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Handlers\Context\MapMovementHandler.cs,HandleGameMapMovementCancelMessage,The length of the statement  "		// the difference is the time elapsed until the client analyse the path and start moving (~160ms) it depends also on computer hardware " is 134.
Long Statement,BiM.Behaviors.Handlers.Context,MapMovementHandler,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Handlers\Context\MapMovementHandler.cs,HandleGameMapMovementCancelMessage,The length of the statement  "		logger.Warn ("Warning the client has canceled the movement but the given cell ({0}) is not the attempted one ({1})." + "Estimated difference : {2}ms"' message.cellId' attemptElement.CurrentCell.Id' (attemptElement.EndTime - clientCell.EndTime).TotalMilliseconds); " is 263.
Long Statement,BiM.Behaviors.Handlers.Context,MapMovementHandler,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Handlers\Context\MapMovementHandler.cs,HandleGameMapMovementMessage,The length of the statement  "		logger.Error ("Actor {0} not found (known : {1})"' message.actorId' String.Join ("'"' fightActor ? bot.Character.Fight.Actors : bot.Character.Context.Actors)); " is 159.
Long Statement,BiM.Behaviors.Handlers.Context,MapMovementHandler,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Handlers\Context\MapMovementHandler.cs,HandleGameMapMovementMessage,The length of the statement  "	// just to update the position. If in fight' better update immediately to be sure that the next action take the mouvement into account " is 134.
Long Statement,BiM.Behaviors.Settings,BotSettings,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Settings\BotSettings.cs,GetOrAddEntry,The length of the statement  "		throw new Exception (string.Format ("Found {0} settings entries of type {1}' 1 or 0 expected"' entries.Length' typeof(T))); " is 123.
Long Statement,BiM.Behaviors.Settings,BotSettings,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Settings\BotSettings.cs,Load,The length of the statement  "			throw new Exception (string.Format ("Found at least 2 entries with name {0}. Expected 1 or 0. File {1} corrupted"' xmlNode.Attributes [AttributeName].Value' FilePath)); " is 168.
Long Statement,BiM.Behaviors.Profiles,PathSchema,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Profiles\PathSchema.cs,CanStart,The length of the statement  "	return (StartFromFirst && Path [0].MapId == character.Map.Id && Path [0].SubMapId == character.SubMap.SubMapId) || Path.Any (x => character.Map.Id == x.MapId && character.SubMap.SubMapId == x.SubMapId); " is 202.
Long Statement,BiM.Behaviors.Profiles,ZoneSchema,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Profiles\ZoneSchema.cs,IsInZone,The length of the statement  "	return Array.IndexOf (SubAreas' character.Map.SubAreaId) != -1 || Maps.Any (x => character.Map.Id == x.MapId && character.SubMap.SubMapId == x.SubMapId); " is 153.
Complex Conditional,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,InitAI,The conditional expression  "eff.zoneShape == (uint)SpellShapeEnum.L || eff.zoneShape == (uint)SpellShapeEnum.T || eff.zoneShape == (uint)SpellShapeEnum.D || eff.zoneShape == (uint)SpellShapeEnum.V || eff.zoneShape == (uint)SpellShapeEnum.slash || eff.zoneShape == (uint)SpellShapeEnum.U"  is complex.
Complex Conditional,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetCellsAtSpellRange,The conditional expression  "!(LevelTemplate.castInLine && (casterCell.X == cell.X || casterCell.Y == cell.Y) || LevelTemplate.castInDiagonal && (Math.Abs (casterCell.X - cell.X) == Math.Abs (casterCell.Y - cell.Y)))"  is complex.
Complex Conditional,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetCellsAtSpellRange,The conditional expression  "!(cell.Walkable && !cell.NonWalkableDuringFight && cell != casterCell && !actors.Any (actor => actor.Cell != null && actor.Cell.Id == cell.Id))"  is complex.
Complex Conditional,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The conditional expression  "spell.IsAvailable (null) && ((spellId != 0 && pc.CanCastSpells) || (spellId == 0 && pc.CanFight)) && spell.LevelTemplate.apCost <= pc.Stats.CurrentAP && pc.CanCastSpell (spellId)"  is complex.
Complex Conditional,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FindBestUsage,The conditional expression  "spell.IsAvailable (null) && ((spellId != 0 && pc.CanCastSpells) || (spellId == 0 && pc.CanFight)) && spell.LevelTemplate.apCost <= pc.Stats.CurrentAP && pc.CanCastSpell (spellId)"  is complex.
Complex Conditional,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,GetAllCellsInRectangle,The conditional expression  "!skipStartAndEndCells || (!(x == X && y == Y) && !(x == oppositeCell.X && y == oppositeCell.Y))"  is complex.
Complex Conditional,BiM.Behaviors.Game.World,MapContext,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapContext.cs,IsCellWalkable,The conditional expression  "cell.MoveZone != previousCell.MoveZone || cell.MoveZone == previousCell.MoveZone && cell.MoveZone == 0 && floorDiff > Map.ElevationTolerance"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.MapTraveling,SubMapBuilder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\MapTraveling\SubMapBuilder.cs,IsCellWalkable,The conditional expression  "cell.MoveZone != previousCell.MoveZone || cell.MoveZone == previousCell.MoveZone && cell.MoveZone == 0 && floorDiff > World.Map.ElevationTolerance"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The conditional expression  "!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id)"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The conditional expression  "!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id)"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The conditional expression  "(selectFartherCells && _cells [cell].DistanceSteps > MinDist) || (!selectFartherCells && _cells [cell].DistanceSteps < MinDist)"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The conditional expression  "newCell == null || (newCell.IsCloseToEnemy && _isCautious && newCell.DistanceSteps != 0)"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,SubMapProcessor,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\SubMapProcessor.cs,SubMapFiller,The conditional expression  "(startingCell == null) || !_map.IsCellWalkable (startingCell.Cell' true' null) || !(!_isInFight || startingCell.IsCombatWalkable) || (startingCell.SubMapId == RegionNb)"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,SubMapProcessor,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\SubMapProcessor.cs,SubMapFiller,The conditional expression  "newCell.SubMapId != RegionNb && _map.IsCellWalkable (newCell.Cell' true' null) && (!_isInFight || newCell.IsCombatWalkable)"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The conditional expression  "newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The conditional expression  "i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The conditional expression  "((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The conditional expression  "cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)"  is complex.
Complex Conditional,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The conditional expression  "cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)"  is complex.
Magic Number,BiM.Behaviors.Data.Maps,MapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsManager.cs,Initialize,The following statement contains a magic number: if (new string (reader.ReadChars (4)) != "MAPS") {  	throw new Exception (string.Format ("File {0} corrupted' delete it manually"' MapsDataFile));  }  
Magic Number,BiM.Behaviors.Data.Maps,MapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsManager.cs,EndFileCreation,The following statement contains a magic number: m_writer.Seek (6' SeekOrigin.Begin);  
Magic Number,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,BeginGeneration,The following statement contains a magic number: Task.Factory.StartNew (() => {  	// step 1 : load areas stuff  	progression.UpdateValue (0' "(1/4) Getting areas ...");  	m_subAreas = ObjectDataManager.Instance.EnumerateObjects<SubArea> ().ToDictionary (x => x.id);  	progression.UpdateValue (33);  	m_areas = ObjectDataManager.Instance.EnumerateObjects<Area> ().ToDictionary (x => x.id);  	progression.UpdateValue (66);  	m_superAreas = ObjectDataManager.Instance.EnumerateObjects<SuperArea> ().ToDictionary (x => x.id);  	progression.UpdateValue (100);  	// step 2 : bind to each map his parents areas  	progression.UpdateValue (0' "(2/4) Getting maps ...");  	var mapsPosition = new List<MapPositionData> ();  	int counter = 0;  	progression.Total = MapsManager.Instance.MapsCount;  	foreach (var map in maps) {  		var pos = new Point (map.X' map.Y);  		var subArea = m_subAreas.ContainsKey (map.SubAreaId) ? m_subAreas [map.SubAreaId] : null;  		var area = subArea != null && m_areas.ContainsKey (subArea.areaId) ? m_areas [subArea.areaId] : null;  		var superArea = area != null && m_subAreas.ContainsKey (area.superAreaId) ? m_superAreas [area.superAreaId] : null;  		var mapWithPrority = new MapWithPriority (map);  		if (subArea != null) {  			m_subAreaMaps.AddRegion (subArea.id' map.Id);  			m_subAreaMaps.AddMap (subArea.id' pos' mapWithPrority);  		}  		if (area != null) {  			if (!m_areaChildrens.ContainsRegion (area.id' subArea.id))  				m_areaChildrens.AddRegion (area.id' subArea.id);  			m_areaChildrens.AddMap (area.id' pos' mapWithPrority);  		}  		if (superArea != null) {  			if (!m_superAreaChildrens.ContainsRegion (superArea.id' area.id))  				m_superAreaChildrens.AddRegion (superArea.id' area.id);  			m_superAreaChildrens.AddMap (superArea.id' pos' mapWithPrority);  		}  		int? worldmapId = superArea != null ? (int?)superArea.worldmapId : null;  		if (superArea != null) {  			if (!m_worldMapsChildrens.ContainsRegion (worldmapId.Value' superArea.id))  				m_worldMapsChildrens.AddRegion (worldmapId.Value' superArea.id);  			m_worldMapsChildrens.AddMap (worldmapId.Value' pos' mapWithPrority);  		}  		mapsPosition.Add (new MapPositionData {  			MapId = map.Id'  			SubAreaId = subArea != null ? subArea.id : (int?)null'  			AreaId = area != null ? area.id : (int?)null'  			SuperAreaId = superArea != null ? superArea.id : (int?)null'  			WorldMapId = worldmapId'  			X = map.X'  			Y = map.Y  		});  		progression.UpdateValue (counter++);  	}  	progression.UpdateValue (0' "(3/4) Finding neighbours ...");  	progression.Total = mapsPosition.Count;  	// step 3 : found for each map his neighbours  	foreach (var map in mapsPosition) {  		var enumerator = FindMapNeighbours (map).GetEnumerator ();  		enumerator.MoveNext ();  		map.RightNeighbourId = enumerator.Current;  		enumerator.MoveNext ();  		map.TopNeighbourId = enumerator.Current;  		enumerator.MoveNext ();  		map.LeftNeighbourId = enumerator.Current;  		enumerator.MoveNext ();  		map.BottomNeighbourId = enumerator.Current;  		Debug.Assert (!enumerator.MoveNext ());  		progression.Value++;  	}  	progression.UpdateValue (0' "(4/4) Saving ...");  	// step 4 : save all the datas and dispose the allocated lists  	using (var client = GetClient ()) {  		var typed = client.As<MapPositionData> ();  		typed.SetRangeInHash (typed.GetHash<int> (REDIS_KEY)' mapsPosition.ToDictionary (x => x.MapId));  		client.Set (REDIS_VERSION' VERSION);  	}  	// dispose  	m_subAreaMaps.Dispose ();  	m_areaChildrens.Dispose ();  	m_superAreaChildrens.Dispose ();  	m_worldMapsChildrens.Dispose ();  	m_subAreas.Clear ();  	m_areas.Clear ();  	m_superAreas.Clear ();  	progression.NotifyEnded ();  });  
Magic Number,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,BeginGeneration,The following statement contains a magic number: Task.Factory.StartNew (() => {  	// step 1 : load areas stuff  	progression.UpdateValue (0' "(1/4) Getting areas ...");  	m_subAreas = ObjectDataManager.Instance.EnumerateObjects<SubArea> ().ToDictionary (x => x.id);  	progression.UpdateValue (33);  	m_areas = ObjectDataManager.Instance.EnumerateObjects<Area> ().ToDictionary (x => x.id);  	progression.UpdateValue (66);  	m_superAreas = ObjectDataManager.Instance.EnumerateObjects<SuperArea> ().ToDictionary (x => x.id);  	progression.UpdateValue (100);  	// step 2 : bind to each map his parents areas  	progression.UpdateValue (0' "(2/4) Getting maps ...");  	var mapsPosition = new List<MapPositionData> ();  	int counter = 0;  	progression.Total = MapsManager.Instance.MapsCount;  	foreach (var map in maps) {  		var pos = new Point (map.X' map.Y);  		var subArea = m_subAreas.ContainsKey (map.SubAreaId) ? m_subAreas [map.SubAreaId] : null;  		var area = subArea != null && m_areas.ContainsKey (subArea.areaId) ? m_areas [subArea.areaId] : null;  		var superArea = area != null && m_subAreas.ContainsKey (area.superAreaId) ? m_superAreas [area.superAreaId] : null;  		var mapWithPrority = new MapWithPriority (map);  		if (subArea != null) {  			m_subAreaMaps.AddRegion (subArea.id' map.Id);  			m_subAreaMaps.AddMap (subArea.id' pos' mapWithPrority);  		}  		if (area != null) {  			if (!m_areaChildrens.ContainsRegion (area.id' subArea.id))  				m_areaChildrens.AddRegion (area.id' subArea.id);  			m_areaChildrens.AddMap (area.id' pos' mapWithPrority);  		}  		if (superArea != null) {  			if (!m_superAreaChildrens.ContainsRegion (superArea.id' area.id))  				m_superAreaChildrens.AddRegion (superArea.id' area.id);  			m_superAreaChildrens.AddMap (superArea.id' pos' mapWithPrority);  		}  		int? worldmapId = superArea != null ? (int?)superArea.worldmapId : null;  		if (superArea != null) {  			if (!m_worldMapsChildrens.ContainsRegion (worldmapId.Value' superArea.id))  				m_worldMapsChildrens.AddRegion (worldmapId.Value' superArea.id);  			m_worldMapsChildrens.AddMap (worldmapId.Value' pos' mapWithPrority);  		}  		mapsPosition.Add (new MapPositionData {  			MapId = map.Id'  			SubAreaId = subArea != null ? subArea.id : (int?)null'  			AreaId = area != null ? area.id : (int?)null'  			SuperAreaId = superArea != null ? superArea.id : (int?)null'  			WorldMapId = worldmapId'  			X = map.X'  			Y = map.Y  		});  		progression.UpdateValue (counter++);  	}  	progression.UpdateValue (0' "(3/4) Finding neighbours ...");  	progression.Total = mapsPosition.Count;  	// step 3 : found for each map his neighbours  	foreach (var map in mapsPosition) {  		var enumerator = FindMapNeighbours (map).GetEnumerator ();  		enumerator.MoveNext ();  		map.RightNeighbourId = enumerator.Current;  		enumerator.MoveNext ();  		map.TopNeighbourId = enumerator.Current;  		enumerator.MoveNext ();  		map.LeftNeighbourId = enumerator.Current;  		enumerator.MoveNext ();  		map.BottomNeighbourId = enumerator.Current;  		Debug.Assert (!enumerator.MoveNext ());  		progression.Value++;  	}  	progression.UpdateValue (0' "(4/4) Saving ...");  	// step 4 : save all the datas and dispose the allocated lists  	using (var client = GetClient ()) {  		var typed = client.As<MapPositionData> ();  		typed.SetRangeInHash (typed.GetHash<int> (REDIS_KEY)' mapsPosition.ToDictionary (x => x.MapId));  		client.Set (REDIS_VERSION' VERSION);  	}  	// dispose  	m_subAreaMaps.Dispose ();  	m_areaChildrens.Dispose ();  	m_superAreaChildrens.Dispose ();  	m_worldMapsChildrens.Dispose ();  	m_subAreas.Clear ();  	m_areas.Clear ();  	m_superAreas.Clear ();  	progression.NotifyEnded ();  });  
Magic Number,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,BeginGeneration,The following statement contains a magic number: Task.Factory.StartNew (() => {  	// step 1 : load areas stuff  	progression.UpdateValue (0' "(1/4) Getting areas ...");  	m_subAreas = ObjectDataManager.Instance.EnumerateObjects<SubArea> ().ToDictionary (x => x.id);  	progression.UpdateValue (33);  	m_areas = ObjectDataManager.Instance.EnumerateObjects<Area> ().ToDictionary (x => x.id);  	progression.UpdateValue (66);  	m_superAreas = ObjectDataManager.Instance.EnumerateObjects<SuperArea> ().ToDictionary (x => x.id);  	progression.UpdateValue (100);  	// step 2 : bind to each map his parents areas  	progression.UpdateValue (0' "(2/4) Getting maps ...");  	var mapsPosition = new List<MapPositionData> ();  	int counter = 0;  	progression.Total = MapsManager.Instance.MapsCount;  	foreach (var map in maps) {  		var pos = new Point (map.X' map.Y);  		var subArea = m_subAreas.ContainsKey (map.SubAreaId) ? m_subAreas [map.SubAreaId] : null;  		var area = subArea != null && m_areas.ContainsKey (subArea.areaId) ? m_areas [subArea.areaId] : null;  		var superArea = area != null && m_subAreas.ContainsKey (area.superAreaId) ? m_superAreas [area.superAreaId] : null;  		var mapWithPrority = new MapWithPriority (map);  		if (subArea != null) {  			m_subAreaMaps.AddRegion (subArea.id' map.Id);  			m_subAreaMaps.AddMap (subArea.id' pos' mapWithPrority);  		}  		if (area != null) {  			if (!m_areaChildrens.ContainsRegion (area.id' subArea.id))  				m_areaChildrens.AddRegion (area.id' subArea.id);  			m_areaChildrens.AddMap (area.id' pos' mapWithPrority);  		}  		if (superArea != null) {  			if (!m_superAreaChildrens.ContainsRegion (superArea.id' area.id))  				m_superAreaChildrens.AddRegion (superArea.id' area.id);  			m_superAreaChildrens.AddMap (superArea.id' pos' mapWithPrority);  		}  		int? worldmapId = superArea != null ? (int?)superArea.worldmapId : null;  		if (superArea != null) {  			if (!m_worldMapsChildrens.ContainsRegion (worldmapId.Value' superArea.id))  				m_worldMapsChildrens.AddRegion (worldmapId.Value' superArea.id);  			m_worldMapsChildrens.AddMap (worldmapId.Value' pos' mapWithPrority);  		}  		mapsPosition.Add (new MapPositionData {  			MapId = map.Id'  			SubAreaId = subArea != null ? subArea.id : (int?)null'  			AreaId = area != null ? area.id : (int?)null'  			SuperAreaId = superArea != null ? superArea.id : (int?)null'  			WorldMapId = worldmapId'  			X = map.X'  			Y = map.Y  		});  		progression.UpdateValue (counter++);  	}  	progression.UpdateValue (0' "(3/4) Finding neighbours ...");  	progression.Total = mapsPosition.Count;  	// step 3 : found for each map his neighbours  	foreach (var map in mapsPosition) {  		var enumerator = FindMapNeighbours (map).GetEnumerator ();  		enumerator.MoveNext ();  		map.RightNeighbourId = enumerator.Current;  		enumerator.MoveNext ();  		map.TopNeighbourId = enumerator.Current;  		enumerator.MoveNext ();  		map.LeftNeighbourId = enumerator.Current;  		enumerator.MoveNext ();  		map.BottomNeighbourId = enumerator.Current;  		Debug.Assert (!enumerator.MoveNext ());  		progression.Value++;  	}  	progression.UpdateValue (0' "(4/4) Saving ...");  	// step 4 : save all the datas and dispose the allocated lists  	using (var client = GetClient ()) {  		var typed = client.As<MapPositionData> ();  		typed.SetRangeInHash (typed.GetHash<int> (REDIS_KEY)' mapsPosition.ToDictionary (x => x.MapId));  		client.Set (REDIS_VERSION' VERSION);  	}  	// dispose  	m_subAreaMaps.Dispose ();  	m_areaChildrens.Dispose ();  	m_superAreaChildrens.Dispose ();  	m_worldMapsChildrens.Dispose ();  	m_subAreas.Clear ();  	m_areas.Clear ();  	m_superAreas.Clear ();  	progression.NotifyEnded ();  });  
Magic Number,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,BeginGeneration,The following statement contains a magic number: progression.UpdateValue (33);  
Magic Number,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,BeginGeneration,The following statement contains a magic number: progression.UpdateValue (66);  
Magic Number,BiM.Behaviors.Data.Maps,MapsPositionManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\MapsPositionManager.cs,BeginGeneration,The following statement contains a magic number: progression.UpdateValue (100);  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: Parallel.ForEach (MapsManager.Instance.EnumerateMaps ()' map => {  	var builder = new SubMapBuilder ();  	AdjacentSubMap[] submaps = builder.GenerateBinders (map);  	m_submaps.TryAdd (map.Id' submaps);  	// update the counter (in percent)  	Interlocked.Increment (ref counter);  	if (counter % 30 == 0) {  		lock (progression) {  			if (counter % 30 == 0)  				progression.UpdateValue (total == 0 ? 100d : (counter / total) * 100d);  		}  	}  });  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: Parallel.ForEach (MapsManager.Instance.EnumerateMaps ()' map => {  	var builder = new SubMapBuilder ();  	AdjacentSubMap[] submaps = builder.GenerateBinders (map);  	m_submaps.TryAdd (map.Id' submaps);  	// update the counter (in percent)  	Interlocked.Increment (ref counter);  	if (counter % 30 == 0) {  		lock (progression) {  			if (counter % 30 == 0)  				progression.UpdateValue (total == 0 ? 100d : (counter / total) * 100d);  		}  	}  });  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: if (counter % 30 == 0) {  	lock (progression) {  		if (counter % 30 == 0)  			progression.UpdateValue (total == 0 ? 100d : (counter / total) * 100d);  	}  }  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: if (counter % 30 == 0) {  	lock (progression) {  		if (counter % 30 == 0)  			progression.UpdateValue (total == 0 ? 100d : (counter / total) * 100d);  	}  }  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: lock (progression) {  	if (counter % 30 == 0)  		progression.UpdateValue (total == 0 ? 100d : (counter / total) * 100d);  }  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: if (counter % 30 == 0)  	progression.UpdateValue (total == 0 ? 100d : (counter / total) * 100d);  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: Parallel.ForEach (m_submaps' cacheEntry => {  	var neighbours = new[] {  		TryGetMapNeighbour (cacheEntry.Key' MapNeighbour.Right)'  		TryGetMapNeighbour (cacheEntry.Key' MapNeighbour.Top)'  		TryGetMapNeighbour (cacheEntry.Key' MapNeighbour.Left)'  		TryGetMapNeighbour (cacheEntry.Key' MapNeighbour.Bottom)'  	};  	foreach (AdjacentSubMap submap in cacheEntry.Value) {  		for (MapNeighbour neighbour = MapNeighbour.Right; neighbour <= MapNeighbour.Bottom; neighbour++) {  			int i = (int)neighbour - 1;  			if (neighbours [i] == null)  				continue;  			MapNeighbour opposite = GetOppositeDirection (neighbour);  			AdjacentSubMap[] submaps;  			int mapChangeData = Map.MapChangeDatas [neighbour];  			int oppositeMapChangeData = Map.MapChangeDatas [neighbour];  			int cellChangement = Map.MapCellChangement [neighbour];  			if (neighbours [i] != null && m_submaps.TryGetValue (neighbours [i].Value' out submaps)) {  				lock (submaps)  					foreach (AdjacentSubMap neighbourSubmap in submaps) {  						// neighbor already set  						lock (submap.SubMap.Neighbours)  							if (submap.SubMap.Neighbours.Any (x => x.GlobalId == neighbourSubmap.SubMap.GlobalId))  								continue;  						// if any cell of the submaps is a transition to another submap  						AdjacentSubMap submap1 = neighbourSubmap;  						short[] links = submap.ChangeCells.Where (x => (x.MapChangeData & mapChangeData) != 0 && submap1.ChangeCells.Any (y => y.Id == x.Id + cellChangement)).Select (x => x.Id).ToArray ();  						if (links.Length > 0) {  							// set in the two ways  							lock (submap.SubMap.Neighbours)  								lock (neighbourSubmap.SubMap.Neighbours) {  									submap.SubMap.Neighbours.Add (new SubMapNeighbour (neighbourSubmap.SubMap.GlobalId' new MovementTransition (neighbour' links)));  									neighbourSubmap.SubMap.Neighbours.Add (new SubMapNeighbour (submap.SubMap.GlobalId' new MovementTransition (opposite' links.Select (x => (short)(x + cellChangement)).ToArray ())));  								}  						}  					}  			}  		}  	}  	// update the counter (in percent)  	Interlocked.Increment (ref counter);  	if (counter % 30 == 0) {  		lock (progression) {  			if (counter % 30 == 0)  				progression.UpdateValue (counter / (double)m_submaps.Count * 100d);  		}  	}  });  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: Parallel.ForEach (m_submaps' cacheEntry => {  	var neighbours = new[] {  		TryGetMapNeighbour (cacheEntry.Key' MapNeighbour.Right)'  		TryGetMapNeighbour (cacheEntry.Key' MapNeighbour.Top)'  		TryGetMapNeighbour (cacheEntry.Key' MapNeighbour.Left)'  		TryGetMapNeighbour (cacheEntry.Key' MapNeighbour.Bottom)'  	};  	foreach (AdjacentSubMap submap in cacheEntry.Value) {  		for (MapNeighbour neighbour = MapNeighbour.Right; neighbour <= MapNeighbour.Bottom; neighbour++) {  			int i = (int)neighbour - 1;  			if (neighbours [i] == null)  				continue;  			MapNeighbour opposite = GetOppositeDirection (neighbour);  			AdjacentSubMap[] submaps;  			int mapChangeData = Map.MapChangeDatas [neighbour];  			int oppositeMapChangeData = Map.MapChangeDatas [neighbour];  			int cellChangement = Map.MapCellChangement [neighbour];  			if (neighbours [i] != null && m_submaps.TryGetValue (neighbours [i].Value' out submaps)) {  				lock (submaps)  					foreach (AdjacentSubMap neighbourSubmap in submaps) {  						// neighbor already set  						lock (submap.SubMap.Neighbours)  							if (submap.SubMap.Neighbours.Any (x => x.GlobalId == neighbourSubmap.SubMap.GlobalId))  								continue;  						// if any cell of the submaps is a transition to another submap  						AdjacentSubMap submap1 = neighbourSubmap;  						short[] links = submap.ChangeCells.Where (x => (x.MapChangeData & mapChangeData) != 0 && submap1.ChangeCells.Any (y => y.Id == x.Id + cellChangement)).Select (x => x.Id).ToArray ();  						if (links.Length > 0) {  							// set in the two ways  							lock (submap.SubMap.Neighbours)  								lock (neighbourSubmap.SubMap.Neighbours) {  									submap.SubMap.Neighbours.Add (new SubMapNeighbour (neighbourSubmap.SubMap.GlobalId' new MovementTransition (neighbour' links)));  									neighbourSubmap.SubMap.Neighbours.Add (new SubMapNeighbour (submap.SubMap.GlobalId' new MovementTransition (opposite' links.Select (x => (short)(x + cellChangement)).ToArray ())));  								}  						}  					}  			}  		}  	}  	// update the counter (in percent)  	Interlocked.Increment (ref counter);  	if (counter % 30 == 0) {  		lock (progression) {  			if (counter % 30 == 0)  				progression.UpdateValue (counter / (double)m_submaps.Count * 100d);  		}  	}  });  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: if (counter % 30 == 0) {  	lock (progression) {  		if (counter % 30 == 0)  			progression.UpdateValue (counter / (double)m_submaps.Count * 100d);  	}  }  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: if (counter % 30 == 0) {  	lock (progression) {  		if (counter % 30 == 0)  			progression.UpdateValue (counter / (double)m_submaps.Count * 100d);  	}  }  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: lock (progression) {  	if (counter % 30 == 0)  		progression.UpdateValue (counter / (double)m_submaps.Count * 100d);  }  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: if (counter % 30 == 0)  	progression.UpdateValue (counter / (double)m_submaps.Count * 100d);  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: using (IRedisClient client = m_clientManager.GetClient ()) {  	progression.UpdateValue (0' "Storing informations on Redis server...");  	IRedisTypedClient<SubMapBinder> typedClient1 = client.As<SubMapBinder> ();  	typedClient1.SetRangeInHash (typedClient1.GetHash<long> (REDIS_KEY)' m_submaps.Values.SelectMany (x => x).ToDictionary (x => x.SubMap.GlobalId' x => x.SubMap));  	progression.UpdateValue (50);  	IRedisTypedClient<long[]> typedClient2 = client.As<long[]> ();  	typedClient2.SetRangeInHash (typedClient2.GetHash<int> (REDIS_MAPS)' m_submaps.ToDictionary (x => x.Key' x => x.Value.Select (y => y.SubMap.GlobalId).ToArray ()));  	progression.UpdateValue (100);  	client.Set (REDIS_VERSION' VERSION);  }  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: using (IRedisClient client = m_clientManager.GetClient ()) {  	progression.UpdateValue (0' "Storing informations on Redis server...");  	IRedisTypedClient<SubMapBinder> typedClient1 = client.As<SubMapBinder> ();  	typedClient1.SetRangeInHash (typedClient1.GetHash<long> (REDIS_KEY)' m_submaps.Values.SelectMany (x => x).ToDictionary (x => x.SubMap.GlobalId' x => x.SubMap));  	progression.UpdateValue (50);  	IRedisTypedClient<long[]> typedClient2 = client.As<long[]> ();  	typedClient2.SetRangeInHash (typedClient2.GetHash<int> (REDIS_MAPS)' m_submaps.ToDictionary (x => x.Key' x => x.Value.Select (y => y.SubMap.GlobalId).ToArray ()));  	progression.UpdateValue (100);  	client.Set (REDIS_VERSION' VERSION);  }  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: progression.UpdateValue (50);  
Magic Number,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,GenerateSubMaps,The following statement contains a magic number: progression.UpdateValue (100);  
Magic Number,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,IsImmune,The following statement contains a magic number: if (spell.Categories == Spells.Spell.SpellCategory.Healing && HasState (76))  	return true;  
Magic Number,BiM.Behaviors.Game.Actors.Fighters,PlayedFighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\PlayedFighter.AI.cs,PassTurn,The following statement contains a magic number: if (IsPlaying ()) {  	Character.Bot.CallDelayed (200' () => Character.Bot.SendToServer (new GameFightTurnFinishMessage ()));  	return true;  }  
Magic Number,BiM.Behaviors.Game.Actors.Fighters,PlayedFighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\PlayedFighter.AI.cs,PassTurn,The following statement contains a magic number: Character.Bot.CallDelayed (200' () => Character.Bot.SendToServer (new GameFightTurnFinishMessage ()));  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,Humanoid,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\Humanoid.cs,GetAdaptedVelocity,The following statement contains a magic number: return path.MPCost <= 3 ? MovementBehavior.WalkingMovementBehavior : MovementBehavior.RunningMovementBehavior;  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,UpdateRegen,The following statement contains a magic number: if (RegenRate > 0 && RegenStartTime != null) {  	double elapsedSeconds = (DateTime.Now - RegenStartTime).Value.TotalSeconds;  	if (elapsedSeconds < 3.0)  		return;  	// Avoids significative errors when UpdateRegen is called too often.  	var regainedLife = (int)Math.Floor (elapsedSeconds / (RegenRate / 10.0f));  	if (regainedLife <= 0)  		return;  	// Avoids significative errors when UpdateRegen is called too often when regenRate is low.  	if (Stats.Health + regainedLife > Stats.MaxHealth) {  		Stats.Health = Stats.MaxHealth;  		RegenRate = 0;  		RegenStartTime = null;  	} else {  		Stats.Health += regainedLife;  		RegenStartTime = DateTime.Now;  	}  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,UpdateRegen,The following statement contains a magic number: if (elapsedSeconds < 3.0)  	return;  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (_pivotLeaderCell != Cell.Id) {  	PathFinder pathFinder = new PathFinder (Map' false);  	if (!Move (_pivotLeaderCell' pathFinder' 0' true)) {  		if (_nbTryLeft > 0) {  			SendWarning ("InternalChangeMap : Can't join the leader yet' try later");  			_nbTryLeft--;  			Bot.CallDelayed (6000' InternalChangeMap);  		} else if (_nbTryLeft > -6) {  			MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  			Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  			if (destCell == null)  				SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  			else {  				SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  				_pivotLeaderCell = destCell.Id;  			}  			_nbTryLeft--;  			Bot.CallDelayed (2000' InternalChangeMap);  		} else {  			SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  			_changingMap = false;  		}  		return;  	}  	SendWarning ("InternalChangeMap : Move from {0} to {1} succeeded. When move is complete' should go from map {2} to map {3}. "' Cell' Map.Cells [_pivotLeaderCell]' Map.ToString ()' new Map (_dstLeaderMap));  	_changingMap = false;  	m_nextMap = _dstLeaderMap;  	return;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (_pivotLeaderCell != Cell.Id) {  	PathFinder pathFinder = new PathFinder (Map' false);  	if (!Move (_pivotLeaderCell' pathFinder' 0' true)) {  		if (_nbTryLeft > 0) {  			SendWarning ("InternalChangeMap : Can't join the leader yet' try later");  			_nbTryLeft--;  			Bot.CallDelayed (6000' InternalChangeMap);  		} else if (_nbTryLeft > -6) {  			MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  			Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  			if (destCell == null)  				SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  			else {  				SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  				_pivotLeaderCell = destCell.Id;  			}  			_nbTryLeft--;  			Bot.CallDelayed (2000' InternalChangeMap);  		} else {  			SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  			_changingMap = false;  		}  		return;  	}  	SendWarning ("InternalChangeMap : Move from {0} to {1} succeeded. When move is complete' should go from map {2} to map {3}. "' Cell' Map.Cells [_pivotLeaderCell]' Map.ToString ()' new Map (_dstLeaderMap));  	_changingMap = false;  	m_nextMap = _dstLeaderMap;  	return;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (_pivotLeaderCell != Cell.Id) {  	PathFinder pathFinder = new PathFinder (Map' false);  	if (!Move (_pivotLeaderCell' pathFinder' 0' true)) {  		if (_nbTryLeft > 0) {  			SendWarning ("InternalChangeMap : Can't join the leader yet' try later");  			_nbTryLeft--;  			Bot.CallDelayed (6000' InternalChangeMap);  		} else if (_nbTryLeft > -6) {  			MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  			Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  			if (destCell == null)  				SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  			else {  				SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  				_pivotLeaderCell = destCell.Id;  			}  			_nbTryLeft--;  			Bot.CallDelayed (2000' InternalChangeMap);  		} else {  			SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  			_changingMap = false;  		}  		return;  	}  	SendWarning ("InternalChangeMap : Move from {0} to {1} succeeded. When move is complete' should go from map {2} to map {3}. "' Cell' Map.Cells [_pivotLeaderCell]' Map.ToString ()' new Map (_dstLeaderMap));  	_changingMap = false;  	m_nextMap = _dstLeaderMap;  	return;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (!Move (_pivotLeaderCell' pathFinder' 0' true)) {  	if (_nbTryLeft > 0) {  		SendWarning ("InternalChangeMap : Can't join the leader yet' try later");  		_nbTryLeft--;  		Bot.CallDelayed (6000' InternalChangeMap);  	} else if (_nbTryLeft > -6) {  		MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  		Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  		if (destCell == null)  			SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  		else {  			SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  			_pivotLeaderCell = destCell.Id;  		}  		_nbTryLeft--;  		Bot.CallDelayed (2000' InternalChangeMap);  	} else {  		SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  		_changingMap = false;  	}  	return;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (!Move (_pivotLeaderCell' pathFinder' 0' true)) {  	if (_nbTryLeft > 0) {  		SendWarning ("InternalChangeMap : Can't join the leader yet' try later");  		_nbTryLeft--;  		Bot.CallDelayed (6000' InternalChangeMap);  	} else if (_nbTryLeft > -6) {  		MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  		Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  		if (destCell == null)  			SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  		else {  			SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  			_pivotLeaderCell = destCell.Id;  		}  		_nbTryLeft--;  		Bot.CallDelayed (2000' InternalChangeMap);  	} else {  		SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  		_changingMap = false;  	}  	return;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (!Move (_pivotLeaderCell' pathFinder' 0' true)) {  	if (_nbTryLeft > 0) {  		SendWarning ("InternalChangeMap : Can't join the leader yet' try later");  		_nbTryLeft--;  		Bot.CallDelayed (6000' InternalChangeMap);  	} else if (_nbTryLeft > -6) {  		MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  		Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  		if (destCell == null)  			SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  		else {  			SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  			_pivotLeaderCell = destCell.Id;  		}  		_nbTryLeft--;  		Bot.CallDelayed (2000' InternalChangeMap);  	} else {  		SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  		_changingMap = false;  	}  	return;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (_nbTryLeft > 0) {  	SendWarning ("InternalChangeMap : Can't join the leader yet' try later");  	_nbTryLeft--;  	Bot.CallDelayed (6000' InternalChangeMap);  } else if (_nbTryLeft > -6) {  	MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  	Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  	if (destCell == null)  		SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  	else {  		SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  		_pivotLeaderCell = destCell.Id;  	}  	_nbTryLeft--;  	Bot.CallDelayed (2000' InternalChangeMap);  } else {  	SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  	_changingMap = false;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (_nbTryLeft > 0) {  	SendWarning ("InternalChangeMap : Can't join the leader yet' try later");  	_nbTryLeft--;  	Bot.CallDelayed (6000' InternalChangeMap);  } else if (_nbTryLeft > -6) {  	MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  	Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  	if (destCell == null)  		SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  	else {  		SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  		_pivotLeaderCell = destCell.Id;  	}  	_nbTryLeft--;  	Bot.CallDelayed (2000' InternalChangeMap);  } else {  	SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  	_changingMap = false;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (_nbTryLeft > 0) {  	SendWarning ("InternalChangeMap : Can't join the leader yet' try later");  	_nbTryLeft--;  	Bot.CallDelayed (6000' InternalChangeMap);  } else if (_nbTryLeft > -6) {  	MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  	Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  	if (destCell == null)  		SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  	else {  		SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  		_pivotLeaderCell = destCell.Id;  	}  	_nbTryLeft--;  	Bot.CallDelayed (2000' InternalChangeMap);  } else {  	SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  	_changingMap = false;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: Bot.CallDelayed (6000' InternalChangeMap);  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (_nbTryLeft > -6) {  	MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  	Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  	if (destCell == null)  		SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  	else {  		SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  		_pivotLeaderCell = destCell.Id;  	}  	_nbTryLeft--;  	Bot.CallDelayed (2000' InternalChangeMap);  } else {  	SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  	_changingMap = false;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: if (_nbTryLeft > -6) {  	MapNeighbour neighbour = Map.GetDirectionOfTransitionCell (Map.Cells [_pivotLeaderCell]);  	Cell destCell = pathFinder.FindConnectedCells (Cell' false' true' cell => (cell.Cell.MapChangeData & Map.MapChangeDatas [neighbour]) != 0).GetRandom ();  	if (destCell == null)  		SendWarning ("InternalChangeMap  : Can't join the leader' no try left. Can't even find any alternate path to go {0}"' neighbour);  	else {  		SendWarning ("InternalChangeMap : Can't join the leader' no try left. Trying alternative path to go {0} : cell {1}"' neighbour' destCell);  		_pivotLeaderCell = destCell.Id;  	}  	_nbTryLeft--;  	Bot.CallDelayed (2000' InternalChangeMap);  } else {  	SendError ("InternalChangeMap : Can't find any path to join the leader. Trying again later. ");  	_changingMap = false;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: Bot.CallDelayed (2000' InternalChangeMap);  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,InternalChangeMap,The following statement contains a magic number: Bot.CallDelayed (400' () => Bot.AddMessage (() => Bot.SendToServer (new ChangeMapMessage (_dstLeaderMap))));  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,CheckCriteria,The following statement contains a magic number: foreach (Match match in matches) {  	Debug.Assert (match.Captures.Count == 4);  	bool greater = match.Captures [2].Value == "g";  	int Value = 0;  	if (!int.TryParse (match.Captures [3].Value' out Value)) {  		logger.Error ("Weapon criteria : {0} is not an int"' match.Captures [3].Value);  		continue;  	}  	if (match.Captures [0].Value == "C") {  		switch (match.Captures [1].Value) {  		case "C":  			if (!SubCheck (greater' Stats.Chance' Value))  				return false;  			break;  		case "W":  			if (!SubCheck (greater' Stats.Wisdom' Value))  				return false;  			break;  		case "S":  			if (!SubCheck (greater' Stats.Strength' Value))  				return false;  			break;  		case "A":  			if (!SubCheck (greater' Stats.Agility' Value))  				return false;  			break;  		case "V":  			if (!SubCheck (greater' Stats.Vitality' Value))  				return false;  			break;  		case "M":  			if (!SubCheck (greater' Stats.MP' Value))  				return false;  			break;  		case "I":  			if (!SubCheck (greater' Stats.Intelligence' Value))  				return false;  			break;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,CheckCriteria,The following statement contains a magic number: foreach (Match match in matches) {  	Debug.Assert (match.Captures.Count == 4);  	bool greater = match.Captures [2].Value == "g";  	int Value = 0;  	if (!int.TryParse (match.Captures [3].Value' out Value)) {  		logger.Error ("Weapon criteria : {0} is not an int"' match.Captures [3].Value);  		continue;  	}  	if (match.Captures [0].Value == "C") {  		switch (match.Captures [1].Value) {  		case "C":  			if (!SubCheck (greater' Stats.Chance' Value))  				return false;  			break;  		case "W":  			if (!SubCheck (greater' Stats.Wisdom' Value))  				return false;  			break;  		case "S":  			if (!SubCheck (greater' Stats.Strength' Value))  				return false;  			break;  		case "A":  			if (!SubCheck (greater' Stats.Agility' Value))  				return false;  			break;  		case "V":  			if (!SubCheck (greater' Stats.Vitality' Value))  				return false;  			break;  		case "M":  			if (!SubCheck (greater' Stats.MP' Value))  				return false;  			break;  		case "I":  			if (!SubCheck (greater' Stats.Intelligence' Value))  				return false;  			break;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,CheckCriteria,The following statement contains a magic number: foreach (Match match in matches) {  	Debug.Assert (match.Captures.Count == 4);  	bool greater = match.Captures [2].Value == "g";  	int Value = 0;  	if (!int.TryParse (match.Captures [3].Value' out Value)) {  		logger.Error ("Weapon criteria : {0} is not an int"' match.Captures [3].Value);  		continue;  	}  	if (match.Captures [0].Value == "C") {  		switch (match.Captures [1].Value) {  		case "C":  			if (!SubCheck (greater' Stats.Chance' Value))  				return false;  			break;  		case "W":  			if (!SubCheck (greater' Stats.Wisdom' Value))  				return false;  			break;  		case "S":  			if (!SubCheck (greater' Stats.Strength' Value))  				return false;  			break;  		case "A":  			if (!SubCheck (greater' Stats.Agility' Value))  				return false;  			break;  		case "V":  			if (!SubCheck (greater' Stats.Vitality' Value))  				return false;  			break;  		case "M":  			if (!SubCheck (greater' Stats.MP' Value))  				return false;  			break;  		case "I":  			if (!SubCheck (greater' Stats.Intelligence' Value))  				return false;  			break;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,CheckCriteria,The following statement contains a magic number: foreach (Match match in matches) {  	Debug.Assert (match.Captures.Count == 4);  	bool greater = match.Captures [2].Value == "g";  	int Value = 0;  	if (!int.TryParse (match.Captures [3].Value' out Value)) {  		logger.Error ("Weapon criteria : {0} is not an int"' match.Captures [3].Value);  		continue;  	}  	if (match.Captures [0].Value == "C") {  		switch (match.Captures [1].Value) {  		case "C":  			if (!SubCheck (greater' Stats.Chance' Value))  				return false;  			break;  		case "W":  			if (!SubCheck (greater' Stats.Wisdom' Value))  				return false;  			break;  		case "S":  			if (!SubCheck (greater' Stats.Strength' Value))  				return false;  			break;  		case "A":  			if (!SubCheck (greater' Stats.Agility' Value))  				return false;  			break;  		case "V":  			if (!SubCheck (greater' Stats.Vitality' Value))  				return false;  			break;  		case "M":  			if (!SubCheck (greater' Stats.MP' Value))  				return false;  			break;  		case "I":  			if (!SubCheck (greater' Stats.Intelligence' Value))  				return false;  			break;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,CheckCriteria,The following statement contains a magic number: Debug.Assert (match.Captures.Count == 4);  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,CheckCriteria,The following statement contains a magic number: if (!int.TryParse (match.Captures [3].Value' out Value)) {  	logger.Error ("Weapon criteria : {0} is not an int"' match.Captures [3].Value);  	continue;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,CheckCriteria,The following statement contains a magic number: if (!int.TryParse (match.Captures [3].Value' out Value)) {  	logger.Error ("Weapon criteria : {0} is not an int"' match.Captures [3].Value);  	continue;  }  
Magic Number,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,CheckCriteria,The following statement contains a magic number: logger.Error ("Weapon criteria : {0} is not an int"' match.Captures [3].Value);  
Magic Number,BiM.Behaviors.Game.Effects,EffectBase,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectBase.AI.cs,canAffectTarget,The following statement contains a magic number: if (spell.LevelTemplate.spellBreed == (uint)BreedEnum.Eniripsa && spell.Categories == Spell.SpellCategory.Healing && caster.HasState (76))  	return false;  
Magic Number,BiM.Behaviors.Game.Effects,EffectCreature,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectCreature.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return (base.GetHashCode () * 397) ^ m_monsterfamily.GetHashCode ();  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectCreature,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectCreature.cs,GetHashCode,The following statement contains a magic number: return (base.GetHashCode () * 397) ^ m_monsterfamily.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,FixDate,The following statement contains a magic number: if (m_year > 9999)  	m_year = 9999;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,FixDate,The following statement contains a magic number: if (m_year > 9999)  	m_year = 9999;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,FixDate,The following statement contains a magic number: m_year = 9999;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,FixDate,The following statement contains a magic number: if (m_month > 12)  	m_month = 12;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,FixDate,The following statement contains a magic number: if (m_month > 12)  	m_month = 12;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,FixDate,The following statement contains a magic number: m_month = 12;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,FixDate,The following statement contains a magic number: if (m_day > 31)  	m_day = 31;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,FixDate,The following statement contains a magic number: if (m_day > 31)  	m_day = 31;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,FixDate,The following statement contains a magic number: m_day = 31;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_day.GetHashCode ();  	result = (result * 397) ^ m_hour.GetHashCode ();  	result = (result * 397) ^ m_minute.GetHashCode ();  	result = (result * 397) ^ m_month.GetHashCode ();  	result = (result * 397) ^ m_year.GetHashCode ();  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_day.GetHashCode ();  	result = (result * 397) ^ m_hour.GetHashCode ();  	result = (result * 397) ^ m_minute.GetHashCode ();  	result = (result * 397) ^ m_month.GetHashCode ();  	result = (result * 397) ^ m_year.GetHashCode ();  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_day.GetHashCode ();  	result = (result * 397) ^ m_hour.GetHashCode ();  	result = (result * 397) ^ m_minute.GetHashCode ();  	result = (result * 397) ^ m_month.GetHashCode ();  	result = (result * 397) ^ m_year.GetHashCode ();  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_day.GetHashCode ();  	result = (result * 397) ^ m_hour.GetHashCode ();  	result = (result * 397) ^ m_minute.GetHashCode ();  	result = (result * 397) ^ m_month.GetHashCode ();  	result = (result * 397) ^ m_year.GetHashCode ();  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_day.GetHashCode ();  	result = (result * 397) ^ m_hour.GetHashCode ();  	result = (result * 397) ^ m_minute.GetHashCode ();  	result = (result * 397) ^ m_month.GetHashCode ();  	result = (result * 397) ^ m_year.GetHashCode ();  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_day.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_hour.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_minute.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_month.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectDate,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDate.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_year.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectDice,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDice.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_diceface;  	result = (result * 397) ^ m_dicenum;  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectDice,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDice.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_diceface;  	result = (result * 397) ^ m_dicenum;  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectDice,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDice.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_diceface;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDice,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDice.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_dicenum;  
Magic Number,BiM.Behaviors.Game.Effects,EffectDuration,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDuration.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_days.GetHashCode ();  	result = (result * 397) ^ m_hours.GetHashCode ();  	result = (result * 397) ^ m_minutes.GetHashCode ();  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectDuration,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDuration.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_days.GetHashCode ();  	result = (result * 397) ^ m_hours.GetHashCode ();  	result = (result * 397) ^ m_minutes.GetHashCode ();  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectDuration,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDuration.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_days.GetHashCode ();  	result = (result * 397) ^ m_hours.GetHashCode ();  	result = (result * 397) ^ m_minutes.GetHashCode ();  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectDuration,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDuration.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_days.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectDuration,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDuration.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_hours.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectDuration,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectDuration.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_minutes.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectInteger,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectInteger.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return (base.GetHashCode () * 397) ^ m_value.GetHashCode ();  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectInteger,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectInteger.cs,GetHashCode,The following statement contains a magic number: return (base.GetHashCode () * 397) ^ m_value.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectLadder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectLadder.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return (base.GetHashCode () * 397) ^ m_monsterCount.GetHashCode ();  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectLadder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectLadder.cs,GetHashCode,The following statement contains a magic number: return (base.GetHashCode () * 397) ^ m_monsterCount.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectMinMax,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMinMax.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_maxvalue.GetHashCode ();  	result = (result * 397) ^ m_minvalue.GetHashCode ();  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectMinMax,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMinMax.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_maxvalue.GetHashCode ();  	result = (result * 397) ^ m_minvalue.GetHashCode ();  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectMinMax,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMinMax.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_maxvalue.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectMinMax,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMinMax.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_minvalue.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectMount,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMount.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_date.GetHashCode ();  	result = (result * 397) ^ m_modelId;  	result = (result * 397) ^ m_mountId;  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectMount,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMount.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_date.GetHashCode ();  	result = (result * 397) ^ m_modelId;  	result = (result * 397) ^ m_mountId;  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectMount,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMount.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = base.GetHashCode ();  	result = (result * 397) ^ m_date.GetHashCode ();  	result = (result * 397) ^ m_modelId;  	result = (result * 397) ^ m_mountId;  	return result;  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectMount,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMount.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_date.GetHashCode ();  
Magic Number,BiM.Behaviors.Game.Effects,EffectMount,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMount.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_modelId;  
Magic Number,BiM.Behaviors.Game.Effects,EffectMount,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectMount.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ m_mountId;  
Magic Number,BiM.Behaviors.Game.Effects,EffectString,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectString.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return (base.GetHashCode () * 397) ^ (m_value != null ? m_value.GetHashCode () : 0);  }  
Magic Number,BiM.Behaviors.Game.Effects,EffectString,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Effects\EffectString.cs,GetHashCode,The following statement contains a magic number: return (base.GetHashCode () * 397) ^ (m_value != null ? m_value.GetHashCode () : 0);  
Magic Number,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelEffect,The following statement contains a magic number: foreach (var effectList in Effects)  	foreach (var effectT in effectList.Value.ToArray ())  		if (effectT.Item1.uid == boostUid && effectT.Item1.targetId == targetId && effectT.Item1.dispelable != 2) {  			if (fighter is PlayedFighter) {  				PlayedFighter playedFighter = fighter as PlayedFighter;  				Spell spell = new Spell (new SpellItem (0' effectT.Item1.spellId' 1));  				playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable);  			}  			Effects [effectList.Key].Remove (effectT);  		}  
Magic Number,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelEffect,The following statement contains a magic number: foreach (var effectT in effectList.Value.ToArray ())  	if (effectT.Item1.uid == boostUid && effectT.Item1.targetId == targetId && effectT.Item1.dispelable != 2) {  		if (fighter is PlayedFighter) {  			PlayedFighter playedFighter = fighter as PlayedFighter;  			Spell spell = new Spell (new SpellItem (0' effectT.Item1.spellId' 1));  			playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable);  		}  		Effects [effectList.Key].Remove (effectT);  	}  
Magic Number,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelEffect,The following statement contains a magic number: if (effectT.Item1.uid == boostUid && effectT.Item1.targetId == targetId && effectT.Item1.dispelable != 2) {  	if (fighter is PlayedFighter) {  		PlayedFighter playedFighter = fighter as PlayedFighter;  		Spell spell = new Spell (new SpellItem (0' effectT.Item1.spellId' 1));  		playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable);  	}  	Effects [effectList.Key].Remove (effectT);  }  
Magic Number,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelTarget,The following statement contains a magic number: foreach (var effectList in Effects)  	foreach (var effectT in effectList.Value.ToArray ())  		if (effectT.Item1.targetId == targetId && effectT.Item1.dispelable != 2) {  			if (fighter is PlayedFighter) {  				PlayedFighter playedFighter = fighter as PlayedFighter;  				Spell spell = new Spell (new SpellItem (0' effectT.Item1.spellId' 1));  				playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable);  			}  			Effects [effectList.Key].Remove (effectT);  		}  
Magic Number,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelTarget,The following statement contains a magic number: foreach (var effectT in effectList.Value.ToArray ())  	if (effectT.Item1.targetId == targetId && effectT.Item1.dispelable != 2) {  		if (fighter is PlayedFighter) {  			PlayedFighter playedFighter = fighter as PlayedFighter;  			Spell spell = new Spell (new SpellItem (0' effectT.Item1.spellId' 1));  			playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable);  		}  		Effects [effectList.Key].Remove (effectT);  	}  
Magic Number,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelTarget,The following statement contains a magic number: if (effectT.Item1.targetId == targetId && effectT.Item1.dispelable != 2) {  	if (fighter is PlayedFighter) {  		PlayedFighter playedFighter = fighter as PlayedFighter;  		Spell spell = new Spell (new SpellItem (0' effectT.Item1.spellId' 1));  		playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable);  	}  	Effects [effectList.Key].Remove (effectT);  }  
Magic Number,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelSpell,The following statement contains a magic number: foreach (var effectList in Effects)  	foreach (var effectT in effectList.Value.ToArray ())  		if (effectT.Item1.targetId == targetId && effectT.Item1.spellId == spellId && effectT.Item1.dispelable != 2) {  			if (fighter is PlayedFighter) {  				PlayedFighter playedFighter = fighter as PlayedFighter;  				Spell spell = new Spell (new SpellItem (0' effectT.Item1.spellId' 1));  				playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable);  			}  			Effects [effectList.Key].Remove (effectT);  		}  
Magic Number,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelSpell,The following statement contains a magic number: foreach (var effectT in effectList.Value.ToArray ())  	if (effectT.Item1.targetId == targetId && effectT.Item1.spellId == spellId && effectT.Item1.dispelable != 2) {  		if (fighter is PlayedFighter) {  			PlayedFighter playedFighter = fighter as PlayedFighter;  			Spell spell = new Spell (new SpellItem (0' effectT.Item1.spellId' 1));  			playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable);  		}  		Effects [effectList.Key].Remove (effectT);  	}  
Magic Number,BiM.Behaviors.Game.Fights,Fight,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\Fight.cs,DispelSpell,The following statement contains a magic number: if (effectT.Item1.targetId == targetId && effectT.Item1.spellId == spellId && effectT.Item1.dispelable != 2) {  	if (fighter is PlayedFighter) {  		PlayedFighter playedFighter = fighter as PlayedFighter;  		Spell spell = new Spell (new SpellItem (0' effectT.Item1.spellId' 1));  		playedFighter.Character.SendInformation ("Effect {0} from spell {1} dispeled (dispelable : {2})"' (EffectsEnum)effectT.Item1.TypeId' spell.Name' effectT.Item1.dispelable);  	}  	Effects [effectList.Key].Remove (effectT);  }  
Magic Number,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,IsFish,The following statement contains a magic number: return m_disabledSkills.Any (skill => skill.JobSkill.parentJobId == 36) || m_enabledSkills.Any (skill => skill.JobSkill.parentJobId == 36);  
Magic Number,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,IsFish,The following statement contains a magic number: return m_disabledSkills.Any (skill => skill.JobSkill.parentJobId == 36) || m_enabledSkills.Any (skill => skill.JobSkill.parentJobId == 36);  
Magic Number,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,GetAdjacentCells,The following statement contains a magic number: if (IsForJob (BiM.Behaviors.Game.Jobs.Job.FISHER)) {  	return Cell.GetCellsInDirections (new DirectionsEnum[] {  		DirectionsEnum.DIRECTION_NORTH_EAST'  		DirectionsEnum.DIRECTION_NORTH_WEST'  		DirectionsEnum.DIRECTION_SOUTH_WEST'  		DirectionsEnum.DIRECTION_SOUTH_EAST  	}' 1' 3).Where (cell => Map.CanStopOnCell (cell) && Map.CanBeSeen (cell' Cell)).ToArray ();  } else {  	return Cell.GetAdjacentCells (x => Map.CanStopOnCell (x)' true).ToArray ();  }  
Magic Number,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,GetAdjacentCells,The following statement contains a magic number: return Cell.GetCellsInDirections (new DirectionsEnum[] {  	DirectionsEnum.DIRECTION_NORTH_EAST'  	DirectionsEnum.DIRECTION_NORTH_WEST'  	DirectionsEnum.DIRECTION_SOUTH_WEST'  	DirectionsEnum.DIRECTION_SOUTH_EAST  }' 1' 3).Where (cell => Map.CanStopOnCell (cell) && Map.CanBeSeen (cell' Cell)).ToArray ();  
Magic Number,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,IsAdjacentTo,The following statement contains a magic number: if (IsForJob (BiM.Behaviors.Game.Jobs.Job.FISHER)) {  	return Map.CanStopOnCell (cell) && cell.ManhattanDistanceTo (Cell) < 4 && cell.X == Cell.X && cell.Y == Cell.Y && Map.CanStopOnCell (cell);  } else {  	return cell.IsAdjacentTo (Cell' true);  }  
Magic Number,BiM.Behaviors.Game.Interactives,InteractiveObject,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Interactives\InteractiveObject.cs,IsAdjacentTo,The following statement contains a magic number: return Map.CanStopOnCell (cell) && cell.ManhattanDistanceTo (Cell) < 4 && cell.X == Cell.X && cell.Y == Cell.Y && Map.CanStopOnCell (cell);  
Magic Number,BiM.Behaviors.Game.Items,Inventory,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Items\Inventory.AI.cs,EquipBestWeaponIfNeeded,The following statement contains a magic number: foreach (BiM.Behaviors.Game.Items.Item item in GetItems (ItemSuperTypeEnum.SUPERTYPE_WEAPON).Union (GetItems (ItemSuperTypeEnum.SUPERTYPE_WEAPON_7)).OrderByDescending (item => item.Level * 10 + item.PowerRate)) {  	if (!item.IsWeapon)  		continue;  	Protocol.Data.Item wpn = item.Template;  	if (wpn.cursed || wpn.etheral)  		continue;  	// Better don't equip this  	if (!item.CheckCriteria (Owner))  		continue;  	// Not the stats to use it  	if (Owner.Level < wpn.level)  		continue;  	// not the level to use it  	if (Equip (item))  		return true;  }  
Magic Number,BiM.Behaviors.Game.Movements,TimedPath,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Movements\TimedPath.cs,Create,The following statement contains a magic number: for (int i = 0; i < cells.Length; i++) {  	int direction;  	if (i + 1 < cells.Length)  		direction = (int)cells [i].OrientationToAdjacent (cells [i + 1]);  	else  		direction = (int)cells [i - 1].OrientationToAdjacent (cells [i]);  	double velocity;  	if (direction % 4 == 0)  		velocity = hVelocity;  	else if (direction % 2 == 0)  		velocity = vVelocity;  	else  		velocity = lVelocity;  	var end = lastCellTime + TimeSpan.FromMilliseconds (1 / velocity);  	result.Add (new TimedPathElement (cells [i]' i + 1 < cells.Length ? cells [i + 1] : null' lastCellTime' end' velocity' (DirectionsEnum)direction));  	lastCellTime = end;  }  
Magic Number,BiM.Behaviors.Game.Movements,TimedPath,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Movements\TimedPath.cs,Create,The following statement contains a magic number: for (int i = 0; i < cells.Length; i++) {  	int direction;  	if (i + 1 < cells.Length)  		direction = (int)cells [i].OrientationToAdjacent (cells [i + 1]);  	else  		direction = (int)cells [i - 1].OrientationToAdjacent (cells [i]);  	double velocity;  	if (direction % 4 == 0)  		velocity = hVelocity;  	else if (direction % 2 == 0)  		velocity = vVelocity;  	else  		velocity = lVelocity;  	var end = lastCellTime + TimeSpan.FromMilliseconds (1 / velocity);  	result.Add (new TimedPathElement (cells [i]' i + 1 < cells.Length ? cells [i + 1] : null' lastCellTime' end' velocity' (DirectionsEnum)direction));  	lastCellTime = end;  }  
Magic Number,BiM.Behaviors.Game.Movements,TimedPath,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Movements\TimedPath.cs,Create,The following statement contains a magic number: if (direction % 4 == 0)  	velocity = hVelocity;  else if (direction % 2 == 0)  	velocity = vVelocity;  else  	velocity = lVelocity;  
Magic Number,BiM.Behaviors.Game.Movements,TimedPath,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Movements\TimedPath.cs,Create,The following statement contains a magic number: if (direction % 4 == 0)  	velocity = hVelocity;  else if (direction % 2 == 0)  	velocity = vVelocity;  else  	velocity = lVelocity;  
Magic Number,BiM.Behaviors.Game.Movements,TimedPath,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Movements\TimedPath.cs,Create,The following statement contains a magic number: if (direction % 2 == 0)  	velocity = vVelocity;  else  	velocity = lVelocity;  
Magic Number,BiM.Behaviors.Game.Spells.Shapes,Zone,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Zone.cs,Zone,The following statement contains a magic number: if (rawZone.Length > 1) {  	rawZone = rawZone.Remove (0' 1);  	string[] splitted = rawZone.Split (''');  	if (splitted.Length >= 1)  		Radius = byte.Parse (splitted [0]);  	if (splitted.Length >= 2)  		MinRadius = byte.Parse (splitted [1]);  }  
Magic Number,BiM.Behaviors.Game.Spells.Shapes,Zone,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Zone.cs,Zone,The following statement contains a magic number: if (splitted.Length >= 2)  	MinRadius = byte.Parse (splitted [1]);  
Magic Number,BiM.Behaviors.Game.Spells.Shapes,Zone,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Zone.cs,InitializeShape,The following statement contains a magic number: switch (ShapeType) {  case SpellShapeEnum.X:  	m_shape = new Cross (0' Radius);  	break;  case SpellShapeEnum.L:  	m_shape = new Line (Radius);  	break;  case SpellShapeEnum.T:  	m_shape = new Cross (0' Radius) {  		OnlyPerpendicular = true  	};  	break;  case SpellShapeEnum.D:  	m_shape = new Cross (0' Radius);  	break;  case SpellShapeEnum.C:  	m_shape = new Lozenge (0' Radius);  	break;  case SpellShapeEnum.I:  	m_shape = new Lozenge (Radius' 63);  	break;  case SpellShapeEnum.O:  	m_shape = new Cross (1' Radius);  	break;  case SpellShapeEnum.Q:  	m_shape = new Cross (1' Radius);  	break;  case SpellShapeEnum.V:  	m_shape = new Cone (0' Radius);  	break;  case SpellShapeEnum.W:  	m_shape = new Square (0' Radius) {  		DiagonalFree = true  	};  	break;  case SpellShapeEnum.plus:  	m_shape = new Cross (0' Radius) {  		Diagonal = true  	};  	break;  case SpellShapeEnum.sharp:  	m_shape = new Cross (1' Radius) {  		Diagonal = true  	};  	break;  case SpellShapeEnum.star:  	m_shape = new Cross (0' Radius) {  		AllDirections = true  	};  	break;  case SpellShapeEnum.slash:  	m_shape = new Line (Radius);  	break;  case SpellShapeEnum.U:  	m_shape = new HalfLozenge (0' Radius);  	break;  case SpellShapeEnum.A:  	m_shape = new Lozenge (0' 63);  	break;  case SpellShapeEnum.P:  	m_shape = new Single ();  	break;  default:  	m_shape = new Cross (0' 0);  	break;  }  
Magic Number,BiM.Behaviors.Game.Spells.Shapes,Zone,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Zone.cs,InitializeShape,The following statement contains a magic number: switch (ShapeType) {  case SpellShapeEnum.X:  	m_shape = new Cross (0' Radius);  	break;  case SpellShapeEnum.L:  	m_shape = new Line (Radius);  	break;  case SpellShapeEnum.T:  	m_shape = new Cross (0' Radius) {  		OnlyPerpendicular = true  	};  	break;  case SpellShapeEnum.D:  	m_shape = new Cross (0' Radius);  	break;  case SpellShapeEnum.C:  	m_shape = new Lozenge (0' Radius);  	break;  case SpellShapeEnum.I:  	m_shape = new Lozenge (Radius' 63);  	break;  case SpellShapeEnum.O:  	m_shape = new Cross (1' Radius);  	break;  case SpellShapeEnum.Q:  	m_shape = new Cross (1' Radius);  	break;  case SpellShapeEnum.V:  	m_shape = new Cone (0' Radius);  	break;  case SpellShapeEnum.W:  	m_shape = new Square (0' Radius) {  		DiagonalFree = true  	};  	break;  case SpellShapeEnum.plus:  	m_shape = new Cross (0' Radius) {  		Diagonal = true  	};  	break;  case SpellShapeEnum.sharp:  	m_shape = new Cross (1' Radius) {  		Diagonal = true  	};  	break;  case SpellShapeEnum.star:  	m_shape = new Cross (0' Radius) {  		AllDirections = true  	};  	break;  case SpellShapeEnum.slash:  	m_shape = new Line (Radius);  	break;  case SpellShapeEnum.U:  	m_shape = new HalfLozenge (0' Radius);  	break;  case SpellShapeEnum.A:  	m_shape = new Lozenge (0' 63);  	break;  case SpellShapeEnum.P:  	m_shape = new Single ();  	break;  default:  	m_shape = new Cross (0' 0);  	break;  }  
Magic Number,BiM.Behaviors.Game.Spells.Shapes,Zone,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Zone.cs,InitializeShape,The following statement contains a magic number: m_shape = new Lozenge (Radius' 63);  
Magic Number,BiM.Behaviors.Game.Spells.Shapes,Zone,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Zone.cs,InitializeShape,The following statement contains a magic number: m_shape = new Lozenge (0' 63);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetDamageReflection,The following statement contains a magic number: foreach (var effect in target.GetFightTriggeredEffects ((short)EffectsEnum.Effect_AddDamageReflection))  	reflect += effect.arg3 + effect.arg1 * (1 + effect.arg2) / 2;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetDamageReflection,The following statement contains a magic number: reflect += effect.arg3 + effect.arg1 * (1 + effect.arg2) / 2;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetDamageReflection,The following statement contains a magic number: return reflect * (1 + target.Level * 0.05);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The following statement contains a magic number: if (reduceDamagePercent >= 100)  	return;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The following statement contains a magic number: minDamage = (DamageType)(((minDamage * (1 + (addDamagePercent / 100.0)) + addDamage) - reduceDamage) * (1 - (reduceDamagePercent / 100.0)) * chanceToHappen);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The following statement contains a magic number: minDamage = (DamageType)(((minDamage * (1 + (addDamagePercent / 100.0)) + addDamage) - reduceDamage) * (1 - (reduceDamagePercent / 100.0)) * chanceToHappen);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The following statement contains a magic number: maxDamage = (DamageType)(((maxDamage * (1 + (addDamagePercent / 100.0)) + addDamage) - reduceDamage) * (1 - (reduceDamagePercent / 100.0)) * chanceToHappen);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The following statement contains a magic number: maxDamage = (DamageType)(((maxDamage * (1 + (addDamagePercent / 100.0)) + addDamage) - reduceDamage) * (1 - (reduceDamagePercent / 100.0)) * chanceToHappen);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The following statement contains a magic number: if (negativ)// or IsFriend   {  	minDamage *= -1.5;  	// High penalty for firing on friends  	maxDamage *= -1.5;  	// High penalty for firing on friends  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The following statement contains a magic number: if (negativ)// or IsFriend   {  	minDamage *= -1.5;  	// High penalty for firing on friends  	maxDamage *= -1.5;  	// High penalty for firing on friends  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The following statement contains a magic number: minDamage *= -1.5;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The following statement contains a magic number: maxDamage *= -1.5;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,IsMaitrise,The following statement contains a magic number: if (Template.typeId == 23)  	// Maîtrise  	return (weaponType == null || LevelTemplate.effects [0].diceNum == weaponType);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (effect.random > 0)  	chanceToHappen = effect.random / 100.0;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: chanceToHappen = effect.random / 100.0;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (target.Summoned && (caster.Breed.Id != (int)BreedEnum.Osamodas || target.Team.Id != caster.Team.Id))  	chanceToHappen /= 2;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: chanceToHappen /= 2;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if ((category & SpellCategory.Healing) > 0) {  	bool steal = (category & SpellCategory.Damages) > 0;  	if (steal)  		target = caster;  	// Probably hp steal  	uint hptoHeal = (uint)(Math.Max (0' target.Stats.MaxHealth - target.Stats.Health));  	// Can't heal over max  	if (steal) {  		result.MinHeal = -Math.Min (hptoHeal' Math.Abs (result.MinDamage));  		result.MaxHeal = -Math.Min (hptoHeal' Math.Abs (result.MaxDamage));  	} else {  		bool skip = false;  		if (spell.Template.id == 140)// Mot de reconstruction => do only use it on purpose  		 {  			if (hptoHeal < target.Stats.Health || hptoHeal < 400)  				skip = true;  			// Only heal targets with under 50% of health and at least 400 hp to heal  		}  		if (!skip && hptoHeal > 0) {  			AdjustDamage (result' Math.Min (effect.diceNum' hptoHeal)' Math.Min (effect.diceSide' hptoHeal)' SpellCategory.Healing' chanceToHappen' GetSafetotal (caster' Stats.PlayerField.HealBonus)' GetSafetotal (caster' Stats.PlayerField.Intelligence)' 0' 0' isFriend);  			if (result.Heal > hptoHeal)  				if (isFriend)  					result.MinHeal = result.MaxHeal = -hptoHeal;  				else  					result.MinHeal = result.MaxHeal = hptoHeal;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if ((category & SpellCategory.Healing) > 0) {  	bool steal = (category & SpellCategory.Damages) > 0;  	if (steal)  		target = caster;  	// Probably hp steal  	uint hptoHeal = (uint)(Math.Max (0' target.Stats.MaxHealth - target.Stats.Health));  	// Can't heal over max  	if (steal) {  		result.MinHeal = -Math.Min (hptoHeal' Math.Abs (result.MinDamage));  		result.MaxHeal = -Math.Min (hptoHeal' Math.Abs (result.MaxDamage));  	} else {  		bool skip = false;  		if (spell.Template.id == 140)// Mot de reconstruction => do only use it on purpose  		 {  			if (hptoHeal < target.Stats.Health || hptoHeal < 400)  				skip = true;  			// Only heal targets with under 50% of health and at least 400 hp to heal  		}  		if (!skip && hptoHeal > 0) {  			AdjustDamage (result' Math.Min (effect.diceNum' hptoHeal)' Math.Min (effect.diceSide' hptoHeal)' SpellCategory.Healing' chanceToHappen' GetSafetotal (caster' Stats.PlayerField.HealBonus)' GetSafetotal (caster' Stats.PlayerField.Intelligence)' 0' 0' isFriend);  			if (result.Heal > hptoHeal)  				if (isFriend)  					result.MinHeal = result.MaxHeal = -hptoHeal;  				else  					result.MinHeal = result.MaxHeal = hptoHeal;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (steal) {  	result.MinHeal = -Math.Min (hptoHeal' Math.Abs (result.MinDamage));  	result.MaxHeal = -Math.Min (hptoHeal' Math.Abs (result.MaxDamage));  } else {  	bool skip = false;  	if (spell.Template.id == 140)// Mot de reconstruction => do only use it on purpose  	 {  		if (hptoHeal < target.Stats.Health || hptoHeal < 400)  			skip = true;  		// Only heal targets with under 50% of health and at least 400 hp to heal  	}  	if (!skip && hptoHeal > 0) {  		AdjustDamage (result' Math.Min (effect.diceNum' hptoHeal)' Math.Min (effect.diceSide' hptoHeal)' SpellCategory.Healing' chanceToHappen' GetSafetotal (caster' Stats.PlayerField.HealBonus)' GetSafetotal (caster' Stats.PlayerField.Intelligence)' 0' 0' isFriend);  		if (result.Heal > hptoHeal)  			if (isFriend)  				result.MinHeal = result.MaxHeal = -hptoHeal;  			else  				result.MinHeal = result.MaxHeal = hptoHeal;  	}  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (steal) {  	result.MinHeal = -Math.Min (hptoHeal' Math.Abs (result.MinDamage));  	result.MaxHeal = -Math.Min (hptoHeal' Math.Abs (result.MaxDamage));  } else {  	bool skip = false;  	if (spell.Template.id == 140)// Mot de reconstruction => do only use it on purpose  	 {  		if (hptoHeal < target.Stats.Health || hptoHeal < 400)  			skip = true;  		// Only heal targets with under 50% of health and at least 400 hp to heal  	}  	if (!skip && hptoHeal > 0) {  		AdjustDamage (result' Math.Min (effect.diceNum' hptoHeal)' Math.Min (effect.diceSide' hptoHeal)' SpellCategory.Healing' chanceToHappen' GetSafetotal (caster' Stats.PlayerField.HealBonus)' GetSafetotal (caster' Stats.PlayerField.Intelligence)' 0' 0' isFriend);  		if (result.Heal > hptoHeal)  			if (isFriend)  				result.MinHeal = result.MaxHeal = -hptoHeal;  			else  				result.MinHeal = result.MaxHeal = hptoHeal;  	}  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (spell.Template.id == 140)// Mot de reconstruction => do only use it on purpose   {  	if (hptoHeal < target.Stats.Health || hptoHeal < 400)  		skip = true;  	// Only heal targets with under 50% of health and at least 400 hp to heal  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (spell.Template.id == 140)// Mot de reconstruction => do only use it on purpose   {  	if (hptoHeal < target.Stats.Health || hptoHeal < 400)  		skip = true;  	// Only heal targets with under 50% of health and at least 400 hp to heal  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (hptoHeal < target.Stats.Health || hptoHeal < 400)  	skip = true;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if ((category & SpellCategory.Curse) > 0) {  	DamageType ratio = spell.Level * chanceToHappen;  	if (effect.effectId == (int)EffectsEnum.Effect_SkipTurn)  		// Let say this effect counts as 2 damage per level of the target  		ratio = target.Level * 2 * chanceToHappen;  	if (isFriend)  		result.Curse -= 2 * ratio;  	else  		result.Curse += ratio;  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if ((category & SpellCategory.Curse) > 0) {  	DamageType ratio = spell.Level * chanceToHappen;  	if (effect.effectId == (int)EffectsEnum.Effect_SkipTurn)  		// Let say this effect counts as 2 damage per level of the target  		ratio = target.Level * 2 * chanceToHappen;  	if (isFriend)  		result.Curse -= 2 * ratio;  	else  		result.Curse += ratio;  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (effect.effectId == (int)EffectsEnum.Effect_SkipTurn)  	// Let say this effect counts as 2 damage per level of the target  	ratio = target.Level * 2 * chanceToHappen;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: ratio = target.Level * 2 * chanceToHappen;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (isFriend)  	result.Curse -= 2 * ratio;  else  	result.Curse += ratio;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: result.Curse -= 2 * ratio;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (!isFriend && ((category & SpellCategory.Damages) > 0) && result.MinDamage > target.Stats.Health)// Enough damage to kill the target => affect an arbitrary 50% of max heal (with at least current health)' so strong spells are not favored anymore.    {  	double ratio = Math.Max (target.Stats.MaxHealth / 2' target.Stats.Health) / result.MinDamage;  	result.Multiply (ratio);  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (spell.Template.id == 114)// Rekop   {  	if (target.Stats.Health < 1000)  		result.Multiply (0.1);  	else if (target.Stats.Health < 2000)  		result.Multiply (0.5);  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (spell.Template.id == 114)// Rekop   {  	if (target.Stats.Health < 1000)  		result.Multiply (0.1);  	else if (target.Stats.Health < 2000)  		result.Multiply (0.5);  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (spell.Template.id == 114)// Rekop   {  	if (target.Stats.Health < 1000)  		result.Multiply (0.1);  	else if (target.Stats.Health < 2000)  		result.Multiply (0.5);  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (spell.Template.id == 114)// Rekop   {  	if (target.Stats.Health < 1000)  		result.Multiply (0.1);  	else if (target.Stats.Health < 2000)  		result.Multiply (0.5);  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (spell.Template.id == 114)// Rekop   {  	if (target.Stats.Health < 1000)  		result.Multiply (0.1);  	else if (target.Stats.Health < 2000)  		result.Multiply (0.5);  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (target.Stats.Health < 1000)  	result.Multiply (0.1);  else if (target.Stats.Health < 2000)  	result.Multiply (0.5);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (target.Stats.Health < 1000)  	result.Multiply (0.1);  else if (target.Stats.Health < 2000)  	result.Multiply (0.5);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (target.Stats.Health < 1000)  	result.Multiply (0.1);  else if (target.Stats.Health < 2000)  	result.Multiply (0.5);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (target.Stats.Health < 1000)  	result.Multiply (0.1);  else if (target.Stats.Health < 2000)  	result.Multiply (0.5);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: result.Multiply (0.1);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (target.Stats.Health < 2000)  	result.Multiply (0.5);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (target.Stats.Health < 2000)  	result.Multiply (0.5);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: result.Multiply (0.5);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (((category & SpellCategory.Damages) > 0) && result.Damage > 0 && !isFriend) {  	DamageType reflected = spell.GetDamageReflection (target);  	if (reflected > 0) {  		if (reflected >= spellImpact.Damage)  			return 0;  		// Reflect all damages  		result.MinHeal += reflected * 2;  		result.MaxHeal += reflected * 2;  	}  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (((category & SpellCategory.Damages) > 0) && result.Damage > 0 && !isFriend) {  	DamageType reflected = spell.GetDamageReflection (target);  	if (reflected > 0) {  		if (reflected >= spellImpact.Damage)  			return 0;  		// Reflect all damages  		result.MinHeal += reflected * 2;  		result.MaxHeal += reflected * 2;  	}  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (reflected > 0) {  	if (reflected >= spellImpact.Damage)  		return 0;  	// Reflect all damages  	result.MinHeal += reflected * 2;  	result.MaxHeal += reflected * 2;  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (reflected > 0) {  	if (reflected >= spellImpact.Damage)  		return 0;  	// Reflect all damages  	result.MinHeal += reflected * 2;  	result.MaxHeal += reflected * 2;  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: result.MinHeal += reflected * 2;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: result.MaxHeal += reflected * 2;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (spell.Template.id == 0 && (category & SpellCategory.Damages) > 0)// Weapon => consider effect of "maîtrise"   {  	Weapon weapon = caster.Character.Inventory.GetEquippedWeapon ();  	if (weapon != null)  		foreach (var boost in caster.GetBoostWeaponDamagesEffects ())  			if (boost.weaponTypeId == weapon.typeId)  				result.Multiply (1.0 + boost.delta / 100.0);  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (weapon != null)  	foreach (var boost in caster.GetBoostWeaponDamagesEffects ())  		if (boost.weaponTypeId == weapon.typeId)  			result.Multiply (1.0 + boost.delta / 100.0);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: foreach (var boost in caster.GetBoostWeaponDamagesEffects ())  	if (boost.weaponTypeId == weapon.typeId)  		result.Multiply (1.0 + boost.delta / 100.0);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: if (boost.weaponTypeId == weapon.typeId)  	result.Multiply (1.0 + boost.delta / 100.0);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,CumulEffects,The following statement contains a magic number: result.Multiply (1.0 + boost.delta / 100.0);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The following statement contains a magic number: if (Template.id == 139)// Mot d'altruisme : only use near end of fight or if lot of spellImpact to heal   {  	int hpLeftOnFoes = actors.Where (actor => actor.Team.Id != pc.Team.Id).Sum (actor => actor.Stats.Health);  	comment += string.Format (" - special \"Mot d'altruisme\" processing : hpLeftOnFoes = {0}' efficiency = {1}"' hpLeftOnFoes' (int)spellImpact.Damage);  	if (hpLeftOnFoes > 500)  		// Not the end of the fight  		if (spellImpact.Damage < 300)  			return 0;  		// Do not cast it if less than 300 hp of healing  		else  			return (int)spellImpact.Damage / 3;  	// Otherwise' far from the end of the fight' divide efficiency by 3                  	// if close to the end of the fight' then returns full result.   }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The following statement contains a magic number: if (Template.id == 139)// Mot d'altruisme : only use near end of fight or if lot of spellImpact to heal   {  	int hpLeftOnFoes = actors.Where (actor => actor.Team.Id != pc.Team.Id).Sum (actor => actor.Stats.Health);  	comment += string.Format (" - special \"Mot d'altruisme\" processing : hpLeftOnFoes = {0}' efficiency = {1}"' hpLeftOnFoes' (int)spellImpact.Damage);  	if (hpLeftOnFoes > 500)  		// Not the end of the fight  		if (spellImpact.Damage < 300)  			return 0;  		// Do not cast it if less than 300 hp of healing  		else  			return (int)spellImpact.Damage / 3;  	// Otherwise' far from the end of the fight' divide efficiency by 3                  	// if close to the end of the fight' then returns full result.   }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The following statement contains a magic number: if (Template.id == 139)// Mot d'altruisme : only use near end of fight or if lot of spellImpact to heal   {  	int hpLeftOnFoes = actors.Where (actor => actor.Team.Id != pc.Team.Id).Sum (actor => actor.Stats.Health);  	comment += string.Format (" - special \"Mot d'altruisme\" processing : hpLeftOnFoes = {0}' efficiency = {1}"' hpLeftOnFoes' (int)spellImpact.Damage);  	if (hpLeftOnFoes > 500)  		// Not the end of the fight  		if (spellImpact.Damage < 300)  			return 0;  		// Do not cast it if less than 300 hp of healing  		else  			return (int)spellImpact.Damage / 3;  	// Otherwise' far from the end of the fight' divide efficiency by 3                  	// if close to the end of the fight' then returns full result.   }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The following statement contains a magic number: if (Template.id == 139)// Mot d'altruisme : only use near end of fight or if lot of spellImpact to heal   {  	int hpLeftOnFoes = actors.Where (actor => actor.Team.Id != pc.Team.Id).Sum (actor => actor.Stats.Health);  	comment += string.Format (" - special \"Mot d'altruisme\" processing : hpLeftOnFoes = {0}' efficiency = {1}"' hpLeftOnFoes' (int)spellImpact.Damage);  	if (hpLeftOnFoes > 500)  		// Not the end of the fight  		if (spellImpact.Damage < 300)  			return 0;  		// Do not cast it if less than 300 hp of healing  		else  			return (int)spellImpact.Damage / 3;  	// Otherwise' far from the end of the fight' divide efficiency by 3                  	// if close to the end of the fight' then returns full result.   }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The following statement contains a magic number: if (hpLeftOnFoes > 500)  	// Not the end of the fight  	if (spellImpact.Damage < 300)  		return 0;  	// Do not cast it if less than 300 hp of healing  	else  		return (int)spellImpact.Damage / 3;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The following statement contains a magic number: if (hpLeftOnFoes > 500)  	// Not the end of the fight  	if (spellImpact.Damage < 300)  		return 0;  	// Do not cast it if less than 300 hp of healing  	else  		return (int)spellImpact.Damage / 3;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The following statement contains a magic number: if (hpLeftOnFoes > 500)  	// Not the end of the fight  	if (spellImpact.Damage < 300)  		return 0;  	// Do not cast it if less than 300 hp of healing  	else  		return (int)spellImpact.Damage / 3;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The following statement contains a magic number: if (spellImpact.Damage < 300)  	return 0;  // Do not cast it if less than 300 hp of healing  else  	return (int)spellImpact.Damage / 3;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The following statement contains a magic number: if (spellImpact.Damage < 300)  	return 0;  // Do not cast it if less than 300 hp of healing  else  	return (int)spellImpact.Damage / 3;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetFullAreaEffect,The following statement contains a magic number: return (int)spellImpact.Damage / 3;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,The following statement contains a magic number: if (surface == 1 && LevelTemplate.range == 0)// Hack fast Cure and protect self   {  	var res = GetSpellDamages (pc' pc);  	if (res.Damage > 0)  		bestResult = new SpellTarget (res.Damage' pc.Cell' pc.Cell' this);  } else  	foreach (Cell source in sourceCells) {  		IEnumerable<Cell> destCells = GetCellsAtSpellRange (pc' source' actors);  		if (goodSpell || badSpell)  			if (surface <= 1 && LevelTemplate.range > 0)  				destCells = destCells.Intersect (targets.Select (fighter => fighter.Cell));  		// for spells that have an area of effect of 1' just find enemies or friends as targets. No need to scan all the range.                      		if (surface >= 560 && destCells.Count () > 1)  			// For spells that cover the full map' use only the first cell  			destCells = destCells.Take (1);  		SpellTarget newResult = FindBestTarget (pc' source' destCells' actors' category);  		if (newResult == null || newResult.Efficiency <= 0)  			continue;  		if (bestResult == null || bestResult.Efficiency < newResult.Efficiency) {  			bestResult = newResult;  			if (surface >= 560)  				break;  			// if spell covers all map' and we have some hit' then no need to continue (first source cells are nearest)  			if (targetsCount == 1 && surface == 1)  				break;  			// only one target and 1 cell area spell => no need to loop further  		}  	}  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,The following statement contains a magic number: if (surface == 1 && LevelTemplate.range == 0)// Hack fast Cure and protect self   {  	var res = GetSpellDamages (pc' pc);  	if (res.Damage > 0)  		bestResult = new SpellTarget (res.Damage' pc.Cell' pc.Cell' this);  } else  	foreach (Cell source in sourceCells) {  		IEnumerable<Cell> destCells = GetCellsAtSpellRange (pc' source' actors);  		if (goodSpell || badSpell)  			if (surface <= 1 && LevelTemplate.range > 0)  				destCells = destCells.Intersect (targets.Select (fighter => fighter.Cell));  		// for spells that have an area of effect of 1' just find enemies or friends as targets. No need to scan all the range.                      		if (surface >= 560 && destCells.Count () > 1)  			// For spells that cover the full map' use only the first cell  			destCells = destCells.Take (1);  		SpellTarget newResult = FindBestTarget (pc' source' destCells' actors' category);  		if (newResult == null || newResult.Efficiency <= 0)  			continue;  		if (bestResult == null || bestResult.Efficiency < newResult.Efficiency) {  			bestResult = newResult;  			if (surface >= 560)  				break;  			// if spell covers all map' and we have some hit' then no need to continue (first source cells are nearest)  			if (targetsCount == 1 && surface == 1)  				break;  			// only one target and 1 cell area spell => no need to loop further  		}  	}  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,The following statement contains a magic number: foreach (Cell source in sourceCells) {  	IEnumerable<Cell> destCells = GetCellsAtSpellRange (pc' source' actors);  	if (goodSpell || badSpell)  		if (surface <= 1 && LevelTemplate.range > 0)  			destCells = destCells.Intersect (targets.Select (fighter => fighter.Cell));  	// for spells that have an area of effect of 1' just find enemies or friends as targets. No need to scan all the range.                      	if (surface >= 560 && destCells.Count () > 1)  		// For spells that cover the full map' use only the first cell  		destCells = destCells.Take (1);  	SpellTarget newResult = FindBestTarget (pc' source' destCells' actors' category);  	if (newResult == null || newResult.Efficiency <= 0)  		continue;  	if (bestResult == null || bestResult.Efficiency < newResult.Efficiency) {  		bestResult = newResult;  		if (surface >= 560)  			break;  		// if spell covers all map' and we have some hit' then no need to continue (first source cells are nearest)  		if (targetsCount == 1 && surface == 1)  			break;  		// only one target and 1 cell area spell => no need to loop further  	}  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,The following statement contains a magic number: foreach (Cell source in sourceCells) {  	IEnumerable<Cell> destCells = GetCellsAtSpellRange (pc' source' actors);  	if (goodSpell || badSpell)  		if (surface <= 1 && LevelTemplate.range > 0)  			destCells = destCells.Intersect (targets.Select (fighter => fighter.Cell));  	// for spells that have an area of effect of 1' just find enemies or friends as targets. No need to scan all the range.                      	if (surface >= 560 && destCells.Count () > 1)  		// For spells that cover the full map' use only the first cell  		destCells = destCells.Take (1);  	SpellTarget newResult = FindBestTarget (pc' source' destCells' actors' category);  	if (newResult == null || newResult.Efficiency <= 0)  		continue;  	if (bestResult == null || bestResult.Efficiency < newResult.Efficiency) {  		bestResult = newResult;  		if (surface >= 560)  			break;  		// if spell covers all map' and we have some hit' then no need to continue (first source cells are nearest)  		if (targetsCount == 1 && surface == 1)  			break;  		// only one target and 1 cell area spell => no need to loop further  	}  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,The following statement contains a magic number: if (surface >= 560 && destCells.Count () > 1)  	// For spells that cover the full map' use only the first cell  	destCells = destCells.Take (1);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,The following statement contains a magic number: if (bestResult == null || bestResult.Efficiency < newResult.Efficiency) {  	bestResult = newResult;  	if (surface >= 560)  		break;  	// if spell covers all map' and we have some hit' then no need to continue (first source cells are nearest)  	if (targetsCount == 1 && surface == 1)  		break;  	// only one target and 1 cell area spell => no need to loop further  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FindBestTarget,The following statement contains a magic number: if (surface >= 560)  	break;  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,FillEffect,The following statement contains a magic number: if (splitted.Length >= 2)  	uint.TryParse (splitted [1]' out effect.zoneMinSize);  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetLevelTemplate,The following statement contains a magic number: if (Template.id == 158)// For Iops' Concentration effects are wrong in D2o   {  	lv.effects [0].targetId = (int)(SpellTargetType.ALLIES_NON_SUMMON | SpellTargetType.ENEMIES_NON_SUMMON | SpellTargetType.SELF);  	lv.effects [1].targetId = (int)(SpellTargetType.ALLIES_SUMMON | SpellTargetType.ENEMIES_SUMMON);  }  
Magic Number,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetLevelTemplate,The following statement contains a magic number: if (Template.id == 126)// For Eni' Mot stimulant also affects the enemies (2nd effect)   {  	lv.effects [1].targetId = (int)(SpellTargetType.ALL);  }  
Magic Number,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,CanUpgradeSpell,The following statement contains a magic number: if (spell.Level == 5 && spell.LevelTemplate.minPlayerLevel + 100 > Character.Level)  	return false;  
Magic Number,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,CanUpgradeSpell,The following statement contains a magic number: if (spell.Level == 5 && spell.LevelTemplate.minPlayerLevel + 100 > Character.Level)  	return false;  
Magic Number,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FullDump,The following statement contains a magic number: foreach (var spell in m_spells) {  	logger.Error ("   Spell {0}"' spell.ToString (true));  	foreach (var effectdice in spell.LevelTemplate.effects) {  		EffectBase effect = new EffectBase (effectdice);  		logger.Error ("       Effect {0} : {1} - {2} {3:P}"' effect.Description' effectdice.diceNum <= effectdice.diceSide ? effectdice.diceNum : effectdice.diceSide' effectdice.diceNum > effectdice.diceSide ? effectdice.diceNum : effectdice.diceSide' effectdice.random == 0 ? 1.0 : effectdice.random / 100.0);  	}  }  
Magic Number,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FullDump,The following statement contains a magic number: foreach (var effectdice in spell.LevelTemplate.effects) {  	EffectBase effect = new EffectBase (effectdice);  	logger.Error ("       Effect {0} : {1} - {2} {3:P}"' effect.Description' effectdice.diceNum <= effectdice.diceSide ? effectdice.diceNum : effectdice.diceSide' effectdice.diceNum > effectdice.diceSide ? effectdice.diceNum : effectdice.diceSide' effectdice.random == 0 ? 1.0 : effectdice.random / 100.0);  }  
Magic Number,BiM.Behaviors.Game.Spells,SpellsBook,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\SpellsBook.AI.cs,FullDump,The following statement contains a magic number: logger.Error ("       Effect {0} : {1} - {2} {3:P}"' effect.Description' effectdice.diceNum <= effectdice.diceSide ? effectdice.diceNum : effectdice.diceSide' effectdice.diceNum > effectdice.diceSide ? effectdice.diceNum : effectdice.diceSide' effectdice.random == 0 ? 1.0 : effectdice.random / 100.0);  
Magic Number,BiM.Behaviors.Game.Stats,BoostThreshold,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Stats\BoostThreshold.cs,BoostThreshold,The following statement contains a magic number: if (threshold.Count != 3 && threshold.Count != 2)  	throw new ArgumentException ("threshold.Count != 3 && threshold.Count != 2");  
Magic Number,BiM.Behaviors.Game.Stats,BoostThreshold,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Stats\BoostThreshold.cs,BoostThreshold,The following statement contains a magic number: if (threshold.Count != 3 && threshold.Count != 2)  	throw new ArgumentException ("threshold.Count != 3 && threshold.Count != 2");  
Magic Number,BiM.Behaviors.Game.Stats,BoostThreshold,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Stats\BoostThreshold.cs,BoostThreshold,The following statement contains a magic number: BoostPerPoints = threshold.Count > 2 ? threshold [2] : 1;  
Magic Number,BiM.Behaviors.Game.Stats,BoostThreshold,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Stats\BoostThreshold.cs,BoostThreshold,The following statement contains a magic number: BoostPerPoints = threshold.Count > 2 ? threshold [2] : 1;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,GetCellFromPoint,The following statement contains a magic number: if (highPart < 0 || highPart > 39)  	return null;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Serialize,The following statement contains a magic number: bytes [0] = (byte)(Id >> 8);  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Serialize,The following statement contains a magic number: bytes [2] = (byte)(Floor >> 8);  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Serialize,The following statement contains a magic number: bytes [2] = (byte)(Floor >> 8);  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Serialize,The following statement contains a magic number: bytes [3] = (byte)(Floor & 0xFF);  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Serialize,The following statement contains a magic number: bytes [4] = LosMov;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Serialize,The following statement contains a magic number: bytes [5] = MapChangeData;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Serialize,The following statement contains a magic number: bytes [6] = Speed;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Serialize,The following statement contains a magic number: bytes [7] = MoveZone;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Deserialize,The following statement contains a magic number: Id = (short)((data [index + 0] << 8) | data [index + 1]);  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Deserialize,The following statement contains a magic number: Floor = (short)((data [index + 2] << 8) | data [index + 3]);  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Deserialize,The following statement contains a magic number: Floor = (short)((data [index + 2] << 8) | data [index + 3]);  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Deserialize,The following statement contains a magic number: Floor = (short)((data [index + 2] << 8) | data [index + 3]);  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Deserialize,The following statement contains a magic number: LosMov = data [index + 4];  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Deserialize,The following statement contains a magic number: MapChangeData = data [index + 5];  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Deserialize,The following statement contains a magic number: Speed = data [index + 6];  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,Deserialize,The following statement contains a magic number: MoveZone = data [index + 7];  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,ManhattanDistanceTo,The following statement contains a magic number: if (cell == null)  	return 255;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,ManhattanDistanceTo,The following statement contains a magic number: return 255;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,IsInMap,The following statement contains a magic number: return x + y >= 0 && x - y >= 0 && x - y < Map.Height * 2 && x + y < Map.Width * 2;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,IsInMap,The following statement contains a magic number: return x + y >= 0 && x - y >= 0 && x - y < Map.Height * 2 && x + y < Map.Width * 2;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,OrientationTo,The following statement contains a magic number: if (orientation < 0) {  	orientation = orientation + 8;  }  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,OrientationTo,The following statement contains a magic number: orientation = orientation + 8;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,GetCellsInLine,The following statement contains a magic number: dx *= 2;  
Magic Number,BiM.Behaviors.Game.World,Cell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Cell.cs,GetCellsInLine,The following statement contains a magic number: dy *= 2;  
Magic Number,BiM.Behaviors.Game.World.Data,MapData,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Data\MapData.cs,MapData,The following statement contains a magic number: if (position != null) {  	X = position.posX;  	Y = position.posY;  	WorldMap = position.worldMap;  	Outdoor = position.outdoor;  } else {  	X = (Id & 0x3FE00) >> 9;  	// 9 higher bits  	Y = Id & 0x01FF;  	// 9 lower bits  	WorldMap = Id & 0x3FFC0000 >> 18;  	if ((X & 0x100) == 0x100)// 9th bit is the sign. 1 means it's minus  	 {  		X = -(X & 0xFF);  		// just take the 8 first bits and take the opposite number  	}  	if ((Y & 0x100) == 0x100)// 9th bit is the sign. 1 means it's minus  	 {  		Y = -(Y & 0xFF);  		// just take the 8 first bits and take the opposite number  	}  }  
Magic Number,BiM.Behaviors.Game.World.Data,MapData,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Data\MapData.cs,MapData,The following statement contains a magic number: if (position != null) {  	X = position.posX;  	Y = position.posY;  	WorldMap = position.worldMap;  	Outdoor = position.outdoor;  } else {  	X = (Id & 0x3FE00) >> 9;  	// 9 higher bits  	Y = Id & 0x01FF;  	// 9 lower bits  	WorldMap = Id & 0x3FFC0000 >> 18;  	if ((X & 0x100) == 0x100)// 9th bit is the sign. 1 means it's minus  	 {  		X = -(X & 0xFF);  		// just take the 8 first bits and take the opposite number  	}  	if ((Y & 0x100) == 0x100)// 9th bit is the sign. 1 means it's minus  	 {  		Y = -(Y & 0xFF);  		// just take the 8 first bits and take the opposite number  	}  }  
Magic Number,BiM.Behaviors.Game.World.Data,MapData,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Data\MapData.cs,MapData,The following statement contains a magic number: X = (Id & 0x3FE00) >> 9;  
Magic Number,BiM.Behaviors.Game.World.Data,MapData,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Data\MapData.cs,MapData,The following statement contains a magic number: WorldMap = Id & 0x3FFC0000 >> 18;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,CellInfo,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\CellInfo.cs,CellIdFromPos,The following statement contains a magic number: if (HighPart < 0 || HighPart > 39)  	return CELL_ERROR;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,CellInfo,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\CellInfo.cs,YFromId,The following statement contains a magic number: return (short)((cellId % 14) - (cellId - cellId % 28) / 28);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,CellInfo,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\CellInfo.cs,YFromId,The following statement contains a magic number: return (short)((cellId % 14) - (cellId - cellId % 28) / 28);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,CellInfo,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\CellInfo.cs,YFromId,The following statement contains a magic number: return (short)((cellId % 14) - (cellId - cellId % 28) / 28);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,CellInfo,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\CellInfo.cs,XFromId,The following statement contains a magic number: return (short)(0.5 + cellId / 14.5 + (YFromId (cellId)) * 13.5 / 14.5);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,CellInfo,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\CellInfo.cs,XFromId,The following statement contains a magic number: return (short)(0.5 + cellId / 14.5 + (YFromId (cellId)) * 13.5 / 14.5);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,CellInfo,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\CellInfo.cs,XFromId,The following statement contains a magic number: return (short)(0.5 + cellId / 14.5 + (YFromId (cellId)) * 13.5 / 14.5);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,CellInfo,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\CellInfo.cs,XFromId,The following statement contains a magic number: return (short)(0.5 + cellId / 14.5 + (YFromId (cellId)) * 13.5 / 14.5);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: switch (mapNeighbour) {  case MapNeighbour.Bottom:  	return 4;  case MapNeighbour.Top:  	return 64;  case MapNeighbour.Left:  	return 16;  case MapNeighbour.Right:  	return 1;  case null:  default:  	return 1 | 4 | 16 | 64;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: switch (mapNeighbour) {  case MapNeighbour.Bottom:  	return 4;  case MapNeighbour.Top:  	return 64;  case MapNeighbour.Left:  	return 16;  case MapNeighbour.Right:  	return 1;  case null:  default:  	return 1 | 4 | 16 | 64;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: switch (mapNeighbour) {  case MapNeighbour.Bottom:  	return 4;  case MapNeighbour.Top:  	return 64;  case MapNeighbour.Left:  	return 16;  case MapNeighbour.Right:  	return 1;  case null:  default:  	return 1 | 4 | 16 | 64;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: switch (mapNeighbour) {  case MapNeighbour.Bottom:  	return 4;  case MapNeighbour.Top:  	return 64;  case MapNeighbour.Left:  	return 16;  case MapNeighbour.Right:  	return 1;  case null:  default:  	return 1 | 4 | 16 | 64;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: switch (mapNeighbour) {  case MapNeighbour.Bottom:  	return 4;  case MapNeighbour.Top:  	return 64;  case MapNeighbour.Left:  	return 16;  case MapNeighbour.Right:  	return 1;  case null:  default:  	return 1 | 4 | 16 | 64;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: switch (mapNeighbour) {  case MapNeighbour.Bottom:  	return 4;  case MapNeighbour.Top:  	return 64;  case MapNeighbour.Left:  	return 16;  case MapNeighbour.Right:  	return 1;  case null:  default:  	return 1 | 4 | 16 | 64;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: return 4;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: return 64;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: return 16;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: return 1 | 4 | 16 | 64;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: return 1 | 4 | 16 | 64;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapExtensions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapExtensions.cs,GetMapChangeMask,The following statement contains a magic number: return 1 | 4 | 16 | 64;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapMovement,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapMovement.cs,PackPath,The following statement contains a magic number: if (path.Length < 2)  	return PackedPath.ToArray ();  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapMovement,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapMovement.cs,PackPath,The following statement contains a magic number: for (short NoCell = 1; NoCell < path.Length; NoCell++) {  	short cellid = path [NoCell];  	Debug.Assert (cellid >= 0 && cellid < CellInfo.NB_CELL);  	Orientation = GetOrientation (PreviousCellId' cellid);  	if (NoCell == 1 || (Orientation != PreviousOrientation) || NoCell == (path.Length - 1))// Odd' but first step is always packed  	 {  		PackedPath.Add ((short)((ushort)cellid | ((ushort)Orientation) << 12));  		PreviousOrientation = Orientation;  	}  	PreviousCellId = cellid;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapMovement,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapMovement.cs,PackPath,The following statement contains a magic number: if (NoCell == 1 || (Orientation != PreviousOrientation) || NoCell == (path.Length - 1))// Odd' but first step is always packed   {  	PackedPath.Add ((short)((ushort)cellid | ((ushort)Orientation) << 12));  	PreviousOrientation = Orientation;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,MapMovement,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\MapMovement.cs,PackPath,The following statement contains a magic number: PackedPath.Add ((short)((ushort)cellid | ((ushort)Orientation) << 12));  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The following statement contains a magic number: while (true) {  	ClearLogic (startingCells' exitCells);  	uint EstimatedDistance = CellInfo.DEFAULT_DISTANCE;  	Cell bestStartingCell = null;  	Cell bestEndingCell = null;  	foreach (short stCell in startingCells)  		if (_cells [stCell] != null) {  			_cells [stCell].DistanceSteps = 0;  			changed [changedPtr++] = _cells [stCell];  			if (!firstStepOnly && !selectFartherCells)  				foreach (short exCell in exitCells) {  					if (exCell == stCell) {  						PathResult = new List<short> {  							stCell  						};  						return true;  						// Empty path : starting stCell = exit stCell  					}  					if (optimizerActiv) {  						uint distance = _cells [stCell].Cell.ManhattanDistanceTo (_cells [exCell].Cell);  						if (distance < EstimatedDistance) {  							bestStartingCell = _cells [stCell].Cell;  							bestEndingCell = _cells [exCell].Cell;  							EstimatedDistance = distance;  						}  					}  				}  		}  	//    cells[StartingCell].distanceSteps = 0;  	int maxDistance = maxDistanceParam;  	// We won't search over this distance - this optimization is OK in all cases  	if (optimizerActiv && bestStartingCell == null || bestEndingCell == null)  		optimizerActiv = false;  	while (changedPtr > 0) {  		changingPtr = 0;  		// Look at each square on the board.  		while (changedPtr > 0) {  			CellInfo curCell = changed [--changedPtr];  			if (curCell.IsCloseToEnemy && _isCautious)  				continue;  			// Cautious mode (in or out of fight) : Can't move from a cell near an ennemy  			if (curCell.DistanceSteps < maxDistance) {  				if (optimizerActiv)// Strong optimisation  				 {  					uint lastEstimatedDistance = curCell.Cell.ManhattanDistanceTo (bestEndingCell);  					uint startDistance = curCell.Cell.ManhattanDistanceTo (bestStartingCell);  					if (startDistance + lastEstimatedDistance > EstimatedDistance)  						continue;  				}  				//Debug.Assert((curCell != null && curCell.DistanceSteps < CellInfo.DEFAULT_DISTANCE));  				short[] cellNeighbours = neighbours [curCell.CellId];  				for (short i = 0; i < cellNeighbours.Length; i++) {  					CellInfo newCell = _cells [cellNeighbours [i]];  					if (newCell == null)  						continue;  					if (newCell.DistanceSteps != 0 && !SquareOpen (newCell' null))  						continue;  					//uint currentDistance = newCell.Cell.ManhattanDistanceTo(_cells[exitCells[0]].Cell);                              					//if (currentDistance >= EstimatedDistance || currentDistance >= lastEstimatedDistance) continue;  					int newPass = curCell.DistanceSteps;  					if (curCell.IsCloseToEnemy)  						newPass++;  					// Penality when close of an ennemy (same in fight and RP map)  					if (_isInFight)  						newPass++;  					else  						newPass += newCell.Weight;  					if (newCell.DistanceSteps > newPass) {  						newCell.DistanceSteps = newPass;  						changing [changingPtr++] = newCell;  						if (!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id))  							maxDistance = newPass;  						// We won't search on distance over closest exit  					}  				}  				if (_isInFight)  					continue;  				cellNeighbours = diagNeighbours [curCell.CellId];  				for (short i = 0; i < cellNeighbours.Length; i++)// Process diagonals  				 {  					CellInfo newCell = _cells [cellNeighbours [i]];  					if (newCell == null)  						continue;  					if (newCell.DistanceSteps != 0 && !SquareOpen (newCell' null))  						continue;  					int newPass = curCell.DistanceSteps;  					if (curCell.IsCloseToEnemy)  						newPass++;  					// Penality when close of an ennemy (same in fight and RP map)  					if (_isInFight)  						newPass++;  					else  						newPass += (int)(newCell.Weight * 1.414);  					if (newCell.DistanceSteps > newPass) {  						newCell.DistanceSteps = newPass;  						changing [changingPtr++] = newCell;  						if (!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id))  							maxDistance = newPass;  						// We won't search on distance over closest exit  					}  				}  			}  		}  		CellInfo[] tmpChanged = changed;  		changed = changing;  		changedPtr = changingPtr;  		changing = tmpChanged;  	}  	if (firstStepOnly)  		return true;  	// Step 2  	// Mark the path from Exit to Starting position.  	// if several Exit cells' then get the lowest distance one = the closest from one starting cell  	// (or the highest distance one if selectFartherCells)  	ExitCell = exitCells [0];  	int MinDist = _cells [ExitCell].DistanceSteps;  	foreach (short cell in exitCells)  		if ((selectFartherCells && _cells [cell].DistanceSteps > MinDist) || (!selectFartherCells && _cells [cell].DistanceSteps < MinDist)) {  			ExitCell = cell;  			MinDist = _cells [cell].DistanceSteps;  		}  	if (optimizerActiv == false || MinDist < CellInfo.DEFAULT_DISTANCE)  		break;  	// No need to run a second unoptimized algorithm  	else  		optimizerActiv = false;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The following statement contains a magic number: while (changedPtr > 0) {  	changingPtr = 0;  	// Look at each square on the board.  	while (changedPtr > 0) {  		CellInfo curCell = changed [--changedPtr];  		if (curCell.IsCloseToEnemy && _isCautious)  			continue;  		// Cautious mode (in or out of fight) : Can't move from a cell near an ennemy  		if (curCell.DistanceSteps < maxDistance) {  			if (optimizerActiv)// Strong optimisation  			 {  				uint lastEstimatedDistance = curCell.Cell.ManhattanDistanceTo (bestEndingCell);  				uint startDistance = curCell.Cell.ManhattanDistanceTo (bestStartingCell);  				if (startDistance + lastEstimatedDistance > EstimatedDistance)  					continue;  			}  			//Debug.Assert((curCell != null && curCell.DistanceSteps < CellInfo.DEFAULT_DISTANCE));  			short[] cellNeighbours = neighbours [curCell.CellId];  			for (short i = 0; i < cellNeighbours.Length; i++) {  				CellInfo newCell = _cells [cellNeighbours [i]];  				if (newCell == null)  					continue;  				if (newCell.DistanceSteps != 0 && !SquareOpen (newCell' null))  					continue;  				//uint currentDistance = newCell.Cell.ManhattanDistanceTo(_cells[exitCells[0]].Cell);                              				//if (currentDistance >= EstimatedDistance || currentDistance >= lastEstimatedDistance) continue;  				int newPass = curCell.DistanceSteps;  				if (curCell.IsCloseToEnemy)  					newPass++;  				// Penality when close of an ennemy (same in fight and RP map)  				if (_isInFight)  					newPass++;  				else  					newPass += newCell.Weight;  				if (newCell.DistanceSteps > newPass) {  					newCell.DistanceSteps = newPass;  					changing [changingPtr++] = newCell;  					if (!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id))  						maxDistance = newPass;  					// We won't search on distance over closest exit  				}  			}  			if (_isInFight)  				continue;  			cellNeighbours = diagNeighbours [curCell.CellId];  			for (short i = 0; i < cellNeighbours.Length; i++)// Process diagonals  			 {  				CellInfo newCell = _cells [cellNeighbours [i]];  				if (newCell == null)  					continue;  				if (newCell.DistanceSteps != 0 && !SquareOpen (newCell' null))  					continue;  				int newPass = curCell.DistanceSteps;  				if (curCell.IsCloseToEnemy)  					newPass++;  				// Penality when close of an ennemy (same in fight and RP map)  				if (_isInFight)  					newPass++;  				else  					newPass += (int)(newCell.Weight * 1.414);  				if (newCell.DistanceSteps > newPass) {  					newCell.DistanceSteps = newPass;  					changing [changingPtr++] = newCell;  					if (!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id))  						maxDistance = newPass;  					// We won't search on distance over closest exit  				}  			}  		}  	}  	CellInfo[] tmpChanged = changed;  	changed = changing;  	changedPtr = changingPtr;  	changing = tmpChanged;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The following statement contains a magic number: while (changedPtr > 0) {  	CellInfo curCell = changed [--changedPtr];  	if (curCell.IsCloseToEnemy && _isCautious)  		continue;  	// Cautious mode (in or out of fight) : Can't move from a cell near an ennemy  	if (curCell.DistanceSteps < maxDistance) {  		if (optimizerActiv)// Strong optimisation  		 {  			uint lastEstimatedDistance = curCell.Cell.ManhattanDistanceTo (bestEndingCell);  			uint startDistance = curCell.Cell.ManhattanDistanceTo (bestStartingCell);  			if (startDistance + lastEstimatedDistance > EstimatedDistance)  				continue;  		}  		//Debug.Assert((curCell != null && curCell.DistanceSteps < CellInfo.DEFAULT_DISTANCE));  		short[] cellNeighbours = neighbours [curCell.CellId];  		for (short i = 0; i < cellNeighbours.Length; i++) {  			CellInfo newCell = _cells [cellNeighbours [i]];  			if (newCell == null)  				continue;  			if (newCell.DistanceSteps != 0 && !SquareOpen (newCell' null))  				continue;  			//uint currentDistance = newCell.Cell.ManhattanDistanceTo(_cells[exitCells[0]].Cell);                              			//if (currentDistance >= EstimatedDistance || currentDistance >= lastEstimatedDistance) continue;  			int newPass = curCell.DistanceSteps;  			if (curCell.IsCloseToEnemy)  				newPass++;  			// Penality when close of an ennemy (same in fight and RP map)  			if (_isInFight)  				newPass++;  			else  				newPass += newCell.Weight;  			if (newCell.DistanceSteps > newPass) {  				newCell.DistanceSteps = newPass;  				changing [changingPtr++] = newCell;  				if (!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id))  					maxDistance = newPass;  				// We won't search on distance over closest exit  			}  		}  		if (_isInFight)  			continue;  		cellNeighbours = diagNeighbours [curCell.CellId];  		for (short i = 0; i < cellNeighbours.Length; i++)// Process diagonals  		 {  			CellInfo newCell = _cells [cellNeighbours [i]];  			if (newCell == null)  				continue;  			if (newCell.DistanceSteps != 0 && !SquareOpen (newCell' null))  				continue;  			int newPass = curCell.DistanceSteps;  			if (curCell.IsCloseToEnemy)  				newPass++;  			// Penality when close of an ennemy (same in fight and RP map)  			if (_isInFight)  				newPass++;  			else  				newPass += (int)(newCell.Weight * 1.414);  			if (newCell.DistanceSteps > newPass) {  				newCell.DistanceSteps = newPass;  				changing [changingPtr++] = newCell;  				if (!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id))  					maxDistance = newPass;  				// We won't search on distance over closest exit  			}  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The following statement contains a magic number: if (curCell.DistanceSteps < maxDistance) {  	if (optimizerActiv)// Strong optimisation  	 {  		uint lastEstimatedDistance = curCell.Cell.ManhattanDistanceTo (bestEndingCell);  		uint startDistance = curCell.Cell.ManhattanDistanceTo (bestStartingCell);  		if (startDistance + lastEstimatedDistance > EstimatedDistance)  			continue;  	}  	//Debug.Assert((curCell != null && curCell.DistanceSteps < CellInfo.DEFAULT_DISTANCE));  	short[] cellNeighbours = neighbours [curCell.CellId];  	for (short i = 0; i < cellNeighbours.Length; i++) {  		CellInfo newCell = _cells [cellNeighbours [i]];  		if (newCell == null)  			continue;  		if (newCell.DistanceSteps != 0 && !SquareOpen (newCell' null))  			continue;  		//uint currentDistance = newCell.Cell.ManhattanDistanceTo(_cells[exitCells[0]].Cell);                              		//if (currentDistance >= EstimatedDistance || currentDistance >= lastEstimatedDistance) continue;  		int newPass = curCell.DistanceSteps;  		if (curCell.IsCloseToEnemy)  			newPass++;  		// Penality when close of an ennemy (same in fight and RP map)  		if (_isInFight)  			newPass++;  		else  			newPass += newCell.Weight;  		if (newCell.DistanceSteps > newPass) {  			newCell.DistanceSteps = newPass;  			changing [changingPtr++] = newCell;  			if (!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id))  				maxDistance = newPass;  			// We won't search on distance over closest exit  		}  	}  	if (_isInFight)  		continue;  	cellNeighbours = diagNeighbours [curCell.CellId];  	for (short i = 0; i < cellNeighbours.Length; i++)// Process diagonals  	 {  		CellInfo newCell = _cells [cellNeighbours [i]];  		if (newCell == null)  			continue;  		if (newCell.DistanceSteps != 0 && !SquareOpen (newCell' null))  			continue;  		int newPass = curCell.DistanceSteps;  		if (curCell.IsCloseToEnemy)  			newPass++;  		// Penality when close of an ennemy (same in fight and RP map)  		if (_isInFight)  			newPass++;  		else  			newPass += (int)(newCell.Weight * 1.414);  		if (newCell.DistanceSteps > newPass) {  			newCell.DistanceSteps = newPass;  			changing [changingPtr++] = newCell;  			if (!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id))  				maxDistance = newPass;  			// We won't search on distance over closest exit  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The following statement contains a magic number: for (short i = 0; i < cellNeighbours.Length; i++)// Process diagonals   {  	CellInfo newCell = _cells [cellNeighbours [i]];  	if (newCell == null)  		continue;  	if (newCell.DistanceSteps != 0 && !SquareOpen (newCell' null))  		continue;  	int newPass = curCell.DistanceSteps;  	if (curCell.IsCloseToEnemy)  		newPass++;  	// Penality when close of an ennemy (same in fight and RP map)  	if (_isInFight)  		newPass++;  	else  		newPass += (int)(newCell.Weight * 1.414);  	if (newCell.DistanceSteps > newPass) {  		newCell.DistanceSteps = newPass;  		changing [changingPtr++] = newCell;  		if (!firstStepOnly && !selectFartherCells && newPass < maxDistance && exitCells.Any (id => newCell.CellId == id))  			maxDistance = newPass;  		// We won't search on distance over closest exit  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The following statement contains a magic number: if (_isInFight)  	newPass++;  else  	newPass += (int)(newCell.Weight * 1.414);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,FindPath,The following statement contains a magic number: newPass += (int)(newCell.Weight * 1.414);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,GetFlightDistance,The following statement contains a magic number: if (dx > dy)  	return dy * 1.414 /* diagonale part */+ /* straight line part */dx - dy;  else  	return dx * 1.414 /* diagonale part */+ /* straight line part */dy - dx;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,GetFlightDistance,The following statement contains a magic number: if (dx > dy)  	return dy * 1.414 /* diagonale part */+ /* straight line part */dx - dy;  else  	return dx * 1.414 /* diagonale part */+ /* straight line part */dy - dx;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,GetFlightDistance,The following statement contains a magic number: return dy * 1.414 /* diagonale part */+ /* straight line part */dx - dy;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,GetFlightDistance,The following statement contains a magic number: return dx * 1.414 /* diagonale part */+ /* straight line part */dy - dx;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,PathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\PathFinder.cs,ComputeNeighbours,The following statement contains a magic number: for (short i = 0; i < 560; i++)  	result [i] = Neighbours (i' fighting).ToArray ();  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldPathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldPathFinder.cs,GetNextSubMapIdToReachTheDestination,The following statement contains a magic number: foreach (int NextSubMap in links [MemberCurrentSubMapId])  	if (cells [NextSubMap].distanceSteps < BestChoiceDistance) {  		BestNextCell = NextSubMap;  		BestChoiceDistance = cells [NextSubMap].distanceSteps;  	} else if ((cells [NextSubMap].distanceSteps == BestChoiceDistance) && (RandomPath) && (rnd.Next (2) == 0))// If 2 possible cells have same value' choose randomly  	 {  		BestNextCell = NextSubMap;  	}  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldPathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldPathFinder.cs,GetNextSubMapIdToReachTheDestination,The following statement contains a magic number: if (cells [NextSubMap].distanceSteps < BestChoiceDistance) {  	BestNextCell = NextSubMap;  	BestChoiceDistance = cells [NextSubMap].distanceSteps;  } else if ((cells [NextSubMap].distanceSteps == BestChoiceDistance) && (RandomPath) && (rnd.Next (2) == 0))// If 2 possible cells have same value' choose randomly   {  	BestNextCell = NextSubMap;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldPathFinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldPathFinder.cs,GetNextSubMapIdToReachTheDestination,The following statement contains a magic number: if ((cells [NextSubMap].distanceSteps == BestChoiceDistance) && (RandomPath) && (rnd.Next (2) == 0))// If 2 possible cells have same value' choose randomly   {  	BestNextCell = NextSubMap;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldPoint,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldPoint.cs,WorldPoint,The following statement contains a magic number: WorldId = (mapId & 0x3FFC0000) >> 18;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldPoint,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldPoint.cs,WorldPoint,The following statement contains a magic number: X = (mapId & 0x0003FFFF) >> 9 & 511;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldPoint,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldPoint.cs,WorldPoint,The following statement contains a magic number: X = (mapId & 0x0003FFFF) >> 9 & 511;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Path,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Path.cs,GetEndCellDirection,The following statement contains a magic number: return m_cellsPath [m_cellsPath.Length - 2].OrientationToAdjacent (m_cellsPath [m_cellsPath.Length - 1]);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Path,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Path.cs,GetClientPathKeys,The following statement contains a magic number: return compressedPath.Select (entry => (short)((ushort)entry.Cell.Id | ((ushort)entry.Direction << 12))).ToArray ();  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Path,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Path.cs,BuildCompressedPath,The following statement contains a magic number: if (path.Count > 0) {  	int i = path.Count - 2;  	// we don't touch to the last vector  	while (i > 0) {  		if (path [i].Direction == path [i - 1].Direction)  			path.RemoveAt (i);  		i--;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Path,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Path.cs,BuildCompletePath,The following statement contains a magic number: for (int i = 0; i < m_compressedPath.Length - 1; i++) {  	completePath.Add (m_compressedPath [i].Cell);  	int l = 0;  	Cell nextPoint = m_compressedPath [i].Cell;  	while ((nextPoint = nextPoint.GetNearestCellInDirection (m_compressedPath [i].Direction)) != null && nextPoint.Id != m_compressedPath [i + 1].Cell.Id) {  		if (l > World.Map.Height * 2 + World.Map.Width)  			throw new Exception ("Path too long. Maybe an orientation problem ?");  		completePath.Add (Map.Cells [nextPoint.Id]);  		l++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Path,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Path.cs,BuildCompletePath,The following statement contains a magic number: while ((nextPoint = nextPoint.GetNearestCellInDirection (m_compressedPath [i].Direction)) != null && nextPoint.Id != m_compressedPath [i + 1].Cell.Id) {  	if (l > World.Map.Height * 2 + World.Map.Width)  		throw new Exception ("Path too long. Maybe an orientation problem ?");  	completePath.Add (Map.Cells [nextPoint.Id]);  	l++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Path,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Path.cs,BuildCompletePath,The following statement contains a magic number: if (l > World.Map.Height * 2 + World.Map.Width)  	throw new Exception ("Path too long. Maybe an orientation problem ?");  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: while (openList.Count > 0) {  	location = openList.Pop ();  	matrix [location.Id].Status = NodeState.Closed;  	if (location == endCell) {  		success = true;  		break;  	}  	if (counter > SearchLimit)  		return Path.GetEmptyPath (m_map' startCell);  	for (int i = 0; i < 8; i++) {  		var isDiagonal = DiagonalsDirections.Contains (i);  		if (isDiagonal && !allowDiagonals)  			continue;  		var newLocation = location.GetNearestCellInDirection (Directions [i]);  		if (newLocation == null)  			continue;  		if (newLocation.Id < 0 || newLocation.Id >= Map.MapSize)  			continue;  		if (matrix [newLocation.Id].Status == NodeState.Closed)  			continue;  		if (!m_context.IsCellWalkable (newLocation))  			continue;  		double baseCost;  		if (newLocation == endCell)  			baseCost = 1;  		else  			baseCost = GetCellCost (newLocation' m_throughEntities);  		double cost = matrix [location.Id].Cost + baseCost * (isDiagonal ? DiagonalCost : HorizontalCost);  		// adjust the cost if the current cell is aligned with the start cell or the end cell  		if (m_throughEntities) {  			bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  			bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  			if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  				cost += newLocation.ManhattanDistanceTo (endCell);  				cost += newLocation.ManhattanDistanceTo (startCell);  			}  			// tests diagonales now  			if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  				cost -= 3;  			if (alignedWithEnd || !isDiagonal)  				cost -= 2;  			if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  				cost -= 3;  			if (alignedWithStart)  				cost -= 2;  			var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  			if (currentDistToEnd < distToEnd) {  				// if aligned with end  				if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  					distToEnd = currentDistToEnd;  					endCellAux = newLocation;  				}  			}  		}  		if (matrix [newLocation.Id].Status == NodeState.Open) {  			if (matrix [newLocation.Id].Cost <= cost)  				continue;  			matrix [newLocation.Id].Parent = location;  			matrix [newLocation.Id].Cost = cost;  		} else {  			matrix [newLocation.Id].Cell = newLocation;  			matrix [newLocation.Id].Parent = location;  			matrix [newLocation.Id].Cost = cost;  			matrix [newLocation.Id].Heuristic = GetHeuristic (newLocation' endCell);  			openList.Push (newLocation);  		}  		matrix [newLocation.Id].Status = NodeState.Open;  	}  	counter++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: while (openList.Count > 0) {  	location = openList.Pop ();  	matrix [location.Id].Status = NodeState.Closed;  	if (location == endCell) {  		success = true;  		break;  	}  	if (counter > SearchLimit)  		return Path.GetEmptyPath (m_map' startCell);  	for (int i = 0; i < 8; i++) {  		var isDiagonal = DiagonalsDirections.Contains (i);  		if (isDiagonal && !allowDiagonals)  			continue;  		var newLocation = location.GetNearestCellInDirection (Directions [i]);  		if (newLocation == null)  			continue;  		if (newLocation.Id < 0 || newLocation.Id >= Map.MapSize)  			continue;  		if (matrix [newLocation.Id].Status == NodeState.Closed)  			continue;  		if (!m_context.IsCellWalkable (newLocation))  			continue;  		double baseCost;  		if (newLocation == endCell)  			baseCost = 1;  		else  			baseCost = GetCellCost (newLocation' m_throughEntities);  		double cost = matrix [location.Id].Cost + baseCost * (isDiagonal ? DiagonalCost : HorizontalCost);  		// adjust the cost if the current cell is aligned with the start cell or the end cell  		if (m_throughEntities) {  			bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  			bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  			if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  				cost += newLocation.ManhattanDistanceTo (endCell);  				cost += newLocation.ManhattanDistanceTo (startCell);  			}  			// tests diagonales now  			if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  				cost -= 3;  			if (alignedWithEnd || !isDiagonal)  				cost -= 2;  			if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  				cost -= 3;  			if (alignedWithStart)  				cost -= 2;  			var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  			if (currentDistToEnd < distToEnd) {  				// if aligned with end  				if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  					distToEnd = currentDistToEnd;  					endCellAux = newLocation;  				}  			}  		}  		if (matrix [newLocation.Id].Status == NodeState.Open) {  			if (matrix [newLocation.Id].Cost <= cost)  				continue;  			matrix [newLocation.Id].Parent = location;  			matrix [newLocation.Id].Cost = cost;  		} else {  			matrix [newLocation.Id].Cell = newLocation;  			matrix [newLocation.Id].Parent = location;  			matrix [newLocation.Id].Cost = cost;  			matrix [newLocation.Id].Heuristic = GetHeuristic (newLocation' endCell);  			openList.Push (newLocation);  		}  		matrix [newLocation.Id].Status = NodeState.Open;  	}  	counter++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: while (openList.Count > 0) {  	location = openList.Pop ();  	matrix [location.Id].Status = NodeState.Closed;  	if (location == endCell) {  		success = true;  		break;  	}  	if (counter > SearchLimit)  		return Path.GetEmptyPath (m_map' startCell);  	for (int i = 0; i < 8; i++) {  		var isDiagonal = DiagonalsDirections.Contains (i);  		if (isDiagonal && !allowDiagonals)  			continue;  		var newLocation = location.GetNearestCellInDirection (Directions [i]);  		if (newLocation == null)  			continue;  		if (newLocation.Id < 0 || newLocation.Id >= Map.MapSize)  			continue;  		if (matrix [newLocation.Id].Status == NodeState.Closed)  			continue;  		if (!m_context.IsCellWalkable (newLocation))  			continue;  		double baseCost;  		if (newLocation == endCell)  			baseCost = 1;  		else  			baseCost = GetCellCost (newLocation' m_throughEntities);  		double cost = matrix [location.Id].Cost + baseCost * (isDiagonal ? DiagonalCost : HorizontalCost);  		// adjust the cost if the current cell is aligned with the start cell or the end cell  		if (m_throughEntities) {  			bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  			bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  			if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  				cost += newLocation.ManhattanDistanceTo (endCell);  				cost += newLocation.ManhattanDistanceTo (startCell);  			}  			// tests diagonales now  			if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  				cost -= 3;  			if (alignedWithEnd || !isDiagonal)  				cost -= 2;  			if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  				cost -= 3;  			if (alignedWithStart)  				cost -= 2;  			var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  			if (currentDistToEnd < distToEnd) {  				// if aligned with end  				if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  					distToEnd = currentDistToEnd;  					endCellAux = newLocation;  				}  			}  		}  		if (matrix [newLocation.Id].Status == NodeState.Open) {  			if (matrix [newLocation.Id].Cost <= cost)  				continue;  			matrix [newLocation.Id].Parent = location;  			matrix [newLocation.Id].Cost = cost;  		} else {  			matrix [newLocation.Id].Cell = newLocation;  			matrix [newLocation.Id].Parent = location;  			matrix [newLocation.Id].Cost = cost;  			matrix [newLocation.Id].Heuristic = GetHeuristic (newLocation' endCell);  			openList.Push (newLocation);  		}  		matrix [newLocation.Id].Status = NodeState.Open;  	}  	counter++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: while (openList.Count > 0) {  	location = openList.Pop ();  	matrix [location.Id].Status = NodeState.Closed;  	if (location == endCell) {  		success = true;  		break;  	}  	if (counter > SearchLimit)  		return Path.GetEmptyPath (m_map' startCell);  	for (int i = 0; i < 8; i++) {  		var isDiagonal = DiagonalsDirections.Contains (i);  		if (isDiagonal && !allowDiagonals)  			continue;  		var newLocation = location.GetNearestCellInDirection (Directions [i]);  		if (newLocation == null)  			continue;  		if (newLocation.Id < 0 || newLocation.Id >= Map.MapSize)  			continue;  		if (matrix [newLocation.Id].Status == NodeState.Closed)  			continue;  		if (!m_context.IsCellWalkable (newLocation))  			continue;  		double baseCost;  		if (newLocation == endCell)  			baseCost = 1;  		else  			baseCost = GetCellCost (newLocation' m_throughEntities);  		double cost = matrix [location.Id].Cost + baseCost * (isDiagonal ? DiagonalCost : HorizontalCost);  		// adjust the cost if the current cell is aligned with the start cell or the end cell  		if (m_throughEntities) {  			bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  			bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  			if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  				cost += newLocation.ManhattanDistanceTo (endCell);  				cost += newLocation.ManhattanDistanceTo (startCell);  			}  			// tests diagonales now  			if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  				cost -= 3;  			if (alignedWithEnd || !isDiagonal)  				cost -= 2;  			if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  				cost -= 3;  			if (alignedWithStart)  				cost -= 2;  			var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  			if (currentDistToEnd < distToEnd) {  				// if aligned with end  				if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  					distToEnd = currentDistToEnd;  					endCellAux = newLocation;  				}  			}  		}  		if (matrix [newLocation.Id].Status == NodeState.Open) {  			if (matrix [newLocation.Id].Cost <= cost)  				continue;  			matrix [newLocation.Id].Parent = location;  			matrix [newLocation.Id].Cost = cost;  		} else {  			matrix [newLocation.Id].Cell = newLocation;  			matrix [newLocation.Id].Parent = location;  			matrix [newLocation.Id].Cost = cost;  			matrix [newLocation.Id].Heuristic = GetHeuristic (newLocation' endCell);  			openList.Push (newLocation);  		}  		matrix [newLocation.Id].Status = NodeState.Open;  	}  	counter++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: while (openList.Count > 0) {  	location = openList.Pop ();  	matrix [location.Id].Status = NodeState.Closed;  	if (location == endCell) {  		success = true;  		break;  	}  	if (counter > SearchLimit)  		return Path.GetEmptyPath (m_map' startCell);  	for (int i = 0; i < 8; i++) {  		var isDiagonal = DiagonalsDirections.Contains (i);  		if (isDiagonal && !allowDiagonals)  			continue;  		var newLocation = location.GetNearestCellInDirection (Directions [i]);  		if (newLocation == null)  			continue;  		if (newLocation.Id < 0 || newLocation.Id >= Map.MapSize)  			continue;  		if (matrix [newLocation.Id].Status == NodeState.Closed)  			continue;  		if (!m_context.IsCellWalkable (newLocation))  			continue;  		double baseCost;  		if (newLocation == endCell)  			baseCost = 1;  		else  			baseCost = GetCellCost (newLocation' m_throughEntities);  		double cost = matrix [location.Id].Cost + baseCost * (isDiagonal ? DiagonalCost : HorizontalCost);  		// adjust the cost if the current cell is aligned with the start cell or the end cell  		if (m_throughEntities) {  			bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  			bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  			if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  				cost += newLocation.ManhattanDistanceTo (endCell);  				cost += newLocation.ManhattanDistanceTo (startCell);  			}  			// tests diagonales now  			if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  				cost -= 3;  			if (alignedWithEnd || !isDiagonal)  				cost -= 2;  			if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  				cost -= 3;  			if (alignedWithStart)  				cost -= 2;  			var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  			if (currentDistToEnd < distToEnd) {  				// if aligned with end  				if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  					distToEnd = currentDistToEnd;  					endCellAux = newLocation;  				}  			}  		}  		if (matrix [newLocation.Id].Status == NodeState.Open) {  			if (matrix [newLocation.Id].Cost <= cost)  				continue;  			matrix [newLocation.Id].Parent = location;  			matrix [newLocation.Id].Cost = cost;  		} else {  			matrix [newLocation.Id].Cell = newLocation;  			matrix [newLocation.Id].Parent = location;  			matrix [newLocation.Id].Cost = cost;  			matrix [newLocation.Id].Heuristic = GetHeuristic (newLocation' endCell);  			openList.Push (newLocation);  		}  		matrix [newLocation.Id].Status = NodeState.Open;  	}  	counter++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	var isDiagonal = DiagonalsDirections.Contains (i);  	if (isDiagonal && !allowDiagonals)  		continue;  	var newLocation = location.GetNearestCellInDirection (Directions [i]);  	if (newLocation == null)  		continue;  	if (newLocation.Id < 0 || newLocation.Id >= Map.MapSize)  		continue;  	if (matrix [newLocation.Id].Status == NodeState.Closed)  		continue;  	if (!m_context.IsCellWalkable (newLocation))  		continue;  	double baseCost;  	if (newLocation == endCell)  		baseCost = 1;  	else  		baseCost = GetCellCost (newLocation' m_throughEntities);  	double cost = matrix [location.Id].Cost + baseCost * (isDiagonal ? DiagonalCost : HorizontalCost);  	// adjust the cost if the current cell is aligned with the start cell or the end cell  	if (m_throughEntities) {  		bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  		bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  		if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  			cost += newLocation.ManhattanDistanceTo (endCell);  			cost += newLocation.ManhattanDistanceTo (startCell);  		}  		// tests diagonales now  		if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  			cost -= 3;  		if (alignedWithEnd || !isDiagonal)  			cost -= 2;  		if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  			cost -= 3;  		if (alignedWithStart)  			cost -= 2;  		var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  		if (currentDistToEnd < distToEnd) {  			// if aligned with end  			if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  				distToEnd = currentDistToEnd;  				endCellAux = newLocation;  			}  		}  	}  	if (matrix [newLocation.Id].Status == NodeState.Open) {  		if (matrix [newLocation.Id].Cost <= cost)  			continue;  		matrix [newLocation.Id].Parent = location;  		matrix [newLocation.Id].Cost = cost;  	} else {  		matrix [newLocation.Id].Cell = newLocation;  		matrix [newLocation.Id].Parent = location;  		matrix [newLocation.Id].Cost = cost;  		matrix [newLocation.Id].Heuristic = GetHeuristic (newLocation' endCell);  		openList.Push (newLocation);  	}  	matrix [newLocation.Id].Status = NodeState.Open;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	var isDiagonal = DiagonalsDirections.Contains (i);  	if (isDiagonal && !allowDiagonals)  		continue;  	var newLocation = location.GetNearestCellInDirection (Directions [i]);  	if (newLocation == null)  		continue;  	if (newLocation.Id < 0 || newLocation.Id >= Map.MapSize)  		continue;  	if (matrix [newLocation.Id].Status == NodeState.Closed)  		continue;  	if (!m_context.IsCellWalkable (newLocation))  		continue;  	double baseCost;  	if (newLocation == endCell)  		baseCost = 1;  	else  		baseCost = GetCellCost (newLocation' m_throughEntities);  	double cost = matrix [location.Id].Cost + baseCost * (isDiagonal ? DiagonalCost : HorizontalCost);  	// adjust the cost if the current cell is aligned with the start cell or the end cell  	if (m_throughEntities) {  		bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  		bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  		if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  			cost += newLocation.ManhattanDistanceTo (endCell);  			cost += newLocation.ManhattanDistanceTo (startCell);  		}  		// tests diagonales now  		if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  			cost -= 3;  		if (alignedWithEnd || !isDiagonal)  			cost -= 2;  		if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  			cost -= 3;  		if (alignedWithStart)  			cost -= 2;  		var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  		if (currentDistToEnd < distToEnd) {  			// if aligned with end  			if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  				distToEnd = currentDistToEnd;  				endCellAux = newLocation;  			}  		}  	}  	if (matrix [newLocation.Id].Status == NodeState.Open) {  		if (matrix [newLocation.Id].Cost <= cost)  			continue;  		matrix [newLocation.Id].Parent = location;  		matrix [newLocation.Id].Cost = cost;  	} else {  		matrix [newLocation.Id].Cell = newLocation;  		matrix [newLocation.Id].Parent = location;  		matrix [newLocation.Id].Cost = cost;  		matrix [newLocation.Id].Heuristic = GetHeuristic (newLocation' endCell);  		openList.Push (newLocation);  	}  	matrix [newLocation.Id].Status = NodeState.Open;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	var isDiagonal = DiagonalsDirections.Contains (i);  	if (isDiagonal && !allowDiagonals)  		continue;  	var newLocation = location.GetNearestCellInDirection (Directions [i]);  	if (newLocation == null)  		continue;  	if (newLocation.Id < 0 || newLocation.Id >= Map.MapSize)  		continue;  	if (matrix [newLocation.Id].Status == NodeState.Closed)  		continue;  	if (!m_context.IsCellWalkable (newLocation))  		continue;  	double baseCost;  	if (newLocation == endCell)  		baseCost = 1;  	else  		baseCost = GetCellCost (newLocation' m_throughEntities);  	double cost = matrix [location.Id].Cost + baseCost * (isDiagonal ? DiagonalCost : HorizontalCost);  	// adjust the cost if the current cell is aligned with the start cell or the end cell  	if (m_throughEntities) {  		bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  		bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  		if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  			cost += newLocation.ManhattanDistanceTo (endCell);  			cost += newLocation.ManhattanDistanceTo (startCell);  		}  		// tests diagonales now  		if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  			cost -= 3;  		if (alignedWithEnd || !isDiagonal)  			cost -= 2;  		if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  			cost -= 3;  		if (alignedWithStart)  			cost -= 2;  		var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  		if (currentDistToEnd < distToEnd) {  			// if aligned with end  			if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  				distToEnd = currentDistToEnd;  				endCellAux = newLocation;  			}  		}  	}  	if (matrix [newLocation.Id].Status == NodeState.Open) {  		if (matrix [newLocation.Id].Cost <= cost)  			continue;  		matrix [newLocation.Id].Parent = location;  		matrix [newLocation.Id].Cost = cost;  	} else {  		matrix [newLocation.Id].Cell = newLocation;  		matrix [newLocation.Id].Parent = location;  		matrix [newLocation.Id].Cost = cost;  		matrix [newLocation.Id].Heuristic = GetHeuristic (newLocation' endCell);  		openList.Push (newLocation);  	}  	matrix [newLocation.Id].Status = NodeState.Open;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	var isDiagonal = DiagonalsDirections.Contains (i);  	if (isDiagonal && !allowDiagonals)  		continue;  	var newLocation = location.GetNearestCellInDirection (Directions [i]);  	if (newLocation == null)  		continue;  	if (newLocation.Id < 0 || newLocation.Id >= Map.MapSize)  		continue;  	if (matrix [newLocation.Id].Status == NodeState.Closed)  		continue;  	if (!m_context.IsCellWalkable (newLocation))  		continue;  	double baseCost;  	if (newLocation == endCell)  		baseCost = 1;  	else  		baseCost = GetCellCost (newLocation' m_throughEntities);  	double cost = matrix [location.Id].Cost + baseCost * (isDiagonal ? DiagonalCost : HorizontalCost);  	// adjust the cost if the current cell is aligned with the start cell or the end cell  	if (m_throughEntities) {  		bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  		bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  		if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  			cost += newLocation.ManhattanDistanceTo (endCell);  			cost += newLocation.ManhattanDistanceTo (startCell);  		}  		// tests diagonales now  		if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  			cost -= 3;  		if (alignedWithEnd || !isDiagonal)  			cost -= 2;  		if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  			cost -= 3;  		if (alignedWithStart)  			cost -= 2;  		var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  		if (currentDistToEnd < distToEnd) {  			// if aligned with end  			if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  				distToEnd = currentDistToEnd;  				endCellAux = newLocation;  			}  		}  	}  	if (matrix [newLocation.Id].Status == NodeState.Open) {  		if (matrix [newLocation.Id].Cost <= cost)  			continue;  		matrix [newLocation.Id].Parent = location;  		matrix [newLocation.Id].Cost = cost;  	} else {  		matrix [newLocation.Id].Cell = newLocation;  		matrix [newLocation.Id].Parent = location;  		matrix [newLocation.Id].Cost = cost;  		matrix [newLocation.Id].Heuristic = GetHeuristic (newLocation' endCell);  		openList.Push (newLocation);  	}  	matrix [newLocation.Id].Status = NodeState.Open;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	var isDiagonal = DiagonalsDirections.Contains (i);  	if (isDiagonal && !allowDiagonals)  		continue;  	var newLocation = location.GetNearestCellInDirection (Directions [i]);  	if (newLocation == null)  		continue;  	if (newLocation.Id < 0 || newLocation.Id >= Map.MapSize)  		continue;  	if (matrix [newLocation.Id].Status == NodeState.Closed)  		continue;  	if (!m_context.IsCellWalkable (newLocation))  		continue;  	double baseCost;  	if (newLocation == endCell)  		baseCost = 1;  	else  		baseCost = GetCellCost (newLocation' m_throughEntities);  	double cost = matrix [location.Id].Cost + baseCost * (isDiagonal ? DiagonalCost : HorizontalCost);  	// adjust the cost if the current cell is aligned with the start cell or the end cell  	if (m_throughEntities) {  		bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  		bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  		if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  			cost += newLocation.ManhattanDistanceTo (endCell);  			cost += newLocation.ManhattanDistanceTo (startCell);  		}  		// tests diagonales now  		if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  			cost -= 3;  		if (alignedWithEnd || !isDiagonal)  			cost -= 2;  		if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  			cost -= 3;  		if (alignedWithStart)  			cost -= 2;  		var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  		if (currentDistToEnd < distToEnd) {  			// if aligned with end  			if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  				distToEnd = currentDistToEnd;  				endCellAux = newLocation;  			}  		}  	}  	if (matrix [newLocation.Id].Status == NodeState.Open) {  		if (matrix [newLocation.Id].Cost <= cost)  			continue;  		matrix [newLocation.Id].Parent = location;  		matrix [newLocation.Id].Cost = cost;  	} else {  		matrix [newLocation.Id].Cell = newLocation;  		matrix [newLocation.Id].Parent = location;  		matrix [newLocation.Id].Cost = cost;  		matrix [newLocation.Id].Heuristic = GetHeuristic (newLocation' endCell);  		openList.Push (newLocation);  	}  	matrix [newLocation.Id].Status = NodeState.Open;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (m_throughEntities) {  	bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  	bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  	if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  		cost += newLocation.ManhattanDistanceTo (endCell);  		cost += newLocation.ManhattanDistanceTo (startCell);  	}  	// tests diagonales now  	if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  		cost -= 3;  	if (alignedWithEnd || !isDiagonal)  		cost -= 2;  	if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  		cost -= 3;  	if (alignedWithStart)  		cost -= 2;  	var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  	if (currentDistToEnd < distToEnd) {  		// if aligned with end  		if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  			distToEnd = currentDistToEnd;  			endCellAux = newLocation;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (m_throughEntities) {  	bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  	bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  	if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  		cost += newLocation.ManhattanDistanceTo (endCell);  		cost += newLocation.ManhattanDistanceTo (startCell);  	}  	// tests diagonales now  	if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  		cost -= 3;  	if (alignedWithEnd || !isDiagonal)  		cost -= 2;  	if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  		cost -= 3;  	if (alignedWithStart)  		cost -= 2;  	var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  	if (currentDistToEnd < distToEnd) {  		// if aligned with end  		if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  			distToEnd = currentDistToEnd;  			endCellAux = newLocation;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (m_throughEntities) {  	bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  	bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  	if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  		cost += newLocation.ManhattanDistanceTo (endCell);  		cost += newLocation.ManhattanDistanceTo (startCell);  	}  	// tests diagonales now  	if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  		cost -= 3;  	if (alignedWithEnd || !isDiagonal)  		cost -= 2;  	if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  		cost -= 3;  	if (alignedWithStart)  		cost -= 2;  	var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  	if (currentDistToEnd < distToEnd) {  		// if aligned with end  		if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  			distToEnd = currentDistToEnd;  			endCellAux = newLocation;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (m_throughEntities) {  	bool alignedWithEnd = newLocation.X + newLocation.Y == endCell.X + endCell.Y || newLocation.X - newLocation.Y == endCell.X - endCell.Y;  	bool alignedWithStart = newLocation.X + newLocation.Y == startCell.X + startCell.Y || newLocation.X - newLocation.Y == startCell.X - startCell.Y;  	if (newLocation.X + newLocation.Y != endCell.X + endCell.Y && newLocation.X - newLocation.Y != endCell.X - endCell.Y || newLocation.X + newLocation.Y != startCell.X + startCell.Y && newLocation.X - newLocation.Y != startCell.X - startCell.Y) {  		cost += newLocation.ManhattanDistanceTo (endCell);  		cost += newLocation.ManhattanDistanceTo (startCell);  	}  	// tests diagonales now  	if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  		cost -= 3;  	if (alignedWithEnd || !isDiagonal)  		cost -= 2;  	if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  		cost -= 3;  	if (alignedWithStart)  		cost -= 2;  	var currentDistToEnd = newLocation.ManhattanDistanceTo (endCell);  	if (currentDistToEnd < distToEnd) {  		// if aligned with end  		if (newLocation.X == endCell.X || newLocation.Y == endCell.Y || alignedWithEnd) {  			distToEnd = currentDistToEnd;  			endCellAux = newLocation;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (newLocation.X == endCell.X || newLocation.Y == endCell.Y)  	cost -= 3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: cost -= 3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (alignedWithEnd || !isDiagonal)  	cost -= 2;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: cost -= 2;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (newLocation.X == startCell.X || newLocation.Y == startCell.Y)  	cost -= 3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: cost -= 3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (alignedWithStart)  	cost -= 2;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: cost -= 2;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	var node = nodes [i];  	var cell = node.Cell;  	cells.Add (cell);  	if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  		i++;  	} else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  		var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  		var middleCell = m_map.Cells [middle];  		if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  			cells.Add (middleCell);  			i += 2;  		}  	} else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  		var middleCell = nodes [i + 1].Cell;  		var nextCell = nodes [i + 2].Cell;  		var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  		var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  		// cell aligned to nextcell but not to middle cell  		if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  			// then ignore middle cell  			i++;  		} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  			cells.Add (middleCell2X);  			i++;  		} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  			cells.Add (middleCell2Y);  			i++;  		}  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 1 && !cell.IsChangeZone (nodes [i + 1].Cell) && !nodes [i + 1].Cell.IsChangeZone (nodes [i + 2].Cell)) {  	i++;  } else if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 3 < len && cell.ManhattanDistanceTo (nodes [i + 3].Cell) == 2) {  	var middle = new Point (cell.X + (int)Math.Round ((nodes [i + 3].Cell.X - cell.X) / 2d)' cell.Y + (int)Math.Round ((nodes [i + 3].Cell.Y - cell.Y) / 2d));  	var middleCell = m_map.Cells [middle];  	if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  		cells.Add (middleCell);  		i += 2;  	}  } else if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  	cells.Add (middleCell);  	i += 2;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (GetCellCost (middleCell' true) < 2 && m_context.IsCellWalkable (middleCell' false' cell)) {  	cells.Add (middleCell);  	i += 2;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: i += 2;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (i + 2 < len && node.Cell.ManhattanDistanceTo (nodes [i + 2].Cell) == 2) {  	var middleCell = nodes [i + 1].Cell;  	var nextCell = nodes [i + 2].Cell;  	var middleCell2X = m_map.Cells [cell.X' middleCell.Y];  	var middleCell2Y = m_map.Cells [middleCell.X' cell.Y];  	// cell aligned to nextcell but not to middle cell  	if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  		// then ignore middle cell  		i++;  	} else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  		cells.Add (middleCell2X);  		i++;  	} else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  		cells.Add (middleCell2Y);  		i++;  	}  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  	// then ignore middle cell  	i++;  } else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  	cells.Add (middleCell2X);  	i++;  } else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  	cells.Add (middleCell2Y);  	i++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (((cell.X + cell.Y == nextCell.X + nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y) || (cell.X - cell.Y == nextCell.X - nextCell.Y && cell.X - cell.Y != middleCell.X - middleCell.Y)) && !cell.IsChangeZone (middleCell) && !middleCell.IsChangeZone (nextCell)) {  	// then ignore middle cell  	i++;  } else if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  	cells.Add (middleCell2X);  	i++;  } else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  	cells.Add (middleCell2Y);  	i++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  	cells.Add (middleCell2X);  	i++;  } else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  	cells.Add (middleCell2Y);  	i++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (cell.X == nextCell.X && cell.X != middleCell.X && GetCellCost (middleCell2X' true) < 2 && m_context.IsCellWalkable (middleCell2X' false' cell)) {  	cells.Add (middleCell2X);  	i++;  } else if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  	cells.Add (middleCell2Y);  	i++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,CreateAndOptimisePath,The following statement contains a magic number: if (cell.Y == nextCell.Y && cell.Y != middleCell.Y && GetCellCost (middleCell2Y' true) < 2 && m_context.IsCellWalkable (middleCell2Y' false' cell)) {  	cells.Add (middleCell2Y);  	i++;  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: if (throughEntities) {  	if (m_context.GetActorsOnCell (cell).Length > 0)  		return 20;  	if (speed >= 0)  		return 1 + 5 - speed;  	return 1 + 11 + Math.Abs (speed);  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: if (throughEntities) {  	if (m_context.GetActorsOnCell (cell).Length > 0)  		return 20;  	if (speed >= 0)  		return 1 + 5 - speed;  	return 1 + 11 + Math.Abs (speed);  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: if (throughEntities) {  	if (m_context.GetActorsOnCell (cell).Length > 0)  		return 20;  	if (speed >= 0)  		return 1 + 5 - speed;  	return 1 + 11 + Math.Abs (speed);  }  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: if (m_context.GetActorsOnCell (cell).Length > 0)  	return 20;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: return 20;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: if (speed >= 0)  	return 1 + 5 - speed;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: return 1 + 5 - speed;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: return 1 + 11 + Math.Abs (speed);  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: if (m_context.GetActorsOnCell (cell).Length > 0)  	cost += 0.3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: cost += 0.3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: if (adjCell != null && m_context.GetActorsOnCell (adjCell).Length > 0)  	cost += 0.3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: cost += 0.3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: if (adjCell != null && m_context.GetActorsOnCell (adjCell).Length > 0)  	cost += 0.3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: cost += 0.3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: if (adjCell != null && m_context.GetActorsOnCell (adjCell).Length > 0)  	cost += 0.3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: cost += 0.3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: if (adjCell != null && m_context.GetActorsOnCell (adjCell).Length > 0)  	cost += 0.3;  
Magic Number,BiM.Behaviors.Game.World.Pathfinding,Pathfinder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\Pathfinder.cs,GetCellCost,The following statement contains a magic number: cost += 0.3;  
Missing Default,BiM.Behaviors.Data.Maps,SubMapsManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Data\Maps\SubMapsManager.cs,TryGetMapNeighbour,The following switch statement is missing a default case: switch (neighbour) {  case MapNeighbour.Left:  	return position.LeftNeighbourId;  case MapNeighbour.Right:  	return position.RightNeighbourId;  case MapNeighbour.Bottom:  	return position.BottomNeighbourId;  case MapNeighbour.Top:  	return position.TopNeighbourId;  }  
Missing Default,BiM.Behaviors.Game.Actors.Fighters,Fighter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\Fighters\Fighter.cs,Update,The following switch statement is missing a default case: switch ((ActionIdEnum)(message.actionId)) {  case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_LOST_CASTER:  	//if (this is PlayedFighter)  	//  (this as PlayedFighter).Character.SendMessage(String.Format("{3} => AP of {0} : {1} => {2}"' Name' Stats.CurrentAP' Stats.CurrentAP + message.delta' (ActionIdEnum)(message.actionId)));  	Stats.UpdateAP (message.delta);  	break;  case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_LOST:  	goto case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_DEBOOST_ACTION_POINTS:  	goto case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_STEAL:  	goto case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_BOOST_ACTION_POINTS:  	goto case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_USE:  	goto case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_WIN:  	goto case ActionIdEnum.ACTION_CHARACTER_ACTION_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_MOVEMENT_POINTS_LOST:  	goto case ActionIdEnum.ACTION_CHARACTER_MOVEMEMT_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_MOVEMENT_POINTS_STEAL:  	goto case ActionIdEnum.ACTION_CHARACTER_MOVEMEMT_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_MOVEMENT_POINTS_WIN:  	goto case ActionIdEnum.ACTION_CHARACTER_MOVEMEMT_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_DEBOOST_MOVEMENT_POINTS:  	goto case ActionIdEnum.ACTION_CHARACTER_MOVEMEMT_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_BOOST_MOVEMENT_POINTS:  	goto case ActionIdEnum.ACTION_CHARACTER_MOVEMEMT_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_MOVEMENT_POINTS_USE:  	goto case ActionIdEnum.ACTION_CHARACTER_MOVEMEMT_POINTS_LOST_CASTER;  case ActionIdEnum.ACTION_CHARACTER_MOVEMEMT_POINTS_LOST_CASTER:  	//if (this is PlayedFighter)  	//  (this as PlayedFighter).Character.SendMessage(String.Format("{3} => MP of {0} : {1} => {2}"' Name' Stats.CurrentMP' Stats.CurrentMP + message.delta' (ActionIdEnum)(message.actionId)));  	Stats.UpdateMP (message.delta);  	break;  }  
Missing Default,BiM.Behaviors.Game.Actors.RolePlay,PlayedCharacter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Actors\RolePlay\PlayedCharacter.cs,CheckCriteria,The following switch statement is missing a default case: switch (match.Captures [1].Value) {  case "C":  	if (!SubCheck (greater' Stats.Chance' Value))  		return false;  	break;  case "W":  	if (!SubCheck (greater' Stats.Wisdom' Value))  		return false;  	break;  case "S":  	if (!SubCheck (greater' Stats.Strength' Value))  		return false;  	break;  case "A":  	if (!SubCheck (greater' Stats.Agility' Value))  		return false;  	break;  case "V":  	if (!SubCheck (greater' Stats.Vitality' Value))  		return false;  	break;  case "M":  	if (!SubCheck (greater' Stats.MP' Value))  		return false;  	break;  case "I":  	if (!SubCheck (greater' Stats.Intelligence' Value))  		return false;  	break;  }  
Missing Default,BiM.Behaviors.Game.Fights,FightTeam,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Fights\FightTeam.cs,Update,The following switch statement is missing a default case: switch ((FightOptionsEnum)msg.option) {  case FightOptionsEnum.FIGHT_OPTION_SET_SECRET:  	IsSecret = msg.state;  	break;  case FightOptionsEnum.FIGHT_OPTION_ASK_FOR_HELP:  	IsHelpRequested = msg.state;  	break;  case FightOptionsEnum.FIGHT_OPTION_SET_CLOSED:  	IsClosed = msg.state;  	break;  case FightOptionsEnum.FIGHT_OPTION_SET_TO_PARTY_ONLY:  	IsRestrictedToParty = msg.state;  	break;  }  
Missing Default,BiM.Behaviors.Game.Spells.Shapes,Cone,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Cone.cs,GetCells,The following switch statement is missing a default case: switch (Direction) {  case DirectionsEnum.DIRECTION_NORTH_WEST:  	x = centerCell.X;  	while (x >= centerCell.X - Radius) {  		y = -i;  		while (y <= i) {  			if (MinRadius == 0 || Math.Abs (centerCell.X - x) + Math.Abs (y) >= MinRadius)  				AddCellIfValid (x' y + centerCell.Y' map' result);  			y++;  		}  		i = i + j;  		x--;  	}  	break;  case DirectionsEnum.DIRECTION_SOUTH_WEST:  	y = centerCell.Y;  	while (y >= centerCell.Y - Radius) {  		x = -i;  		while (x <= i) {  			if (MinRadius == 0 || Math.Abs (x) + Math.Abs (centerCell.Y - y) >= MinRadius)  				AddCellIfValid (x + centerCell.X' y' map' result);  			x++;  		}  		i = i + j;  		y--;  	}  	break;  case DirectionsEnum.DIRECTION_SOUTH_EAST:  	x = centerCell.X;  	while (x <= centerCell.X + Radius) {  		y = -i;  		while (y <= i) {  			if (MinRadius == 0 || Math.Abs (centerCell.X - x) + Math.Abs (y) >= MinRadius)  				AddCellIfValid (x' y + centerCell.Y' map' result);  			y++;  		}  		i = i + j;  		x++;  	}  	break;  case DirectionsEnum.DIRECTION_NORTH_EAST:  	y = centerCell.Y;  	while (y <= centerCell.Y - Radius) {  		x = -i;  		while (x <= i) {  			if (MinRadius == 0 || Math.Abs (x) + Math.Abs (centerCell.Y - y) >= MinRadius)  				AddCellIfValid (x + centerCell.X' y' map' result);  			x++;  		}  		i = i + j;  		y++;  	}  	break;  }  
Missing Default,BiM.Behaviors.Game.Spells.Shapes,Cross,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Cross.cs,GetCells,The following switch statement is missing a default case: switch (Direction) {  case DirectionsEnum.DIRECTION_SOUTH_EAST:  case DirectionsEnum.DIRECTION_NORTH_WEST: {  	disabledDirections.Add (DirectionsEnum.DIRECTION_SOUTH_EAST);  	disabledDirections.Add (DirectionsEnum.DIRECTION_NORTH_WEST);  	break;  }  case DirectionsEnum.DIRECTION_NORTH_EAST:  case DirectionsEnum.DIRECTION_SOUTH_WEST: {  	disabledDirections.Add (DirectionsEnum.DIRECTION_NORTH_EAST);  	disabledDirections.Add (DirectionsEnum.DIRECTION_SOUTH_WEST);  	break;  }  case DirectionsEnum.DIRECTION_SOUTH:  case DirectionsEnum.DIRECTION_NORTH: {  	disabledDirections.Add (DirectionsEnum.DIRECTION_SOUTH);  	disabledDirections.Add (DirectionsEnum.DIRECTION_NORTH);  	break;  }  case DirectionsEnum.DIRECTION_EAST:  case DirectionsEnum.DIRECTION_WEST: {  	disabledDirections.Add (DirectionsEnum.DIRECTION_EAST);  	disabledDirections.Add (DirectionsEnum.DIRECTION_WEST);  	break;  }  }  
Missing Default,BiM.Behaviors.Game.Spells.Shapes,HalfLozenge,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\HalfLozenge.cs,GetCells,The following switch statement is missing a default case: switch (Direction) {  case DirectionsEnum.DIRECTION_NORTH_WEST:  	AddCellIfValid (centerCell.X + i' centerCell.Y + i' map' result);  	AddCellIfValid (centerCell.X + i' centerCell.Y - i' map' result);  	break;  case DirectionsEnum.DIRECTION_NORTH_EAST:  	AddCellIfValid (centerCell.X - i' centerCell.Y - i' map' result);  	AddCellIfValid (centerCell.X + i' centerCell.Y - i' map' result);  	break;  case DirectionsEnum.DIRECTION_SOUTH_EAST:  	AddCellIfValid (centerCell.X - i' centerCell.Y + i' map' result);  	AddCellIfValid (centerCell.X - i' centerCell.Y - i' map' result);  	break;  case DirectionsEnum.DIRECTION_SOUTH_WEST:  	AddCellIfValid (centerCell.X - i' centerCell.Y + i' map' result);  	AddCellIfValid (centerCell.X + i' centerCell.Y + i' map' result);  	break;  }  
Missing Default,BiM.Behaviors.Game.Spells.Shapes,Line,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Shapes\Line.cs,GetCells,The following switch statement is missing a default case: switch (Direction) {  case DirectionsEnum.DIRECTION_WEST:  	AddCellIfValid (centerCell.X - i' centerCell.Y - i' map' result);  	break;  case DirectionsEnum.DIRECTION_NORTH:  	AddCellIfValid (centerCell.X - i' centerCell.Y + i' map' result);  	break;  case DirectionsEnum.DIRECTION_EAST:  	AddCellIfValid (centerCell.X + i' centerCell.Y + i' map' result);  	break;  case DirectionsEnum.DIRECTION_SOUTH:  	AddCellIfValid (centerCell.X + i' centerCell.Y - i' map' result);  	break;  case DirectionsEnum.DIRECTION_NORTH_WEST:  	AddCellIfValid (centerCell.X - i' centerCell.Y' map' result);  	break;  case DirectionsEnum.DIRECTION_SOUTH_WEST:  	AddCellIfValid (centerCell.X' centerCell.Y - i' map' result);  	break;  case DirectionsEnum.DIRECTION_SOUTH_EAST:  	AddCellIfValid (centerCell.X + i' centerCell.Y' map' result);  	break;  case DirectionsEnum.DIRECTION_NORTH_EAST:  	AddCellIfValid (centerCell.X' centerCell.Y + i' map' result);  	break;  }  
Missing Default,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,GetEffectCategories,The following switch statement is missing a default case: switch ((EffectsEnum)effectId) {  case EffectsEnum.Effect_StealHPAir:  	return SpellCategory.DamagesAir | SpellCategory.Healing;  case EffectsEnum.Effect_StealHPWater:  	return SpellCategory.DamagesWater | SpellCategory.Healing;  case EffectsEnum.Effect_StealHPFire:  	return SpellCategory.DamagesFire | SpellCategory.Healing;  case EffectsEnum.Effect_StealHPEarth:  	return SpellCategory.DamagesEarth | SpellCategory.Healing;  case EffectsEnum.Effect_StealHPNeutral:  	return SpellCategory.DamagesNeutral | SpellCategory.Healing;  case EffectsEnum.Effect_DamageFire:  	return SpellCategory.DamagesFire;  case EffectsEnum.Effect_DamageWater:  	return SpellCategory.DamagesWater;  case EffectsEnum.Effect_DamageAir:  	return SpellCategory.DamagesAir;  case EffectsEnum.Effect_DamageNeutral:  case EffectsEnum.Effect_Punishment_Damage:  	return SpellCategory.DamagesNeutral;  case EffectsEnum.Effect_DamageEarth:  	return SpellCategory.DamagesEarth;  case EffectsEnum.Effect_HealHP_108:  case EffectsEnum.Effect_HealHP_143:  case EffectsEnum.Effect_HealHP_81:  	return SpellCategory.Healing;  case EffectsEnum.Effect_Summon:  case EffectsEnum.Effect_Double:  case EffectsEnum.Effect_185:  case EffectsEnum.Effect_621:  case EffectsEnum.Effect_623:  	return SpellCategory.Invocation;  case EffectsEnum.Effect_AddArmorDamageReduction:  case EffectsEnum.Effect_AddAirResistPercent:  case EffectsEnum.Effect_AddFireResistPercent:  case EffectsEnum.Effect_AddEarthResistPercent:  case EffectsEnum.Effect_AddWaterResistPercent:  case EffectsEnum.Effect_AddNeutralResistPercent:  case EffectsEnum.Effect_AddAirElementReduction:  case EffectsEnum.Effect_AddFireElementReduction:  case EffectsEnum.Effect_AddEarthElementReduction:  case EffectsEnum.Effect_AddWaterElementReduction:  case EffectsEnum.Effect_AddNeutralElementReduction:  case EffectsEnum.Effect_AddAgility:  case EffectsEnum.Effect_AddStrength:  case EffectsEnum.Effect_AddIntelligence:  case EffectsEnum.Effect_AddHealth:  case EffectsEnum.Effect_AddChance:  case EffectsEnum.Effect_AddCriticalHit:  case EffectsEnum.Effect_AddCriticalDamageBonus:  case EffectsEnum.Effect_AddCriticalDamageReduction:  case EffectsEnum.Effect_AddDamageBonus:  case EffectsEnum.Effect_AddDamageBonusPercent:  case EffectsEnum.Effect_AddDamageBonus_121:  case EffectsEnum.Effect_AddFireDamageBonus:  case EffectsEnum.Effect_AddAirDamageBonus:  case EffectsEnum.Effect_AddWaterDamageBonus:  case EffectsEnum.Effect_AddEarthDamageBonus:  case EffectsEnum.Effect_AddNeutralDamageBonus:  case EffectsEnum.Effect_AddDamageMultiplicator:  case EffectsEnum.Effect_AddDamageReflection:  case EffectsEnum.Effect_AddGlobalDamageReduction:  case EffectsEnum.Effect_AddGlobalDamageReduction_105:  case EffectsEnum.Effect_AddAP_111:  case EffectsEnum.Effect_AddHealBonus:  case EffectsEnum.Effect_AddWisdom:  case EffectsEnum.Effect_AddProspecting:  case EffectsEnum.Effect_AddMP:  case EffectsEnum.Effect_AddMP_128:  case EffectsEnum.Effect_AddPhysicalDamage_137:  case EffectsEnum.Effect_AddPhysicalDamage_142:  case EffectsEnum.Effect_AddPhysicalDamageReduction:  case EffectsEnum.Effect_AddPushDamageReduction:  case EffectsEnum.Effect_AddPushDamageBonus:  case EffectsEnum.Effect_AddRange:  case EffectsEnum.Effect_AddRange_136:  case EffectsEnum.Effect_AddSummonLimit:  case EffectsEnum.Effect_AddVitality:  case EffectsEnum.Effect_AddVitalityPercent:  case EffectsEnum.Effect_Dodge:  case EffectsEnum.Effect_IncreaseAPAvoid:  case EffectsEnum.Effect_IncreaseMPAvoid:  case EffectsEnum.Effect_Invisibility:  case EffectsEnum.Effect_ReflectSpell:  case EffectsEnum.Effect_RegainAP:  	return SpellCategory.Buff;  case EffectsEnum.Effect_Teleport:  	return SpellCategory.Teleport;  case EffectsEnum.Effect_PushBack:  case EffectsEnum.Effect_RemoveAP:  case EffectsEnum.Effect_LostMP:  case EffectsEnum.Effect_StealKamas:  case EffectsEnum.Effect_LoseHPByUsingAP:  case EffectsEnum.Effect_LosingAP:  case EffectsEnum.Effect_LosingMP:  case EffectsEnum.Effect_SubRange_135:  case EffectsEnum.Effect_SkipTurn:  case EffectsEnum.Effect_Kill:  case EffectsEnum.Effect_SubDamageBonus:  case EffectsEnum.Effect_SubChance:  case EffectsEnum.Effect_SubVitality:  case EffectsEnum.Effect_SubAgility:  case EffectsEnum.Effect_SubIntelligence:  case EffectsEnum.Effect_SubWisdom:  case EffectsEnum.Effect_SubStrength:  case EffectsEnum.Effect_SubDodgeAPProbability:  case EffectsEnum.Effect_SubDodgeMPProbability:  case EffectsEnum.Effect_SubAP:  case EffectsEnum.Effect_SubMP:  case EffectsEnum.Effect_SubCriticalHit:  case EffectsEnum.Effect_SubMagicDamageReduction:  case EffectsEnum.Effect_SubPhysicalDamageReduction:  case EffectsEnum.Effect_SubInitiative:  case EffectsEnum.Effect_SubProspecting:  case EffectsEnum.Effect_SubHealBonus:  case EffectsEnum.Effect_SubDamageBonusPercent:  case EffectsEnum.Effect_197:  case EffectsEnum.Effect_SubEarthResistPercent:  case EffectsEnum.Effect_SubWaterResistPercent:  case EffectsEnum.Effect_SubAirResistPercent:  case EffectsEnum.Effect_SubFireResistPercent:  case EffectsEnum.Effect_SubNeutralResistPercent:  case EffectsEnum.Effect_SubEarthElementReduction:  case EffectsEnum.Effect_SubWaterElementReduction:  case EffectsEnum.Effect_SubAirElementReduction:  case EffectsEnum.Effect_SubFireElementReduction:  case EffectsEnum.Effect_SubNeutralElementReduction:  case EffectsEnum.Effect_SubPvpEarthResistPercent:  case EffectsEnum.Effect_SubPvpWaterResistPercent:  case EffectsEnum.Effect_SubPvpAirResistPercent:  case EffectsEnum.Effect_SubPvpFireResistPercent:  case EffectsEnum.Effect_SubPvpNeutralResistPercent:  case EffectsEnum.Effect_StealChance:  case EffectsEnum.Effect_StealVitality:  case EffectsEnum.Effect_StealAgility:  case EffectsEnum.Effect_StealIntelligence:  case EffectsEnum.Effect_StealWisdom:  case EffectsEnum.Effect_StealStrength:  case EffectsEnum.Effect_275:  case EffectsEnum.Effect_276:  case EffectsEnum.Effect_277:  case EffectsEnum.Effect_278:  case EffectsEnum.Effect_279:  case EffectsEnum.Effect_411:  case EffectsEnum.Effect_413:  case EffectsEnum.Effect_SubCriticalDamageBonus:  case EffectsEnum.Effect_SubPushDamageReduction:  case EffectsEnum.Effect_SubCriticalDamageReduction:  case EffectsEnum.Effect_SubEarthDamageBonus:  case EffectsEnum.Effect_SubFireDamageBonus:  case EffectsEnum.Effect_SubWaterDamageBonus:  case EffectsEnum.Effect_SubAirDamageBonus:  case EffectsEnum.Effect_SubNeutralDamageBonus:  case EffectsEnum.Effect_StealAP_440:  case EffectsEnum.Effect_StealMP_441:  	return SpellCategory.Curse;  }  
Missing Default,BiM.Behaviors.Game.Spells,Spell,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\Spells\Spell.AI.cs,AdjustDamage,The following switch statement is missing a default case: switch (category) {  case SpellCategory.DamagesNeutral:  	damages.MinNeutral += minDamage;  	damages.MaxNeutral += maxDamage;  	break;  case SpellCategory.DamagesFire:  	damages.MinFire += minDamage;  	damages.MaxAir += maxDamage;  	break;  case SpellCategory.DamagesAir:  	damages.MinAir += minDamage;  	damages.MaxAir += maxDamage;  	break;  case SpellCategory.DamagesWater:  	damages.MinWater += minDamage;  	damages.MaxWater += maxDamage;  	break;  case SpellCategory.DamagesEarth:  	damages.MinEarth += minDamage;  	damages.MaxEarth += maxDamage;  	break;  case SpellCategory.Healing:  	damages.MinHeal += minDamage;  	damages.MaxHeal += maxDamage;  	break;  }  
Missing Default,BiM.Behaviors.Game.World.Pathfinding.FFPathFinding,WorldPoint,F:\newReposMay17\Emudofus_BehaviorIsManaged\Behaviors\Game\World\Pathfinding\FFPathFinding\WorldPoint.cs,Move,The following switch statement is missing a default case: switch (MapNeighbour) {  case MapNeighbour.Bottom:  	Y += 1;  	break;  case MapNeighbour.Top:  	Y -= 1;  	break;  case MapNeighbour.Left:  	X -= 1;  	break;  case MapNeighbour.Right:  	X += 1;  	break;  }  
