Implementation smell,Namespace,Class,File,Method,Description
Long Method,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The method has 143 lines of code.
Long Method,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The method has 101 lines of code.
Long Method,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,Drop,The method has 138 lines of code.
Long Method,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,Drop,The method has 150 lines of code.
Long Method,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The method has 116 lines of code.
Long Method,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The method has 116 lines of code.
Long Method,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ToggleAutoHide,The method has 115 lines of code.
Long Method,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The method has 122 lines of code.
Complex Method,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,Cyclomatic complexity of the method is 36
Complex Method,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,Cyclomatic complexity of the method is 11
Complex Method,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,Drop,Cyclomatic complexity of the method is 24
Complex Method,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,ClearDefaultBindings,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,SetDefaultBindings,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,Cyclomatic complexity of the method is 32
Complex Method,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,Drop,Cyclomatic complexity of the method is 23
Complex Method,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,Drop,Cyclomatic complexity of the method is 32
Complex Method,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,Cyclomatic complexity of the method is 11
Complex Method,AvalonDock.Controls,DragService,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DragService.cs,UpdateMouseLocation,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,FilterMessage,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Controls,LayoutAnchorGroupControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorGroupControl.cs,OnModelChildrenCollectionChanged,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Controls,LayoutAnchorSideControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorSideControl.cs,UpdateSide,Cyclomatic complexity of the method is 12
Complex Method,AvalonDock.Controls,LayoutDocumentFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutDocumentFloatingWindowControl.cs,FilterMessage,Cyclomatic complexity of the method is 11
Complex Method,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,FilterMessage,Cyclomatic complexity of the method is 18
Complex Method,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,UpdateRowColDefinitions,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,Cyclomatic complexity of the method is 14
Complex Method,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,Cyclomatic complexity of the method is 39
Complex Method,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,Cyclomatic complexity of the method is 22
Complex Method,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragLeave,Cyclomatic complexity of the method is 14
Complex Method,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,OnResizerDragCompleted,Cyclomatic complexity of the method is 10
Complex Method,Standard,HRESULT,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Standard,HRESULT,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,ThrowIfFailed,Cyclomatic complexity of the method is 10
Complex Method,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,AreStreamsEqual,Cyclomatic complexity of the method is 8
Complex Method,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,Cyclomatic complexity of the method is 12
Complex Method,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,Cyclomatic complexity of the method is 9
Complex Method,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlEncode,Cyclomatic complexity of the method is 9
Complex Method,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_UrlEncodeIsSafe,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_UpdateSystemMenu,Cyclomatic complexity of the method is 24
Complex Method,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,OnLayoutChanged,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,DockingManager_Loaded,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,CreateUIElementForModel,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,StartDraggingFloatingWindowForContent,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,GetDropAreas,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachDocumentsSource,Cyclomatic complexity of the method is 11
Complex Method,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,documentsSourceElementsChanged,Cyclomatic complexity of the method is 17
Complex Method,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,Cyclomatic complexity of the method is 13
Complex Method,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,Cyclomatic complexity of the method is 19
Complex Method,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,OnThemeChanged,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,Show,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,InternalDock,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,AddToLayout,Cyclomatic complexity of the method is 15
Complex Method,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ToggleAutoHide,Cyclomatic complexity of the method is 34
Complex Method,AvalonDock.Layout,LayoutContent,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,ReadXml,Cyclomatic complexity of the method is 15
Complex Method,AvalonDock.Layout,LayoutContent,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,WriteXml,Cyclomatic complexity of the method is 17
Complex Method,AvalonDock.Layout,LayoutGroup,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutGroup.cs,_children_CollectionChanged,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Layout,LayoutGroup,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutGroup.cs,ReadXml,Cyclomatic complexity of the method is 12
Complex Method,AvalonDock.Layout,LayoutPositionableGroup,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutPositionableGroup.cs,WriteXml,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock.Layout,LayoutPositionableGroup,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutPositionableGroup.cs,ReadXml,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,_hiddenAnchorables_CollectionChanged,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,RemoveChild,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,ReplaceChild,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,Cyclomatic complexity of the method is 25
Complex Method,AvalonDock.Layout.Serialization,LayoutSerializer,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,Cyclomatic complexity of the method is 15
Long Parameter List,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,FilterMessage,The method has 5 parameters.
Long Parameter List,AvalonDock.Controls,LayoutDocumentFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutDocumentFloatingWindowControl.cs,FilterMessage,The method has 5 parameters.
Long Parameter List,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,FilterMessage,The method has 5 parameters.
Long Parameter List,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,WndProc,The method has 5 parameters.
Long Parameter List,Standard,MessageWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\MessageWindow.cs,MessageWindow,The method has 6 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_CreateDIBSection,The method has 6 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_CreateDIBSectionIntPtr,The method has 6 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,CreateDIBSection,The method has 5 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_CreateRoundRectRgn,The method has 6 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,CreateRoundRectRgn,The method has 6 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_CreateWindowEx,The method has 12 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,CreateWindowEx,The method has 12 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,DwmDefWindowProc,The method has 5 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_GetCurrentThemeName,The method has 6 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_SetWindowPos,The method has 7 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,SetWindowPos,The method has 7 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,TrackPopupMenuEx,The method has 6 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_UpdateLayeredWindow,The method has 9 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_UpdateLayeredWindowIntPtr,The method has 9 parameters.
Long Parameter List,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,UpdateLayeredWindow,The method has 9 parameters.
Long Parameter List,Standard,IShellFolder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ShellProvider.cs,ParseDisplayName,The method has 6 parameters.
Long Parameter List,Standard,IShellFolder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ShellProvider.cs,GetUIObjectOf,The method has 5 parameters.
Long Parameter List,Standard,IShellFolder,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ShellProvider.cs,SetNameOf,The method has 5 parameters.
Long Parameter List,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_MatchImage,The method has 5 parameters.
Long Parameter List,Standard,Verify,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,BoundedDoubleInc,The method has 5 parameters.
Long Parameter List,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_WndProc,The method has 5 parameters.
Long Parameter List,AvalonDock,Win32Helper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,CreateWindowEx,The method has 12 parameters.
Long Parameter List,AvalonDock,Win32Helper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,SetWindowPos,The method has 7 parameters.
Long Identifier,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the parameter targetModelAsPositionableElement is 32.
Long Identifier,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the parameter targetModelAsPositionableElement is 32.
Long Identifier,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the parameter targetModelAsPositionableElement is 32.
Long Identifier,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the parameter targetModelAsPositionableElement is 32.
Long Identifier,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The length of the parameter layoutAnchorablePaneWithActualSize is 34.
Long Identifier,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the parameter layoutAnchorablePaneWithActualSize is 34.
Long Identifier,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The length of the parameter childPositionableModelWidthActualSize is 37.
Long Identifier,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The length of the parameter childPositionableModelWidthActualSize is 37.
Long Identifier,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,StartDraggingFloatingWindowForContent,The length of the parameter parentPaneAsPositionableElement is 31.
Long Identifier,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,StartDraggingFloatingWindowForContent,The length of the parameter contentModelParentChildrenIndex is 31.
Long Identifier,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,StartDraggingFloatingWindowForPane,The length of the parameter contentModelAsPreviousContainer is 31.
Long Identifier,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,Show,The length of the parameter previousContainerAsLayoutGroup is 30.
Long Identifier,AvalonDock.Layout,LayoutContent,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,Float,The length of the parameter previousContainerAsLayoutGroup is 30.
Long Identifier,AvalonDock.Layout,LayoutContent,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,Dock,The length of the parameter previousContainerAsLayoutGroup is 30.
Long Statement,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the statement  "			if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Vertical && parentModel.ChildrenCount == 1) " is 120.
Long Statement,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the statement  "				if (layoutAnchorablePaneGroup != null && (layoutAnchorablePaneGroup.Children.Count == 1 || layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical)) { " is 180.
Long Statement,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the statement  "			if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Vertical && parentModel.ChildrenCount == 1) " is 120.
Long Statement,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the statement  "				if (layoutAnchorablePaneGroup != null && (layoutAnchorablePaneGroup.Children.Count == 1 || layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical)) { " is 180.
Long Statement,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the statement  "			if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Horizontal && parentModel.ChildrenCount == 1) " is 122.
Long Statement,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the statement  "				if (layoutAnchorablePaneGroup != null && (layoutAnchorablePaneGroup.Children.Count == 1 || layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal)) { " is 182.
Long Statement,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the statement  "			if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Horizontal && parentModel.ChildrenCount == 1) " is 122.
Long Statement,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the statement  "				if (layoutAnchorablePaneGroup != null && (layoutAnchorablePaneGroup.Children.Count == 1 || layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal)) { " is 182.
Long Statement,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The length of the statement  "	var layoutAnchorablePaneWithActualSize = anchorableFloatingWindowModel.RootPanel as ILayoutPositionableElementWithActualSize; " is 125.
Long Statement,AvalonDock.Controls,AutoHideWindowManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AutoHideWindowManager.cs,SetupCloseTimer,The length of the statement  "		if (_manager.AutoHideWindow.IsWin32MouseOver || ((LayoutAnchorable)_manager.AutoHideWindow.Model).IsActive || _manager.AutoHideWindow.IsResizing) " is 145.
Long Statement,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,Drop,The length of the statement  "				parentGroupPanel.Children.Insert (parentGroupPanel.IndexOfChild (parentGroup != null ? parentGroup : targetModel) + 1' floatingWindow.RootPanel); " is 145.
Long Statement,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,Drop,The length of the statement  "				parentGroupPanel.Children.Insert (parentGroupPanel.IndexOfChild (parentGroup != null ? parentGroup : targetModel)' floatingWindow.RootPanel); " is 141.
Long Statement,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,Drop,The length of the statement  "				parentGroupPanel.Children.Insert (parentGroupPanel.IndexOfChild (parentGroup != null ? parentGroup : targetModel)' floatingWindow.RootPanel); " is 141.
Long Statement,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,Drop,The length of the statement  "				parentGroupPanel.Children.Insert (parentGroupPanel.IndexOfChild (parentGroup != null ? parentGroup : targetModel) + 1' floatingWindow.RootPanel); " is 145.
Long Statement,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The length of the statement  "	//    var documentPaneGroupControl = manager.FindLogicalChildren<LayoutDocumentPaneGroupControl>().First(d => d.Model == parentGroup); " is 134.
Long Statement,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The length of the statement  "	//    var documentPaneControl = manager.FindLogicalChildren<LayoutDocumentPaneControl>().First(d => d.Model == targetModel); " is 124.
Long Statement,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The length of the statement  "	var documentPaneControl = manager.FindLogicalChildren<FrameworkElement> ().OfType<ILayoutControl> ().First (d => parentGroup != null ? d.Model == parentGroup : d.Model == parentGroupPanel) as FrameworkElement; " is 209.
Long Statement,AvalonDock.Controls,WindowHookHandler,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\WindowHookHandler.cs,Attach,The length of the statement  "	_windowHook = Win32Helper.SetWindowsHookEx (Win32Helper.HookType.WH_CBT' _hookProc' IntPtr.Zero' (int)Win32Helper.GetCurrentThreadId ()); " is 137.
Long Statement,AvalonDock.Controls,FocusElementManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\FocusElementManager.cs,manager_PreviewGotKeyboardFocus,The length of the statement  "	if (focusedElement != null && !(focusedElement is LayoutAnchorableTabItem || focusedElement is LayoutDocumentTabItem) && !(focusedElement is ICommandSource))//Avoid tracking focus for elements like this " is 202.
Long Statement,AvalonDock.Controls,FocusElementManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\FocusElementManager.cs,SetFocusOnLastElement,The length of the statement  "	Debug.WriteLine ("SetFocusOnLastElement(focused={0}' model={1}' element={2})"' focused' model' handleToFocus == IntPtr.Zero ? (objectToFocus == null ? "" : objectToFocus.ToString ()) : handleToFocus.ToString ()); " is 212.
Long Statement,AvalonDock.Controls,FocusElementManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\FocusElementManager.cs,WindowFocusChanging,The length of the statement  "		var hostContainingFocusedHandle = manager.FindLogicalChildren<HwndHost> ().FirstOrDefault (hw => Win32Helper.IsChild (hw.Handle' e.GotFocusWinHandle)); " is 151.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "	_defaultDockAsDocumentCommand = new RelayCommand (p => ExecuteDockAsDocumentCommand (p)' p => CanExecuteDockAsDocumentCommand (p)); " is 131.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "	_defaultCloseAllButThisCommand = new RelayCommand (p => ExecuteCloseAllButThisCommand (p)' p => CanExecuteCloseAllButThisCommand (p)); " is 134.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "	_defaultNewVerticalTabGroupCommand = new RelayCommand (p => ExecuteNewVerticalTabGroupCommand (p)' p => CanExecuteNewVerticalTabGroupCommand (p)); " is 146.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "	_defaultNewHorizontalTabGroupCommand = new RelayCommand (p => ExecuteNewHorizontalTabGroupCommand (p)' p => CanExecuteNewHorizontalTabGroupCommand (p)); " is 152.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "	_defaultMoveToNextTabGroupCommand = new RelayCommand (p => ExecuteMoveToNextTabGroupCommand (p)' p => CanExecuteMoveToNextTabGroupCommand (p)); " is 143.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "	_defaultMoveToPreviousTabGroupCommand = new RelayCommand (p => ExecuteMoveToPreviousTabGroupCommand (p)' p => CanExecuteMoveToPreviousTabGroupCommand (p)); " is 155.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,CanExecuteCloseCommand,The length of the statement  "		System.Diagnostics.Debug.WriteLine (string.Format ("CanExecuteCloseCommand({0}) = {1}"' LayoutElement.Title' LayoutElement.CanClose)); " is 134.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,CanExecuteCloseAllButThisCommand,The length of the statement  "	return LayoutElement.Root.Manager.Layout.Descendents ().OfType<LayoutContent> ().Where (d => d != LayoutElement && (d.Parent is LayoutDocumentPane || d.Parent is LayoutDocumentFloatingWindow)).Any (); " is 200.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,CanExecuteNewVerticalTabGroupCommand,The length of the statement  "	return ((parentDocumentGroup == null || parentDocumentGroup.ChildrenCount == 1 || parentDocumentGroup.Root.Manager.AllowMixedOrientation || parentDocumentGroup.Orientation == System.Windows.Controls.Orientation.Horizontal) && parentDocumentPane != null && parentDocumentPane.ChildrenCount > 1); " is 294.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,CanExecuteNewHorizontalTabGroupCommand,The length of the statement  "	return ((parentDocumentGroup == null || parentDocumentGroup.ChildrenCount == 1 || parentDocumentGroup.Root.Manager.AllowMixedOrientation || parentDocumentGroup.Orientation == System.Windows.Controls.Orientation.Vertical) && parentDocumentPane != null && parentDocumentPane.ChildrenCount > 1); " is 292.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,CanExecuteMoveToNextTabGroupCommand,The length of the statement  "	return (parentDocumentGroup != null && parentDocumentPane != null && parentDocumentGroup.ChildrenCount > 1 && parentDocumentGroup.IndexOfChild (parentDocumentPane) < parentDocumentGroup.ChildrenCount - 1 && parentDocumentGroup.Children [parentDocumentGroup.IndexOfChild (parentDocumentPane) + 1] is LayoutDocumentPane); " is 319.
Long Statement,AvalonDock.Controls,LayoutItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,CanExecuteMoveToPreviousTabGroupCommand,The length of the statement  "	return (parentDocumentGroup != null && parentDocumentPane != null && parentDocumentGroup.ChildrenCount > 1 && parentDocumentGroup.IndexOfChild (parentDocumentPane) > 0 && parentDocumentGroup.Children [parentDocumentGroup.IndexOfChild (parentDocumentPane) - 1] is LayoutDocumentPane); " is 283.
Long Statement,AvalonDock.Controls,NavigatorWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\NavigatorWindow.cs,UpdateThemeResources,The length of the statement  "		var resourceDictionaryToRemove = Resources.MergedDictionaries.FirstOrDefault (r => r.Source == oldTheme.GetResourceUri ()); " is 123.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The length of the statement  "			if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Horizontal && _manager.Layout.RootPanel.Children.Count == 1) " is 141.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The length of the statement  "				if (layoutAnchorablePaneGroup != null && layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal) { " is 131.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The length of the statement  "			if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Horizontal && _manager.Layout.RootPanel.Children.Count == 1) " is 141.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The length of the statement  "				if (layoutAnchorablePaneGroup != null && layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal) { " is 131.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The length of the statement  "			if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Vertical && _manager.Layout.RootPanel.Children.Count == 1) " is 139.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The length of the statement  "				if (layoutAnchorablePaneGroup != null && layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical) { " is 129.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The length of the statement  "			if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Vertical && _manager.Layout.RootPanel.Children.Count == 1) " is 139.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The length of the statement  "				if (layoutAnchorablePaneGroup != null && layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical) { " is 129.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "	var layoutAnchorablePaneWithActualSize = anchorableFloatingWindowModel.RootPanel as ILayoutPositionableElementWithActualSize; " is 125.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "		var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth; " is 151.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "		var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height); " is 199.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "		var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight; " is 155.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "		var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0)); " is 200.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "		var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth; " is 151.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "		var previewBoxRect = new Rect (targetScreenRect.Right - overlayWindow.Left - Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height); " is 258.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "		var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight; " is 155.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "		var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Bottom - overlayWindow.Top - Math.Min (desideredHeight' targetScreenRect.Height / 2.0)' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0)); " is 263.
Long Statement,AvalonDock.Controls,DragService,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DragService.cs,GetOverlayWindowHosts,The length of the statement  "	_overlayWindowHosts.AddRange (_manager.GetFloatingWindowsByZOrder ().OfType<LayoutAnchorableFloatingWindowControl> ().Where (fw => fw != _floatingWindow && fw.IsVisible)); " is 171.
Long Statement,AvalonDock.Controls,DragService,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DragService.cs,UpdateMouseLocation,The length of the statement  "	var areasToAdd = _currentHost.GetDropAreas (_floatingWindow).Where (cw => !_currentWindowAreas.Contains (cw) && cw.DetectionRect.Contains (dragPosition)).ToList (); " is 164.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,OnInitialized,The length of the statement  "	//SetBinding(VisibilityProperty' new Binding("IsVisible") { Source = _model' Converter = new BoolToVisibilityConverter()' Mode = BindingMode.OneWay' ConverterParameter = Visibility.Hidden }); " is 191.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,HitTest,The length of the statement  "	Rect detectionRect = new Rect (this.PointToScreenDPIWithoutFlowDirection (new Point ())' this.TransformActualSizeToAncestor ()); " is 128.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,CreateOverlayWindow,The length of the statement  "	Rect rectWindow = new Rect (this.PointToScreenDPIWithoutFlowDirection (new Point ())' this.TransformActualSizeToAncestor ()); " is 125.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,FilterMessage,The length of the statement  "			_model.Descendents ().OfType<LayoutAnchorablePane> ().First (p => p.ChildrenCount > 0 && p.SelectedContent != null).SelectedContent.IsActive = true; " is 148.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,CanExecuteHideWindowCommand,The length of the statement  "		if (anchorableLayoutItem == null || anchorableLayoutItem.HideCommand == null || !anchorableLayoutItem.HideCommand.CanExecute (parameter)) { " is 139.
Long Statement,AvalonDock.Controls,LayoutAnchorControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorControl.cs,OnVisualParentChanged,The length of the statement  "		var oldLogicalParentPaneControl = LogicalTreeHelper.GetParent (contentModel.Content as UIElement) as ILogicalChildrenContainer; " is 127.
Long Statement,AvalonDock.Controls,LayoutAnchorControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorControl.cs,OnVisualParentChanged,The length of the statement  "	if (contentModel != null && contentModel.Content != null && contentModel.Root != null && contentModel.Content is UIElement) { " is 125.
Long Statement,AvalonDock.Controls,LayoutAnchorGroupControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorGroupControl.cs,OnModelChildrenCollectionChanged,The length of the statement  "	if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Remove || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace) { " is 170.
Long Statement,AvalonDock.Controls,LayoutAnchorGroupControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorGroupControl.cs,OnModelChildrenCollectionChanged,The length of the statement  "	if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace) { " is 167.
Long Statement,AvalonDock.Controls,LayoutAnchorSideControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorSideControl.cs,OnModelChildrenCollectionChanged,The length of the statement  "	if (e.OldItems != null && (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Remove || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace)) { " is 194.
Long Statement,AvalonDock.Controls,LayoutAnchorSideControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorSideControl.cs,OnModelChildrenCollectionChanged,The length of the statement  "	if (e.NewItems != null && (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace)) { " is 191.
Long Statement,AvalonDock.Controls,LayoutDocumentTabItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutDocumentTabItem.cs,UpdateDragDetails,The length of the statement  "	_otherTabs = _parentDocumentTabPanel.Children.Cast<TabItem> ().Where (ch => ch.Visibility != System.Windows.Visibility.Collapsed).ToList (); " is 140.
Long Statement,AvalonDock.Controls,LayoutDocumentTabItem,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutDocumentTabItem.cs,OnMouseMove,The length of the statement  "		if (Math.Abs (ptMouseMove.X - _mouseDownPoint.X) > SystemParameters.MinimumHorizontalDragDistance || Math.Abs (ptMouseMove.Y - _mouseDownPoint.Y) > SystemParameters.MinimumVerticalDragDistance) { " is 195.
Long Statement,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,UpdateThemeResources,The length of the statement  "		var resourceDictionaryToRemove = Resources.MergedDictionaries.FirstOrDefault (r => r.Source == oldTheme.GetResourceUri ()); " is 123.
Long Statement,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnInitialized,The length of the statement  "	CommandBindings.Add (new CommandBinding (Microsoft.Windows.Shell.SystemCommands.CloseWindowCommand' new ExecutedRoutedEventHandler ((s' args) => Microsoft.Windows.Shell.SystemCommands.CloseWindow ((Window)args.Parameter)))); " is 224.
Long Statement,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnInitialized,The length of the statement  "	CommandBindings.Add (new CommandBinding (Microsoft.Windows.Shell.SystemCommands.MaximizeWindowCommand' new ExecutedRoutedEventHandler ((s' args) => Microsoft.Windows.Shell.SystemCommands.MaximizeWindow ((Window)args.Parameter)))); " is 230.
Long Statement,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnInitialized,The length of the statement  "	CommandBindings.Add (new CommandBinding (Microsoft.Windows.Shell.SystemCommands.MinimizeWindowCommand' new ExecutedRoutedEventHandler ((s' args) => Microsoft.Windows.Shell.SystemCommands.MinimizeWindow ((Window)args.Parameter)))); " is 230.
Long Statement,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnInitialized,The length of the statement  "	CommandBindings.Add (new CommandBinding (Microsoft.Windows.Shell.SystemCommands.RestoreWindowCommand' new ExecutedRoutedEventHandler ((s' args) => Microsoft.Windows.Shell.SystemCommands.RestoreWindow ((Window)args.Parameter)))); " is 228.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,AttachPropertyChangeHandler,The length of the statement  "		child.Model.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler (this.OnChildModelPropertyChanged); " is 120.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,DetachPropertChangeHandler,The length of the statement  "		child.Model.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler (this.OnChildModelPropertyChanged); " is 120.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnChildModelPropertyChanged,The length of the statement  "	if (_fixingChildrenDockLengths.CanEnter && e.PropertyName == "DockWidth" && Orientation == System.Windows.Controls.Orientation.Horizontal) { " is 140.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnChildModelPropertyChanged,The length of the statement  "	} else if (_fixingChildrenDockLengths.CanEnter && e.PropertyName == "DockHeight" && Orientation == System.Windows.Controls.Orientation.Vertical) { " is 146.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,UpdateRowColDefinitions,The length of the statement  "					Width = childModel.IsVisible && nextChildModelVisibleExist ? new GridLength (manager.GridSplitterWidth) : new GridLength (0.0' GridUnitType.Pixel) " is 146.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,UpdateRowColDefinitions,The length of the statement  "					Height = childModel.IsVisible && nextChildModelVisibleExist ? new GridLength (manager.GridSplitterHeight) : new GridLength (0.0' GridUnitType.Pixel) " is 148.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragDelta,The length of the statement  "	Vector transformedDelta = trToWnd.Transform (new Point (e.HorizontalChange' e.VerticalChange)) - trToWnd.Transform (new Point ()); " is 130.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragDelta,The length of the statement  "		Canvas.SetLeft (_resizerGhost' MathHelper.MinMax (_initialStartPoint.X + transformedDelta.X' 0.0' _resizerWindowHost.Width - _resizerGhost.Width)); " is 147.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragDelta,The length of the statement  "		Canvas.SetTop (_resizerGhost' MathHelper.MinMax (_initialStartPoint.Y + transformedDelta.Y' 0.0' _resizerWindowHost.Height - _resizerGhost.Height)); " is 148.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragCompleted,The length of the statement  "	Vector transformedDelta = trToWnd.Transform (new Point (e.HorizontalChange' e.VerticalChange)) - trToWnd.Transform (new Point ()); " is 130.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragCompleted,The length of the statement  "			prevChildModel.DockWidth = new GridLength (prevChildModel.DockWidth.Value * (prevChildActualSize.Width + delta) / prevChildActualSize.Width' GridUnitType.Star); " is 160.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragCompleted,The length of the statement  "			nextChildModel.DockWidth = new GridLength (nextChildModel.DockWidth.Value * (nextChildActualSize.Width - delta) / nextChildActualSize.Width' GridUnitType.Star); " is 160.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragCompleted,The length of the statement  "			prevChildModel.DockHeight = new GridLength (prevChildModel.DockHeight.Value * (prevChildActualSize.Height + delta) / prevChildActualSize.Height' GridUnitType.Star); " is 164.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragCompleted,The length of the statement  "			nextChildModel.DockHeight = new GridLength (nextChildModel.DockHeight.Value * (nextChildActualSize.Height - delta) / nextChildActualSize.Height' GridUnitType.Star); " is 164.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,ShowResizerOverlayWindow,The length of the statement  "		actualSize = new Size (prevChildActualSize.Width - prevChildModel.DockMinWidth + splitter.ActualWidth + nextChildActualSize.Width - nextChildModel.DockMinWidth' nextChildActualSize.Height); " is 189.
Long Statement,AvalonDock.Controls,LayoutGridControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,ShowResizerOverlayWindow,The length of the statement  "		actualSize = new Size (prevChildActualSize.Width' prevChildActualSize.Height - prevChildModel.DockMinHeight + splitter.ActualHeight + nextChildActualSize.Height - nextChildModel.DockMinHeight); " is 193.
Long Statement,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The length of the statement  "				if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) { " is 207.
Long Statement,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The length of the statement  "				if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) { " is 207.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,UpdateThemeResources,The length of the statement  "		var resourceDictionaryToRemove = Resources.MergedDictionaries.FirstOrDefault (r => r.Source == oldTheme.GetResourceUri ()); " is 123.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,OnApplyTemplate,The length of the statement  "	_documentPaneDropTargetBottomAsAnchorablePane = GetTemplateChild ("PART_DocumentPaneDropTargetBottomAsAnchorablePane") as FrameworkElement; " is 139.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,OnApplyTemplate,The length of the statement  "	_documentPaneDropTargetTopAsAnchorablePane = GetTemplateChild ("PART_DocumentPaneDropTargetTopAsAnchorablePane") as FrameworkElement; " is 133.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,OnApplyTemplate,The length of the statement  "	_documentPaneDropTargetLeftAsAnchorablePane = GetTemplateChild ("PART_DocumentPaneDropTargetLeftAsAnchorablePane") as FrameworkElement; " is 135.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,OnApplyTemplate,The length of the statement  "	_documentPaneDropTargetRightAsAnchorablePane = GetTemplateChild ("PART_DocumentPaneDropTargetRightAsAnchorablePane") as FrameworkElement; " is 137.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "				yield return new DockingManagerDropTarget (dropAreaDockingManager.AreaElement' _dockingManagerDropTargetLeft.GetScreenArea ()' DropTargetType.DockingManagerDockLeft); " is 166.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "				yield return new DockingManagerDropTarget (dropAreaDockingManager.AreaElement' _dockingManagerDropTargetTop.GetScreenArea ()' DropTargetType.DockingManagerDockTop); " is 164.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "				yield return new DockingManagerDropTarget (dropAreaDockingManager.AreaElement' _dockingManagerDropTargetBottom.GetScreenArea ()' DropTargetType.DockingManagerDockBottom); " is 170.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "				yield return new DockingManagerDropTarget (dropAreaDockingManager.AreaElement' _dockingManagerDropTargetRight.GetScreenArea ()' DropTargetType.DockingManagerDockRight); " is 168.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "				yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetLeft.GetScreenArea ()' DropTargetType.AnchorablePaneDockLeft); " is 166.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "				yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetTop.GetScreenArea ()' DropTargetType.AnchorablePaneDockTop); " is 164.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "				yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetRight.GetScreenArea ()' DropTargetType.AnchorablePaneDockRight); " is 168.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "				yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetBottom.GetScreenArea ()' DropTargetType.AnchorablePaneDockBottom); " is 170.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "				yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetInto.GetScreenArea ()' DropTargetType.AnchorablePaneDockInside); " is 168.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "					lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea ().Right < dropAreaTabItem.GetScreenArea ().Right ? dropAreaTabItem : lastAreaTabItem; " is 161.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "					yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' dropAreaTabItem.GetScreenArea ()' DropTargetType.AnchorablePaneDockInside' tabIndex); " is 164.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "					var newAreaTabItemScreenArea = new Rect (lastAreaTabItemScreenArea.TopRight' new Point (lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom)); " is 190.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' newAreaTabItemScreenArea' DropTargetType.AnchorablePaneDockInside' parentPaneModel.Children.Count); " is 178.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "					yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' dropAreaTitle.GetScreenArea ()' DropTargetType.AnchorablePaneDockInside); " is 152.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetLeft.GetScreenArea ()' DropTargetType.DocumentPaneDockLeft); " is 162.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetTop.GetScreenArea ()' DropTargetType.DocumentPaneDockTop); " is 160.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetRight.GetScreenArea ()' DropTargetType.DocumentPaneDockRight); " is 164.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetBottom.GetScreenArea ()' DropTargetType.DocumentPaneDockBottom); " is 166.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetInto.GetScreenArea ()' DropTargetType.DocumentPaneDockInside); " is 164.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea ().Right < dropAreaTabItem.GetScreenArea ().Right ? dropAreaTabItem : lastAreaTabItem; " is 161.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' dropAreaTabItem.GetScreenArea ()' DropTargetType.DocumentPaneDockInside' tabIndex); " is 158.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						var newAreaTabItemScreenArea = new Rect (lastAreaTabItemScreenArea.TopRight' new Point (lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom)); " is 190.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "							yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' newAreaTabItemScreenArea' DropTargetType.DocumentPaneDockInside' parentPaneModel.Children.Count); " is 172.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropAsAnchorableTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetLeftAsAnchorablePane.GetScreenArea ()' DropTargetType.DocumentPaneDockAsAnchorableLeft); " is 198.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropAsAnchorableTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetTopAsAnchorablePane.GetScreenArea ()' DropTargetType.DocumentPaneDockAsAnchorableTop); " is 196.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropAsAnchorableTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetRightAsAnchorablePane.GetScreenArea ()' DropTargetType.DocumentPaneDockAsAnchorableRight); " is 200.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropAsAnchorableTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetBottomAsAnchorablePane.GetScreenArea ()' DropTargetType.DocumentPaneDockAsAnchorableBottom); " is 202.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetLeft.GetScreenArea ()' DropTargetType.DocumentPaneDockLeft); " is 158.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetTop.GetScreenArea ()' DropTargetType.DocumentPaneDockTop); " is 156.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetRight.GetScreenArea ()' DropTargetType.DocumentPaneDockRight); " is 160.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetBottom.GetScreenArea ()' DropTargetType.DocumentPaneDockBottom); " is 162.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetInto.GetScreenArea ()' DropTargetType.DocumentPaneDockInside); " is 160.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea ().Right < dropAreaTabItem.GetScreenArea ().Right ? dropAreaTabItem : lastAreaTabItem; " is 161.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' dropAreaTabItem.GetScreenArea ()' DropTargetType.DocumentPaneDockInside' tabIndex); " is 158.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "						var newAreaTabItemScreenArea = new Rect (lastAreaTabItemScreenArea.TopRight' new Point (lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom)); " is 190.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "							yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' newAreaTabItemScreenArea' DropTargetType.DocumentPaneDockInside' parentPaneModel.Children.Count); " is 172.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "					yield return new DocumentPaneGroupDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetInto.GetScreenArea ()' DropTargetType.DocumentPaneGroupDockInside); " is 170.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "			var layoutDocumentPane = (dropAreaDocumentPaneGroup.AreaElement.Model as LayoutDocumentPaneGroup).Children.First () as LayoutDocumentPane; " is 138.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneFullDropTargetLeft.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Horizontal ? Visibility.Visible : Visibility.Hidden; " is 148.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneFullDropTargetRight.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Horizontal ? Visibility.Visible : Visibility.Hidden; " is 149.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneFullDropTargetTop.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Vertical ? Visibility.Visible : Visibility.Hidden; " is 145.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneFullDropTargetBottom.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Vertical ? Visibility.Visible : Visibility.Hidden; " is 148.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "					int indexOfDocumentPane = parentDocumentPaneGroup.Children.Where (ch => ch.IsVisible).ToList ().IndexOf (layoutDocumentPane); " is 125.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneDropTargetBottomAsAnchorablePane.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Vertical ? (isLastChild ? System.Windows.Visibility.Visible : System.Windows.Visibility.Hidden) : System.Windows.Visibility.Hidden; " is 241.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneDropTargetTopAsAnchorablePane.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Vertical ? (isFirstChild ? System.Windows.Visibility.Visible : System.Windows.Visibility.Hidden) : System.Windows.Visibility.Hidden; " is 239.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneDropTargetLeftAsAnchorablePane.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Horizontal ? (isFirstChild ? System.Windows.Visibility.Visible : System.Windows.Visibility.Hidden) : System.Windows.Visibility.Hidden; " is 242.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneDropTargetRightAsAnchorablePane.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Horizontal ? (isLastChild ? System.Windows.Visibility.Visible : System.Windows.Visibility.Hidden) : System.Windows.Visibility.Hidden; " is 242.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneDropTargetLeft.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Horizontal ? Visibility.Visible : Visibility.Hidden; " is 144.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneDropTargetRight.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Horizontal ? Visibility.Visible : Visibility.Hidden; " is 145.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneDropTargetTop.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Vertical ? Visibility.Visible : Visibility.Hidden; " is 141.
Long Statement,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "						_documentPaneDropTargetBottom.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Vertical ? Visibility.Visible : Visibility.Hidden; " is 144.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,BuildWindowCore,The length of the statement  "		WindowStyle = Win32Helper.WS_CHILD | Win32Helper.WS_VISIBLE | Win32Helper.WS_CLIPSIBLINGS | Win32Helper.WS_CLIPCHILDREN' " is 120.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,WndProc,The length of the statement  "		Win32Helper.SetWindowPos (_internalHwndSource.Handle' Win32Helper.HWND_TOP' 0' 0' 0' 0' Win32Helper.SetWindowPosFlags.IgnoreMove | Win32Helper.SetWindowPosFlags.IgnoreResize); " is 175.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,CreateInternalGrid,The length of the statement  "			Width = _model.AutoHideWidth == 0.0 ? new GridLength (_model.AutoHideMinWidth) : new GridLength (_model.AutoHideWidth' GridUnitType.Pixel) " is 138.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,CreateInternalGrid,The length of the statement  "			Width = _model.AutoHideWidth == 0.0 ? new GridLength (_model.AutoHideMinWidth) : new GridLength (_model.AutoHideWidth' GridUnitType.Pixel)' " is 139.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,CreateInternalGrid,The length of the statement  "			Height = _model.AutoHideHeight == 0.0 ? new GridLength (_model.AutoHideMinHeight) : new GridLength (_model.AutoHideHeight' GridUnitType.Pixel)' " is 143.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,CreateInternalGrid,The length of the statement  "			Height = _model.AutoHideHeight == 0.0 ? new GridLength (_model.AutoHideMinHeight) : new GridLength (_model.AutoHideHeight' GridUnitType.Pixel)' " is 143.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The length of the statement  "		windowSize = new Size (managerSize.Width' managerSize.Height - _model.AutoHideMinHeight - 25.0 + splitter.ActualHeight); " is 120.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,OnResizerDragCompleted,The length of the statement  "	Vector transformedDelta = trToWnd.Transform (new Point (e.HorizontalChange' e.VerticalChange)) - trToWnd.Transform (new Point ()); " is 130.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,OnResizerDragDelta,The length of the statement  "	Vector transformedDelta = trToWnd.Transform (new Point (e.HorizontalChange' e.VerticalChange)) - trToWnd.Transform (new Point ()); " is 130.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,OnResizerDragDelta,The length of the statement  "		Canvas.SetLeft (_resizerGhost' MathHelper.MinMax (_initialStartPoint.X + transformedDelta.X' 0.0' _resizerWindowHost.Width - _resizerGhost.Width)); " is 147.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,OnResizerDragDelta,The length of the statement  "		Canvas.SetTop (_resizerGhost' MathHelper.MinMax (_initialStartPoint.Y + transformedDelta.Y' 0.0' _resizerWindowHost.Height - _resizerGhost.Height)); " is 148.
Long Statement,Standard,HRESULT,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,Make,The length of the statement  "	Assert.Implies ((int)facility != (int)((int)facility & 0x1FF)' facility == Facility.Ese || facility == Facility.WinCodec); " is 122.
Long Statement,Standard,MessageWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\MessageWindow.cs,_Dispose,The length of the statement  "		Dispatcher.BeginInvoke (DispatcherPriority.Normal' (DispatcherOperationCallback)(arg => _DestroyWindow (IntPtr.Zero' className))); " is 130.
Long Statement,Standard,MessageWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\MessageWindow.cs,_Dispose,The length of the statement  "			Dispatcher.BeginInvoke (DispatcherPriority.Normal' (DispatcherOperationCallback)(arg => _DestroyWindow (hwnd' className))); " is 123.
Long Statement,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,CreateWindowEx,The length of the statement  "	IntPtr ret = _CreateWindowEx (dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam); " is 139.
Long Statement,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetCurrentThemeName,The length of the statement  "	_GetCurrentThemeName (fileNameBuilder' fileNameBuilder.Capacity' colorBuilder' colorBuilder.Capacity' sizeBuilder' sizeBuilder.Capacity).ThrowIfFailed (); " is 154.
Long Statement,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,SetProcessWorkingSetSize,The length of the statement  "	if (!_SetProcessWorkingSetSize (hProcess' new IntPtr (dwMinimumWorkingSetSize)' new IntPtr (dwMaximumWorkingSetSize))) { " is 120.
Long Statement,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,UpdateLayeredWindow,The length of the statement  "	if (!_UpdateLayeredWindowIntPtr (hwnd' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' crKey' ref pblend' dwFlags)) { " is 134.
Long Statement,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,ColorFromArgbDword,The length of the statement  "	return Color.FromArgb ((byte)((color & 0xFF000000) >> 24)' (byte)((color & 0x00FF0000) >> 16)' (byte)((color & 0x0000FF00) >> 8)' (byte)((color & 0x000000FF) >> 0)); " is 165.
Long Statement,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The length of the statement  "			drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height); " is 135.
Long Statement,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_MatchImage,The length of the statement  "	int score = 2 * _WeightedAbs (bpp' bitDepth' false) + _WeightedAbs (frame.PixelWidth' width' true) + _WeightedAbs (frame.PixelHeight' height' true); " is 148.
Long Statement,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_GetBestMatch,The length of the statement  "		int currentIconBitDepth = isBitmapIconDecoder ? frames [i].Thumbnail.Format.BitsPerPixel : frames [i].Format.BitsPerPixel; " is 122.
Long Statement,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_GetBitDepth,The length of the statement  "			s_bitDepth = NativeMethods.GetDeviceCaps (dc' DeviceCap.BITSPIXEL) * NativeMethods.GetDeviceCaps (dc' DeviceCap.PLANES); " is 120.
Long Statement,Standard,Verify,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,PropertyIsNotNull,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.InvariantCulture' "The property {0} cannot be null at this time."' name)); " is 138.
Long Statement,Standard,Verify,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,PropertyIsNull,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.InvariantCulture' "The property {0} must be null at this time."' name)); " is 136.
Long Statement,Standard,Verify,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,BoundedInteger,The length of the statement  "		throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "The integer value must be bounded with [{0}' {1})"' lowerBoundInclusive' upperBoundExclusive)' parameterName); " is 185.
Long Statement,Standard,Verify,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,FileExists,The length of the statement  "		throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "No file exists at \"{0}\""' filePath)' parameterName); " is 129.
Long Statement,Standard,Verify,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,ImplementsInterface,The length of the statement  "		throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "The parameter must implement interface {0}."' interfaceType.ToString ())' parameterName); " is 164.
Long Statement,Microsoft.Windows.Shell,SystemCommands,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemCommands.cs,ShowSystemMenuPhysicalCoordinates,The length of the statement  "	uint cmd = NativeMethods.TrackPopupMenuEx (hmenu' TPM_LEFTBUTTON | TPM_RETURNCMD' (int)physicalScreenLocation.X' (int)physicalScreenLocation.Y' hwnd' IntPtr.Zero); " is 163.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowResizeBorderThickness,The length of the statement  "	Size frameSize = new Size (NativeMethods.GetSystemMetrics (SM.CXSIZEFRAME)' NativeMethods.GetSystemMetrics (SM.CYSIZEFRAME)); " is 125.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowResizeBorderThickness,The length of the statement  "	WindowResizeBorderThickness = new Thickness (frameSizeInDips.Width' frameSizeInDips.Height' frameSizeInDips.Width' frameSizeInDips.Height); " is 139.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowNonClientFrameThickness,The length of the statement  "	Size frameSize = new Size (NativeMethods.GetSystemMetrics (SM.CXSIZEFRAME)' NativeMethods.GetSystemMetrics (SM.CYSIZEFRAME)); " is 125.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowNonClientFrameThickness,The length of the statement  "	WindowNonClientFrameThickness = new Thickness (frameSizeInDips.Width' frameSizeInDips.Height + captionHeightInDips' frameSizeInDips.Width' frameSizeInDips.Height); " is 163.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeCaptionButtonLocation,The length of the statement  "	// For all known themes' the RECT for the maximize box shouldn't add anything to the union of the minimize and close boxes. " is 123.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeCaptionButtonLocation,The length of the statement  "	var deviceCaptionLocation = new Rect (rcAllCaptionButtons.Left - rcWindow.Width - rcWindow.Left' rcAllCaptionButtons.Top - rcWindow.Top' rcAllCaptionButtons.Width' rcAllCaptionButtons.Height); " is 192.
Long Statement,Microsoft.Windows.Shell,WindowChrome,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChrome.cs,_OnChromeChanged,The length of the statement  "	// There can be a many:1 relationship of to Window to WindowChrome objects' but a 1:1 for a Window and a WindowChromeWorker. " is 124.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetWindow,The length of the statement  "		Utility.AddDependencyPropertyChangeListener (_window' Window.TemplateProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 130.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetWindow,The length of the statement  "		Utility.AddDependencyPropertyChangeListener (_window' Window.FlowDirectionProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 135.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_UnsetWindow,The length of the statement  "		Utility.RemoveDependencyPropertyChangeListener (_window' Window.TemplateProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 133.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_UnsetWindow,The length of the statement  "		Utility.RemoveDependencyPropertyChangeListener (_window' Window.FlowDirectionProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 138.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "	Rect rcLogicalWindow = DpiHelper.DeviceRectToLogical (new Rect (rcWindow.Left' rcWindow.Top' rcWindow.Width' rcWindow.Height)); " is 127.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "	Rect rcLogicalClient = DpiHelper.DeviceRectToLogical (new Rect (rcAdjustedClient.Left' rcAdjustedClient.Top' rcAdjustedClient.Width' rcAdjustedClient.Height)); " is 159.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "	Thickness nonClientThickness = new Thickness (rcLogicalWindow.Left - rcLogicalClient.Left' rcLogicalWindow.Top - rcLogicalClient.Top' rcLogicalClient.Right - rcLogicalWindow.Right' rcLogicalClient.Bottom - rcLogicalWindow.Bottom); " is 230.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "	rootElement.Margin = new Thickness (0' 0' -(nonClientThickness.Left + nonClientThickness.Right)' -(nonClientThickness.Top + nonClientThickness.Bottom)); " is 152.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "	// This works fine' but if the window is dynamically changing its FlowDirection then this can have really bizarre side effects. " is 127.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "	// This will mostly work if the FlowDirection is dynamically changed' but there aren't many real scenarios that would call for " is 126.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "		rootElement.RenderTransform = new MatrixTransform (1' 0' 0' 1' -(nonClientThickness.Left + nonClientThickness.Right)' 0); " is 121.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupWindows7Issues,The length of the statement  "			// Disabling this for the published code to reduce debug noise.  This will get compiled away for retail binaries anyways. " is 121.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupRestoreBounds,The length of the statement  "			Point adjustedTopLeft = DpiHelper.DevicePixelsToLogical (new Point (wp.rcNormalPosition.Left - adjustedDeviceRc.Left' wp.rcNormalPosition.Top - adjustedDeviceRc.Top)); " is 167.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HandleNCRButtonUp,The length of the statement  "			SystemCommands.ShowSystemMenuPhysicalCoordinates (_window' new Point (Utility.GET_X_LPARAM (lParam)' Utility.GET_Y_LPARAM (lParam))); " is 133.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HandleEnterSizeMove,The length of the statement  "		// Realistically we also don't want to update the start position when moving from one docked state to another (or to and from maximized)' " is 137.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HandleEnterSizeMove,The length of the statement  "		// but it's tricky to detect and this is already a workaround for a bug that's fixed in newer versions of the framework. " is 120.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HandleExitSizeMove,The length of the statement  "	// If they did that' then we need to try to update the restore bounds or else WPF will put the window at the maximized location (e.g. (-8'-8)). " is 143.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "				hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius); " is 137.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "				Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius); " is 121.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "				Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius); " is 127.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "				Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius); " is 130.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_CreateRoundRectRgn,The length of the statement  "		return NativeMethods.CreateRectRgn ((int)Math.Floor (region.Left)' (int)Math.Floor (region.Top)' (int)Math.Ceiling (region.Right)' (int)Math.Ceiling (region.Bottom)); " is 166.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_CreateRoundRectRgn,The length of the statement  "	return NativeMethods.CreateRoundRectRgn ((int)Math.Floor (region.Left)' (int)Math.Floor (region.Top)' (int)Math.Ceiling (region.Right) + 1' (int)Math.Ceiling (region.Bottom) + 1' (int)Math.Ceiling (radius)' (int)Math.Ceiling (radius)); " is 235.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_ExtendGlassFrame,The length of the statement  "		Point deviceTopLeft = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.GlassFrameThickness.Left' _chromeInfo.GlassFrameThickness.Top)); " is 142.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_ExtendGlassFrame,The length of the statement  "		Point deviceBottomRight = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.GlassFrameThickness.Right' _chromeInfo.GlassFrameThickness.Bottom)); " is 150.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "	if (mousePosition.Y >= windowPosition.Top && mousePosition.Y < windowPosition.Top + _chromeInfo.ResizeBorderThickness.Top + _chromeInfo.CaptionHeight) { " is 152.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "	} else if (mousePosition.Y < windowPosition.Bottom && mousePosition.Y >= windowPosition.Bottom - (int)_chromeInfo.ResizeBorderThickness.Bottom) { " is 145.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "	if (mousePosition.X >= windowPosition.Left && mousePosition.X < windowPosition.Left + (int)_chromeInfo.ResizeBorderThickness.Left) { " is 132.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "	} else if (mousePosition.X < windowPosition.Right && mousePosition.X >= windowPosition.Right - _chromeInfo.ResizeBorderThickness.Right) { " is 137.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,HitTest,The length of the statement  "	Rect detectionRect = new Rect (this.PointToScreenDPIWithoutFlowDirection (new Point ())' this.TransformActualSizeToAncestor ()); " is 128.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,CreateOverlayWindow,The length of the statement  "	Rect rectWindow = new Rect (this.PointToScreenDPIWithoutFlowDirection (new Point ())' this.TransformActualSizeToAncestor ()); " is 125.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachDocumentsSource,The length of the statement  "	//    throw new InvalidOperationException("Unable to set the DocumentsSource property if LayoutDocument objects are already present in the model"); " is 147.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachDocumentsSource,The length of the statement  "	//    throw new InvalidOperationException("Layout must contains at least one LayoutDocumentPane in order to host documents"); " is 125.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachDocumentsSource,The length of the statement  "				throw new InvalidOperationException ("Layout must contains at least one LayoutDocumentPane in order to host documents"); " is 120.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachDocumentsSource,The length of the statement  "		documentsSourceAsNotifier.CollectionChanged += new NotifyCollectionChangedEventHandler (documentsSourceElementsChanged); " is 120.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,documentsSourceElementsChanged,The length of the statement  "	if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Remove || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace) { " is 170.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,documentsSourceElementsChanged,The length of the statement  "			var documentsToRemove = Layout.Descendents ().OfType<LayoutDocument> ().Where (d => e.OldItems.Contains (d.Content)).ToArray (); " is 128.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,documentsSourceElementsChanged,The length of the statement  "	if (e.NewItems != null && (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace)) { " is 191.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,documentsSourceElementsChanged,The length of the statement  "			//    throw new InvalidOperationException("Layout must contains at least one LayoutDocumentPane in order to host documents"); " is 125.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,documentsSourceElementsChanged,The length of the statement  "						throw new InvalidOperationException ("Layout must contains at least one LayoutDocumentPane in order to host documents"); " is 120.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,DetachDocumentsSource,The length of the statement  "	var documentsToRemove = layout.Descendents ().OfType<LayoutDocument> ().Where (d => documentsSource.Contains (d.Content)).ToArray (); " is 133.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,DetachDocumentsSource,The length of the statement  "		documentsSourceAsNotifier.CollectionChanged -= new NotifyCollectionChangedEventHandler (documentsSourceElementsChanged); " is 120.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,_ExecuteCloseAllButThisCommand,The length of the statement  "	foreach (var contentToClose in Layout.Descendents ().OfType<LayoutContent> ().Where (d => d != contentSelected && (d.Parent is LayoutDocumentPane || d.Parent is LayoutDocumentFloatingWindow)).ToArray ()) { " is 205.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The length of the statement  "	//    throw new InvalidOperationException("Unable to set the AnchorablesSource property if LayoutAnchorable objects are already present in the model"); " is 151.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The length of the statement  "		anchorablePane = layout.Descendents ().OfType<LayoutAnchorablePane> ().Where (pane => !pane.IsHostedInFloatingWindow && pane.GetSide () == AnchorSide.Right).FirstOrDefault (); " is 175.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The length of the statement  "		anchorablesSourceAsNotifier.CollectionChanged += new NotifyCollectionChangedEventHandler (anchorablesSourceElementsChanged); " is 124.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The length of the statement  "	if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Remove || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace) { " is 170.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The length of the statement  "			var anchorablesToRemove = Layout.Descendents ().OfType<LayoutAnchorable> ().Where (d => e.OldItems.Contains (d.Content)).ToArray (); " is 132.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The length of the statement  "	if (e.NewItems != null && (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace)) { " is 191.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The length of the statement  "				anchorablePane = Layout.Descendents ().OfType<LayoutAnchorablePane> ().Where (pane => !pane.IsHostedInFloatingWindow && pane.GetSide () == AnchorSide.Right).FirstOrDefault (); " is 175.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,DetachAnchorablesSource,The length of the statement  "	var anchorablesToRemove = layout.Descendents ().OfType<LayoutAnchorable> ().Where (d => anchorablesSource.Contains (d.Content)).ToArray (); " is 139.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,DetachAnchorablesSource,The length of the statement  "		anchorablesSourceAsNotifier.CollectionChanged -= new NotifyCollectionChangedEventHandler (anchorablesSourceElementsChanged); " is 124.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,InternalSetActiveContent,The length of the statement  "	var layoutContent = Layout.Descendents ().OfType<LayoutContent> ().FirstOrDefault (lc => lc == contentObject || lc.Content == contentObject); " is 141.
Long Statement,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,OnThemeChanged,The length of the statement  "		var resourceDictionaryToRemove = resources.MergedDictionaries.FirstOrDefault (r => r.Source == oldTheme.GetResourceUri ()); " is 123.
Long Statement,AvalonDock.Layout,Extentions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Extentions.cs,GetSide,The length of the statement  "				return parentContainer.Orientation == System.Windows.Controls.Orientation.Horizontal ? AnchorSide.Left : AnchorSide.Top; " is 120.
Long Statement,AvalonDock.Layout,Extentions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Extentions.cs,GetSide,The length of the statement  "			if (childElementAsContainer != null && (childElementAsContainer.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childElementAsContainer.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) { " is 219.
Long Statement,AvalonDock.Layout,Extentions,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Extentions.cs,GetSide,The length of the statement  "				return parentContainer.Orientation == System.Windows.Controls.Orientation.Horizontal ? AnchorSide.Right : AnchorSide.Bottom; " is 124.
Long Statement,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,InternalDock,The length of the statement  "		anchorablePane = root.Descendents ().OfType<LayoutAnchorablePane> ().Where (pane => !pane.IsHostedInFloatingWindow && pane.GetSide () == AnchorSide.Right).FirstOrDefault (); " is 173.
Long Statement,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,AddToLayout,The length of the statement  "		var anchorablePane = manager.Layout.Descendents ().OfType<LayoutAnchorablePane> ().FirstOrDefault (p => p.GetSide () == side); " is 126.
Long Statement,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ToggleAutoHide,The length of the statement  "			foreach (var cnt in root.Descendents ().OfType<ILayoutPreviousContainer> ().Where (c => c.PreviousContainer == parentGroup)) { " is 126.
Long Statement,AvalonDock.Layout,LayoutContent,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,WriteXml,The length of the statement  "		writer.WriteAttributeString ("LastActivationTimeStamp"' LastActivationTimeStamp.Value.ToString (CultureInfo.InvariantCulture)); " is 127.
Long Statement,AvalonDock.Layout,LayoutContent,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,Dock,The length of the statement  "		var currentContainerIndex = (currentContainer is ILayoutGroup) ? (currentContainer as ILayoutGroup).IndexOfChild (this) : -1; " is 125.
Long Statement,AvalonDock.Layout,LayoutDocument,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutDocument.cs,InternalDock,The length of the statement  "			throw new InvalidOperationException ("Layout must contains at least one LayoutDocumentPane in order to host documents"); " is 120.
Long Statement,AvalonDock.Layout,LayoutGroup,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutGroup.cs,_children_CollectionChanged,The length of the statement  "	if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Remove || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace) { " is 170.
Long Statement,AvalonDock.Layout,LayoutGroup,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutGroup.cs,_children_CollectionChanged,The length of the statement  "	if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace) { " is 167.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,_floatingWindows_CollectionChanged,The length of the statement  "	if (e.OldItems != null && (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Remove || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace)) { " is 194.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,_floatingWindows_CollectionChanged,The length of the statement  "	if (e.NewItems != null && (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace)) { " is 191.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,_hiddenAnchorables_CollectionChanged,The length of the statement  "	if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Remove || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace) { " is 170.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,_hiddenAnchorables_CollectionChanged,The length of the statement  "	if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace) { " is 167.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "		foreach (var content in this.Descendents ().OfType<ILayoutPreviousContainer> ().Where (c => c.PreviousContainer != null && (c.PreviousContainer.Parent == null || c.PreviousContainer.Parent.Root != this))) { " is 206.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "			foreach (var contentReferencingEmptyPane in this.Descendents ().OfType<LayoutContent> ().Where (c => ((ILayoutPreviousContainer)c).PreviousContainer == emptyPane && !c.IsFloating)) { " is 182.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "			if (emptyPane is LayoutDocumentPane && this.Descendents ().OfType<LayoutDocumentPane> ().Count (c => c != emptyPane) == 0) " is 122.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "			foreach (var emptyPaneGroup in this.Descendents ().OfType<LayoutAnchorablePaneGroup> ().Where (p => p.ChildrenCount == 0)) { " is 124.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "		foreach (var paneGroupToCollapse in this.Descendents ().OfType<LayoutAnchorablePaneGroup> ().Where (p => p.ChildrenCount == 1 && p.Children [0] is LayoutAnchorablePaneGroup).ToArray ()) { " is 187.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "		foreach (var paneGroupToCollapse in this.Descendents ().OfType<LayoutDocumentPaneGroup> ().Where (p => p.ChildrenCount == 1 && p.Children [0] is LayoutDocumentPaneGroup).ToArray ()) { " is 183.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "		foreach (var panelToCollapse in this.Descendents ().OfType<LayoutPanel> ().Where (p => p.ChildrenCount == 1 && p.Children [0] is LayoutPanel).ToArray ()) { " is 155.
Long Statement,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "	System.Diagnostics.Debug.Assert (!this.Descendents ().OfType<LayoutAnchorablePane> ().Any (a => a.ChildrenCount == 0 && a.IsVisible)); " is 134.
Long Statement,AvalonDock.Layout.Serialization,LayoutSerializer,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,The length of the statement  "	foreach (var lcToAttach in layout.Descendents ().OfType<ILayoutPreviousContainer> ().Where (lc => lc.PreviousContainerId != null)) { " is 132.
Long Statement,AvalonDock.Layout.Serialization,LayoutSerializer,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,The length of the statement  "		var paneContainerToAttach = layout.Descendents ().OfType<ILayoutPaneSerializable> ().FirstOrDefault (lps => lps.Id == lcToAttach.PreviousContainerId); " is 150.
Long Statement,AvalonDock.Layout.Serialization,LayoutSerializer,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,The length of the statement  "	foreach (var lcToFix in layout.Descendents ().OfType<LayoutAnchorable> ().Where (lc => lc.Content == null).ToArray ()) { " is 120.
Long Statement,AvalonDock.Layout.Serialization,LayoutSerializer,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,The length of the statement  "			var args = new LayoutSerializationCallbackEventArgs (lcToFix' previousAchorable != null ? previousAchorable.Content : null); " is 124.
Long Statement,AvalonDock.Layout.Serialization,LayoutSerializer,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,The length of the statement  "			var args = new LayoutSerializationCallbackEventArgs (lcToFix' previousDocument != null ? previousDocument.Content : null); " is 122.
Complex Conditional,AvalonDock.Controls,FocusElementManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\FocusElementManager.cs,manager_PreviewGotKeyboardFocus,The conditional expression  "focusedElement != null && !(focusedElement is LayoutAnchorableTabItem || focusedElement is LayoutDocumentTabItem) && !(focusedElement is ICommandSource)"  is complex.
Complex Conditional,AvalonDock.Controls,LayoutAnchorControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorControl.cs,OnVisualParentChanged,The conditional expression  "contentModel != null && contentModel.Content != null && contentModel.Root != null && contentModel.Content is UIElement"  is complex.
Complex Conditional,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The conditional expression  "a >= 0 && b >= 0 && c >= 0 && d >= 0"  is complex.
Virtual Method Call from Constructor,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,LayoutFloatingWindowControl,The constructor "LayoutFloatingWindowControl" calls a virtual method "UpdateThemeResources".
Empty Catch Block,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GuidTryParse,The method has an empty catch block.
Empty Catch Block,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GuidTryParse,The method has an empty catch block.
Empty Catch Block,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupWindows7Issues,The method has an empty catch block.
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.AnchorablePaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.TopLeft;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.TopRight  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  }  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.AnchorablePaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.TopLeft;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.TopRight  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  }  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.AnchorablePaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.TopLeft;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.TopRight  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  }  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.AnchorablePaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.TopLeft;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.TopRight  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  }  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.AnchorablePaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.TopLeft;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.TopRight  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  }  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.AnchorablePaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.TopLeft;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.TopRight  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  }  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Height /= 2.0;  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Height /= 2.0;  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Width /= 2.0;  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Width /= 2.0;  
Magic Number,AvalonDock.Controls,AutoHideWindowManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AutoHideWindowManager.cs,SetupCloseTimer,The following statement contains a magic number: _closeTimer.Interval = TimeSpan.FromMilliseconds (1500);  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockAsAnchorableBottom: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableTop: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableRight: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableLeft: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockAsAnchorableBottom: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableTop: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableRight: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableLeft: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockAsAnchorableBottom: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableTop: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableRight: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableLeft: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockAsAnchorableBottom: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableTop: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableRight: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableLeft: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockAsAnchorableBottom: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableTop: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableRight: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableLeft: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockAsAnchorableBottom: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableTop: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableRight: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableLeft: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Offset (0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Height /= 3.0;  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Height /= 3.0;  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Offset (targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Width /= 3.0;  
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Width /= 3.0;  
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DockingManagerDockLeft: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockTop: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockRight: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Right - overlayWindow.Left - Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockBottom: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Bottom - overlayWindow.Top - Math.Min (desideredHeight' targetScreenRect.Height / 2.0)' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  }  
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DockingManagerDockLeft: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockTop: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockRight: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Right - overlayWindow.Left - Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockBottom: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Bottom - overlayWindow.Top - Math.Min (desideredHeight' targetScreenRect.Height / 2.0)' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  }  
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DockingManagerDockLeft: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockTop: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockRight: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Right - overlayWindow.Left - Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockBottom: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Bottom - overlayWindow.Top - Math.Min (desideredHeight' targetScreenRect.Height / 2.0)' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  }  
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DockingManagerDockLeft: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockTop: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockRight: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Right - overlayWindow.Left - Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockBottom: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Bottom - overlayWindow.Top - Math.Min (desideredHeight' targetScreenRect.Height / 2.0)' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  }  
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DockingManagerDockLeft: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockTop: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockRight: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Right - overlayWindow.Left - Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockBottom: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Bottom - overlayWindow.Top - Math.Min (desideredHeight' targetScreenRect.Height / 2.0)' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  }  
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DockingManagerDockLeft: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockTop: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockRight: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Right - overlayWindow.Left - Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockBottom: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Bottom - overlayWindow.Top - Math.Min (desideredHeight' targetScreenRect.Height / 2.0)' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.BottomRight;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.BottomLeft  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  case DropTargetType.DocumentPaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.BottomRight;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.BottomLeft  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  case DropTargetType.DocumentPaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.BottomRight;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.BottomLeft  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  case DropTargetType.DocumentPaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.BottomRight;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.BottomLeft  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  case DropTargetType.DocumentPaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.BottomRight;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.BottomLeft  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  case DropTargetType.DocumentPaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type) {  case DropTargetType.DocumentPaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.BottomRight;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.BottomLeft  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  case DropTargetType.DocumentPaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Height /= 2.0;  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Height /= 2.0;  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Width /= 2.0;  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: targetScreenRect.Width /= 2.0;  
Magic Number,AvalonDock.Controls,LayoutAnchorControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorControl.cs,OnMouseEnter,The following statement contains a magic number: if (!e.Handled) {  	_openUpTimer = new DispatcherTimer (DispatcherPriority.ApplicationIdle);  	_openUpTimer.Interval = TimeSpan.FromMilliseconds (400);  	_openUpTimer.Tick += new EventHandler (_openUpTimer_Tick);  	_openUpTimer.Start ();  }  
Magic Number,AvalonDock.Controls,LayoutAnchorControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorControl.cs,OnMouseEnter,The following statement contains a magic number: _openUpTimer.Interval = TimeSpan.FromMilliseconds (400);  
Magic Number,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnActivated,The following statement contains a magic number: if (_attachDrag && Mouse.LeftButton == MouseButtonState.Pressed) {  	IntPtr windowHandle = new WindowInteropHelper (this).Handle;  	var mousePosition = this.PointToScreenDPI (Mouse.GetPosition (this));  	var clientArea = Win32Helper.GetClientRect (windowHandle);  	var windowArea = Win32Helper.GetWindowRect (windowHandle);  	Left = mousePosition.X - windowArea.Width / 2.0;  	Top = mousePosition.Y - (windowArea.Height - clientArea.Height) / 2.0;  	_attachDrag = false;  	IntPtr lParam = new IntPtr (((int)mousePosition.X & (int)0xFFFF) | (((int)mousePosition.Y) << 16));  	Win32Helper.SendMessage (windowHandle' Win32Helper.WM_NCLBUTTONDOWN' new IntPtr (Win32Helper.HT_CAPTION)' lParam);  }  
Magic Number,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnActivated,The following statement contains a magic number: if (_attachDrag && Mouse.LeftButton == MouseButtonState.Pressed) {  	IntPtr windowHandle = new WindowInteropHelper (this).Handle;  	var mousePosition = this.PointToScreenDPI (Mouse.GetPosition (this));  	var clientArea = Win32Helper.GetClientRect (windowHandle);  	var windowArea = Win32Helper.GetWindowRect (windowHandle);  	Left = mousePosition.X - windowArea.Width / 2.0;  	Top = mousePosition.Y - (windowArea.Height - clientArea.Height) / 2.0;  	_attachDrag = false;  	IntPtr lParam = new IntPtr (((int)mousePosition.X & (int)0xFFFF) | (((int)mousePosition.Y) << 16));  	Win32Helper.SendMessage (windowHandle' Win32Helper.WM_NCLBUTTONDOWN' new IntPtr (Win32Helper.HT_CAPTION)' lParam);  }  
Magic Number,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnActivated,The following statement contains a magic number: if (_attachDrag && Mouse.LeftButton == MouseButtonState.Pressed) {  	IntPtr windowHandle = new WindowInteropHelper (this).Handle;  	var mousePosition = this.PointToScreenDPI (Mouse.GetPosition (this));  	var clientArea = Win32Helper.GetClientRect (windowHandle);  	var windowArea = Win32Helper.GetWindowRect (windowHandle);  	Left = mousePosition.X - windowArea.Width / 2.0;  	Top = mousePosition.Y - (windowArea.Height - clientArea.Height) / 2.0;  	_attachDrag = false;  	IntPtr lParam = new IntPtr (((int)mousePosition.X & (int)0xFFFF) | (((int)mousePosition.Y) << 16));  	Win32Helper.SendMessage (windowHandle' Win32Helper.WM_NCLBUTTONDOWN' new IntPtr (Win32Helper.HT_CAPTION)' lParam);  }  
Magic Number,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnActivated,The following statement contains a magic number: Left = mousePosition.X - windowArea.Width / 2.0;  
Magic Number,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnActivated,The following statement contains a magic number: Top = mousePosition.Y - (windowArea.Height - clientArea.Height) / 2.0;  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: if (_model.Orientation == Orientation.Horizontal) {  	if (_model.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ()) {  		for (int i = 0; i < _model.Children.Count; i++) {  			var childContainerModel = _model.Children [i] as ILayoutContainer;  			var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  			if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) {  				childPositionableModel.DockWidth = new GridLength (1.0' GridUnitType.Star);  			} else if (childPositionableModel != null && childPositionableModel.DockWidth.IsStar) {  				var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  				var widthToSet = Math.Max (childPositionableModelWidthActualSize.ActualWidth' childPositionableModel.DockMinWidth);  				widthToSet = Math.Min (widthToSet' ActualWidth / 2.0);  				widthToSet = Math.Max (widthToSet' childPositionableModel.DockMinWidth);  				childPositionableModel.DockWidth = new GridLength (widthToSet' GridUnitType.Pixel);  			}  		}  	} else {  		for (int i = 0; i < _model.Children.Count; i++) {  			var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  			if (!childPositionableModel.DockWidth.IsStar) {  				childPositionableModel.DockWidth = new GridLength (1.0' GridUnitType.Star);  			}  		}  	}  } else {  	if (_model.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ()) {  		for (int i = 0; i < _model.Children.Count; i++) {  			var childContainerModel = _model.Children [i] as ILayoutContainer;  			var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  			if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) {  				childPositionableModel.DockHeight = new GridLength (1.0' GridUnitType.Star);  			} else if (childPositionableModel != null && childPositionableModel.DockHeight.IsStar) {  				var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  				var heightToSet = Math.Max (childPositionableModelWidthActualSize.ActualHeight' childPositionableModel.DockMinHeight);  				heightToSet = Math.Min (heightToSet' ActualHeight / 2.0);  				heightToSet = Math.Max (heightToSet' childPositionableModel.DockMinHeight);  				childPositionableModel.DockHeight = new GridLength (heightToSet' GridUnitType.Pixel);  			}  		}  	} else {  		for (int i = 0; i < _model.Children.Count; i++) {  			var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  			if (!childPositionableModel.DockHeight.IsStar) {  				childPositionableModel.DockHeight = new GridLength (1.0' GridUnitType.Star);  			}  		}  	}  }  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: if (_model.Orientation == Orientation.Horizontal) {  	if (_model.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ()) {  		for (int i = 0; i < _model.Children.Count; i++) {  			var childContainerModel = _model.Children [i] as ILayoutContainer;  			var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  			if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) {  				childPositionableModel.DockWidth = new GridLength (1.0' GridUnitType.Star);  			} else if (childPositionableModel != null && childPositionableModel.DockWidth.IsStar) {  				var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  				var widthToSet = Math.Max (childPositionableModelWidthActualSize.ActualWidth' childPositionableModel.DockMinWidth);  				widthToSet = Math.Min (widthToSet' ActualWidth / 2.0);  				widthToSet = Math.Max (widthToSet' childPositionableModel.DockMinWidth);  				childPositionableModel.DockWidth = new GridLength (widthToSet' GridUnitType.Pixel);  			}  		}  	} else {  		for (int i = 0; i < _model.Children.Count; i++) {  			var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  			if (!childPositionableModel.DockWidth.IsStar) {  				childPositionableModel.DockWidth = new GridLength (1.0' GridUnitType.Star);  			}  		}  	}  } else {  	if (_model.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ()) {  		for (int i = 0; i < _model.Children.Count; i++) {  			var childContainerModel = _model.Children [i] as ILayoutContainer;  			var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  			if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) {  				childPositionableModel.DockHeight = new GridLength (1.0' GridUnitType.Star);  			} else if (childPositionableModel != null && childPositionableModel.DockHeight.IsStar) {  				var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  				var heightToSet = Math.Max (childPositionableModelWidthActualSize.ActualHeight' childPositionableModel.DockMinHeight);  				heightToSet = Math.Min (heightToSet' ActualHeight / 2.0);  				heightToSet = Math.Max (heightToSet' childPositionableModel.DockMinHeight);  				childPositionableModel.DockHeight = new GridLength (heightToSet' GridUnitType.Pixel);  			}  		}  	} else {  		for (int i = 0; i < _model.Children.Count; i++) {  			var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  			if (!childPositionableModel.DockHeight.IsStar) {  				childPositionableModel.DockHeight = new GridLength (1.0' GridUnitType.Star);  			}  		}  	}  }  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: if (_model.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ()) {  	for (int i = 0; i < _model.Children.Count; i++) {  		var childContainerModel = _model.Children [i] as ILayoutContainer;  		var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  		if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) {  			childPositionableModel.DockWidth = new GridLength (1.0' GridUnitType.Star);  		} else if (childPositionableModel != null && childPositionableModel.DockWidth.IsStar) {  			var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  			var widthToSet = Math.Max (childPositionableModelWidthActualSize.ActualWidth' childPositionableModel.DockMinWidth);  			widthToSet = Math.Min (widthToSet' ActualWidth / 2.0);  			widthToSet = Math.Max (widthToSet' childPositionableModel.DockMinWidth);  			childPositionableModel.DockWidth = new GridLength (widthToSet' GridUnitType.Pixel);  		}  	}  } else {  	for (int i = 0; i < _model.Children.Count; i++) {  		var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  		if (!childPositionableModel.DockWidth.IsStar) {  			childPositionableModel.DockWidth = new GridLength (1.0' GridUnitType.Star);  		}  	}  }  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: for (int i = 0; i < _model.Children.Count; i++) {  	var childContainerModel = _model.Children [i] as ILayoutContainer;  	var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  	if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) {  		childPositionableModel.DockWidth = new GridLength (1.0' GridUnitType.Star);  	} else if (childPositionableModel != null && childPositionableModel.DockWidth.IsStar) {  		var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  		var widthToSet = Math.Max (childPositionableModelWidthActualSize.ActualWidth' childPositionableModel.DockMinWidth);  		widthToSet = Math.Min (widthToSet' ActualWidth / 2.0);  		widthToSet = Math.Max (widthToSet' childPositionableModel.DockMinWidth);  		childPositionableModel.DockWidth = new GridLength (widthToSet' GridUnitType.Pixel);  	}  }  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) {  	childPositionableModel.DockWidth = new GridLength (1.0' GridUnitType.Star);  } else if (childPositionableModel != null && childPositionableModel.DockWidth.IsStar) {  	var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  	var widthToSet = Math.Max (childPositionableModelWidthActualSize.ActualWidth' childPositionableModel.DockMinWidth);  	widthToSet = Math.Min (widthToSet' ActualWidth / 2.0);  	widthToSet = Math.Max (widthToSet' childPositionableModel.DockMinWidth);  	childPositionableModel.DockWidth = new GridLength (widthToSet' GridUnitType.Pixel);  }  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: if (childPositionableModel != null && childPositionableModel.DockWidth.IsStar) {  	var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  	var widthToSet = Math.Max (childPositionableModelWidthActualSize.ActualWidth' childPositionableModel.DockMinWidth);  	widthToSet = Math.Min (widthToSet' ActualWidth / 2.0);  	widthToSet = Math.Max (widthToSet' childPositionableModel.DockMinWidth);  	childPositionableModel.DockWidth = new GridLength (widthToSet' GridUnitType.Pixel);  }  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: widthToSet = Math.Min (widthToSet' ActualWidth / 2.0);  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: if (_model.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ()) {  	for (int i = 0; i < _model.Children.Count; i++) {  		var childContainerModel = _model.Children [i] as ILayoutContainer;  		var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  		if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) {  			childPositionableModel.DockHeight = new GridLength (1.0' GridUnitType.Star);  		} else if (childPositionableModel != null && childPositionableModel.DockHeight.IsStar) {  			var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  			var heightToSet = Math.Max (childPositionableModelWidthActualSize.ActualHeight' childPositionableModel.DockMinHeight);  			heightToSet = Math.Min (heightToSet' ActualHeight / 2.0);  			heightToSet = Math.Max (heightToSet' childPositionableModel.DockMinHeight);  			childPositionableModel.DockHeight = new GridLength (heightToSet' GridUnitType.Pixel);  		}  	}  } else {  	for (int i = 0; i < _model.Children.Count; i++) {  		var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  		if (!childPositionableModel.DockHeight.IsStar) {  			childPositionableModel.DockHeight = new GridLength (1.0' GridUnitType.Star);  		}  	}  }  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: for (int i = 0; i < _model.Children.Count; i++) {  	var childContainerModel = _model.Children [i] as ILayoutContainer;  	var childPositionableModel = _model.Children [i] as ILayoutPositionableElement;  	if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) {  		childPositionableModel.DockHeight = new GridLength (1.0' GridUnitType.Star);  	} else if (childPositionableModel != null && childPositionableModel.DockHeight.IsStar) {  		var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  		var heightToSet = Math.Max (childPositionableModelWidthActualSize.ActualHeight' childPositionableModel.DockMinHeight);  		heightToSet = Math.Min (heightToSet' ActualHeight / 2.0);  		heightToSet = Math.Max (heightToSet' childPositionableModel.DockMinHeight);  		childPositionableModel.DockHeight = new GridLength (heightToSet' GridUnitType.Pixel);  	}  }  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: if (childContainerModel != null && (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> () || childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup> ())) {  	childPositionableModel.DockHeight = new GridLength (1.0' GridUnitType.Star);  } else if (childPositionableModel != null && childPositionableModel.DockHeight.IsStar) {  	var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  	var heightToSet = Math.Max (childPositionableModelWidthActualSize.ActualHeight' childPositionableModel.DockMinHeight);  	heightToSet = Math.Min (heightToSet' ActualHeight / 2.0);  	heightToSet = Math.Max (heightToSet' childPositionableModel.DockMinHeight);  	childPositionableModel.DockHeight = new GridLength (heightToSet' GridUnitType.Pixel);  }  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: if (childPositionableModel != null && childPositionableModel.DockHeight.IsStar) {  	var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;  	var heightToSet = Math.Max (childPositionableModelWidthActualSize.ActualHeight' childPositionableModel.DockMinHeight);  	heightToSet = Math.Min (heightToSet' ActualHeight / 2.0);  	heightToSet = Math.Max (heightToSet' childPositionableModel.DockMinHeight);  	childPositionableModel.DockHeight = new GridLength (heightToSet' GridUnitType.Pixel);  }  
Magic Number,AvalonDock.Controls,LayoutPanelControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: heightToSet = Math.Min (heightToSet' ActualHeight / 2.0);  
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: if (_side == AnchorSide.Right || _side == AnchorSide.Left) {  	windowSize = new Size (managerSize.Width - 25.0 + splitter.ActualWidth' managerSize.Height);  	_resizerGhost.Width = splitter.ActualWidth;  	_resizerGhost.Height = windowSize.Height;  	ptTopLeftScreen.Offset (25' 0.0);  } else {  	windowSize = new Size (managerSize.Width' managerSize.Height - _model.AutoHideMinHeight - 25.0 + splitter.ActualHeight);  	_resizerGhost.Height = splitter.ActualHeight;  	_resizerGhost.Width = windowSize.Width;  	ptTopLeftScreen.Offset (0.0' 25.0);  }  
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: if (_side == AnchorSide.Right || _side == AnchorSide.Left) {  	windowSize = new Size (managerSize.Width - 25.0 + splitter.ActualWidth' managerSize.Height);  	_resizerGhost.Width = splitter.ActualWidth;  	_resizerGhost.Height = windowSize.Height;  	ptTopLeftScreen.Offset (25' 0.0);  } else {  	windowSize = new Size (managerSize.Width' managerSize.Height - _model.AutoHideMinHeight - 25.0 + splitter.ActualHeight);  	_resizerGhost.Height = splitter.ActualHeight;  	_resizerGhost.Width = windowSize.Width;  	ptTopLeftScreen.Offset (0.0' 25.0);  }  
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: if (_side == AnchorSide.Right || _side == AnchorSide.Left) {  	windowSize = new Size (managerSize.Width - 25.0 + splitter.ActualWidth' managerSize.Height);  	_resizerGhost.Width = splitter.ActualWidth;  	_resizerGhost.Height = windowSize.Height;  	ptTopLeftScreen.Offset (25' 0.0);  } else {  	windowSize = new Size (managerSize.Width' managerSize.Height - _model.AutoHideMinHeight - 25.0 + splitter.ActualHeight);  	_resizerGhost.Height = splitter.ActualHeight;  	_resizerGhost.Width = windowSize.Width;  	ptTopLeftScreen.Offset (0.0' 25.0);  }  
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: if (_side == AnchorSide.Right || _side == AnchorSide.Left) {  	windowSize = new Size (managerSize.Width - 25.0 + splitter.ActualWidth' managerSize.Height);  	_resizerGhost.Width = splitter.ActualWidth;  	_resizerGhost.Height = windowSize.Height;  	ptTopLeftScreen.Offset (25' 0.0);  } else {  	windowSize = new Size (managerSize.Width' managerSize.Height - _model.AutoHideMinHeight - 25.0 + splitter.ActualHeight);  	_resizerGhost.Height = splitter.ActualHeight;  	_resizerGhost.Width = windowSize.Width;  	ptTopLeftScreen.Offset (0.0' 25.0);  }  
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: windowSize = new Size (managerSize.Width - 25.0 + splitter.ActualWidth' managerSize.Height);  
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: ptTopLeftScreen.Offset (25' 0.0);  
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: windowSize = new Size (managerSize.Width' managerSize.Height - _model.AutoHideMinHeight - 25.0 + splitter.ActualHeight);  
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: ptTopLeftScreen.Offset (0.0' 25.0);  
Magic Number,Standard,HRESULT,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,Make,The following statement contains a magic number: return new HRESULT ((uint)((severe ? (1 << 31) : 0) | ((int)facility << 16) | code));  
Magic Number,Standard,HRESULT,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,Make,The following statement contains a magic number: return new HRESULT ((uint)((severe ? (1 << 31) : 0) | ((int)facility << 16) | code));  
Magic Number,Standard,HRESULT,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,GetFacility,The following statement contains a magic number: return (Facility)((errorCode >> 16) & 0x1fff);  
Magic Number,Standard,RECT,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetHashCode,The following statement contains a magic number: return (_left << 16 | Utility.LOWORD (_right)) ^ (_top << 16 | Utility.LOWORD (_bottom));  
Magic Number,Standard,RECT,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetHashCode,The following statement contains a magic number: return (_left << 16 | Utility.LOWORD (_right)) ^ (_top << 16 | Utility.LOWORD (_bottom));  
Magic Number,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetModuleFileName,The following statement contains a magic number: while (true) {  	int size = _GetModuleFileName (hModule' buffer' buffer.Capacity);  	if (size == 0) {  		HRESULT.ThrowLastError ();  	}  	// GetModuleFileName returns nSize when it's truncated but does NOT set the last error.  	// MSDN documentation says this has changed in Windows 2000+.  	if (size == buffer.Capacity) {  		// Enlarge the buffer and try again.  		buffer.EnsureCapacity (buffer.Capacity * 2);  		continue;  	}  	return buffer.ToString ();  }  
Magic Number,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetModuleFileName,The following statement contains a magic number: if (size == buffer.Capacity) {  	// Enlarge the buffer and try again.  	buffer.EnsureCapacity (buffer.Capacity * 2);  	continue;  }  
Magic Number,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetModuleFileName,The following statement contains a magic number: buffer.EnsureCapacity (buffer.Capacity * 2);  
Magic Number,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetWindowLongPtr,The following statement contains a magic number: if (8 == IntPtr.Size) {  	ret = GetWindowLongPtr64 (hwnd' nIndex);  } else {  	ret = new IntPtr (GetWindowLongPtr32 (hwnd' nIndex));  }  
Magic Number,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,SetClassLongPtr,The following statement contains a magic number: if (8 == IntPtr.Size) {  	return SetClassLongPtr64 (hwnd' nIndex' dwNewLong);  }  
Magic Number,Standard,NativeMethods,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,SetWindowLongPtr,The following statement contains a magic number: if (8 == IntPtr.Size) {  	return SetWindowLongPtr64 (hwnd' nIndex' dwNewLong);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,RGB,The following statement contains a magic number: return c.R | (c.G << 8) | (c.B << 16);  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,RGB,The following statement contains a magic number: return c.R | (c.G << 8) | (c.B << 16);  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,ColorFromArgbDword,The following statement contains a magic number: return Color.FromArgb ((byte)((color & 0xFF000000) >> 24)' (byte)((color & 0x00FF0000) >> 16)' (byte)((color & 0x0000FF00) >> 8)' (byte)((color & 0x000000FF) >> 0));  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,ColorFromArgbDword,The following statement contains a magic number: return Color.FromArgb ((byte)((color & 0xFF000000) >> 24)' (byte)((color & 0x00FF0000) >> 16)' (byte)((color & 0x0000FF00) >> 8)' (byte)((color & 0x000000FF) >> 0));  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,ColorFromArgbDword,The following statement contains a magic number: return Color.FromArgb ((byte)((color & 0xFF000000) >> 24)' (byte)((color & 0x00FF0000) >> 16)' (byte)((color & 0x0000FF00) >> 8)' (byte)((color & 0x000000FF) >> 0));  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,HIWORD,The following statement contains a magic number: return (short)(i >> 16);  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null) {  	bf = GetBestMatch (bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);  } else {  	// Constrain the dimensions based on the aspect ratio.  	var drawingDimensions = new Rect (0' 0' dimensions.Width' dimensions.Height);  	// There's no reason to assume that the requested image dimensions are square.  	double renderRatio = dimensions.Width / dimensions.Height;  	double aspectRatio = image.Width / image.Height;  	// If it's smaller than the requested size' then place it in the middle and pad the image.  	if (image.Width <= dimensions.Width && image.Height <= dimensions.Height) {  		drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  	} else if (renderRatio > aspectRatio) {  		double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  		drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  	} else if (renderRatio < aspectRatio) {  		double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  		drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  	}  	var dv = new DrawingVisual ();  	DrawingContext dc = dv.RenderOpen ();  	dc.DrawImage (image' drawingDimensions);  	dc.Close ();  	var bmp = new RenderTargetBitmap ((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);  	bmp.Render (dv);  	bf = BitmapFrame.Create (bmp);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null) {  	bf = GetBestMatch (bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);  } else {  	// Constrain the dimensions based on the aspect ratio.  	var drawingDimensions = new Rect (0' 0' dimensions.Width' dimensions.Height);  	// There's no reason to assume that the requested image dimensions are square.  	double renderRatio = dimensions.Width / dimensions.Height;  	double aspectRatio = image.Width / image.Height;  	// If it's smaller than the requested size' then place it in the middle and pad the image.  	if (image.Width <= dimensions.Width && image.Height <= dimensions.Height) {  		drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  	} else if (renderRatio > aspectRatio) {  		double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  		drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  	} else if (renderRatio < aspectRatio) {  		double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  		drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  	}  	var dv = new DrawingVisual ();  	DrawingContext dc = dv.RenderOpen ();  	dc.DrawImage (image' drawingDimensions);  	dc.Close ();  	var bmp = new RenderTargetBitmap ((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);  	bmp.Render (dv);  	bf = BitmapFrame.Create (bmp);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null) {  	bf = GetBestMatch (bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);  } else {  	// Constrain the dimensions based on the aspect ratio.  	var drawingDimensions = new Rect (0' 0' dimensions.Width' dimensions.Height);  	// There's no reason to assume that the requested image dimensions are square.  	double renderRatio = dimensions.Width / dimensions.Height;  	double aspectRatio = image.Width / image.Height;  	// If it's smaller than the requested size' then place it in the middle and pad the image.  	if (image.Width <= dimensions.Width && image.Height <= dimensions.Height) {  		drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  	} else if (renderRatio > aspectRatio) {  		double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  		drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  	} else if (renderRatio < aspectRatio) {  		double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  		drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  	}  	var dv = new DrawingVisual ();  	DrawingContext dc = dv.RenderOpen ();  	dc.DrawImage (image' drawingDimensions);  	dc.Close ();  	var bmp = new RenderTargetBitmap ((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);  	bmp.Render (dv);  	bf = BitmapFrame.Create (bmp);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null) {  	bf = GetBestMatch (bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);  } else {  	// Constrain the dimensions based on the aspect ratio.  	var drawingDimensions = new Rect (0' 0' dimensions.Width' dimensions.Height);  	// There's no reason to assume that the requested image dimensions are square.  	double renderRatio = dimensions.Width / dimensions.Height;  	double aspectRatio = image.Width / image.Height;  	// If it's smaller than the requested size' then place it in the middle and pad the image.  	if (image.Width <= dimensions.Width && image.Height <= dimensions.Height) {  		drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  	} else if (renderRatio > aspectRatio) {  		double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  		drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  	} else if (renderRatio < aspectRatio) {  		double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  		drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  	}  	var dv = new DrawingVisual ();  	DrawingContext dc = dv.RenderOpen ();  	dc.DrawImage (image' drawingDimensions);  	dc.Close ();  	var bmp = new RenderTargetBitmap ((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);  	bmp.Render (dv);  	bf = BitmapFrame.Create (bmp);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null) {  	bf = GetBestMatch (bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);  } else {  	// Constrain the dimensions based on the aspect ratio.  	var drawingDimensions = new Rect (0' 0' dimensions.Width' dimensions.Height);  	// There's no reason to assume that the requested image dimensions are square.  	double renderRatio = dimensions.Width / dimensions.Height;  	double aspectRatio = image.Width / image.Height;  	// If it's smaller than the requested size' then place it in the middle and pad the image.  	if (image.Width <= dimensions.Width && image.Height <= dimensions.Height) {  		drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  	} else if (renderRatio > aspectRatio) {  		double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  		drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  	} else if (renderRatio < aspectRatio) {  		double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  		drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  	}  	var dv = new DrawingVisual ();  	DrawingContext dc = dv.RenderOpen ();  	dc.DrawImage (image' drawingDimensions);  	dc.Close ();  	var bmp = new RenderTargetBitmap ((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);  	bmp.Render (dv);  	bf = BitmapFrame.Create (bmp);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null) {  	bf = GetBestMatch (bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);  } else {  	// Constrain the dimensions based on the aspect ratio.  	var drawingDimensions = new Rect (0' 0' dimensions.Width' dimensions.Height);  	// There's no reason to assume that the requested image dimensions are square.  	double renderRatio = dimensions.Width / dimensions.Height;  	double aspectRatio = image.Width / image.Height;  	// If it's smaller than the requested size' then place it in the middle and pad the image.  	if (image.Width <= dimensions.Width && image.Height <= dimensions.Height) {  		drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  	} else if (renderRatio > aspectRatio) {  		double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  		drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  	} else if (renderRatio < aspectRatio) {  		double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  		drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  	}  	var dv = new DrawingVisual ();  	DrawingContext dc = dv.RenderOpen ();  	dc.DrawImage (image' drawingDimensions);  	dc.Close ();  	var bmp = new RenderTargetBitmap ((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);  	bmp.Render (dv);  	bf = BitmapFrame.Create (bmp);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (image.Width <= dimensions.Width && image.Height <= dimensions.Height) {  	drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  } else if (renderRatio > aspectRatio) {  	double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  	drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  } else if (renderRatio < aspectRatio) {  	double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  	drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (image.Width <= dimensions.Width && image.Height <= dimensions.Height) {  	drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  } else if (renderRatio > aspectRatio) {  	double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  	drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  } else if (renderRatio < aspectRatio) {  	double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  	drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (image.Width <= dimensions.Width && image.Height <= dimensions.Height) {  	drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  } else if (renderRatio > aspectRatio) {  	double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  	drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  } else if (renderRatio < aspectRatio) {  	double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  	drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (image.Width <= dimensions.Width && image.Height <= dimensions.Height) {  	drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  } else if (renderRatio > aspectRatio) {  	double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  	drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  } else if (renderRatio < aspectRatio) {  	double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  	drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: drawingDimensions = new Rect ((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (renderRatio > aspectRatio) {  	double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  	drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  } else if (renderRatio < aspectRatio) {  	double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  	drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (renderRatio > aspectRatio) {  	double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;  	drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  } else if (renderRatio < aspectRatio) {  	double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  	drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: drawingDimensions = new Rect ((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (renderRatio < aspectRatio) {  	double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;  	drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: drawingDimensions = new Rect (0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_WeightedAbs,The following statement contains a magic number: if (diff < 0) {  	diff = (fPunish ? -2 : -1) * diff;  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_WeightedAbs,The following statement contains a magic number: diff = (fPunish ? -2 : -1) * diff;  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_GetBestMatch,The following statement contains a magic number: for (int i = 0; i < frames.Count && bestScore != 0; ++i) {  	int currentIconBitDepth = isBitmapIconDecoder ? frames [i].Thumbnail.Format.BitsPerPixel : frames [i].Format.BitsPerPixel;  	if (currentIconBitDepth == 0) {  		currentIconBitDepth = 8;  	}  	int score = _MatchImage (frames [i]' bitDepth' width' height' currentIconBitDepth);  	if (score < bestScore) {  		bestIndex = i;  		bestBpp = currentIconBitDepth;  		bestScore = score;  	} else if (score == bestScore) {  		// Tie breaker: choose the higher color depth.  If that fails' choose first one.  		if (bestBpp < currentIconBitDepth) {  			bestIndex = i;  			bestBpp = currentIconBitDepth;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_GetBestMatch,The following statement contains a magic number: if (currentIconBitDepth == 0) {  	currentIconBitDepth = 8;  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_GetBestMatch,The following statement contains a magic number: currentIconBitDepth = 8;  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i) {  	char ch = url [i];  	if (ch == '+') {  		decoder.AddByte ((byte)' ');  		continue;  	}  	if (ch == '%' && i < length - 2) {  		// decode %uXXXX into a Unicode character.  		if (url [i + 1] == 'u' && i < length - 5) {  			int a = _HexToInt (url [i + 2]);  			int b = _HexToInt (url [i + 3]);  			int c = _HexToInt (url [i + 4]);  			int d = _HexToInt (url [i + 5]);  			if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  				decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  				i += 5;  				continue;  			}  		} else {  			// decode %XX into a Unicode character.  			int a = _HexToInt (url [i + 1]);  			int b = _HexToInt (url [i + 2]);  			if (a >= 0 && b >= 0) {  				decoder.AddByte ((byte)((a << 4) | b));  				i += 2;  				continue;  			}  		}  	}  	// Add any 7bit character as a byte.  	if ((ch & 0xFF80) == 0) {  		decoder.AddByte ((byte)ch);  	} else {  		decoder.AddChar (ch);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (ch == '%' && i < length - 2) {  	// decode %uXXXX into a Unicode character.  	if (url [i + 1] == 'u' && i < length - 5) {  		int a = _HexToInt (url [i + 2]);  		int b = _HexToInt (url [i + 3]);  		int c = _HexToInt (url [i + 4]);  		int d = _HexToInt (url [i + 5]);  		if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  			decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  			i += 5;  			continue;  		}  	} else {  		// decode %XX into a Unicode character.  		int a = _HexToInt (url [i + 1]);  		int b = _HexToInt (url [i + 2]);  		if (a >= 0 && b >= 0) {  			decoder.AddByte ((byte)((a << 4) | b));  			i += 2;  			continue;  		}  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (url [i + 1] == 'u' && i < length - 5) {  	int a = _HexToInt (url [i + 2]);  	int b = _HexToInt (url [i + 3]);  	int c = _HexToInt (url [i + 4]);  	int d = _HexToInt (url [i + 5]);  	if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  		decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  		i += 5;  		continue;  	}  } else {  	// decode %XX into a Unicode character.  	int a = _HexToInt (url [i + 1]);  	int b = _HexToInt (url [i + 2]);  	if (a >= 0 && b >= 0) {  		decoder.AddByte ((byte)((a << 4) | b));  		i += 2;  		continue;  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  	decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  	i += 5;  	continue;  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  	decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  	i += 5;  	continue;  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  	decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  	i += 5;  	continue;  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (a >= 0 && b >= 0 && c >= 0 && d >= 0) {  	decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  	i += 5;  	continue;  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: decoder.AddChar ((char)((a << 12) | (b << 8) | (c << 4) | d));  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: i += 5;  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (a >= 0 && b >= 0) {  	decoder.AddByte ((byte)((a << 4) | b));  	i += 2;  	continue;  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: if (a >= 0 && b >= 0) {  	decoder.AddByte ((byte)((a << 4) | b));  	i += 2;  	continue;  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: decoder.AddByte ((byte)((a << 4) | b));  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: i += 2;  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlEncode,The following statement contains a magic number: if (needsEncoding) {  	var buffer = new byte[bytes.Length + (unsafeCharCount * 2)];  	int writeIndex = 0;  	foreach (byte b in bytes) {  		if (_UrlEncodeIsSafe (b)) {  			buffer [writeIndex++] = b;  		} else if (b == ' ') {  			buffer [writeIndex++] = (byte)'+';  		} else {  			buffer [writeIndex++] = (byte)'%';  			buffer [writeIndex++] = _IntToHex ((b >> 4) & 0xF);  			buffer [writeIndex++] = _IntToHex (b & 0xF);  		}  	}  	bytes = buffer;  	Assert.AreEqual (buffer.Length' writeIndex);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlEncode,The following statement contains a magic number: if (needsEncoding) {  	var buffer = new byte[bytes.Length + (unsafeCharCount * 2)];  	int writeIndex = 0;  	foreach (byte b in bytes) {  		if (_UrlEncodeIsSafe (b)) {  			buffer [writeIndex++] = b;  		} else if (b == ' ') {  			buffer [writeIndex++] = (byte)'+';  		} else {  			buffer [writeIndex++] = (byte)'%';  			buffer [writeIndex++] = _IntToHex ((b >> 4) & 0xF);  			buffer [writeIndex++] = _IntToHex (b & 0xF);  		}  	}  	bytes = buffer;  	Assert.AreEqual (buffer.Length' writeIndex);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlEncode,The following statement contains a magic number: foreach (byte b in bytes) {  	if (_UrlEncodeIsSafe (b)) {  		buffer [writeIndex++] = b;  	} else if (b == ' ') {  		buffer [writeIndex++] = (byte)'+';  	} else {  		buffer [writeIndex++] = (byte)'%';  		buffer [writeIndex++] = _IntToHex ((b >> 4) & 0xF);  		buffer [writeIndex++] = _IntToHex (b & 0xF);  	}  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlEncode,The following statement contains a magic number: if (_UrlEncodeIsSafe (b)) {  	buffer [writeIndex++] = b;  } else if (b == ' ') {  	buffer [writeIndex++] = (byte)'+';  } else {  	buffer [writeIndex++] = (byte)'%';  	buffer [writeIndex++] = _IntToHex ((b >> 4) & 0xF);  	buffer [writeIndex++] = _IntToHex (b & 0xF);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlEncode,The following statement contains a magic number: if (b == ' ') {  	buffer [writeIndex++] = (byte)'+';  } else {  	buffer [writeIndex++] = (byte)'%';  	buffer [writeIndex++] = _IntToHex ((b >> 4) & 0xF);  	buffer [writeIndex++] = _IntToHex (b & 0xF);  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlEncode,The following statement contains a magic number: buffer [writeIndex++] = _IntToHex ((b >> 4) & 0xF);  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_IntToHex,The following statement contains a magic number: Assert.BoundedInteger (0' n' 16);  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_IntToHex,The following statement contains a magic number: if (n <= 9) {  	return (byte)(n + '0');  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_IntToHex,The following statement contains a magic number: return (byte)(n - 10 + 'A');  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_HexToInt,The following statement contains a magic number: if (h >= 'a' && h <= 'f') {  	return h - 'a' + 10;  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_HexToInt,The following statement contains a magic number: return h - 'a' + 10;  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_HexToInt,The following statement contains a magic number: if (h >= 'A' && h <= 'F') {  	return h - 'A' + 10;  }  
Magic Number,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_HexToInt,The following statement contains a magic number: return h - 'A' + 10;  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant ()) {  case "LUNA":  	cornerRadius = new CornerRadius (6' 6' 0' 0);  	break;  case "AERO":  	// Aero has two cases.  One with glass and one without...  	if (NativeMethods.DwmIsCompositionEnabled ()) {  		cornerRadius = new CornerRadius (8);  	} else {  		cornerRadius = new CornerRadius (6' 6' 0' 0);  	}  	break;  case "CLASSIC":  case "ZUNE":  case "ROYALE":  default:  	cornerRadius = new CornerRadius (0);  	break;  }  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant ()) {  case "LUNA":  	cornerRadius = new CornerRadius (6' 6' 0' 0);  	break;  case "AERO":  	// Aero has two cases.  One with glass and one without...  	if (NativeMethods.DwmIsCompositionEnabled ()) {  		cornerRadius = new CornerRadius (8);  	} else {  		cornerRadius = new CornerRadius (6' 6' 0' 0);  	}  	break;  case "CLASSIC":  case "ZUNE":  case "ROYALE":  default:  	cornerRadius = new CornerRadius (0);  	break;  }  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant ()) {  case "LUNA":  	cornerRadius = new CornerRadius (6' 6' 0' 0);  	break;  case "AERO":  	// Aero has two cases.  One with glass and one without...  	if (NativeMethods.DwmIsCompositionEnabled ()) {  		cornerRadius = new CornerRadius (8);  	} else {  		cornerRadius = new CornerRadius (6' 6' 0' 0);  	}  	break;  case "CLASSIC":  case "ZUNE":  case "ROYALE":  default:  	cornerRadius = new CornerRadius (0);  	break;  }  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant ()) {  case "LUNA":  	cornerRadius = new CornerRadius (6' 6' 0' 0);  	break;  case "AERO":  	// Aero has two cases.  One with glass and one without...  	if (NativeMethods.DwmIsCompositionEnabled ()) {  		cornerRadius = new CornerRadius (8);  	} else {  		cornerRadius = new CornerRadius (6' 6' 0' 0);  	}  	break;  case "CLASSIC":  case "ZUNE":  case "ROYALE":  default:  	cornerRadius = new CornerRadius (0);  	break;  }  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant ()) {  case "LUNA":  	cornerRadius = new CornerRadius (6' 6' 0' 0);  	break;  case "AERO":  	// Aero has two cases.  One with glass and one without...  	if (NativeMethods.DwmIsCompositionEnabled ()) {  		cornerRadius = new CornerRadius (8);  	} else {  		cornerRadius = new CornerRadius (6' 6' 0' 0);  	}  	break;  case "CLASSIC":  case "ZUNE":  case "ROYALE":  default:  	cornerRadius = new CornerRadius (0);  	break;  }  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: cornerRadius = new CornerRadius (6' 6' 0' 0);  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: cornerRadius = new CornerRadius (6' 6' 0' 0);  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: if (NativeMethods.DwmIsCompositionEnabled ()) {  	cornerRadius = new CornerRadius (8);  } else {  	cornerRadius = new CornerRadius (6' 6' 0' 0);  }  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: if (NativeMethods.DwmIsCompositionEnabled ()) {  	cornerRadius = new CornerRadius (8);  } else {  	cornerRadius = new CornerRadius (6' 6' 0' 0);  }  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: if (NativeMethods.DwmIsCompositionEnabled ()) {  	cornerRadius = new CornerRadius (8);  } else {  	cornerRadius = new CornerRadius (6' 6' 0' 0);  }  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: cornerRadius = new CornerRadius (8);  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: cornerRadius = new CornerRadius (6' 6' 0' 0);  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: cornerRadius = new CornerRadius (6' 6' 0' 0);  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow ((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect (-16000' -16000' 100' 100)' ""' _WndProc);  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow ((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect (-16000' -16000' 100' 100)' ""' _WndProc);  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow ((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect (-16000' -16000' 100' 100)' ""' _WndProc);  
Magic Number,Microsoft.Windows.Shell,SystemParameters2,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow ((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect (-16000' -16000' 100' 100)' ""' _WndProc);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupWindows7Issues,The following statement contains a magic number: if (_blackGlassFixupAttemptCount > 5) {  	// Don't keep trying if there's an endemic problem with this.  	return;  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupRestoreBounds,The following statement contains a magic number: if (_window.WindowState == WindowState.Maximized || _window.WindowState == WindowState.Minimized) {  	// Old versions of WPF sometimes force their incorrect idea of the Window's location  	// on the Win32 restore bounds.  If we have reason to think this is the case' then  	// try to undo what WPF did after it has done its thing.  	if (_hasUserMovedWindow) {  		_hasUserMovedWindow = false;  		WINDOWPLACEMENT wp = NativeMethods.GetWindowPlacement (_hwnd);  		RECT adjustedDeviceRc = _GetAdjustedWindowRect (new RECT {  			Bottom = 100'  			Right = 100  		});  		Point adjustedTopLeft = DpiHelper.DevicePixelsToLogical (new Point (wp.rcNormalPosition.Left - adjustedDeviceRc.Left' wp.rcNormalPosition.Top - adjustedDeviceRc.Top));  		_window.Top = adjustedTopLeft.Y;  		_window.Left = adjustedTopLeft.X;  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupRestoreBounds,The following statement contains a magic number: if (_window.WindowState == WindowState.Maximized || _window.WindowState == WindowState.Minimized) {  	// Old versions of WPF sometimes force their incorrect idea of the Window's location  	// on the Win32 restore bounds.  If we have reason to think this is the case' then  	// try to undo what WPF did after it has done its thing.  	if (_hasUserMovedWindow) {  		_hasUserMovedWindow = false;  		WINDOWPLACEMENT wp = NativeMethods.GetWindowPlacement (_hwnd);  		RECT adjustedDeviceRc = _GetAdjustedWindowRect (new RECT {  			Bottom = 100'  			Right = 100  		});  		Point adjustedTopLeft = DpiHelper.DevicePixelsToLogical (new Point (wp.rcNormalPosition.Left - adjustedDeviceRc.Left' wp.rcNormalPosition.Top - adjustedDeviceRc.Top));  		_window.Top = adjustedTopLeft.Y;  		_window.Left = adjustedTopLeft.X;  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupRestoreBounds,The following statement contains a magic number: if (_hasUserMovedWindow) {  	_hasUserMovedWindow = false;  	WINDOWPLACEMENT wp = NativeMethods.GetWindowPlacement (_hwnd);  	RECT adjustedDeviceRc = _GetAdjustedWindowRect (new RECT {  		Bottom = 100'  		Right = 100  	});  	Point adjustedTopLeft = DpiHelper.DevicePixelsToLogical (new Point (wp.rcNormalPosition.Left - adjustedDeviceRc.Left' wp.rcNormalPosition.Top - adjustedDeviceRc.Top));  	_window.Top = adjustedTopLeft.Y;  	_window.Left = adjustedTopLeft.X;  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupRestoreBounds,The following statement contains a magic number: if (_hasUserMovedWindow) {  	_hasUserMovedWindow = false;  	WINDOWPLACEMENT wp = NativeMethods.GetWindowPlacement (_hwnd);  	RECT adjustedDeviceRc = _GetAdjustedWindowRect (new RECT {  		Bottom = 100'  		Right = 100  	});  	Point adjustedTopLeft = DpiHelper.DevicePixelsToLogical (new Point (wp.rcNormalPosition.Left - adjustedDeviceRc.Left' wp.rcNormalPosition.Top - adjustedDeviceRc.Top));  	_window.Top = adjustedTopLeft.Y;  	_window.Left = adjustedTopLeft.X;  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED) {  	int left;  	int top;  	if (wp.HasValue) {  		left = wp.Value.x;  		top = wp.Value.y;  	} else {  		Rect r = _GetWindowRect ();  		left = (int)r.Left;  		top = (int)r.Top;  	}  	IntPtr hMon = NativeMethods.MonitorFromWindow (_hwnd' MONITOR_DEFAULTTONEAREST);  	MONITORINFO mi = NativeMethods.GetMonitorInfo (hMon);  	RECT rcMax = mi.rcWork;  	// The location of maximized window takes into account the border that Windows was  	// going to remove' so we also need to consider it.  	rcMax.Offset (-left' -top);  	IntPtr hrgn = IntPtr.Zero;  	try {  		hrgn = NativeMethods.CreateRectRgnIndirect (rcMax);  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		Utility.SafeDeleteObject (ref hrgn);  	}  } else {  	Size windowSize;  	// Use the size if it's specified.  	if (null != wp && !Utility.IsFlagSet (wp.Value.flags' (int)SWP.NOSIZE)) {  		windowSize = new Size ((double)wp.Value.cx' (double)wp.Value.cy);  	} else if (null != wp && (_lastRoundingState == _window.WindowState)) {  		return;  	} else {  		windowSize = _GetWindowRect ().Size;  	}  	_lastRoundingState = _window.WindowState;  	IntPtr hrgn = IntPtr.Zero;  	try {  		double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  		double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  		topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  		if (_IsUniform (_chromeInfo.CornerRadius)) {  			// RoundedRect HRGNs require an additional pixel of padding.  			hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  		} else {  			// We need to combine HRGNs for each of the corners.  			// Create one for each quadrant' but let it overlap into the two adjacent ones  			// by the radius amount to ensure that there aren't corners etched into the middle  			// of the window.  			hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  			double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  			topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  			Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  			topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  			Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  			_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  			double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  			bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  			Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  			bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  			Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  			double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  			bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  			Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  			bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  			Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  			Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  			_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  		}  		NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  		hrgn = IntPtr.Zero;  	} finally {  		// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  		Utility.SafeDeleteObject (ref hrgn);  	}  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: try {  	double shortestDimension = Math.Min (windowSize.Width' windowSize.Height);  	double topLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopLeft' 0)).X;  	topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  	if (_IsUniform (_chromeInfo.CornerRadius)) {  		// RoundedRect HRGNs require an additional pixel of padding.  		hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  	} else {  		// We need to combine HRGNs for each of the corners.  		// Create one for each quadrant' but let it overlap into the two adjacent ones  		// by the radius amount to ensure that there aren't corners etched into the middle  		// of the window.  		hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  		double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  		topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  		Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  		topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  		Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  		_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  		double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  		bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  		Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  		bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  		Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  		double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  		bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  		Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  		bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  		Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  		Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  		_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  	}  	NativeMethods.SetWindowRgn (_hwnd' hrgn' NativeMethods.IsWindowVisible (_hwnd));  	hrgn = IntPtr.Zero;  } finally {  	// Free the memory associated with the HRGN if it wasn't assigned to the HWND.  	Utility.SafeDeleteObject (ref hrgn);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: topLeftRadius = Math.Min (topLeftRadius' shortestDimension / 2);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (_IsUniform (_chromeInfo.CornerRadius)) {  	// RoundedRect HRGNs require an additional pixel of padding.  	hrgn = _CreateRoundRectRgn (new Rect (windowSize)' topLeftRadius);  } else {  	// We need to combine HRGNs for each of the corners.  	// Create one for each quadrant' but let it overlap into the two adjacent ones  	// by the radius amount to ensure that there aren't corners etched into the middle  	// of the window.  	hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  	double topRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.TopRight' 0)).X;  	topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  	Rect topRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);  	topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  	Assert.AreEqual (topRightRegionRect.Right' windowSize.Width);  	_CreateAndCombineRoundRectRgn (hrgn' topRightRegionRect' topRightRadius);  	double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomLeft' 0)).X;  	bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  	Rect bottomLeftRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);  	bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  	Assert.AreEqual (bottomLeftRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomLeftRegionRect' bottomLeftRadius);  	double bottomRightRadius = DpiHelper.LogicalPixelsToDevice (new Point (_chromeInfo.CornerRadius.BottomRight' 0)).X;  	bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  	Rect bottomRightRegionRect = new Rect (0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);  	bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  	Assert.AreEqual (bottomRightRegionRect.Right' windowSize.Width);  	Assert.AreEqual (bottomRightRegionRect.Bottom' windowSize.Height);  	_CreateAndCombineRoundRectRgn (hrgn' bottomRightRegionRect' bottomRightRadius);  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: hrgn = _CreateRoundRectRgn (new Rect (0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: topRightRadius = Math.Min (topRightRadius' shortestDimension / 2);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: topRightRegionRect.Offset (windowSize.Width / 2 - topRightRadius' 0);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: bottomLeftRadius = Math.Min (bottomLeftRadius' shortestDimension / 2);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: bottomLeftRegionRect.Offset (0' windowSize.Height / 2 - bottomLeftRadius);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: bottomRightRadius = Math.Min (bottomRightRadius' shortestDimension / 2);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: bottomRightRegionRect.Offset (windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The following statement contains a magic number: if (mousePosition.Y >= windowPosition.Top && mousePosition.Y < windowPosition.Top + _chromeInfo.ResizeBorderThickness.Top + _chromeInfo.CaptionHeight) {  	onResizeBorder = (mousePosition.Y < (windowPosition.Top + _chromeInfo.ResizeBorderThickness.Top));  	uRow = 0;  	// top (caption or resize border)  } else if (mousePosition.Y < windowPosition.Bottom && mousePosition.Y >= windowPosition.Bottom - (int)_chromeInfo.ResizeBorderThickness.Bottom) {  	uRow = 2;  	// bottom  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The following statement contains a magic number: if (mousePosition.Y < windowPosition.Bottom && mousePosition.Y >= windowPosition.Bottom - (int)_chromeInfo.ResizeBorderThickness.Bottom) {  	uRow = 2;  	// bottom  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The following statement contains a magic number: uRow = 2;  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The following statement contains a magic number: if (mousePosition.X >= windowPosition.Left && mousePosition.X < windowPosition.Left + (int)_chromeInfo.ResizeBorderThickness.Left) {  	uCol = 0;  	// left side  } else if (mousePosition.X < windowPosition.Right && mousePosition.X >= windowPosition.Right - _chromeInfo.ResizeBorderThickness.Right) {  	uCol = 2;  	// right side  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The following statement contains a magic number: if (mousePosition.X < windowPosition.Right && mousePosition.X >= windowPosition.Right - _chromeInfo.ResizeBorderThickness.Right) {  	uCol = 2;  	// right side  }  
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The following statement contains a magic number: uCol = 2;  
Magic Number,AvalonDock.Converters,AnchorSideToAngleConverter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Converters\AnchorSideToAngleConverter.cs,Convert,The following statement contains a magic number: if (side == AnchorSide.Left || side == AnchorSide.Right)  	return 90.0;  
Magic Number,AvalonDock.Converters,AnchorSideToAngleConverter,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Converters\AnchorSideToAngleConverter.cs,Convert,The following statement contains a magic number: return 90.0;  
Magic Number,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The following statement contains a magic number: foreach (var anchorableContentToImport in listOfAnchorablesToImport) {  	var anchorableToImport = new LayoutAnchorable () {  		Content = anchorableContentToImport  	};  	bool added = false;  	if (LayoutUpdateStrategy != null) {  		added = LayoutUpdateStrategy.BeforeInsertAnchorable (layout' anchorableToImport' anchorablePane);  	}  	if (!added) {  		if (anchorablePane == null) {  			var mainLayoutPanel = new LayoutPanel () {  				Orientation = Orientation.Horizontal  			};  			if (layout.RootPanel != null) {  				mainLayoutPanel.Children.Add (layout.RootPanel);  			}  			layout.RootPanel = mainLayoutPanel;  			anchorablePane = new LayoutAnchorablePane () {  				DockWidth = new GridLength (200.0' GridUnitType.Pixel)  			};  			mainLayoutPanel.Children.Add (anchorablePane);  		}  		anchorablePane.Children.Add (anchorableToImport);  		added = true;  	}  	if (LayoutUpdateStrategy != null)  		LayoutUpdateStrategy.AfterInsertAnchorable (layout' anchorableToImport);  	CreateAnchorableLayoutItem (anchorableToImport);  }  
Magic Number,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The following statement contains a magic number: if (!added) {  	if (anchorablePane == null) {  		var mainLayoutPanel = new LayoutPanel () {  			Orientation = Orientation.Horizontal  		};  		if (layout.RootPanel != null) {  			mainLayoutPanel.Children.Add (layout.RootPanel);  		}  		layout.RootPanel = mainLayoutPanel;  		anchorablePane = new LayoutAnchorablePane () {  			DockWidth = new GridLength (200.0' GridUnitType.Pixel)  		};  		mainLayoutPanel.Children.Add (anchorablePane);  	}  	anchorablePane.Children.Add (anchorableToImport);  	added = true;  }  
Magic Number,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The following statement contains a magic number: if (anchorablePane == null) {  	var mainLayoutPanel = new LayoutPanel () {  		Orientation = Orientation.Horizontal  	};  	if (layout.RootPanel != null) {  		mainLayoutPanel.Children.Add (layout.RootPanel);  	}  	layout.RootPanel = mainLayoutPanel;  	anchorablePane = new LayoutAnchorablePane () {  		DockWidth = new GridLength (200.0' GridUnitType.Pixel)  	};  	mainLayoutPanel.Children.Add (anchorablePane);  }  
Magic Number,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The following statement contains a magic number: anchorablePane = new LayoutAnchorablePane () {  	DockWidth = new GridLength (200.0' GridUnitType.Pixel)  };  
Magic Number,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The following statement contains a magic number: if (e.NewItems != null && (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace)) {  	if (e.NewItems != null) {  		LayoutAnchorablePane anchorablePane = null;  		if (Layout.ActiveContent != null) {  			//look for active content parent pane  			anchorablePane = Layout.ActiveContent.Parent as LayoutAnchorablePane;  		}  		if (anchorablePane == null) {  			//look for a pane on the right side  			anchorablePane = Layout.Descendents ().OfType<LayoutAnchorablePane> ().Where (pane => !pane.IsHostedInFloatingWindow && pane.GetSide () == AnchorSide.Right).FirstOrDefault ();  		}  		if (anchorablePane == null) {  			//look for an available pane  			anchorablePane = Layout.Descendents ().OfType<LayoutAnchorablePane> ().FirstOrDefault ();  		}  		_suspendLayoutItemCreation = true;  		foreach (var anchorableContentToImport in e.NewItems) {  			var anchorableToImport = new LayoutAnchorable () {  				Content = anchorableContentToImport  			};  			bool added = false;  			if (LayoutUpdateStrategy != null) {  				added = LayoutUpdateStrategy.BeforeInsertAnchorable (Layout' anchorableToImport' anchorablePane);  			}  			if (!added) {  				if (anchorablePane == null) {  					var mainLayoutPanel = new LayoutPanel () {  						Orientation = Orientation.Horizontal  					};  					if (Layout.RootPanel != null) {  						mainLayoutPanel.Children.Add (Layout.RootPanel);  					}  					Layout.RootPanel = mainLayoutPanel;  					anchorablePane = new LayoutAnchorablePane () {  						DockWidth = new GridLength (200.0' GridUnitType.Pixel)  					};  					mainLayoutPanel.Children.Add (anchorablePane);  				}  				anchorablePane.Children.Add (anchorableToImport);  				added = true;  			}  			if (LayoutUpdateStrategy != null) {  				LayoutUpdateStrategy.AfterInsertAnchorable (Layout' anchorableToImport);  			}  			var root = anchorableToImport.Root;  			if (root != null && root.Manager == this) {  				CreateAnchorableLayoutItem (anchorableToImport);  			}  		}  		_suspendLayoutItemCreation = false;  	}  }  
Magic Number,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The following statement contains a magic number: if (e.NewItems != null) {  	LayoutAnchorablePane anchorablePane = null;  	if (Layout.ActiveContent != null) {  		//look for active content parent pane  		anchorablePane = Layout.ActiveContent.Parent as LayoutAnchorablePane;  	}  	if (anchorablePane == null) {  		//look for a pane on the right side  		anchorablePane = Layout.Descendents ().OfType<LayoutAnchorablePane> ().Where (pane => !pane.IsHostedInFloatingWindow && pane.GetSide () == AnchorSide.Right).FirstOrDefault ();  	}  	if (anchorablePane == null) {  		//look for an available pane  		anchorablePane = Layout.Descendents ().OfType<LayoutAnchorablePane> ().FirstOrDefault ();  	}  	_suspendLayoutItemCreation = true;  	foreach (var anchorableContentToImport in e.NewItems) {  		var anchorableToImport = new LayoutAnchorable () {  			Content = anchorableContentToImport  		};  		bool added = false;  		if (LayoutUpdateStrategy != null) {  			added = LayoutUpdateStrategy.BeforeInsertAnchorable (Layout' anchorableToImport' anchorablePane);  		}  		if (!added) {  			if (anchorablePane == null) {  				var mainLayoutPanel = new LayoutPanel () {  					Orientation = Orientation.Horizontal  				};  				if (Layout.RootPanel != null) {  					mainLayoutPanel.Children.Add (Layout.RootPanel);  				}  				Layout.RootPanel = mainLayoutPanel;  				anchorablePane = new LayoutAnchorablePane () {  					DockWidth = new GridLength (200.0' GridUnitType.Pixel)  				};  				mainLayoutPanel.Children.Add (anchorablePane);  			}  			anchorablePane.Children.Add (anchorableToImport);  			added = true;  		}  		if (LayoutUpdateStrategy != null) {  			LayoutUpdateStrategy.AfterInsertAnchorable (Layout' anchorableToImport);  		}  		var root = anchorableToImport.Root;  		if (root != null && root.Manager == this) {  			CreateAnchorableLayoutItem (anchorableToImport);  		}  	}  	_suspendLayoutItemCreation = false;  }  
Magic Number,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The following statement contains a magic number: foreach (var anchorableContentToImport in e.NewItems) {  	var anchorableToImport = new LayoutAnchorable () {  		Content = anchorableContentToImport  	};  	bool added = false;  	if (LayoutUpdateStrategy != null) {  		added = LayoutUpdateStrategy.BeforeInsertAnchorable (Layout' anchorableToImport' anchorablePane);  	}  	if (!added) {  		if (anchorablePane == null) {  			var mainLayoutPanel = new LayoutPanel () {  				Orientation = Orientation.Horizontal  			};  			if (Layout.RootPanel != null) {  				mainLayoutPanel.Children.Add (Layout.RootPanel);  			}  			Layout.RootPanel = mainLayoutPanel;  			anchorablePane = new LayoutAnchorablePane () {  				DockWidth = new GridLength (200.0' GridUnitType.Pixel)  			};  			mainLayoutPanel.Children.Add (anchorablePane);  		}  		anchorablePane.Children.Add (anchorableToImport);  		added = true;  	}  	if (LayoutUpdateStrategy != null) {  		LayoutUpdateStrategy.AfterInsertAnchorable (Layout' anchorableToImport);  	}  	var root = anchorableToImport.Root;  	if (root != null && root.Manager == this) {  		CreateAnchorableLayoutItem (anchorableToImport);  	}  }  
Magic Number,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The following statement contains a magic number: if (!added) {  	if (anchorablePane == null) {  		var mainLayoutPanel = new LayoutPanel () {  			Orientation = Orientation.Horizontal  		};  		if (Layout.RootPanel != null) {  			mainLayoutPanel.Children.Add (Layout.RootPanel);  		}  		Layout.RootPanel = mainLayoutPanel;  		anchorablePane = new LayoutAnchorablePane () {  			DockWidth = new GridLength (200.0' GridUnitType.Pixel)  		};  		mainLayoutPanel.Children.Add (anchorablePane);  	}  	anchorablePane.Children.Add (anchorableToImport);  	added = true;  }  
Magic Number,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The following statement contains a magic number: if (anchorablePane == null) {  	var mainLayoutPanel = new LayoutPanel () {  		Orientation = Orientation.Horizontal  	};  	if (Layout.RootPanel != null) {  		mainLayoutPanel.Children.Add (Layout.RootPanel);  	}  	Layout.RootPanel = mainLayoutPanel;  	anchorablePane = new LayoutAnchorablePane () {  		DockWidth = new GridLength (200.0' GridUnitType.Pixel)  	};  	mainLayoutPanel.Children.Add (anchorablePane);  }  
Magic Number,AvalonDock,DockingManager,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The following statement contains a magic number: anchorablePane = new LayoutAnchorablePane () {  	DockWidth = new GridLength (200.0' GridUnitType.Pixel)  };  
Magic Number,AvalonDock,Win32Helper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,MakeLParam,The following statement contains a magic number: return (int)((HiWord << 16) | (LoWord & 0xffff));  
Magic Number,AvalonDock,Win32Helper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,SetOwner,The following statement contains a magic number: SetWindowLong (childHandle' -8' // GWL_HWNDPARENT  ownerHandle.ToInt32 ());  
Magic Number,AvalonDock,Win32Helper,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,GetOwner,The following statement contains a magic number: return new IntPtr (GetWindowLong (childHandle' -8));  
Magic Number,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,InternalDock,The following statement contains a magic number: if (!added) {  	if (anchorablePane == null) {  		var mainLayoutPanel = new LayoutPanel () {  			Orientation = Orientation.Horizontal  		};  		if (root.RootPanel != null) {  			mainLayoutPanel.Children.Add (root.RootPanel);  		}  		root.RootPanel = mainLayoutPanel;  		anchorablePane = new LayoutAnchorablePane () {  			DockWidth = new GridLength (200.0' GridUnitType.Pixel)  		};  		mainLayoutPanel.Children.Add (anchorablePane);  	}  	anchorablePane.Children.Add (this);  	added = true;  }  
Magic Number,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,InternalDock,The following statement contains a magic number: if (anchorablePane == null) {  	var mainLayoutPanel = new LayoutPanel () {  		Orientation = Orientation.Horizontal  	};  	if (root.RootPanel != null) {  		mainLayoutPanel.Children.Add (root.RootPanel);  	}  	root.RootPanel = mainLayoutPanel;  	anchorablePane = new LayoutAnchorablePane () {  		DockWidth = new GridLength (200.0' GridUnitType.Pixel)  	};  	mainLayoutPanel.Children.Add (anchorablePane);  }  
Magic Number,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,InternalDock,The following statement contains a magic number: anchorablePane = new LayoutAnchorablePane () {  	DockWidth = new GridLength (200.0' GridUnitType.Pixel)  };  
Magic Number,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,WriteXml,The following statement contains a magic number: if (AutoHideMinWidth != 25.0)  	writer.WriteAttributeString ("AutoHideMinWidth"' AutoHideMinWidth.ToString (CultureInfo.InvariantCulture));  
Magic Number,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,WriteXml,The following statement contains a magic number: if (AutoHideMinHeight != 25.0)  	writer.WriteAttributeString ("AutoHideMinHeight"' AutoHideMinHeight.ToString (CultureInfo.InvariantCulture));  
Magic Number,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutAnchorableFloatingWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorableFloatingWindow.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutAnchorablePane,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorablePane.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutAnchorablePaneGroup,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorablePaneGroup.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutDocument,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutDocument.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutDocumentFloatingWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutDocumentFloatingWindow.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutDocumentPane,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutDocumentPane.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutDocumentPaneGroup,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutDocumentPaneGroup.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutElement,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutElement.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new String (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutPanel,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutPanel.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutPositionableGroup,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutPositionableGroup.cs,WriteXml,The following statement contains a magic number: if (DockMinWidth != 25.0)  	writer.WriteAttributeString ("DocMinWidth"' DockMinWidth.ToString (CultureInfo.InvariantCulture));  
Magic Number,AvalonDock.Layout,LayoutPositionableGroup,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutPositionableGroup.cs,WriteXml,The following statement contains a magic number: if (DockMinHeight != 25.0)  	writer.WriteAttributeString ("DockMinHeight"' DockMinHeight.ToString (CultureInfo.InvariantCulture));  
Magic Number,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Magic Number,AvalonDock.Layout,LayoutRoot,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write (new string (' '' tab * 4));  
Missing Default,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.AnchorablePaneDockBottom:  	#region DropTargetType.AnchorablePaneDockBottom  	{  		var parentModel = targetModel.Parent as ILayoutGroup;  		var parentModelOrientable = targetModel.Parent as ILayoutOrientableGroup;  		int insertToIndex = parentModel.IndexOfChild (targetModel);  		if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Vertical && parentModel.ChildrenCount == 1)  			parentModelOrientable.Orientation = System.Windows.Controls.Orientation.Vertical;  		if (parentModelOrientable.Orientation == System.Windows.Controls.Orientation.Vertical) {  			var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  			if (layoutAnchorablePaneGroup != null && (layoutAnchorablePaneGroup.Children.Count == 1 || layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical)) {  				var anchorablesToMove = layoutAnchorablePaneGroup.Children.ToArray ();  				for (int i = 0; i < anchorablesToMove.Length; i++)  					parentModel.InsertChildAt (insertToIndex + 1 + i' anchorablesToMove [i]);  			} else  				parentModel.InsertChildAt (insertToIndex + 1' floatingWindow.RootPanel);  		} else {  			var targetModelAsPositionableElement = targetModel as ILayoutPositionableElement;  			var newOrientedPanel = new LayoutAnchorablePaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Vertical'  				DockWidth = targetModelAsPositionableElement.DockWidth'  				DockHeight = targetModelAsPositionableElement.DockHeight'  			};  			parentModel.InsertChildAt (insertToIndex' newOrientedPanel);  			newOrientedPanel.Children.Add (targetModel);  			newOrientedPanel.Children.Add (floatingWindow.RootPanel);  		}  	}  	break;  #endregion  case DropTargetType.AnchorablePaneDockTop:  	#region DropTargetType.AnchorablePaneDockTop  	{  		var parentModel = targetModel.Parent as ILayoutGroup;  		var parentModelOrientable = targetModel.Parent as ILayoutOrientableGroup;  		int insertToIndex = parentModel.IndexOfChild (targetModel);  		if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Vertical && parentModel.ChildrenCount == 1)  			parentModelOrientable.Orientation = System.Windows.Controls.Orientation.Vertical;  		if (parentModelOrientable.Orientation == System.Windows.Controls.Orientation.Vertical) {  			var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  			if (layoutAnchorablePaneGroup != null && (layoutAnchorablePaneGroup.Children.Count == 1 || layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical)) {  				var anchorablesToMove = layoutAnchorablePaneGroup.Children.ToArray ();  				for (int i = 0; i < anchorablesToMove.Length; i++)  					parentModel.InsertChildAt (insertToIndex + i' anchorablesToMove [i]);  			} else  				parentModel.InsertChildAt (insertToIndex' floatingWindow.RootPanel);  		} else {  			var targetModelAsPositionableElement = targetModel as ILayoutPositionableElement;  			var newOrientedPanel = new LayoutAnchorablePaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Vertical'  				DockWidth = targetModelAsPositionableElement.DockWidth'  				DockHeight = targetModelAsPositionableElement.DockHeight'  			};  			parentModel.InsertChildAt (insertToIndex' newOrientedPanel);  			//the floating window must be added after the target modal as it could be raise a CollectGarbage call  			newOrientedPanel.Children.Add (targetModel);  			newOrientedPanel.Children.Insert (0' floatingWindow.RootPanel);  		}  	}  	break;  #endregion  case DropTargetType.AnchorablePaneDockLeft:  	#region DropTargetType.AnchorablePaneDockLeft  	{  		var parentModel = targetModel.Parent as ILayoutGroup;  		var parentModelOrientable = targetModel.Parent as ILayoutOrientableGroup;  		int insertToIndex = parentModel.IndexOfChild (targetModel);  		if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Horizontal && parentModel.ChildrenCount == 1)  			parentModelOrientable.Orientation = System.Windows.Controls.Orientation.Horizontal;  		if (parentModelOrientable.Orientation == System.Windows.Controls.Orientation.Horizontal) {  			var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  			if (layoutAnchorablePaneGroup != null && (layoutAnchorablePaneGroup.Children.Count == 1 || layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal)) {  				var anchorablesToMove = layoutAnchorablePaneGroup.Children.ToArray ();  				for (int i = 0; i < anchorablesToMove.Length; i++)  					parentModel.InsertChildAt (insertToIndex + i' anchorablesToMove [i]);  			} else  				parentModel.InsertChildAt (insertToIndex' floatingWindow.RootPanel);  		} else {  			var targetModelAsPositionableElement = targetModel as ILayoutPositionableElement;  			var newOrientedPanel = new LayoutAnchorablePaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Horizontal'  				DockWidth = targetModelAsPositionableElement.DockWidth'  				DockHeight = targetModelAsPositionableElement.DockHeight'  			};  			parentModel.InsertChildAt (insertToIndex' newOrientedPanel);  			//the floating window must be added after the target modal as it could be raise a CollectGarbage call  			newOrientedPanel.Children.Add (targetModel);  			newOrientedPanel.Children.Insert (0' floatingWindow.RootPanel);  		}  	}  	break;  #endregion  case DropTargetType.AnchorablePaneDockRight:  	#region DropTargetType.AnchorablePaneDockRight  	{  		var parentModel = targetModel.Parent as ILayoutGroup;  		var parentModelOrientable = targetModel.Parent as ILayoutOrientableGroup;  		int insertToIndex = parentModel.IndexOfChild (targetModel);  		if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Horizontal && parentModel.ChildrenCount == 1)  			parentModelOrientable.Orientation = System.Windows.Controls.Orientation.Horizontal;  		if (parentModelOrientable.Orientation == System.Windows.Controls.Orientation.Horizontal) {  			var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  			if (layoutAnchorablePaneGroup != null && (layoutAnchorablePaneGroup.Children.Count == 1 || layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal)) {  				var anchorablesToMove = layoutAnchorablePaneGroup.Children.ToArray ();  				for (int i = 0; i < anchorablesToMove.Length; i++)  					parentModel.InsertChildAt (insertToIndex + 1 + i' anchorablesToMove [i]);  			} else  				parentModel.InsertChildAt (insertToIndex + 1' floatingWindow.RootPanel);  		} else {  			var targetModelAsPositionableElement = targetModel as ILayoutPositionableElement;  			var newOrientedPanel = new LayoutAnchorablePaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Horizontal'  				DockWidth = targetModelAsPositionableElement.DockWidth'  				DockHeight = targetModelAsPositionableElement.DockHeight'  			};  			parentModel.InsertChildAt (insertToIndex' newOrientedPanel);  			newOrientedPanel.Children.Add (targetModel);  			newOrientedPanel.Children.Add (floatingWindow.RootPanel);  		}  	}  	break;  #endregion  case DropTargetType.AnchorablePaneDockInside:  	#region DropTargetType.AnchorablePaneDockInside  	{  		var paneModel = targetModel as LayoutAnchorablePane;  		var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  		int i = _tabIndex == -1 ? 0 : _tabIndex;  		foreach (var anchorableToImport in layoutAnchorablePaneGroup.Descendents ().OfType<LayoutAnchorable> ().ToArray ()) {  			paneModel.Children.Insert (i' anchorableToImport);  			i++;  		}  	}  	break;  #endregion  }  
Missing Default,AvalonDock.Controls,AnchorablePaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.AnchorablePaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.AnchorablePaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.TopLeft;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Top)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.TopRight  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  }  
Missing Default,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,Drop,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.DocumentPaneDockAsAnchorableBottom:  	#region DropTargetType.DocumentPaneDockAsAnchorableBottom  	{  		if (parentGroupPanel != null && parentGroupPanel.ChildrenCount == 1)  			parentGroupPanel.Orientation = System.Windows.Controls.Orientation.Vertical;  		if (parentGroupPanel != null && parentGroupPanel.Orientation == System.Windows.Controls.Orientation.Vertical) {  			parentGroupPanel.Children.Insert (parentGroupPanel.IndexOfChild (parentGroup != null ? parentGroup : targetModel) + 1' floatingWindow.RootPanel);  		} else if (parentGroupPanel != null) {  			var newParentPanel = new LayoutPanel () {  				Orientation = System.Windows.Controls.Orientation.Vertical  			};  			parentGroupPanel.ReplaceChild (parentGroup != null ? parentGroup : targetModel' newParentPanel);  			newParentPanel.Children.Add (parentGroup != null ? parentGroup : targetModel);  			newParentPanel.Children.Add (floatingWindow.RootPanel);  		} else {  			throw new NotImplementedException ();  		}  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockAsAnchorableTop:  	#region DropTargetType.DocumentPaneDockAsAnchorableTop  	{  		if (parentGroupPanel != null && parentGroupPanel.ChildrenCount == 1)  			parentGroupPanel.Orientation = System.Windows.Controls.Orientation.Vertical;  		if (parentGroupPanel != null && parentGroupPanel.Orientation == System.Windows.Controls.Orientation.Vertical) {  			parentGroupPanel.Children.Insert (parentGroupPanel.IndexOfChild (parentGroup != null ? parentGroup : targetModel)' floatingWindow.RootPanel);  		} else if (parentGroupPanel != null) {  			var newParentPanel = new LayoutPanel () {  				Orientation = System.Windows.Controls.Orientation.Vertical  			};  			parentGroupPanel.ReplaceChild (parentGroup != null ? parentGroup : targetModel' newParentPanel);  			newParentPanel.Children.Add (parentGroup != null ? parentGroup : targetModel);  			newParentPanel.Children.Insert (0' floatingWindow.RootPanel);  		} else {  			throw new NotImplementedException ();  		}  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockAsAnchorableLeft:  	#region DropTargetType.DocumentPaneDockAsAnchorableLeft  	{  		if (parentGroupPanel != null && parentGroupPanel.ChildrenCount == 1)  			parentGroupPanel.Orientation = System.Windows.Controls.Orientation.Horizontal;  		if (parentGroupPanel != null && parentGroupPanel.Orientation == System.Windows.Controls.Orientation.Horizontal) {  			parentGroupPanel.Children.Insert (parentGroupPanel.IndexOfChild (parentGroup != null ? parentGroup : targetModel)' floatingWindow.RootPanel);  		} else if (parentGroupPanel != null) {  			var newParentPanel = new LayoutPanel () {  				Orientation = System.Windows.Controls.Orientation.Horizontal  			};  			parentGroupPanel.ReplaceChild (parentGroup != null ? parentGroup : targetModel' newParentPanel);  			newParentPanel.Children.Add (parentGroup != null ? parentGroup : targetModel);  			newParentPanel.Children.Insert (0' floatingWindow.RootPanel);  		} else {  			throw new NotImplementedException ();  		}  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockAsAnchorableRight:  	#region DropTargetType.DocumentPaneDockAsAnchorableRight  	{  		if (parentGroupPanel != null && parentGroupPanel.ChildrenCount == 1)  			parentGroupPanel.Orientation = System.Windows.Controls.Orientation.Horizontal;  		if (parentGroupPanel != null && parentGroupPanel.Orientation == System.Windows.Controls.Orientation.Horizontal) {  			parentGroupPanel.Children.Insert (parentGroupPanel.IndexOfChild (parentGroup != null ? parentGroup : targetModel) + 1' floatingWindow.RootPanel);  		} else if (parentGroupPanel != null) {  			var newParentPanel = new LayoutPanel () {  				Orientation = System.Windows.Controls.Orientation.Horizontal  			};  			parentGroupPanel.ReplaceChild (parentGroup != null ? parentGroup : targetModel' newParentPanel);  			newParentPanel.Children.Add (parentGroup != null ? parentGroup : targetModel);  			newParentPanel.Children.Add (floatingWindow.RootPanel);  		} else {  			throw new NotImplementedException ();  		}  	}  	break;  #endregion  }  
Missing Default,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.DocumentPaneDockAsAnchorableBottom: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableTop: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableRight: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockAsAnchorableLeft: {  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 3.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Missing Default,AvalonDock.Controls,DocumentPaneGroupDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneGroupDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.DocumentPaneGroupDockInside:  	#region DropTargetType.DocumentPaneGroupDockInside  	{  		var paneGroupModel = targetModel as LayoutDocumentPaneGroup;  		var paneModel = paneGroupModel.Children [0] as LayoutDocumentPane;  		var sourceModel = floatingWindow.RootDocument;  		paneModel.Children.Insert (0' sourceModel);  	}  	break;  #endregion  }  
Missing Default,AvalonDock.Controls,DocumentPaneGroupDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneGroupDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.DocumentPaneGroupDockInside:  	#region DropTargetType.DocumentPaneGroupDockInside  	{  		var paneGroupModel = targetModel as LayoutDocumentPaneGroup;  		var paneModel = paneGroupModel.Children [0] as LayoutDocumentPane;  		var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  		int i = 0;  		foreach (var anchorableToImport in layoutAnchorablePaneGroup.Descendents ().OfType<LayoutAnchorable> ().ToArray ()) {  			paneModel.Children.Insert (i' anchorableToImport);  			i++;  		}  	}  	break;  #endregion  }  
Missing Default,AvalonDock.Controls,DocumentPaneGroupDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneGroupDropTarget.cs,GetPreviewPath,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.DocumentPaneGroupDockInside:  #region DropTargetType.DocumentPaneGroupDockInside   {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	return new RectangleGeometry (targetScreenRect);  }  #endregion  }  
Missing Default,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.DockingManagerDockLeft:  	#region DropTargetType.DockingManagerDockLeft  	{  		if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Horizontal && _manager.Layout.RootPanel.Children.Count == 1)  			_manager.Layout.RootPanel.Orientation = System.Windows.Controls.Orientation.Horizontal;  		if (_manager.Layout.RootPanel.Orientation == System.Windows.Controls.Orientation.Horizontal) {  			var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  			if (layoutAnchorablePaneGroup != null && layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal) {  				var childrenToTransfer = layoutAnchorablePaneGroup.Children.ToArray ();  				for (int i = 0; i < childrenToTransfer.Length; i++)  					_manager.Layout.RootPanel.Children.Insert (i' childrenToTransfer [i]);  			} else  				_manager.Layout.RootPanel.Children.Insert (0' floatingWindow.RootPanel);  		} else {  			var newOrientedPanel = new LayoutPanel () {  				Orientation = System.Windows.Controls.Orientation.Horizontal  			};  			newOrientedPanel.Children.Add (floatingWindow.RootPanel);  			newOrientedPanel.Children.Add (_manager.Layout.RootPanel);  			_manager.Layout.RootPanel = newOrientedPanel;  		}  	}  	break;  #endregion  case DropTargetType.DockingManagerDockRight:  	#region DropTargetType.DockingManagerDockRight  	{  		if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Horizontal && _manager.Layout.RootPanel.Children.Count == 1)  			_manager.Layout.RootPanel.Orientation = System.Windows.Controls.Orientation.Horizontal;  		if (_manager.Layout.RootPanel.Orientation == System.Windows.Controls.Orientation.Horizontal) {  			var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  			if (layoutAnchorablePaneGroup != null && layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal) {  				var childrenToTransfer = layoutAnchorablePaneGroup.Children.ToArray ();  				for (int i = 0; i < childrenToTransfer.Length; i++)  					_manager.Layout.RootPanel.Children.Add (childrenToTransfer [i]);  			} else  				_manager.Layout.RootPanel.Children.Add (floatingWindow.RootPanel);  		} else {  			var newOrientedPanel = new LayoutPanel () {  				Orientation = System.Windows.Controls.Orientation.Horizontal  			};  			newOrientedPanel.Children.Add (_manager.Layout.RootPanel);  			newOrientedPanel.Children.Add (floatingWindow.RootPanel);  			_manager.Layout.RootPanel = newOrientedPanel;  		}  	}  	break;  #endregion  case DropTargetType.DockingManagerDockTop:  	#region DropTargetType.DockingManagerDockTop  	{  		if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Vertical && _manager.Layout.RootPanel.Children.Count == 1)  			_manager.Layout.RootPanel.Orientation = System.Windows.Controls.Orientation.Vertical;  		if (_manager.Layout.RootPanel.Orientation == System.Windows.Controls.Orientation.Vertical) {  			var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  			if (layoutAnchorablePaneGroup != null && layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical) {  				var childrenToTransfer = layoutAnchorablePaneGroup.Children.ToArray ();  				for (int i = 0; i < childrenToTransfer.Length; i++)  					_manager.Layout.RootPanel.Children.Insert (i' childrenToTransfer [i]);  			} else  				_manager.Layout.RootPanel.Children.Insert (0' floatingWindow.RootPanel);  		} else {  			var newOrientedPanel = new LayoutPanel () {  				Orientation = System.Windows.Controls.Orientation.Vertical  			};  			newOrientedPanel.Children.Add (floatingWindow.RootPanel);  			newOrientedPanel.Children.Add (_manager.Layout.RootPanel);  			_manager.Layout.RootPanel = newOrientedPanel;  		}  	}  	break;  #endregion  case DropTargetType.DockingManagerDockBottom:  	#region DropTargetType.DockingManagerDockBottom  	{  		if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Vertical && _manager.Layout.RootPanel.Children.Count == 1)  			_manager.Layout.RootPanel.Orientation = System.Windows.Controls.Orientation.Vertical;  		if (_manager.Layout.RootPanel.Orientation == System.Windows.Controls.Orientation.Vertical) {  			var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  			if (layoutAnchorablePaneGroup != null && layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical) {  				var childrenToTransfer = layoutAnchorablePaneGroup.Children.ToArray ();  				for (int i = 0; i < childrenToTransfer.Length; i++)  					_manager.Layout.RootPanel.Children.Add (childrenToTransfer [i]);  			} else  				_manager.Layout.RootPanel.Children.Add (floatingWindow.RootPanel);  		} else {  			var newOrientedPanel = new LayoutPanel () {  				Orientation = System.Windows.Controls.Orientation.Vertical  			};  			newOrientedPanel.Children.Add (_manager.Layout.RootPanel);  			newOrientedPanel.Children.Add (floatingWindow.RootPanel);  			_manager.Layout.RootPanel = newOrientedPanel;  		}  	}  	break;  #endregion  }  
Missing Default,AvalonDock.Controls,DockingManagerDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.DockingManagerDockLeft: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockTop: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Top - overlayWindow.Top' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockRight: {  	var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;  	var previewBoxRect = new Rect (targetScreenRect.Right - overlayWindow.Left - Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Top - overlayWindow.Top' Math.Min (desideredWidth' targetScreenRect.Width / 2.0)' targetScreenRect.Height);  	return new RectangleGeometry (previewBoxRect);  }  case DropTargetType.DockingManagerDockBottom: {  	var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;  	var previewBoxRect = new Rect (targetScreenRect.Left - overlayWindow.Left' targetScreenRect.Bottom - overlayWindow.Top - Math.Min (desideredHeight' targetScreenRect.Height / 2.0)' targetScreenRect.Width' Math.Min (desideredHeight' targetScreenRect.Height / 2.0));  	return new RectangleGeometry (previewBoxRect);  }  }  
Missing Default,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.DocumentPaneDockBottom:  	#region DropTargetType.DocumentPaneDockBottom  	{  		var newLayoutDocumentPane = new LayoutDocumentPane (floatingWindow.RootDocument);  		var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;  		if (parentModel == null) {  			var parentContainer = targetModel.Parent as ILayoutContainer;  			var newParentModel = new LayoutDocumentPaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Vertical  			};  			parentContainer.ReplaceChild (targetModel' newParentModel);  			newParentModel.Children.Add (targetModel as LayoutDocumentPane);  			newParentModel.Children.Add (newLayoutDocumentPane);  		} else {  			var manager = parentModel.Root.Manager;  			if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Vertical) {  				parentModel.Orientation = System.Windows.Controls.Orientation.Vertical;  				int targetPaneIndex = parentModel.IndexOfChild (targetModel);  				parentModel.Children.Insert (targetPaneIndex + 1' newLayoutDocumentPane);  			} else {  				LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup ();  				newChildGroup.Orientation = System.Windows.Controls.Orientation.Vertical;  				parentModel.ReplaceChild (targetModel' newChildGroup);  				newChildGroup.Children.Add (targetModel);  				newChildGroup.Children.Add (newLayoutDocumentPane);  			}  		}  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockTop:  	#region DropTargetType.DocumentPaneDockTop  	{  		var newLayoutDocumentPane = new LayoutDocumentPane (floatingWindow.RootDocument);  		var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;  		if (parentModel == null) {  			var parentContainer = targetModel.Parent as ILayoutContainer;  			var newParentModel = new LayoutDocumentPaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Vertical  			};  			parentContainer.ReplaceChild (targetModel' newParentModel);  			newParentModel.Children.Add (targetModel as LayoutDocumentPane);  			newParentModel.Children.Insert (0' newLayoutDocumentPane);  		} else {  			var manager = parentModel.Root.Manager;  			if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Vertical) {  				parentModel.Orientation = System.Windows.Controls.Orientation.Vertical;  				int targetPaneIndex = parentModel.IndexOfChild (targetModel);  				parentModel.Children.Insert (targetPaneIndex' newLayoutDocumentPane);  			} else {  				LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup ();  				newChildGroup.Orientation = System.Windows.Controls.Orientation.Vertical;  				parentModel.ReplaceChild (targetModel' newChildGroup);  				newChildGroup.Children.Add (newLayoutDocumentPane);  				newChildGroup.Children.Add (targetModel);  			}  		}  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockLeft:  	#region DropTargetType.DocumentPaneDockLeft  	{  		var newLayoutDocumentPane = new LayoutDocumentPane (floatingWindow.RootDocument);  		var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;  		if (parentModel == null) {  			var parentContainer = targetModel.Parent as ILayoutContainer;  			var newParentModel = new LayoutDocumentPaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Horizontal  			};  			parentContainer.ReplaceChild (targetModel' newParentModel);  			newParentModel.Children.Add (targetModel);  			newParentModel.Children.Insert (0' newLayoutDocumentPane);  		} else {  			var manager = parentModel.Root.Manager;  			if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Horizontal) {  				parentModel.Orientation = System.Windows.Controls.Orientation.Horizontal;  				int targetPaneIndex = parentModel.IndexOfChild (targetModel);  				parentModel.Children.Insert (targetPaneIndex' newLayoutDocumentPane);  			} else {  				LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup ();  				newChildGroup.Orientation = System.Windows.Controls.Orientation.Horizontal;  				parentModel.ReplaceChild (targetModel' newChildGroup);  				newChildGroup.Children.Add (newLayoutDocumentPane);  				newChildGroup.Children.Add (targetModel);  			}  		}  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockRight:  	#region DropTargetType.DocumentPaneDockRight  	{  		var newLayoutDocumentPane = new LayoutDocumentPane (floatingWindow.RootDocument);  		var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;  		if (parentModel == null) {  			var parentContainer = targetModel.Parent as ILayoutContainer;  			var newParentModel = new LayoutDocumentPaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Horizontal  			};  			parentContainer.ReplaceChild (targetModel' newParentModel);  			newParentModel.Children.Add (targetModel as LayoutDocumentPane);  			newParentModel.Children.Add (newLayoutDocumentPane);  		} else {  			var manager = parentModel.Root.Manager;  			if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Horizontal) {  				parentModel.Orientation = System.Windows.Controls.Orientation.Horizontal;  				int targetPaneIndex = parentModel.IndexOfChild (targetModel);  				parentModel.Children.Insert (targetPaneIndex + 1' newLayoutDocumentPane);  			} else {  				LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup ();  				newChildGroup.Orientation = System.Windows.Controls.Orientation.Horizontal;  				parentModel.ReplaceChild (targetModel' newChildGroup);  				newChildGroup.Children.Add (targetModel);  				newChildGroup.Children.Add (newLayoutDocumentPane);  			}  		}  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockInside:  	#region DropTargetType.DocumentPaneDockInside  	{  		var paneModel = targetModel as LayoutDocumentPane;  		var sourceModel = floatingWindow.RootDocument;  		int i = _tabIndex == -1 ? 0 : _tabIndex;  		sourceModel.IsActive = false;  		paneModel.Children.Insert (i' sourceModel);  		sourceModel.IsActive = true;  	}  	break;  #endregion  }  
Missing Default,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.DocumentPaneDockBottom:  	#region DropTargetType.DocumentPaneDockBottom  	{  		var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;  		var newLayoutDocumentPane = new LayoutDocumentPane ();  		if (parentModel == null) {  			var parentContainer = targetModel.Parent as ILayoutContainer;  			var newParentModel = new LayoutDocumentPaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Vertical  			};  			parentContainer.ReplaceChild (targetModel' newParentModel);  			newParentModel.Children.Add (targetModel as LayoutDocumentPane);  			newParentModel.Children.Add (newLayoutDocumentPane);  		} else {  			var manager = parentModel.Root.Manager;  			if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Vertical) {  				parentModel.Orientation = System.Windows.Controls.Orientation.Vertical;  				int targetPaneIndex = parentModel.IndexOfChild (targetModel);  				parentModel.Children.Insert (targetPaneIndex + 1' newLayoutDocumentPane);  			} else {  				LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup ();  				newChildGroup.Orientation = System.Windows.Controls.Orientation.Vertical;  				parentModel.ReplaceChild (targetModel' newChildGroup);  				newChildGroup.Children.Add (targetModel);  				newChildGroup.Children.Add (newLayoutDocumentPane);  			}  		}  		foreach (var cntToTransfer in floatingWindow.RootPanel.Descendents ().OfType<LayoutAnchorable> ().ToArray ())  			newLayoutDocumentPane.Children.Add (cntToTransfer);  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockTop:  	#region DropTargetType.DocumentPaneDockTop  	{  		var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;  		var newLayoutDocumentPane = new LayoutDocumentPane ();  		if (parentModel == null) {  			var parentContainer = targetModel.Parent as ILayoutContainer;  			var newParentModel = new LayoutDocumentPaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Vertical  			};  			parentContainer.ReplaceChild (targetModel' newParentModel);  			newParentModel.Children.Add (newLayoutDocumentPane);  			newParentModel.Children.Add (targetModel as LayoutDocumentPane);  		} else {  			var manager = parentModel.Root.Manager;  			if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Vertical) {  				parentModel.Orientation = System.Windows.Controls.Orientation.Vertical;  				int targetPaneIndex = parentModel.IndexOfChild (targetModel);  				parentModel.Children.Insert (targetPaneIndex' newLayoutDocumentPane);  			} else {  				LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup ();  				newChildGroup.Orientation = System.Windows.Controls.Orientation.Vertical;  				parentModel.ReplaceChild (targetModel' newChildGroup);  				newChildGroup.Children.Add (newLayoutDocumentPane);  				newChildGroup.Children.Add (targetModel);  			}  		}  		foreach (var cntToTransfer in floatingWindow.RootPanel.Descendents ().OfType<LayoutAnchorable> ().ToArray ())  			newLayoutDocumentPane.Children.Add (cntToTransfer);  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockLeft:  	#region DropTargetType.DocumentPaneDockLeft  	{  		var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;  		var newLayoutDocumentPane = new LayoutDocumentPane ();  		if (parentModel == null) {  			var parentContainer = targetModel.Parent as ILayoutContainer;  			var newParentModel = new LayoutDocumentPaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Horizontal  			};  			parentContainer.ReplaceChild (targetModel' newParentModel);  			newParentModel.Children.Add (newLayoutDocumentPane);  			newParentModel.Children.Add (targetModel as LayoutDocumentPane);  		} else {  			var manager = parentModel.Root.Manager;  			if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Horizontal) {  				parentModel.Orientation = System.Windows.Controls.Orientation.Horizontal;  				int targetPaneIndex = parentModel.IndexOfChild (targetModel);  				parentModel.Children.Insert (targetPaneIndex' newLayoutDocumentPane);  			} else {  				LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup ();  				newChildGroup.Orientation = System.Windows.Controls.Orientation.Horizontal;  				parentModel.ReplaceChild (targetModel' newChildGroup);  				newChildGroup.Children.Add (newLayoutDocumentPane);  				newChildGroup.Children.Add (targetModel);  			}  		}  		foreach (var cntToTransfer in floatingWindow.RootPanel.Descendents ().OfType<LayoutAnchorable> ().ToArray ())  			newLayoutDocumentPane.Children.Add (cntToTransfer);  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockRight:  	#region DropTargetType.DocumentPaneDockRight  	{  		var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;  		var newLayoutDocumentPane = new LayoutDocumentPane ();  		if (parentModel == null) {  			var parentContainer = targetModel.Parent as ILayoutContainer;  			var newParentModel = new LayoutDocumentPaneGroup () {  				Orientation = System.Windows.Controls.Orientation.Horizontal  			};  			parentContainer.ReplaceChild (targetModel' newParentModel);  			newParentModel.Children.Add (targetModel as LayoutDocumentPane);  			newParentModel.Children.Add (newLayoutDocumentPane);  		} else {  			var manager = parentModel.Root.Manager;  			if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Horizontal) {  				parentModel.Orientation = System.Windows.Controls.Orientation.Horizontal;  				int targetPaneIndex = parentModel.IndexOfChild (targetModel);  				parentModel.Children.Insert (targetPaneIndex + 1' newLayoutDocumentPane);  			} else {  				LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup ();  				newChildGroup.Orientation = System.Windows.Controls.Orientation.Horizontal;  				parentModel.ReplaceChild (targetModel' newChildGroup);  				newChildGroup.Children.Add (targetModel);  				newChildGroup.Children.Add (newLayoutDocumentPane);  			}  		}  		foreach (var cntToTransfer in floatingWindow.RootPanel.Descendents ().OfType<LayoutAnchorable> ().ToArray ())  			newLayoutDocumentPane.Children.Add (cntToTransfer);  	}  	break;  #endregion  case DropTargetType.DocumentPaneDockInside:  	#region DropTargetType.DocumentPaneDockInside  	{  		var paneModel = targetModel as LayoutDocumentPane;  		var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;  		int i = _tabIndex == -1 ? 0 : _tabIndex;  		LayoutAnchorable anchorableToActivate = null;  		foreach (var anchorableToImport in layoutAnchorablePaneGroup.Descendents ().OfType<LayoutAnchorable> ().ToArray ()) {  			paneModel.Children.Insert (i' anchorableToImport);  			i++;  			anchorableToActivate = anchorableToImport;  		}  		anchorableToActivate.IsActive = true;  	}  	break;  #endregion  }  
Missing Default,AvalonDock.Controls,DocumentPaneDropTarget,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following switch statement is missing a default case: switch (Type) {  case DropTargetType.DocumentPaneDockInside: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	if (_tabIndex == -1) {  		return new RectangleGeometry (targetScreenRect);  	} else {  		var translatedDetectionRect = new Rect (DetectionRects [0].TopLeft' DetectionRects [0].BottomRight);  		translatedDetectionRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  		var pathFigure = new PathFigure ();  		pathFigure.StartPoint = targetScreenRect.BottomRight;  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Right' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopRight  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.TopLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = translatedDetectionRect.BottomLeft  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = new Point (targetScreenRect.Left' translatedDetectionRect.Bottom)  		});  		pathFigure.Segments.Add (new LineSegment () {  			Point = targetScreenRect.BottomLeft  		});  		pathFigure.IsClosed = true;  		pathFigure.IsFilled = true;  		pathFigure.Freeze ();  		return new PathGeometry (new PathFigure[] {  			pathFigure  		});  	}  }  case DropTargetType.DocumentPaneDockBottom: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (0.0' targetScreenRect.Height / 2.0);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockTop: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Height /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockLeft: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  case DropTargetType.DocumentPaneDockRight: {  	var targetScreenRect = TargetElement.GetScreenArea ();  	targetScreenRect.Offset (-overlayWindow.Left' -overlayWindow.Top);  	targetScreenRect.Offset (targetScreenRect.Width / 2.0' 0.0);  	targetScreenRect.Width /= 2.0;  	return new RectangleGeometry (targetScreenRect);  }  }  
Missing Default,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,FilterMessage,The following switch statement is missing a default case: switch (msg) {  case Win32Helper.WM_NCLBUTTONDOWN:  	//Left button down on title -> start dragging over docking manager  	if (wParam.ToInt32 () == Win32Helper.HT_CAPTION) {  		_model.Descendents ().OfType<LayoutAnchorablePane> ().First (p => p.ChildrenCount > 0 && p.SelectedContent != null).SelectedContent.IsActive = true;  		handled = true;  	}  	break;  case Win32Helper.WM_NCRBUTTONUP:  	if (wParam.ToInt32 () == Win32Helper.HT_CAPTION) {  		if (OpenContextMenu ())  			handled = true;  		if (_model.Root.Manager.ShowSystemMenu)  			WindowChrome.GetWindowChrome (this).ShowSystemMenu = !handled;  		else  			WindowChrome.GetWindowChrome (this).ShowSystemMenu = false;  	}  	break;  }  
Missing Default,AvalonDock.Controls,LayoutAnchorSideControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorSideControl.cs,UpdateSide,The following switch statement is missing a default case: switch (_model.Side) {  case AnchorSide.Left:  	SetIsLeftSide (true);  	break;  case AnchorSide.Top:  	SetIsTopSide (true);  	break;  case AnchorSide.Right:  	SetIsRightSide (true);  	break;  case AnchorSide.Bottom:  	SetIsBottomSide (true);  	break;  }  
Missing Default,AvalonDock.Controls,LayoutDocumentFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutDocumentFloatingWindowControl.cs,FilterMessage,The following switch statement is missing a default case: switch (msg) {  case Win32Helper.WM_NCLBUTTONDOWN:  	//Left button down on title -> start dragging over docking manager  	if (wParam.ToInt32 () == Win32Helper.HT_CAPTION) {  		if (_model.RootDocument != null)  			_model.RootDocument.IsActive = true;  	}  	break;  case Win32Helper.WM_NCRBUTTONUP:  	if (wParam.ToInt32 () == Win32Helper.HT_CAPTION) {  		if (OpenContextMenu ())  			handled = true;  		if (_model.Root.Manager.ShowSystemMenu)  			WindowChrome.GetWindowChrome (this).ShowSystemMenu = !handled;  		else  			WindowChrome.GetWindowChrome (this).ShowSystemMenu = false;  	}  	break;  }  
Missing Default,AvalonDock.Controls,LayoutFloatingWindowControl,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,FilterMessage,The following switch statement is missing a default case: switch (msg) {  case Win32Helper.WM_ACTIVATE:  	if (((int)wParam & 0xFFFF) == Win32Helper.WA_INACTIVE) {  		if (lParam == this.GetParentWindowHandle ()) {  			Win32Helper.SetActiveWindow (_hwndSrc.Handle);  			handled = true;  		}  	}  	break;  case Win32Helper.WM_EXITSIZEMOVE:  	UpdatePositionAndSizeOfPanes ();  	if (_dragService != null) {  		bool dropFlag;  		var mousePosition = this.TransformToDeviceDPI (Win32Helper.GetMousePosition ());  		_dragService.Drop (mousePosition' out dropFlag);  		_dragService = null;  		SetIsDragging (false);  		if (dropFlag)  			InternalClose ();  	}  	break;  case Win32Helper.WM_MOVING:  	{  		UpdateDragPosition ();  	}  	break;  case Win32Helper.WM_LBUTTONUP:  	//set as handled right button click on title area (after showing context menu)  	if (_dragService != null && Mouse.LeftButton == MouseButtonState.Released) {  		_dragService.Abort ();  		_dragService = null;  		SetIsDragging (false);  	}  	break;  }  
Missing Default,AvalonDock.Controls,OverlayWindow,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The following switch statement is missing a default case: switch (visibleArea.Type) {  case DropAreaType.DockingManager:  	{  		var dropAreaDockingManager = visibleArea as DropArea<DockingManager>;  		yield return new DockingManagerDropTarget (dropAreaDockingManager.AreaElement' _dockingManagerDropTargetLeft.GetScreenArea ()' DropTargetType.DockingManagerDockLeft);  		yield return new DockingManagerDropTarget (dropAreaDockingManager.AreaElement' _dockingManagerDropTargetTop.GetScreenArea ()' DropTargetType.DockingManagerDockTop);  		yield return new DockingManagerDropTarget (dropAreaDockingManager.AreaElement' _dockingManagerDropTargetBottom.GetScreenArea ()' DropTargetType.DockingManagerDockBottom);  		yield return new DockingManagerDropTarget (dropAreaDockingManager.AreaElement' _dockingManagerDropTargetRight.GetScreenArea ()' DropTargetType.DockingManagerDockRight);  	}  	break;  case DropAreaType.AnchorablePane:  	{  		var dropAreaAnchorablePane = visibleArea as DropArea<LayoutAnchorablePaneControl>;  		yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetLeft.GetScreenArea ()' DropTargetType.AnchorablePaneDockLeft);  		yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetTop.GetScreenArea ()' DropTargetType.AnchorablePaneDockTop);  		yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetRight.GetScreenArea ()' DropTargetType.AnchorablePaneDockRight);  		yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetBottom.GetScreenArea ()' DropTargetType.AnchorablePaneDockBottom);  		yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetInto.GetScreenArea ()' DropTargetType.AnchorablePaneDockInside);  		var parentPaneModel = dropAreaAnchorablePane.AreaElement.Model as LayoutAnchorablePane;  		LayoutAnchorableTabItem lastAreaTabItem = null;  		foreach (var dropAreaTabItem in dropAreaAnchorablePane.AreaElement.FindVisualChildren<LayoutAnchorableTabItem> ()) {  			var tabItemModel = dropAreaTabItem.Model as LayoutAnchorable;  			lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea ().Right < dropAreaTabItem.GetScreenArea ().Right ? dropAreaTabItem : lastAreaTabItem;  			int tabIndex = parentPaneModel.Children.IndexOf (tabItemModel);  			yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' dropAreaTabItem.GetScreenArea ()' DropTargetType.AnchorablePaneDockInside' tabIndex);  		}  		if (lastAreaTabItem != null) {  			var lastAreaTabItemScreenArea = lastAreaTabItem.GetScreenArea ();  			var newAreaTabItemScreenArea = new Rect (lastAreaTabItemScreenArea.TopRight' new Point (lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom));  			if (newAreaTabItemScreenArea.Right < dropAreaAnchorablePane.AreaElement.GetScreenArea ().Right)  				yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' newAreaTabItemScreenArea' DropTargetType.AnchorablePaneDockInside' parentPaneModel.Children.Count);  		}  		var dropAreaTitle = dropAreaAnchorablePane.AreaElement.FindVisualChildren<AnchorablePaneTitle> ().FirstOrDefault ();  		if (dropAreaTitle != null)  			yield return new AnchorablePaneDropTarget (dropAreaAnchorablePane.AreaElement' dropAreaTitle.GetScreenArea ()' DropTargetType.AnchorablePaneDockInside);  	}  	break;  case DropAreaType.DocumentPane:  	{  		bool isDraggingAnchorables = _floatingWindow.Model is LayoutAnchorableFloatingWindow;  		if (isDraggingAnchorables && _gridDocumentPaneFullDropTargets != null) {  			var dropAreaDocumentPane = visibleArea as DropArea<LayoutDocumentPaneControl>;  			if (_documentPaneFullDropTargetLeft.IsVisible)  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetLeft.GetScreenArea ()' DropTargetType.DocumentPaneDockLeft);  			if (_documentPaneFullDropTargetTop.IsVisible)  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetTop.GetScreenArea ()' DropTargetType.DocumentPaneDockTop);  			if (_documentPaneFullDropTargetRight.IsVisible)  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetRight.GetScreenArea ()' DropTargetType.DocumentPaneDockRight);  			if (_documentPaneFullDropTargetBottom.IsVisible)  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetBottom.GetScreenArea ()' DropTargetType.DocumentPaneDockBottom);  			if (_documentPaneFullDropTargetInto.IsVisible)  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetInto.GetScreenArea ()' DropTargetType.DocumentPaneDockInside);  			var parentPaneModel = dropAreaDocumentPane.AreaElement.Model as LayoutDocumentPane;  			LayoutDocumentTabItem lastAreaTabItem = null;  			foreach (var dropAreaTabItem in dropAreaDocumentPane.AreaElement.FindVisualChildren<LayoutDocumentTabItem> ()) {  				var tabItemModel = dropAreaTabItem.Model;  				lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea ().Right < dropAreaTabItem.GetScreenArea ().Right ? dropAreaTabItem : lastAreaTabItem;  				int tabIndex = parentPaneModel.Children.IndexOf (tabItemModel);  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' dropAreaTabItem.GetScreenArea ()' DropTargetType.DocumentPaneDockInside' tabIndex);  			}  			if (lastAreaTabItem != null) {  				var lastAreaTabItemScreenArea = lastAreaTabItem.GetScreenArea ();  				var newAreaTabItemScreenArea = new Rect (lastAreaTabItemScreenArea.TopRight' new Point (lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom));  				if (newAreaTabItemScreenArea.Right < dropAreaDocumentPane.AreaElement.GetScreenArea ().Right)  					yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' newAreaTabItemScreenArea' DropTargetType.DocumentPaneDockInside' parentPaneModel.Children.Count);  			}  			if (_documentPaneDropTargetLeftAsAnchorablePane.IsVisible)  				yield return new DocumentPaneDropAsAnchorableTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetLeftAsAnchorablePane.GetScreenArea ()' DropTargetType.DocumentPaneDockAsAnchorableLeft);  			if (_documentPaneDropTargetTopAsAnchorablePane.IsVisible)  				yield return new DocumentPaneDropAsAnchorableTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetTopAsAnchorablePane.GetScreenArea ()' DropTargetType.DocumentPaneDockAsAnchorableTop);  			if (_documentPaneDropTargetRightAsAnchorablePane.IsVisible)  				yield return new DocumentPaneDropAsAnchorableTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetRightAsAnchorablePane.GetScreenArea ()' DropTargetType.DocumentPaneDockAsAnchorableRight);  			if (_documentPaneDropTargetBottomAsAnchorablePane.IsVisible)  				yield return new DocumentPaneDropAsAnchorableTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetBottomAsAnchorablePane.GetScreenArea ()' DropTargetType.DocumentPaneDockAsAnchorableBottom);  		} else {  			var dropAreaDocumentPane = visibleArea as DropArea<LayoutDocumentPaneControl>;  			if (_documentPaneDropTargetLeft.IsVisible)  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetLeft.GetScreenArea ()' DropTargetType.DocumentPaneDockLeft);  			if (_documentPaneDropTargetTop.IsVisible)  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetTop.GetScreenArea ()' DropTargetType.DocumentPaneDockTop);  			if (_documentPaneDropTargetRight.IsVisible)  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetRight.GetScreenArea ()' DropTargetType.DocumentPaneDockRight);  			if (_documentPaneDropTargetBottom.IsVisible)  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetBottom.GetScreenArea ()' DropTargetType.DocumentPaneDockBottom);  			if (_documentPaneDropTargetInto.IsVisible)  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetInto.GetScreenArea ()' DropTargetType.DocumentPaneDockInside);  			var parentPaneModel = dropAreaDocumentPane.AreaElement.Model as LayoutDocumentPane;  			LayoutDocumentTabItem lastAreaTabItem = null;  			foreach (var dropAreaTabItem in dropAreaDocumentPane.AreaElement.FindVisualChildren<LayoutDocumentTabItem> ()) {  				var tabItemModel = dropAreaTabItem.Model;  				lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea ().Right < dropAreaTabItem.GetScreenArea ().Right ? dropAreaTabItem : lastAreaTabItem;  				int tabIndex = parentPaneModel.Children.IndexOf (tabItemModel);  				yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' dropAreaTabItem.GetScreenArea ()' DropTargetType.DocumentPaneDockInside' tabIndex);  			}  			if (lastAreaTabItem != null) {  				var lastAreaTabItemScreenArea = lastAreaTabItem.GetScreenArea ();  				var newAreaTabItemScreenArea = new Rect (lastAreaTabItemScreenArea.TopRight' new Point (lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom));  				if (newAreaTabItemScreenArea.Right < dropAreaDocumentPane.AreaElement.GetScreenArea ().Right)  					yield return new DocumentPaneDropTarget (dropAreaDocumentPane.AreaElement' newAreaTabItemScreenArea' DropTargetType.DocumentPaneDockInside' parentPaneModel.Children.Count);  			}  		}  	}  	break;  case DropAreaType.DocumentPaneGroup:  	{  		var dropAreaDocumentPane = visibleArea as DropArea<LayoutDocumentPaneGroupControl>;  		if (_documentPaneDropTargetInto.IsVisible)  			yield return new DocumentPaneGroupDropTarget (dropAreaDocumentPane.AreaElement' _documentPaneDropTargetInto.GetScreenArea ()' DropTargetType.DocumentPaneGroupDockInside);  	}  	break;  }  
Missing Default,Standard,Utility,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_UrlEncodeIsSafe,The following switch statement is missing a default case: switch ((char)b) {  case '-':  case '_':  case '.':  case '!':  //case '~':  case '*':  case '\'':  case '(':  case ')':  	return true;  }  
Missing Default,Microsoft.Windows.Shell,WindowChromeWorker,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_GetHwndState,The following switch statement is missing a default case: switch (wpl.showCmd) {  case SW.SHOWMINIMIZED:  	return WindowState.Minimized;  case SW.SHOWMAXIMIZED:  	return WindowState.Maximized;  }  
Missing Default,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ToggleAutoHide,The following switch statement is missing a default case: switch (side) {  case AnchorSide.Right:  	if (parentGroup.Root.RootPanel.Orientation == Orientation.Horizontal) {  		previousContainer = new LayoutAnchorablePane ();  		parentGroup.Root.RootPanel.Children.Add (previousContainer);  	} else {  		previousContainer = new LayoutAnchorablePane ();  		LayoutPanel panel = new LayoutPanel () {  			Orientation = Orientation.Horizontal  		};  		LayoutRoot root = parentGroup.Root as LayoutRoot;  		LayoutPanel oldRootPanel = parentGroup.Root.RootPanel as LayoutPanel;  		root.RootPanel = panel;  		panel.Children.Add (oldRootPanel);  		panel.Children.Add (previousContainer);  	}  	break;  case AnchorSide.Left:  	if (parentGroup.Root.RootPanel.Orientation == Orientation.Horizontal) {  		previousContainer = new LayoutAnchorablePane ();  		parentGroup.Root.RootPanel.Children.Insert (0' previousContainer);  	} else {  		previousContainer = new LayoutAnchorablePane ();  		LayoutPanel panel = new LayoutPanel () {  			Orientation = Orientation.Horizontal  		};  		LayoutRoot root = parentGroup.Root as LayoutRoot;  		LayoutPanel oldRootPanel = parentGroup.Root.RootPanel as LayoutPanel;  		root.RootPanel = panel;  		panel.Children.Add (previousContainer);  		panel.Children.Add (oldRootPanel);  	}  	break;  case AnchorSide.Top:  	if (parentGroup.Root.RootPanel.Orientation == Orientation.Vertical) {  		previousContainer = new LayoutAnchorablePane ();  		parentGroup.Root.RootPanel.Children.Insert (0' previousContainer);  	} else {  		previousContainer = new LayoutAnchorablePane ();  		LayoutPanel panel = new LayoutPanel () {  			Orientation = Orientation.Vertical  		};  		LayoutRoot root = parentGroup.Root as LayoutRoot;  		LayoutPanel oldRootPanel = parentGroup.Root.RootPanel as LayoutPanel;  		root.RootPanel = panel;  		panel.Children.Add (previousContainer);  		panel.Children.Add (oldRootPanel);  	}  	break;  case AnchorSide.Bottom:  	if (parentGroup.Root.RootPanel.Orientation == Orientation.Vertical) {  		previousContainer = new LayoutAnchorablePane ();  		parentGroup.Root.RootPanel.Children.Add (previousContainer);  	} else {  		previousContainer = new LayoutAnchorablePane ();  		LayoutPanel panel = new LayoutPanel () {  			Orientation = Orientation.Vertical  		};  		LayoutRoot root = parentGroup.Root as LayoutRoot;  		LayoutPanel oldRootPanel = parentGroup.Root.RootPanel as LayoutPanel;  		root.RootPanel = panel;  		panel.Children.Add (oldRootPanel);  		panel.Children.Add (previousContainer);  	}  	break;  }  
Missing Default,AvalonDock.Layout,LayoutAnchorable,F:\newReposMay17\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ToggleAutoHide,The following switch statement is missing a default case: switch (anchorSide) {  case AnchorSide.Right:  	root.RightSide.Children.Add (newAnchorGroup);  	break;  case AnchorSide.Left:  	root.LeftSide.Children.Add (newAnchorGroup);  	break;  case AnchorSide.Top:  	root.TopSide.Children.Add (newAnchorGroup);  	break;  case AnchorSide.Bottom:  	root.BottomSide.Children.Add (newAnchorGroup);  	break;  }  
