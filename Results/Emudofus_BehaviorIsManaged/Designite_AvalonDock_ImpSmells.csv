Implementation smell,Namespace,Class,File,Method,Description
Long Method,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The method has 185 lines of code.
Long Method,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,Drop,The method has 119 lines of code.
Long Method,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The method has 135 lines of code.
Long Method,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,Drop,The method has 157 lines of code.
Long Method,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,Drop,The method has 168 lines of code.
Long Method,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The method has 130 lines of code.
Long Method,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The method has 163 lines of code.
Long Method,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The method has 105 lines of code.
Long Method,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ToggleAutoHide,The method has 129 lines of code.
Long Method,AvalonDock.Layout,LayoutRoot,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The method has 158 lines of code.
Complex Method,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,ClearDefaultBindings,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,SetDefaultBindings,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Controls,DragService,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DragService.cs,UpdateMouseLocation,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Controls,LayoutAnchorGroupControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorGroupControl.cs,OnModelChildrenCollectionChanged,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,UpdateRowColDefinitions,Cyclomatic complexity of the method is 8
Complex Method,Standard,HRESULT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,AreStreamsEqual,Cyclomatic complexity of the method is 8
Complex Method,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,OnLayoutChanged,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,CreateUIElementForModel,Cyclomatic complexity of the method is 15
Complex Method,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,StartDraggingFloatingWindowForContent,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,GetDropAreas,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachDocumentsSource,Cyclomatic complexity of the method is 13
Complex Method,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,documentsSourceElementsChanged,Cyclomatic complexity of the method is 19
Complex Method,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,Cyclomatic complexity of the method is 15
Complex Method,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,Cyclomatic complexity of the method is 21
Complex Method,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,OnThemeChanged,Cyclomatic complexity of the method is 8
Complex Method,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,Show,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,InternalDock,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,AddToLayout,Cyclomatic complexity of the method is 13
Complex Method,AvalonDock.Layout,LayoutContent,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,ReadXml,Cyclomatic complexity of the method is 15
Complex Method,AvalonDock.Layout,LayoutContent,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,WriteXml,Cyclomatic complexity of the method is 17
Complex Method,AvalonDock.Layout,LayoutGroup<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutGroup.cs,_children_CollectionChanged,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Layout,LayoutPositionableGroup<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutPositionableGroup.cs,WriteXml,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock.Layout,LayoutPositionableGroup<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutPositionableGroup.cs,ReadXml,Cyclomatic complexity of the method is 9
Complex Method,AvalonDock.Layout,LayoutRoot,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,_hiddenAnchorables_CollectionChanged,Cyclomatic complexity of the method is 10
Complex Method,AvalonDock.Layout.Serialization,LayoutSerializer,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,Cyclomatic complexity of the method is 11
Long Parameter List,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,FilterMessage,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,AvalonDock.Controls,LayoutDocumentFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutDocumentFloatingWindowControl.cs,FilterMessage,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,AvalonDock.Controls,LayoutFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,FilterMessage,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,AvalonDock.Controls,FloatingWindowContentHost,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,WndProc,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,WndProc,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,Standard,MessageWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\MessageWindow.cs,MessageWindow,The method has 6 parameters. Parameters: classStyle' style' exStyle' location' name' callback
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_CreateDIBSection,The method has 6 parameters. Parameters: hdc' bitmapInfo' iUsage' ppvBits' hSection' dwOffset
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_CreateDIBSectionIntPtr,The method has 6 parameters. Parameters: hdc' bitmapInfo' iUsage' ppvBits' hSection' dwOffset
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,CreateDIBSection,The method has 5 parameters. Parameters: hdc' bitmapInfo' ppvBits' hSection' dwOffset
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_CreateRoundRectRgn,The method has 6 parameters. Parameters: nLeftRect' nTopRect' nRightRect' nBottomRect' nWidthEllipse' nHeightEllipse
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,CreateRoundRectRgn,The method has 6 parameters. Parameters: nLeftRect' nTopRect' nRightRect' nBottomRect' nWidthEllipse' nHeightEllipse
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,DwmDefWindowProc,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' plResult
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_GetCurrentThemeName,The method has 6 parameters. Parameters: pszThemeFileName' dwMaxNameChars' pszColorBuff' cchMaxColorChars' pszSizeBuff' cchMaxSizeChars
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' x' y' cx' cy' uFlags
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' x' y' cx' cy' uFlags
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,TrackPopupMenuEx,The method has 6 parameters. Parameters: hmenu' fuFlags' x' y' hwnd' lptpm
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_UpdateLayeredWindow,The method has 9 parameters. Parameters: hwnd' hdcDst' pptDst' psize' hdcSrc' pptSrc' crKey' pblend' dwFlags
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,_UpdateLayeredWindowIntPtr,The method has 9 parameters. Parameters: hwnd' hdcDst' pptDst' psize' hdcSrc' pptSrc' crKey' pblend' dwFlags
Long Parameter List,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,UpdateLayeredWindow,The method has 9 parameters. Parameters: hwnd' hdcDst' pptDst' psize' hdcSrc' pptSrc' crKey' pblend' dwFlags
Long Parameter List,Standard,IShellFolder,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ShellProvider.cs,ParseDisplayName,The method has 6 parameters. Parameters: hwnd' pbc' pszDisplayName' pchEaten' ppidl' pdwAttributes
Long Parameter List,Standard,IShellFolder,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ShellProvider.cs,GetUIObjectOf,The method has 5 parameters. Parameters: hwndOwner' cidl' apidl' riid' rgfReserved
Long Parameter List,Standard,IShellFolder,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ShellProvider.cs,SetNameOf,The method has 5 parameters. Parameters: hwnd' pidl' pszName' uFlags' ppidlOut
Long Parameter List,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_MatchImage,The method has 5 parameters. Parameters: frame' bitDepth' width' height' bpp
Long Parameter List,Standard,Verify,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,BoundedDoubleInc,The method has 5 parameters. Parameters: lowerBoundInclusive' value' upperBoundInclusive' message' parameter
Long Parameter List,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_WndProc,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,AvalonDock,Win32Helper,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpszClassName' lpszWindowName' style' x' y' width' height' hwndParent' hMenu' hInst' pvParam
Long Parameter List,AvalonDock,Win32Helper,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' X' Y' cx' cy' uFlags
Long Identifier,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the parameter targetModelAsPositionableElement is 32.
Long Identifier,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the parameter targetModelAsPositionableElement is 32.
Long Identifier,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the parameter targetModelAsPositionableElement is 32.
Long Identifier,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The length of the parameter targetModelAsPositionableElement is 32.
Long Identifier,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The length of the parameter layoutAnchorablePaneWithActualSize is 34.
Long Identifier,AvalonDock.Controls,DropDownButton,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DropDownButton.cs,,The length of the parameter DropDownContextMenuDataContextProperty is 38.
Long Identifier,AvalonDock.Controls,DropDownControlArea,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DropDownControlArea.cs,,The length of the parameter DropDownContextMenuDataContextProperty is 38.
Long Identifier,AvalonDock.Controls,FocusElementManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\FocusElementManager.cs,,The length of the parameter _lastFocusedElementBeforeEnterMenuMode is 38.
Long Identifier,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,,The length of the parameter _defaultCloseAllButThisCommand is 30.
Long Identifier,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,,The length of the parameter _defaultNewVerticalTabGroupCommand is 34.
Long Identifier,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,,The length of the parameter _defaultNewHorizontalTabGroupCommand is 36.
Long Identifier,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,,The length of the parameter _defaultMoveToNextTabGroupCommand is 33.
Long Identifier,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,,The length of the parameter _defaultMoveToPreviousTabGroupCommand is 37.
Long Identifier,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,,The length of the parameter CloseAllButThisCommandProperty is 30.
Long Identifier,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,,The length of the parameter NewVerticalTabGroupCommandProperty is 34.
Long Identifier,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,,The length of the parameter NewHorizontalTabGroupCommandProperty is 36.
Long Identifier,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,,The length of the parameter MoveToNextTabGroupCommandProperty is 33.
Long Identifier,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,,The length of the parameter MoveToPreviousTabGroupCommandProperty is 37.
Long Identifier,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the parameter layoutAnchorablePaneWithActualSize is 34.
Long Identifier,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,,The length of the parameter SingleContentLayoutItemProperty is 31.
Long Identifier,AvalonDock.Controls,LayoutDocumentTabItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutDocumentTabItem.cs,,The length of the parameter _parentDocumentTabPanelScreenArea is 33.
Long Identifier,AvalonDock.Controls,LayoutGridResizerControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridResizerControl.cs,,The length of the parameter BackgroundWhileDraggingProperty is 31.
Long Identifier,AvalonDock.Controls,LayoutPanelControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The length of the parameter childPositionableModelWidthActualSize is 37.
Long Identifier,AvalonDock.Controls,LayoutPanelControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The length of the parameter childPositionableModelWidthActualSize is 37.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _gridDockingManagerDropTargets is 30.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _gridAnchorablePaneDropTargets is 30.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _gridDocumentPaneFullDropTargets is 32.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _dockingManagerDropTargetBottom is 31.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _dockingManagerDropTargetRight is 30.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _anchorablePaneDropTargetBottom is 31.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _anchorablePaneDropTargetRight is 30.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _documentPaneDropTargetBottomAsAnchorablePane is 45.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _documentPaneDropTargetTopAsAnchorablePane is 42.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _documentPaneDropTargetLeftAsAnchorablePane is 43.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _documentPaneDropTargetRightAsAnchorablePane is 44.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _documentPaneFullDropTargetBottom is 33.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _documentPaneFullDropTargetTop is 30.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _documentPaneFullDropTargetLeft is 31.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _documentPaneFullDropTargetRight is 32.
Long Identifier,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,,The length of the parameter _documentPaneFullDropTargetInto is 31.
Long Identifier,Standard,HRESULT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,,The length of the parameter DESTS_E_NO_MATCHING_ASSOC_HANDLER is 33.
Long Identifier,Standard,PKEY,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ShellProvider.cs,,The length of the parameter AppUserModel_IsDestListSeparator is 32.
Long Identifier,Standard,PKEY,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ShellProvider.cs,,The length of the parameter AppUserModel_RelaunchDisplayNameResource is 40.
Long Identifier,Standard,PKEY,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ShellProvider.cs,,The length of the parameter AppUserModel_RelaunchIconResource is 33.
Long Identifier,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,,The length of the parameter _windowNonClientFrameThickness is 30.
Long Identifier,Microsoft.Windows.Shell,WindowChrome,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChrome.cs,,The length of the parameter IsHitTestVisibleInChromeProperty is 32.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,StartDraggingFloatingWindowForContent,The length of the parameter parentPaneAsPositionableElement is 31.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,StartDraggingFloatingWindowForContent,The length of the parameter contentModelParentChildrenIndex is 31.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,StartDraggingFloatingWindowForPane,The length of the parameter contentModelAsPreviousContainer is 31.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter AnchorablePaneTemplateProperty is 30.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter DocumentPaneControlStyleProperty is 32.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter AnchorablePaneControlStyleProperty is 34.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter DocumentHeaderTemplateProperty is 30.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter DocumentHeaderTemplateSelectorProperty is 38.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter DocumentTitleTemplateSelectorProperty is 37.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter AnchorableTitleTemplateProperty is 31.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter AnchorableTitleTemplateSelectorProperty is 39.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter AnchorableHeaderTemplateProperty is 32.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter AnchorableHeaderTemplateSelectorProperty is 40.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter LayoutItemTemplateSelectorProperty is 34.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter SuspendAnchorablesSourceBinding is 31.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter _insideInternalSetActiveContent is 31.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter DocumentPaneMenuItemHeaderTemplateProperty is 42.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter DocumentPaneMenuItemHeaderTemplateSelectorProperty is 50.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter IconContentTemplateSelectorProperty is 35.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter LayoutItemContainerStyleProperty is 32.
Long Identifier,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,,The length of the parameter LayoutItemContainerStyleSelectorProperty is 40.
Long Identifier,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,Show,The length of the parameter previousContainerAsLayoutGroup is 30.
Long Identifier,AvalonDock.Layout,LayoutContent,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,Float,The length of the parameter previousContainerAsLayoutGroup is 30.
Long Identifier,AvalonDock.Layout,LayoutContent,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,Dock,The length of the parameter previousContainerAsLayoutGroup is 30.
Long Statement,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The length of the statement  "            var layoutAnchorablePaneWithActualSize = anchorableFloatingWindowModel.RootPanel as ILayoutPositionableElementWithActualSize; " is 125.
Long Statement,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The length of the statement  "            //    var documentPaneGroupControl = manager.FindLogicalChildren<LayoutDocumentPaneGroupControl>().First(d => d.Model == parentGroup); " is 134.
Long Statement,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The length of the statement  "            //    var documentPaneControl = manager.FindLogicalChildren<LayoutDocumentPaneControl>().First(d => d.Model == targetModel); " is 124.
Long Statement,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The length of the statement  "            var documentPaneControl = manager.FindLogicalChildren<FrameworkElement>().OfType<ILayoutControl>().First(d => parentGroup != null ? d.Model == parentGroup : d.Model == parentGroupPanel) as FrameworkElement; " is 206.
Long Statement,AvalonDock.Controls,FocusElementManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\FocusElementManager.cs,SetFocusOnLastElement,The length of the statement  "            Debug.WriteLine("SetFocusOnLastElement(focused={0}' model={1}' element={2})"' focused' model' handleToFocus == IntPtr.Zero ? (objectToFocus == null ?  "" : objectToFocus.ToString()) : handleToFocus.ToString()); " is 210.
Long Statement,AvalonDock.Controls,FocusElementManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\FocusElementManager.cs,WindowFocusChanging,The length of the statement  "                var hostContainingFocusedHandle = manager.FindLogicalChildren<HwndHost>().FirstOrDefault(hw => Win32Helper.IsChild(hw.Handle' e.GotFocusWinHandle)); " is 148.
Long Statement,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "            _defaultDockAsDocumentCommand = new RelayCommand((p) => ExecuteDockAsDocumentCommand(p)' (p) => CanExecuteDockAsDocumentCommand(p)); " is 132.
Long Statement,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "            _defaultCloseAllButThisCommand = new RelayCommand((p) => ExecuteCloseAllButThisCommand(p)' (p) => CanExecuteCloseAllButThisCommand(p)); " is 135.
Long Statement,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "            _defaultNewVerticalTabGroupCommand = new RelayCommand((p) => ExecuteNewVerticalTabGroupCommand(p)' (p) => CanExecuteNewVerticalTabGroupCommand(p)); " is 147.
Long Statement,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "            _defaultNewHorizontalTabGroupCommand = new RelayCommand((p) => ExecuteNewHorizontalTabGroupCommand(p)' (p) => CanExecuteNewHorizontalTabGroupCommand(p)); " is 153.
Long Statement,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "            _defaultMoveToNextTabGroupCommand = new RelayCommand((p) => ExecuteMoveToNextTabGroupCommand(p)' (p) => CanExecuteMoveToNextTabGroupCommand(p)); " is 144.
Long Statement,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,InitDefaultCommands,The length of the statement  "            _defaultMoveToPreviousTabGroupCommand = new RelayCommand((p) => ExecuteMoveToPreviousTabGroupCommand(p)' (p) => CanExecuteMoveToPreviousTabGroupCommand(p)); " is 156.
Long Statement,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,CanExecuteCloseCommand,The length of the statement  "                System.Diagnostics.Debug.WriteLine(string.Format("CanExecuteCloseCommand({0}) = {1}"' LayoutElement.Title' LayoutElement.CanClose)); " is 132.
Long Statement,AvalonDock.Controls,LayoutItem,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutItem.cs,CanExecuteCloseAllButThisCommand,The length of the statement  "                Descendents().OfType<LayoutContent>().Where(d => d != LayoutElement && (d.Parent is LayoutDocumentPane || d.Parent is LayoutDocumentFloatingWindow)).Any(); " is 155.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "            var layoutAnchorablePaneWithActualSize = anchorableFloatingWindowModel.RootPanel as ILayoutPositionableElementWithActualSize; " is 125.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "                        var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth; " is 151.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "                        var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight; " is 155.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "                        var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth; " is 151.
Long Statement,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The length of the statement  "                        var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight; " is 155.
Long Statement,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The length of the statement  "                            pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Bottom) }); " is 121.
Long Statement,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The length of the statement  "                            pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Bottom) }); " is 120.
Long Statement,AvalonDock.Controls,DragService,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DragService.cs,GetOverlayWindowHosts,The length of the statement  "            _overlayWindowHosts.AddRange(_manager.GetFloatingWindowsByZOrder().OfType<LayoutAnchorableFloatingWindowControl>().Where(fw => fw != _floatingWindow && fw.IsVisible)); " is 167.
Long Statement,AvalonDock.Controls,DragService,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DragService.cs,UpdateMouseLocation,The length of the statement  "                _currentHost.GetDropAreas(_floatingWindow).Where(cw => !_currentWindowAreas.Contains(cw) && cw.DetectionRect.Contains(dragPosition)).ToList(); " is 142.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,OnInitialized,The length of the statement  "            //SetBinding(VisibilityProperty' new Binding("IsVisible") { Source = _model' Converter = new BoolToVisibilityConverter()' Mode = BindingMode.OneWay' ConverterParameter = Visibility.Hidden }); " is 191.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,OnInitialized,The length of the statement  "                    SetBinding(VisibilityProperty' new Binding("IsVisible") { Source = _model' Converter = new BoolToVisibilityConverter()' Mode = BindingMode.OneWay' ConverterParameter = Visibility.Hidden }); " is 189.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,OnInitialized,The length of the statement  "            SetBinding(SingleContentLayoutItemProperty' new Binding("Model.SinglePane.SelectedContent") { Source = this' Converter = new LayoutItemFromLayoutModelConverter() }); " is 165.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,HitTest,The length of the statement  "            Rect detectionRect = new Rect(this.PointToScreenDPIWithoutFlowDirection(new Point())' this.TransformActualSizeToAncestor()); " is 124.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,CreateOverlayWindow,The length of the statement  "            Rect rectWindow = new Rect(this.PointToScreenDPIWithoutFlowDirection(new Point())' this.TransformActualSizeToAncestor()); " is 121.
Long Statement,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,FilterMessage,The length of the statement  "                        _model.Descendents().OfType<LayoutAnchorablePane>().First(p => p.ChildrenCount > 0 && p.SelectedContent != null).SelectedContent.IsActive = true; " is 145.
Long Statement,AvalonDock.Controls,LayoutAnchorControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorControl.cs,OnVisualParentChanged,The length of the statement  "            if (contentModel != null && contentModel.Content != null && contentModel.Root != null && contentModel.Content is UIElement) " is 123.
Long Statement,AvalonDock.Controls,LayoutFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnInitialized,The length of the statement  "                new ExecutedRoutedEventHandler((s' args) => Microsoft.Windows.Shell.SystemCommands.CloseWindow((Window)args.Parameter)))); " is 122.
Long Statement,AvalonDock.Controls,LayoutFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnInitialized,The length of the statement  "                new ExecutedRoutedEventHandler((s' args) => Microsoft.Windows.Shell.SystemCommands.MaximizeWindow((Window)args.Parameter)))); " is 125.
Long Statement,AvalonDock.Controls,LayoutFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnInitialized,The length of the statement  "                new ExecutedRoutedEventHandler((s' args) => Microsoft.Windows.Shell.SystemCommands.MinimizeWindow((Window)args.Parameter)))); " is 125.
Long Statement,AvalonDock.Controls,LayoutFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnInitialized,The length of the statement  "                new ExecutedRoutedEventHandler((s' args) => Microsoft.Windows.Shell.SystemCommands.RestoreWindow((Window)args.Parameter)))); " is 124.
Long Statement,AvalonDock.Controls,FloatingWindowContentHost,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,BuildWindowCore,The length of the statement  "                    WindowStyle = Win32Helper.WS_CHILD | Win32Helper.WS_VISIBLE | Win32Helper.WS_CLIPSIBLINGS | Win32Helper.WS_CLIPCHILDREN' " is 120.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnChildModelPropertyChanged,The length of the statement  "            if (_fixingChildrenDockLengths.CanEnter && e.PropertyName == "DockWidth" && Orientation == System.Windows.Controls.Orientation.Horizontal) " is 138.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnChildModelPropertyChanged,The length of the statement  "            else if (_fixingChildrenDockLengths.CanEnter && e.PropertyName == "DockHeight" && Orientation == System.Windows.Controls.Orientation.Vertical) " is 142.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,UpdateRowColDefinitions,The length of the statement  "                            Width = childModel.IsVisible && nextChildModelVisibleExist ? new GridLength(manager.GridSplitterWidth) : new GridLength(0.0' GridUnitType.Pixel) " is 144.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,UpdateRowColDefinitions,The length of the statement  "                            Height = childModel.IsVisible && nextChildModelVisibleExist ? new GridLength(manager.GridSplitterHeight) : new GridLength(0.0' GridUnitType.Pixel) " is 146.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragDelta,The length of the statement  "                Canvas.SetLeft(_resizerGhost' MathHelper.MinMax(_initialStartPoint.X + transformedDelta.X' 0.0' _resizerWindowHost.Width - _resizerGhost.Width)); " is 145.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragDelta,The length of the statement  "                Canvas.SetTop(_resizerGhost' MathHelper.MinMax(_initialStartPoint.Y + transformedDelta.Y' 0.0' _resizerWindowHost.Height - _resizerGhost.Height)); " is 146.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragCompleted,The length of the statement  "                    prevChildModel.DockWidth = new GridLength(prevChildModel.DockWidth.Value * (prevChildActualSize.Width + delta) / prevChildActualSize.Width' GridUnitType.Star); " is 159.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragCompleted,The length of the statement  "                    nextChildModel.DockWidth = new GridLength(nextChildModel.DockWidth.Value * (nextChildActualSize.Width - delta) / nextChildActualSize.Width' GridUnitType.Star); " is 159.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragCompleted,The length of the statement  "                    prevChildModel.DockHeight = new GridLength(prevChildModel.DockHeight.Value * (prevChildActualSize.Height + delta) / prevChildActualSize.Height' GridUnitType.Star); " is 163.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,OnSplitterDragCompleted,The length of the statement  "                    nextChildModel.DockHeight = new GridLength(nextChildModel.DockHeight.Value * (nextChildActualSize.Height - delta) / nextChildActualSize.Height' GridUnitType.Star); " is 163.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,ShowResizerOverlayWindow,The length of the statement  "                    prevChildActualSize.Width - prevChildModel.DockMinWidth + splitter.ActualWidth + nextChildActualSize.Width - nextChildModel.DockMinWidth' " is 137.
Long Statement,AvalonDock.Controls,LayoutGridControl<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutGridControl.cs,ShowResizerOverlayWindow,The length of the statement  "                    prevChildActualSize.Height - prevChildModel.DockMinHeight + splitter.ActualHeight + nextChildActualSize.Height - nextChildModel.DockMinHeight); " is 143.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,OnApplyTemplate,The length of the statement  "            _documentPaneDropTargetBottomAsAnchorablePane = GetTemplateChild("PART_DocumentPaneDropTargetBottomAsAnchorablePane") as FrameworkElement; " is 138.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,OnApplyTemplate,The length of the statement  "            _documentPaneDropTargetTopAsAnchorablePane = GetTemplateChild("PART_DocumentPaneDropTargetTopAsAnchorablePane") as FrameworkElement; " is 132.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,OnApplyTemplate,The length of the statement  "            _documentPaneDropTargetLeftAsAnchorablePane = GetTemplateChild("PART_DocumentPaneDropTargetLeftAsAnchorablePane") as FrameworkElement; " is 134.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,OnApplyTemplate,The length of the statement  "            _documentPaneDropTargetRightAsAnchorablePane = GetTemplateChild("PART_DocumentPaneDropTargetRightAsAnchorablePane") as FrameworkElement; " is 136.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                            yield return new DockingManagerDropTarget(dropAreaDockingManager.AreaElement' _dockingManagerDropTargetLeft.GetScreenArea()' DropTargetType.DockingManagerDockLeft); " is 164.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                            yield return new DockingManagerDropTarget(dropAreaDockingManager.AreaElement' _dockingManagerDropTargetTop.GetScreenArea()' DropTargetType.DockingManagerDockTop); " is 162.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                            yield return new DockingManagerDropTarget(dropAreaDockingManager.AreaElement' _dockingManagerDropTargetBottom.GetScreenArea()' DropTargetType.DockingManagerDockBottom); " is 168.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                            yield return new DockingManagerDropTarget(dropAreaDockingManager.AreaElement' _dockingManagerDropTargetRight.GetScreenArea()' DropTargetType.DockingManagerDockRight); " is 166.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                            yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetLeft.GetScreenArea()' DropTargetType.AnchorablePaneDockLeft); " is 164.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                            yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetTop.GetScreenArea()' DropTargetType.AnchorablePaneDockTop); " is 162.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                            yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetRight.GetScreenArea()' DropTargetType.AnchorablePaneDockRight); " is 166.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                            yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetBottom.GetScreenArea()' DropTargetType.AnchorablePaneDockBottom); " is 168.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                            yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetInto.GetScreenArea()' DropTargetType.AnchorablePaneDockInside); " is 166.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea().Right < dropAreaTabItem.GetScreenArea().Right ? " is 124.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' dropAreaTabItem.GetScreenArea()' DropTargetType.AnchorablePaneDockInside' tabIndex); " is 162.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                var newAreaTabItemScreenArea = new Rect(lastAreaTabItemScreenArea.TopRight' new Point(lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom)); " is 188.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' newAreaTabItemScreenArea' DropTargetType.AnchorablePaneDockInside' parentPaneModel.Children.Count); " is 177.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' dropAreaTitle.GetScreenArea()' DropTargetType.AnchorablePaneDockInside); " is 150.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetLeft.GetScreenArea()' DropTargetType.DocumentPaneDockLeft); " is 160.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetTop.GetScreenArea()' DropTargetType.DocumentPaneDockTop); " is 158.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetRight.GetScreenArea()' DropTargetType.DocumentPaneDockRight); " is 162.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetBottom.GetScreenArea()' DropTargetType.DocumentPaneDockBottom); " is 164.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetInto.GetScreenArea()' DropTargetType.DocumentPaneDockInside); " is 162.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea().Right < dropAreaTabItem.GetScreenArea().Right ? " is 124.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' dropAreaTabItem.GetScreenArea()' DropTargetType.DocumentPaneDockInside' tabIndex); " is 156.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    var newAreaTabItemScreenArea = new Rect(lastAreaTabItemScreenArea.TopRight' new Point(lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom)); " is 188.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                        yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' newAreaTabItemScreenArea' DropTargetType.DocumentPaneDockInside' parentPaneModel.Children.Count); " is 171.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropAsAnchorableTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetLeftAsAnchorablePane.GetScreenArea()' DropTargetType.DocumentPaneDockAsAnchorableLeft); " is 196.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropAsAnchorableTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetTopAsAnchorablePane.GetScreenArea()' DropTargetType.DocumentPaneDockAsAnchorableTop); " is 194.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropAsAnchorableTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetRightAsAnchorablePane.GetScreenArea()' DropTargetType.DocumentPaneDockAsAnchorableRight); " is 198.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropAsAnchorableTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetBottomAsAnchorablePane.GetScreenArea()' DropTargetType.DocumentPaneDockAsAnchorableBottom); " is 200.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetLeft.GetScreenArea()' DropTargetType.DocumentPaneDockLeft); " is 156.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetTop.GetScreenArea()' DropTargetType.DocumentPaneDockTop); " is 154.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetRight.GetScreenArea()' DropTargetType.DocumentPaneDockRight); " is 158.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetBottom.GetScreenArea()' DropTargetType.DocumentPaneDockBottom); " is 160.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetInto.GetScreenArea()' DropTargetType.DocumentPaneDockInside); " is 158.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea().Right < dropAreaTabItem.GetScreenArea().Right ? " is 124.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' dropAreaTabItem.GetScreenArea()' DropTargetType.DocumentPaneDockInside' tabIndex); " is 156.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                    var newAreaTabItemScreenArea = new Rect(lastAreaTabItemScreenArea.TopRight' new Point(lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom)); " is 188.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                        yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' newAreaTabItemScreenArea' DropTargetType.DocumentPaneDockInside' parentPaneModel.Children.Count); " is 171.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The length of the statement  "                                yield return new DocumentPaneGroupDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetInto.GetScreenArea()' DropTargetType.DocumentPaneGroupDockInside); " is 168.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "                        var layoutDocumentPane = (dropAreaDocumentPaneGroup.AreaElement.Model as LayoutDocumentPaneGroup).Children.First() as LayoutDocumentPane; " is 137.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "                                    _documentPaneFullDropTargetLeft.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Horizontal ? Visibility.Visible : Visibility.Hidden; " is 148.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "                                    _documentPaneFullDropTargetRight.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Horizontal ? Visibility.Visible : Visibility.Hidden; " is 149.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "                                    _documentPaneFullDropTargetTop.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Vertical ? Visibility.Visible : Visibility.Hidden; " is 145.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "                                    _documentPaneFullDropTargetBottom.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Vertical ? Visibility.Visible : Visibility.Hidden; " is 148.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "                                int indexOfDocumentPane = parentDocumentPaneGroup.Children.Where(ch => ch.IsVisible).ToList().IndexOf(layoutDocumentPane); " is 122.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "                                    _documentPaneDropTargetLeft.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Horizontal ? Visibility.Visible : Visibility.Hidden; " is 144.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "                                    _documentPaneDropTargetRight.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Horizontal ? Visibility.Visible : Visibility.Hidden; " is 145.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "                                    _documentPaneDropTargetTop.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Vertical ? Visibility.Visible : Visibility.Hidden; " is 141.
Long Statement,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,DragEnter,The length of the statement  "                                    _documentPaneDropTargetBottom.Visibility = parentDocumentPaneGroup.Orientation == Orientation.Vertical ? Visibility.Visible : Visibility.Hidden; " is 144.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,BuildWindowCore,The length of the statement  "                WindowStyle = Win32Helper.WS_CHILD | Win32Helper.WS_VISIBLE | Win32Helper.WS_CLIPSIBLINGS | Win32Helper.WS_CLIPCHILDREN' " is 120.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,WndProc,The length of the statement  "                Win32Helper.SetWindowPos(_internalHwndSource.Handle' Win32Helper.HWND_TOP' 0' 0' 0' 0' Win32Helper.SetWindowPosFlags.IgnoreMove | Win32Helper.SetWindowPosFlags.IgnoreResize); " is 174.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,CreateInternalGrid,The length of the statement  "                    Width = _model.AutoHideWidth == 0.0 ? new GridLength(_model.AutoHideMinWidth) : new GridLength(_model.AutoHideWidth' GridUnitType.Pixel)}); " is 139.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,CreateInternalGrid,The length of the statement  "                    Width = _model.AutoHideWidth == 0.0 ? new GridLength(_model.AutoHideMinWidth) : new GridLength(_model.AutoHideWidth' GridUnitType.Pixel)' " is 137.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,CreateInternalGrid,The length of the statement  "                    Height = _model.AutoHideHeight == 0.0 ? new GridLength(_model.AutoHideMinHeight) : new GridLength(_model.AutoHideHeight' GridUnitType.Pixel)' " is 141.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,CreateInternalGrid,The length of the statement  "                    Height = _model.AutoHideHeight == 0.0 ? new GridLength(_model.AutoHideMinHeight) : new GridLength(_model.AutoHideHeight' GridUnitType.Pixel)' " is 141.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,OnResizerDragDelta,The length of the statement  "                Canvas.SetLeft(_resizerGhost' MathHelper.MinMax(_initialStartPoint.X + transformedDelta.X' 0.0' _resizerWindowHost.Width - _resizerGhost.Width)); " is 145.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,OnResizerDragDelta,The length of the statement  "                Canvas.SetTop(_resizerGhost' MathHelper.MinMax(_initialStartPoint.Y + transformedDelta.Y' 0.0' _resizerWindowHost.Height - _resizerGhost.Height)); " is 146.
Long Statement,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ArrangeOverride,The length of the statement  "            return base.ArrangeOverride(finalSize);// new Size(_internalHostPresenter.ActualWidth' _internalHostPresenter.ActualHeight); " is 124.
Long Statement,Standard,HRESULT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,Make,The length of the statement  "            Assert.Implies((int)facility != (int)((int)facility & 0x1FF)' facility == Facility.Ese || facility == Facility.WinCodec); " is 121.
Long Statement,Standard,MessageWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\MessageWindow.cs,_Dispose,The length of the statement  "                Dispatcher.BeginInvoke(DispatcherPriority.Normal' (DispatcherOperationCallback)(arg => _DestroyWindow(IntPtr.Zero' className))); " is 128.
Long Statement,Standard,MessageWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\MessageWindow.cs,_Dispose,The length of the statement  "                    Dispatcher.BeginInvoke(DispatcherPriority.Normal' (DispatcherOperationCallback)(arg => _DestroyWindow(hwnd' className))); " is 121.
Long Statement,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,CreateWindowEx,The length of the statement  "            IntPtr ret = _CreateWindowEx(dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam); " is 138.
Long Statement,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,UpdateLayeredWindow,The length of the statement  "            if (!_UpdateLayeredWindowIntPtr(hwnd' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' crKey' ref pblend' dwFlags)) " is 131.
Long Statement,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The length of the statement  "                    drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height); " is 134.
Long Statement,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_GetBestMatch,The length of the statement  "                int currentIconBitDepth = isBitmapIconDecoder ? frames[i].Thumbnail.Format.BitsPerPixel : frames[i].Format.BitsPerPixel; " is 120.
Long Statement,Standard,Verify,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,PropertyIsNotNull,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "The property {0} cannot be null at this time."' name)); " is 136.
Long Statement,Standard,Verify,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,PropertyIsNull,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "The property {0} must be null at this time."' name)); " is 134.
Long Statement,Standard,Verify,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,BoundedInteger,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture' "The integer value must be bounded with [{0}' {1})"' lowerBoundInclusive' upperBoundExclusive)' parameterName); " is 183.
Long Statement,Standard,Verify,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,FileExists,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture' "No file exists at \"{0}\""' filePath)' parameterName); " is 127.
Long Statement,Standard,Verify,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Verify.cs,ImplementsInterface,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture' "The parameter must implement interface {0}."' interfaceType.ToString())' parameterName); " is 161.
Long Statement,Microsoft.Windows.Shell,SystemCommands,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemCommands.cs,ShowSystemMenuPhysicalCoordinates,The length of the statement  "            uint cmd = NativeMethods.TrackPopupMenuEx(hmenu' TPM_LEFTBUTTON | TPM_RETURNCMD' (int)physicalScreenLocation.X' (int)physicalScreenLocation.Y' hwnd' IntPtr.Zero); " is 162.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowResizeBorderThickness,The length of the statement  "            WindowResizeBorderThickness = new Thickness(frameSizeInDips.Width' frameSizeInDips.Height' frameSizeInDips.Width' frameSizeInDips.Height); " is 138.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowNonClientFrameThickness,The length of the statement  "            WindowNonClientFrameThickness = new Thickness(frameSizeInDips.Width' frameSizeInDips.Height + captionHeightInDips' frameSizeInDips.Width' frameSizeInDips.Height); " is 162.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeCaptionButtonLocation,The length of the statement  "            // For all known themes' the RECT for the maximize box shouldn't add anything to the union of the minimize and close boxes. " is 123.
Long Statement,Microsoft.Windows.Shell,WindowChrome,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChrome.cs,_OnChromeChanged,The length of the statement  "            // There can be a many:1 relationship of to Window to WindowChrome objects' but a 1:1 for a Window and a WindowChromeWorker. " is 124.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetWindow,The length of the statement  "                Utility.AddDependencyPropertyChangeListener(_window' Window.TemplateProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 129.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetWindow,The length of the statement  "                Utility.AddDependencyPropertyChangeListener(_window' Window.FlowDirectionProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 134.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_UnsetWindow,The length of the statement  "                Utility.RemoveDependencyPropertyChangeListener(_window' Window.TemplateProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 132.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_UnsetWindow,The length of the statement  "                Utility.RemoveDependencyPropertyChangeListener(_window' Window.FlowDirectionProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 137.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "            Rect rcLogicalWindow = DpiHelper.DeviceRectToLogical(new Rect(rcWindow.Left' rcWindow.Top' rcWindow.Width' rcWindow.Height)); " is 125.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "            Rect rcLogicalClient = DpiHelper.DeviceRectToLogical(new Rect(rcAdjustedClient.Left' rcAdjustedClient.Top' rcAdjustedClient.Width' rcAdjustedClient.Height)); " is 157.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "            // This works fine' but if the window is dynamically changing its FlowDirection then this can have really bizarre side effects. " is 127.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "            // This will mostly work if the FlowDirection is dynamically changed' but there aren't many real scenarios that would call for " is 126.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "                rootElement.RenderTransform = new MatrixTransform(1' 0' 0' 1' -(nonClientThickness.Left + nonClientThickness.Right)' 0); " is 120.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupWindows7Issues,The length of the statement  "                    // Disabling this for the published code to reduce debug noise.  This will get compiled away for retail binaries anyways. " is 121.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HandleNCRButtonUp,The length of the statement  "                    SystemCommands.ShowSystemMenuPhysicalCoordinates(_window' new Point(Utility.GET_X_LPARAM(lParam)' Utility.GET_Y_LPARAM(lParam))); " is 129.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HandleEnterSizeMove,The length of the statement  "                // Realistically we also don't want to update the start position when moving from one docked state to another (or to and from maximized)' " is 137.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HandleEnterSizeMove,The length of the statement  "                // but it's tricky to detect and this is already a workaround for a bug that's fixed in newer versions of the framework. " is 120.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HandleExitSizeMove,The length of the statement  "            // If they did that' then we need to try to update the restore bounds or else WPF will put the window at the maximized location (e.g. (-8'-8)). " is 143.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "                        hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius); " is 135.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "                        Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius); " is 120.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "                        Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius); " is 126.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "                        Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius); " is 129.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_ExtendGlassFrame,The length of the statement  "                Point deviceTopLeft = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.GlassFrameThickness.Left' _chromeInfo.GlassFrameThickness.Top)); " is 140.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_ExtendGlassFrame,The length of the statement  "                Point deviceBottomRight = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.GlassFrameThickness.Right' _chromeInfo.GlassFrameThickness.Bottom)); " is 148.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "            if (mousePosition.Y >= windowPosition.Top && mousePosition.Y < windowPosition.Top + _chromeInfo.ResizeBorderThickness.Top + _chromeInfo.CaptionHeight) " is 150.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "            else if (mousePosition.Y < windowPosition.Bottom && mousePosition.Y >= windowPosition.Bottom - (int)_chromeInfo.ResizeBorderThickness.Bottom) " is 141.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "            if (mousePosition.X >= windowPosition.Left && mousePosition.X < windowPosition.Left + (int)_chromeInfo.ResizeBorderThickness.Left) " is 130.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "            else if (mousePosition.X < windowPosition.Right && mousePosition.X >= windowPosition.Right - _chromeInfo.ResizeBorderThickness.Right) " is 133.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,CreateUIElementForModel,The length of the statement  "                templateModelView.SetBinding(LayoutAnchorSideControl.TemplateProperty' new Binding("AnchorSideTemplate") { Source = this }); " is 124.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,CreateUIElementForModel,The length of the statement  "                templateModelView.SetBinding(LayoutAnchorGroupControl.TemplateProperty' new Binding("AnchorGroupTemplate") { Source = this }); " is 126.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,CreateUIElementForModel,The length of the statement  "                templateModelView.SetBinding(LayoutDocumentPaneControl.StyleProperty' new Binding("DocumentPaneControlStyle") { Source = this }); " is 129.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,CreateUIElementForModel,The length of the statement  "                templateModelView.SetBinding(LayoutAnchorablePaneControl.StyleProperty' new Binding("AnchorablePaneControlStyle") { Source = this }); " is 133.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,HitTest,The length of the statement  "            Rect detectionRect = new Rect(this.PointToScreenDPIWithoutFlowDirection(new Point())' this.TransformActualSizeToAncestor()); " is 124.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,CreateOverlayWindow,The length of the statement  "            Rect rectWindow = new Rect(this.PointToScreenDPIWithoutFlowDirection(new Point())' this.TransformActualSizeToAncestor()); " is 121.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachDocumentsSource,The length of the statement  "            //    throw new InvalidOperationException("Unable to set the DocumentsSource property if LayoutDocument objects are already present in the model"); " is 147.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachDocumentsSource,The length of the statement  "            //    throw new InvalidOperationException("Layout must contains at least one LayoutDocumentPane in order to host documents"); " is 125.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,documentsSourceElementsChanged,The length of the statement  "                    var documentsToRemove = Layout.Descendents().OfType<LayoutDocument>().Where(d => e.OldItems.Contains(d.Content)).ToArray(); " is 123.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,documentsSourceElementsChanged,The length of the statement  "                    //    throw new InvalidOperationException("Layout must contains at least one LayoutDocumentPane in order to host documents"); " is 125.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,_ExecuteCloseAllButThisCommand,The length of the statement  "            foreach (var contentToClose in Layout.Descendents().OfType<LayoutContent>().Where(d => d != contentSelected && (d.Parent is LayoutDocumentPane || d.Parent is LayoutDocumentFloatingWindow)).ToArray()) " is 199.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The length of the statement  "            //    throw new InvalidOperationException("Unable to set the AnchorablesSource property if LayoutAnchorable objects are already present in the model"); " is 151.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The length of the statement  "                anchorablePane = layout.Descendents().OfType<LayoutAnchorablePane>().Where(pane => !pane.IsHostedInFloatingWindow && pane.GetSide() == AnchorSide.Right).FirstOrDefault(); " is 170.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The length of the statement  "                anchorablesSourceAsNotifier.CollectionChanged += new NotifyCollectionChangedEventHandler(anchorablesSourceElementsChanged); " is 123.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The length of the statement  "                    var anchorablesToRemove = Layout.Descendents().OfType<LayoutAnchorable>().Where(d => e.OldItems.Contains(d.Content)).ToArray(); " is 127.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The length of the statement  "                        anchorablePane = Layout.Descendents().OfType<LayoutAnchorablePane>().Where(pane => !pane.IsHostedInFloatingWindow && pane.GetSide() == AnchorSide.Right).FirstOrDefault(); " is 170.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,DetachAnchorablesSource,The length of the statement  "                anchorablesSourceAsNotifier.CollectionChanged -= new NotifyCollectionChangedEventHandler(anchorablesSourceElementsChanged); " is 123.
Long Statement,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,InternalSetActiveContent,The length of the statement  "            var layoutContent = Layout.Descendents().OfType<LayoutContent>().FirstOrDefault(lc => lc == contentObject || lc.Content == contentObject); " is 138.
Long Statement,AvalonDock,RECT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,GetHashCode,The length of the statement  "{ return Left ^ ((Top << 13) | (Top >> 0x13)) ^ ((Width << 0x1a) | (Width >> 6)) ^ ((Height << 7) | (Height >> 0x19)); }" is 120.
Long Statement,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,InternalDock,The length of the statement  "                anchorablePane = root.Descendents().OfType<LayoutAnchorablePane>().Where(pane => !pane.IsHostedInFloatingWindow && pane.GetSide() == AnchorSide.Right).FirstOrDefault(); " is 168.
Long Statement,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,AddToLayout,The length of the statement  "                var anchorablePane = manager.Layout.Descendents().OfType<LayoutAnchorablePane>().FirstOrDefault(p => p.GetSide() == side); " is 122.
Long Statement,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,AddToLayout,The length of the statement  "                    manager.Layout.RootPanel = new LayoutPanel() { Orientation = (left || right ? Orientation.Horizontal : Orientation.Vertical) }; " is 127.
Long Statement,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ToggleAutoHide,The length of the statement  "                    foreach (var cnt in root.Descendents().OfType<ILayoutPreviousContainer>().Where(c => c.PreviousContainer == parentGroup)) " is 121.
Long Statement,AvalonDock.Layout,LayoutContent,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,WriteXml,The length of the statement  "                writer.WriteAttributeString("LastActivationTimeStamp"' LastActivationTimeStamp.Value.ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,AvalonDock.Layout,LayoutContent,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutContent.cs,Dock,The length of the statement  "                var currentContainerIndex = (currentContainer is ILayoutGroup) ? (currentContainer as ILayoutGroup).IndexOfChild(this) : -1; " is 124.
Long Statement,AvalonDock.Layout,LayoutRoot,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "                foreach (var paneGroupToCollapse in this.Descendents().OfType<LayoutAnchorablePaneGroup>().Where(p => p.ChildrenCount == 1 && p.Children[0] is LayoutAnchorablePaneGroup).ToArray()) " is 180.
Long Statement,AvalonDock.Layout,LayoutRoot,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "                foreach (var paneGroupToCollapse in this.Descendents().OfType<LayoutDocumentPaneGroup>().Where(p => p.ChildrenCount == 1 && p.Children[0] is LayoutDocumentPaneGroup).ToArray()) " is 176.
Long Statement,AvalonDock.Layout,LayoutRoot,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,CollectGarbage,The length of the statement  "                foreach (var panelToCollapse in this.Descendents().OfType<LayoutPanel>().Where(p => p.ChildrenCount == 1 && p.Children[0] is LayoutPanel).ToArray()) " is 148.
Long Statement,AvalonDock.Layout.Serialization,LayoutSerializer,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,The length of the statement  "            foreach (var lcToAttach in layout.Descendents().OfType<ILayoutPreviousContainer>().Where(lc => lc.PreviousContainerId != null)) " is 127.
Long Statement,AvalonDock.Layout.Serialization,LayoutSerializer,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,The length of the statement  "                var paneContainerToAttach = layout.Descendents().OfType<ILayoutPaneSerializable>().FirstOrDefault(lps => lps.Id == lcToAttach.PreviousContainerId); " is 147.
Long Statement,AvalonDock.Layout.Serialization,LayoutSerializer,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,The length of the statement  "                    var args = new LayoutSerializationCallbackEventArgs(lcToFix' previousAchorable != null ? previousAchorable.Content : null); " is 123.
Long Statement,AvalonDock.Layout.Serialization,LayoutSerializer,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\Serialization\LayoutSerializer.cs,FixupLayout,The length of the statement  "                    var args = new LayoutSerializationCallbackEventArgs(lcToFix' previousDocument != null ? previousDocument.Content : null); " is 121.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\obj\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,AvalonDock.Controls,FocusElementManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\FocusElementManager.cs,manager_PreviewGotKeyboardFocus,The conditional expression  "focusedElement != null &&                  !(focusedElement is LayoutAnchorableTabItem || focusedElement is LayoutDocumentTabItem) &&                  !(focusedElement is ICommandSource)"  is complex.
Complex Conditional,AvalonDock.Controls,LayoutAnchorControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorControl.cs,OnVisualParentChanged,The conditional expression  "contentModel != null && contentModel.Content != null && contentModel.Root != null && contentModel.Content is UIElement"  is complex.
Complex Conditional,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The conditional expression  "a >= 0 && b >= 0 && c >= 0 && d >= 0"  is complex.
Virtual Method Call from Constructor,AvalonDock.Controls,LayoutFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,LayoutFloatingWindowControl,The constructor "LayoutFloatingWindowControl" calls a virtual method "UpdateThemeResources".
Empty Catch Block,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GuidTryParse,The method has an empty catch block.
Empty Catch Block,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GuidTryParse,The method has an empty catch block.
Empty Catch Block,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupWindows7Issues,The method has an empty catch block.
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.AnchorablePaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                              var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.TopLeft;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.TopRight });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }              }
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.AnchorablePaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                              var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.TopLeft;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.TopRight });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }              }
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.AnchorablePaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                              var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.TopLeft;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.TopRight });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }              }
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.AnchorablePaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                              var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.TopLeft;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.TopRight });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }              }
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.AnchorablePaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                              var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.TopLeft;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.TopRight });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }              }
Magic Number,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.AnchorablePaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                              var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.TopLeft;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.TopRight });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }              }
Magic Number,AvalonDock.Controls,AutoHideWindowManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AutoHideWindowManager.cs,SetupCloseTimer,The following statement contains a magic number: _closeTimer.Interval = TimeSpan.FromMilliseconds(1500);
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockAsAnchorableBottom:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableTop:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableRight:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableLeft:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockAsAnchorableBottom:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableTop:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableRight:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableLeft:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockAsAnchorableBottom:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableTop:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableRight:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableLeft:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockAsAnchorableBottom:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableTop:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableRight:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableLeft:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockAsAnchorableBottom:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableTop:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableRight:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableLeft:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockAsAnchorableBottom:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableTop:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableRight:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableLeft:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DockingManagerDockLeft:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockTop:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockRight:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Right - overlayWindow.Left - Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockBottom:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Bottom - overlayWindow.Top - Math.Min(desideredHeight' targetScreenRect.Height / 2.0)'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }              }
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DockingManagerDockLeft:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockTop:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockRight:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Right - overlayWindow.Left - Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockBottom:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Bottom - overlayWindow.Top - Math.Min(desideredHeight' targetScreenRect.Height / 2.0)'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }              }
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DockingManagerDockLeft:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockTop:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockRight:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Right - overlayWindow.Left - Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockBottom:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Bottom - overlayWindow.Top - Math.Min(desideredHeight' targetScreenRect.Height / 2.0)'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }              }
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DockingManagerDockLeft:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockTop:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockRight:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Right - overlayWindow.Left - Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockBottom:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Bottom - overlayWindow.Top - Math.Min(desideredHeight' targetScreenRect.Height / 2.0)'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }              }
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DockingManagerDockLeft:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockTop:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockRight:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Right - overlayWindow.Left - Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockBottom:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Bottom - overlayWindow.Top - Math.Min(desideredHeight' targetScreenRect.Height / 2.0)'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }              }
Magic Number,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DockingManagerDockLeft:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockTop:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockRight:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Right - overlayWindow.Left - Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockBottom:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Bottom - overlayWindow.Top - Math.Min(desideredHeight' targetScreenRect.Height / 2.0)'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                                                            var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.BottomRight;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.BottomLeft });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }                  case DropTargetType.DocumentPaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                                                            var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.BottomRight;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.BottomLeft });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }                  case DropTargetType.DocumentPaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                                                            var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.BottomRight;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.BottomLeft });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }                  case DropTargetType.DocumentPaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                                                            var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.BottomRight;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.BottomLeft });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }                  case DropTargetType.DocumentPaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                                                            var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.BottomRight;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.BottomLeft });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }                  case DropTargetType.DocumentPaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following statement contains a magic number: switch (Type)              {                  case DropTargetType.DocumentPaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                                                            var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.BottomRight;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.BottomLeft });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }                  case DropTargetType.DocumentPaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Magic Number,AvalonDock.Controls,LayoutAnchorControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorControl.cs,OnMouseEnter,The following statement contains a magic number: if (!e.Handled)              {                  _openUpTimer = new DispatcherTimer(DispatcherPriority.ApplicationIdle);                  _openUpTimer.Interval = TimeSpan.FromMilliseconds(400);                  _openUpTimer.Tick += new EventHandler(_openUpTimer_Tick);                  _openUpTimer.Start();              }
Magic Number,AvalonDock.Controls,LayoutFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnActivated,The following statement contains a magic number: if (_attachDrag && Mouse.LeftButton == MouseButtonState.Pressed)              {                  IntPtr windowHandle = new WindowInteropHelper(this).Handle;                  var mousePosition = this.PointToScreenDPI(Mouse.GetPosition(this));                  var clientArea = Win32Helper.GetClientRect(windowHandle);                  var windowArea = Win32Helper.GetWindowRect(windowHandle);                    Left = mousePosition.X - windowArea.Width / 2.0;                  Top = mousePosition.Y - (windowArea.Height - clientArea.Height) / 2.0;                  _attachDrag = false;                    IntPtr lParam = new IntPtr(((int)mousePosition.X & (int)0xFFFF) | (((int)mousePosition.Y) << 16));                  Win32Helper.SendMessage(windowHandle' Win32Helper.WM_NCLBUTTONDOWN' new IntPtr(Win32Helper.HT_CAPTION)' lParam);              }
Magic Number,AvalonDock.Controls,LayoutFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnActivated,The following statement contains a magic number: if (_attachDrag && Mouse.LeftButton == MouseButtonState.Pressed)              {                  IntPtr windowHandle = new WindowInteropHelper(this).Handle;                  var mousePosition = this.PointToScreenDPI(Mouse.GetPosition(this));                  var clientArea = Win32Helper.GetClientRect(windowHandle);                  var windowArea = Win32Helper.GetWindowRect(windowHandle);                    Left = mousePosition.X - windowArea.Width / 2.0;                  Top = mousePosition.Y - (windowArea.Height - clientArea.Height) / 2.0;                  _attachDrag = false;                    IntPtr lParam = new IntPtr(((int)mousePosition.X & (int)0xFFFF) | (((int)mousePosition.Y) << 16));                  Win32Helper.SendMessage(windowHandle' Win32Helper.WM_NCLBUTTONDOWN' new IntPtr(Win32Helper.HT_CAPTION)' lParam);              }
Magic Number,AvalonDock.Controls,LayoutFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,OnActivated,The following statement contains a magic number: if (_attachDrag && Mouse.LeftButton == MouseButtonState.Pressed)              {                  IntPtr windowHandle = new WindowInteropHelper(this).Handle;                  var mousePosition = this.PointToScreenDPI(Mouse.GetPosition(this));                  var clientArea = Win32Helper.GetClientRect(windowHandle);                  var windowArea = Win32Helper.GetWindowRect(windowHandle);                    Left = mousePosition.X - windowArea.Width / 2.0;                  Top = mousePosition.Y - (windowArea.Height - clientArea.Height) / 2.0;                  _attachDrag = false;                    IntPtr lParam = new IntPtr(((int)mousePosition.X & (int)0xFFFF) | (((int)mousePosition.Y) << 16));                  Win32Helper.SendMessage(windowHandle' Win32Helper.WM_NCLBUTTONDOWN' new IntPtr(Win32Helper.HT_CAPTION)' lParam);              }
Magic Number,AvalonDock.Controls,LayoutPanelControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: if (_model.Orientation == Orientation.Horizontal)              {                  if (_model.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>())                  {                      for (int i = 0; i < _model.Children.Count; i++)                      {                          var childContainerModel = _model.Children[i] as ILayoutContainer;                          var childPositionableModel = _model.Children[i] as ILayoutPositionableElement;                            if (childContainerModel != null &&                              (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>() ||                               childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>()))                          {                              childPositionableModel.DockWidth = new GridLength(1.0' GridUnitType.Star);                          }                          else if (childPositionableModel != null && childPositionableModel.DockWidth.IsStar)                          {                              var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;                                var widthToSet = Math.Max(childPositionableModelWidthActualSize.ActualWidth' childPositionableModel.DockMinWidth);                                                            widthToSet = Math.Min(widthToSet' ActualWidth / 2.0);                              widthToSet = Math.Max(widthToSet' childPositionableModel.DockMinWidth);                                        childPositionableModel.DockWidth = new GridLength(                                  widthToSet'                                  GridUnitType.Pixel);                          }                      }                  }                  else                  {                      for (int i = 0; i < _model.Children.Count; i++)                      {                          var childPositionableModel = _model.Children[i] as ILayoutPositionableElement;                          if (!childPositionableModel.DockWidth.IsStar)                          {                              childPositionableModel.DockWidth = new GridLength(1.0' GridUnitType.Star);                          }                      }                  }              }              else              {                  if (_model.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>())                  {                      for (int i = 0; i < _model.Children.Count; i++)                      {                          var childContainerModel = _model.Children[i] as ILayoutContainer;                          var childPositionableModel = _model.Children[i] as ILayoutPositionableElement;                            if (childContainerModel != null &&                              (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>() ||                               childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>()))                          {                              childPositionableModel.DockHeight = new GridLength(1.0' GridUnitType.Star);                          }                          else if (childPositionableModel != null && childPositionableModel.DockHeight.IsStar)                          {                              var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;                                var heightToSet = Math.Max(childPositionableModelWidthActualSize.ActualHeight' childPositionableModel.DockMinHeight);                              heightToSet = Math.Min(heightToSet' ActualHeight / 2.0);                              heightToSet = Math.Max(heightToSet' childPositionableModel.DockMinHeight);                                childPositionableModel.DockHeight = new GridLength(heightToSet' GridUnitType.Pixel);                          }                      }                  }                  else                  {                      for (int i = 0; i < _model.Children.Count; i++)                      {                          var childPositionableModel = _model.Children[i] as ILayoutPositionableElement;                          if (!childPositionableModel.DockHeight.IsStar)                          {                              childPositionableModel.DockHeight = new GridLength(1.0' GridUnitType.Star);                          }                      }                  }              }
Magic Number,AvalonDock.Controls,LayoutPanelControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutPanelControl.cs,OnFixChildrenDockLengths,The following statement contains a magic number: if (_model.Orientation == Orientation.Horizontal)              {                  if (_model.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>())                  {                      for (int i = 0; i < _model.Children.Count; i++)                      {                          var childContainerModel = _model.Children[i] as ILayoutContainer;                          var childPositionableModel = _model.Children[i] as ILayoutPositionableElement;                            if (childContainerModel != null &&                              (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>() ||                               childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>()))                          {                              childPositionableModel.DockWidth = new GridLength(1.0' GridUnitType.Star);                          }                          else if (childPositionableModel != null && childPositionableModel.DockWidth.IsStar)                          {                              var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;                                var widthToSet = Math.Max(childPositionableModelWidthActualSize.ActualWidth' childPositionableModel.DockMinWidth);                                                            widthToSet = Math.Min(widthToSet' ActualWidth / 2.0);                              widthToSet = Math.Max(widthToSet' childPositionableModel.DockMinWidth);                                        childPositionableModel.DockWidth = new GridLength(                                  widthToSet'                                  GridUnitType.Pixel);                          }                      }                  }                  else                  {                      for (int i = 0; i < _model.Children.Count; i++)                      {                          var childPositionableModel = _model.Children[i] as ILayoutPositionableElement;                          if (!childPositionableModel.DockWidth.IsStar)                          {                              childPositionableModel.DockWidth = new GridLength(1.0' GridUnitType.Star);                          }                      }                  }              }              else              {                  if (_model.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>())                  {                      for (int i = 0; i < _model.Children.Count; i++)                      {                          var childContainerModel = _model.Children[i] as ILayoutContainer;                          var childPositionableModel = _model.Children[i] as ILayoutPositionableElement;                            if (childContainerModel != null &&                              (childContainerModel.IsOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>() ||                               childContainerModel.ContainsChildOfType<LayoutDocumentPane' LayoutDocumentPaneGroup>()))                          {                              childPositionableModel.DockHeight = new GridLength(1.0' GridUnitType.Star);                          }                          else if (childPositionableModel != null && childPositionableModel.DockHeight.IsStar)                          {                              var childPositionableModelWidthActualSize = childPositionableModel as ILayoutPositionableElementWithActualSize;                                var heightToSet = Math.Max(childPositionableModelWidthActualSize.ActualHeight' childPositionableModel.DockMinHeight);                              heightToSet = Math.Min(heightToSet' ActualHeight / 2.0);                              heightToSet = Math.Max(heightToSet' childPositionableModel.DockMinHeight);                                childPositionableModel.DockHeight = new GridLength(heightToSet' GridUnitType.Pixel);                          }                      }                  }                  else                  {                      for (int i = 0; i < _model.Children.Count; i++)                      {                          var childPositionableModel = _model.Children[i] as ILayoutPositionableElement;                          if (!childPositionableModel.DockHeight.IsStar)                          {                              childPositionableModel.DockHeight = new GridLength(1.0' GridUnitType.Star);                          }                      }                  }              }
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: if (_side == AnchorSide.Right || _side == AnchorSide.Left)              {                  windowSize = new Size(                      managerSize.Width - 25.0 + splitter.ActualWidth'                      managerSize.Height);                    _resizerGhost.Width = splitter.ActualWidth;                  _resizerGhost.Height = windowSize.Height;                  ptTopLeftScreen.Offset(25' 0.0);              }              else              {                  windowSize = new Size(                      managerSize.Width'                      managerSize.Height - _model.AutoHideMinHeight - 25.0 + splitter.ActualHeight);                    _resizerGhost.Height = splitter.ActualHeight;                  _resizerGhost.Width = windowSize.Width;                  ptTopLeftScreen.Offset(0.0' 25.0);              }
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: if (_side == AnchorSide.Right || _side == AnchorSide.Left)              {                  windowSize = new Size(                      managerSize.Width - 25.0 + splitter.ActualWidth'                      managerSize.Height);                    _resizerGhost.Width = splitter.ActualWidth;                  _resizerGhost.Height = windowSize.Height;                  ptTopLeftScreen.Offset(25' 0.0);              }              else              {                  windowSize = new Size(                      managerSize.Width'                      managerSize.Height - _model.AutoHideMinHeight - 25.0 + splitter.ActualHeight);                    _resizerGhost.Height = splitter.ActualHeight;                  _resizerGhost.Width = windowSize.Width;                  ptTopLeftScreen.Offset(0.0' 25.0);              }
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: if (_side == AnchorSide.Right || _side == AnchorSide.Left)              {                  windowSize = new Size(                      managerSize.Width - 25.0 + splitter.ActualWidth'                      managerSize.Height);                    _resizerGhost.Width = splitter.ActualWidth;                  _resizerGhost.Height = windowSize.Height;                  ptTopLeftScreen.Offset(25' 0.0);              }              else              {                  windowSize = new Size(                      managerSize.Width'                      managerSize.Height - _model.AutoHideMinHeight - 25.0 + splitter.ActualHeight);                    _resizerGhost.Height = splitter.ActualHeight;                  _resizerGhost.Width = windowSize.Width;                  ptTopLeftScreen.Offset(0.0' 25.0);              }
Magic Number,AvalonDock.Controls,LayoutAutoHideWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAutoHideWindowControl.cs,ShowResizerOverlayWindow,The following statement contains a magic number: if (_side == AnchorSide.Right || _side == AnchorSide.Left)              {                  windowSize = new Size(                      managerSize.Width - 25.0 + splitter.ActualWidth'                      managerSize.Height);                    _resizerGhost.Width = splitter.ActualWidth;                  _resizerGhost.Height = windowSize.Height;                  ptTopLeftScreen.Offset(25' 0.0);              }              else              {                  windowSize = new Size(                      managerSize.Width'                      managerSize.Height - _model.AutoHideMinHeight - 25.0 + splitter.ActualHeight);                    _resizerGhost.Height = splitter.ActualHeight;                  _resizerGhost.Width = windowSize.Width;                  ptTopLeftScreen.Offset(0.0' 25.0);              }
Magic Number,Standard,HRESULT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,Make,The following statement contains a magic number: return new HRESULT((uint)((severe ? (1 << 31) : 0) | ((int)facility << 16) | code));
Magic Number,Standard,HRESULT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,Make,The following statement contains a magic number: return new HRESULT((uint)((severe ? (1 << 31) : 0) | ((int)facility << 16) | code));
Magic Number,Standard,HRESULT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\ErrorCodes.cs,GetFacility,The following statement contains a magic number: return (Facility)((errorCode >> 16) & 0x1fff);
Magic Number,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetModuleFileName,The following statement contains a magic number: while (true)              {                  int size = _GetModuleFileName(hModule' buffer' buffer.Capacity);                  if (size == 0)                  {                      HRESULT.ThrowLastError();                  }                    // GetModuleFileName returns nSize when it's truncated but does NOT set the last error.                  // MSDN documentation says this has changed in Windows 2000+.                  if (size == buffer.Capacity)                  {                      // Enlarge the buffer and try again.                      buffer.EnsureCapacity(buffer.Capacity * 2);                      continue;                  }                    return buffer.ToString();              }
Magic Number,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetWindowLongPtr,The following statement contains a magic number: if (8 == IntPtr.Size)              {                  ret = GetWindowLongPtr64(hwnd' nIndex);              }              else              {                  ret = new IntPtr(GetWindowLongPtr32(hwnd' nIndex));              }
Magic Number,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,SetClassLongPtr,The following statement contains a magic number: if (8 == IntPtr.Size)              {                  return SetClassLongPtr64(hwnd' nIndex' dwNewLong);              }
Magic Number,Standard,NativeMethods,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,SetWindowLongPtr,The following statement contains a magic number: if (8 == IntPtr.Size)              {                  return SetWindowLongPtr64(hwnd' nIndex' dwNewLong);              }
Magic Number,Standard,RECT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetHashCode,The following statement contains a magic number: return (_left << 16 | Utility.LOWORD(_right)) ^ (_top << 16 | Utility.LOWORD(_bottom));
Magic Number,Standard,RECT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\NativeMethods.cs,GetHashCode,The following statement contains a magic number: return (_left << 16 | Utility.LOWORD(_right)) ^ (_top << 16 | Utility.LOWORD(_bottom));
Magic Number,Standard,ManagedIStream,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\StreamHelper.cs,CopyTo,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,RGB,The following statement contains a magic number: return c.R | (c.G << 8) | (c.B << 16);
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,RGB,The following statement contains a magic number: return c.R | (c.G << 8) | (c.B << 16);
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,ColorFromArgbDword,The following statement contains a magic number: return Color.FromArgb(                  (byte)((color & 0xFF000000) >> 24)'                  (byte)((color & 0x00FF0000) >> 16)'                  (byte)((color & 0x0000FF00) >> 8)'                  (byte)((color & 0x000000FF) >> 0));
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,ColorFromArgbDword,The following statement contains a magic number: return Color.FromArgb(                  (byte)((color & 0xFF000000) >> 24)'                  (byte)((color & 0x00FF0000) >> 16)'                  (byte)((color & 0x0000FF00) >> 8)'                  (byte)((color & 0x000000FF) >> 0));
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,ColorFromArgbDword,The following statement contains a magic number: return Color.FromArgb(                  (byte)((color & 0xFF000000) >> 24)'                  (byte)((color & 0x00FF0000) >> 16)'                  (byte)((color & 0x0000FF00) >> 8)'                  (byte)((color & 0x000000FF) >> 0));
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,HIWORD,The following statement contains a magic number: return (short)(i >> 16);
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,AreStreamsEqual,The following statement contains a magic number: var leftBuffer = new byte[512];
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,AreStreamsEqual,The following statement contains a magic number: var rightBuffer = new byte[512];
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_MatchImage,The following statement contains a magic number: int score = 2 * _WeightedAbs(bpp' bitDepth' false) +                      _WeightedAbs(frame.PixelWidth' width' true) +                      _WeightedAbs(frame.PixelHeight' height' true);
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_WeightedAbs,The following statement contains a magic number: if (diff < 0)              {                  diff = (fPunish ? -2 : -1) * diff;              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_GetBestMatch,The following statement contains a magic number: for (int i = 0; i < frames.Count && bestScore != 0; ++i)              {                  int currentIconBitDepth = isBitmapIconDecoder ? frames[i].Thumbnail.Format.BitsPerPixel : frames[i].Format.BitsPerPixel;                    if (currentIconBitDepth == 0)                  {                      currentIconBitDepth = 8;                  }                    int score = _MatchImage(frames[i]' bitDepth' width' height' currentIconBitDepth);                  if (score < bestScore)                  {                      bestIndex = i;                      bestBpp = currentIconBitDepth;                      bestScore = score;                  }                  else if (score == bestScore)                  {                      // Tie breaker: choose the higher color depth.  If that fails' choose first one.                      if (bestBpp < currentIconBitDepth)                      {                          bestIndex = i;                          bestBpp = currentIconBitDepth;                      }                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,CopyStream,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlEncode,The following statement contains a magic number: if (needsEncoding)              {                  var buffer = new byte[bytes.Length + (unsafeCharCount * 2)];                  int writeIndex = 0;                  foreach (byte b in bytes)                  {                      if (_UrlEncodeIsSafe(b))                      {                          buffer[writeIndex++] = b;                      }                      else if (b == ' ')                      {                          buffer[writeIndex++] = (byte)'+';                      }                      else                      {                          buffer[writeIndex++] = (byte)'%';                          buffer[writeIndex++] = _IntToHex((b >> 4) & 0xF);                          buffer[writeIndex++] = _IntToHex(b & 0xF);                      }                  }                  bytes = buffer;                  Assert.AreEqual(buffer.Length' writeIndex);              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,UrlEncode,The following statement contains a magic number: if (needsEncoding)              {                  var buffer = new byte[bytes.Length + (unsafeCharCount * 2)];                  int writeIndex = 0;                  foreach (byte b in bytes)                  {                      if (_UrlEncodeIsSafe(b))                      {                          buffer[writeIndex++] = b;                      }                      else if (b == ' ')                      {                          buffer[writeIndex++] = (byte)'+';                      }                      else                      {                          buffer[writeIndex++] = (byte)'%';                          buffer[writeIndex++] = _IntToHex((b >> 4) & 0xF);                          buffer[writeIndex++] = _IntToHex(b & 0xF);                      }                  }                  bytes = buffer;                  Assert.AreEqual(buffer.Length' writeIndex);              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_IntToHex,The following statement contains a magic number: Assert.BoundedInteger(0' n' 16);
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_IntToHex,The following statement contains a magic number: if (n <= 9)              {                  return (byte)(n + '0');              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_IntToHex,The following statement contains a magic number: return (byte)(n - 10 + 'A');
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_HexToInt,The following statement contains a magic number: if (h >= 'a' && h <= 'f')              {                  return h - 'a' + 10;              }
Magic Number,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_HexToInt,The following statement contains a magic number: if (h >= 'A' && h <= 'F')              {                  return h - 'A' + 10;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_LegacyInitializeCaptionButtonLocation,The following statement contains a magic number: Rect captionRect = new Rect(0' 0' captionX * 3' captionY);
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant())              {                  case "LUNA":                      cornerRadius = new CornerRadius(6' 6' 0' 0);                      break;                  case "AERO":                      // Aero has two cases.  One with glass and one without...                      if (NativeMethods.DwmIsCompositionEnabled())                      {                          cornerRadius = new CornerRadius(8);                      }                      else                      {                          cornerRadius = new CornerRadius(6' 6' 0' 0);                      }                      break;                  case "CLASSIC":                  case "ZUNE":                  case "ROYALE":                  default:                      cornerRadius = new CornerRadius(0);                      break;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant())              {                  case "LUNA":                      cornerRadius = new CornerRadius(6' 6' 0' 0);                      break;                  case "AERO":                      // Aero has two cases.  One with glass and one without...                      if (NativeMethods.DwmIsCompositionEnabled())                      {                          cornerRadius = new CornerRadius(8);                      }                      else                      {                          cornerRadius = new CornerRadius(6' 6' 0' 0);                      }                      break;                  case "CLASSIC":                  case "ZUNE":                  case "ROYALE":                  default:                      cornerRadius = new CornerRadius(0);                      break;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant())              {                  case "LUNA":                      cornerRadius = new CornerRadius(6' 6' 0' 0);                      break;                  case "AERO":                      // Aero has two cases.  One with glass and one without...                      if (NativeMethods.DwmIsCompositionEnabled())                      {                          cornerRadius = new CornerRadius(8);                      }                      else                      {                          cornerRadius = new CornerRadius(6' 6' 0' 0);                      }                      break;                  case "CLASSIC":                  case "ZUNE":                  case "ROYALE":                  default:                      cornerRadius = new CornerRadius(0);                      break;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant())              {                  case "LUNA":                      cornerRadius = new CornerRadius(6' 6' 0' 0);                      break;                  case "AERO":                      // Aero has two cases.  One with glass and one without...                      if (NativeMethods.DwmIsCompositionEnabled())                      {                          cornerRadius = new CornerRadius(8);                      }                      else                      {                          cornerRadius = new CornerRadius(6' 6' 0' 0);                      }                      break;                  case "CLASSIC":                  case "ZUNE":                  case "ROYALE":                  default:                      cornerRadius = new CornerRadius(0);                      break;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant())              {                  case "LUNA":                      cornerRadius = new CornerRadius(6' 6' 0' 0);                      break;                  case "AERO":                      // Aero has two cases.  One with glass and one without...                      if (NativeMethods.DwmIsCompositionEnabled())                      {                          cornerRadius = new CornerRadius(8);                      }                      else                      {                          cornerRadius = new CornerRadius(6' 6' 0' 0);                      }                      break;                  case "CLASSIC":                  case "ZUNE":                  case "ROYALE":                  default:                      cornerRadius = new CornerRadius(0);                      break;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect(-16000' -16000' 100' 100)' ""' _WndProc);
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect(-16000' -16000' 100' 100)' ""' _WndProc);
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect(-16000' -16000' 100' 100)' ""' _WndProc);
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect(-16000' -16000' 100' 100)' ""' _WndProc);
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupWindows7Issues,The following statement contains a magic number: if (_blackGlassFixupAttemptCount > 5)              {                  // Don't keep trying if there's an endemic problem with this.                  return;              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupRestoreBounds,The following statement contains a magic number: if (_window.WindowState == WindowState.Maximized || _window.WindowState == WindowState.Minimized)              {                  // Old versions of WPF sometimes force their incorrect idea of the Window's location                  // on the Win32 restore bounds.  If we have reason to think this is the case' then                  // try to undo what WPF did after it has done its thing.                  if (_hasUserMovedWindow)                  {                      _hasUserMovedWindow = false;                      WINDOWPLACEMENT wp = NativeMethods.GetWindowPlacement(_hwnd);                        RECT adjustedDeviceRc = _GetAdjustedWindowRect(new RECT { Bottom = 100' Right = 100 });                      Point adjustedTopLeft = DpiHelper.DevicePixelsToLogical(                          new Point(                              wp.rcNormalPosition.Left - adjustedDeviceRc.Left'                              wp.rcNormalPosition.Top - adjustedDeviceRc.Top));                                            _window.Top = adjustedTopLeft.Y;                      _window.Left = adjustedTopLeft.X;                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_FixupRestoreBounds,The following statement contains a magic number: if (_window.WindowState == WindowState.Maximized || _window.WindowState == WindowState.Minimized)              {                  // Old versions of WPF sometimes force their incorrect idea of the Window's location                  // on the Win32 restore bounds.  If we have reason to think this is the case' then                  // try to undo what WPF did after it has done its thing.                  if (_hasUserMovedWindow)                  {                      _hasUserMovedWindow = false;                      WINDOWPLACEMENT wp = NativeMethods.GetWindowPlacement(_hwnd);                        RECT adjustedDeviceRc = _GetAdjustedWindowRect(new RECT { Bottom = 100' Right = 100 });                      Point adjustedTopLeft = DpiHelper.DevicePixelsToLogical(                          new Point(                              wp.rcNormalPosition.Left - adjustedDeviceRc.Left'                              wp.rcNormalPosition.Top - adjustedDeviceRc.Top));                                            _window.Top = adjustedTopLeft.Y;                      _window.Left = adjustedTopLeft.X;                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HandleSize,The following statement contains a magic number: const int SIZE_MAXIMIZED = 2;
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The following statement contains a magic number: if (mousePosition.Y >= windowPosition.Top && mousePosition.Y < windowPosition.Top + _chromeInfo.ResizeBorderThickness.Top + _chromeInfo.CaptionHeight)              {                  onResizeBorder = (mousePosition.Y < (windowPosition.Top + _chromeInfo.ResizeBorderThickness.Top));                  uRow = 0; // top (caption or resize border)              }              else if (mousePosition.Y < windowPosition.Bottom && mousePosition.Y >= windowPosition.Bottom - (int)_chromeInfo.ResizeBorderThickness.Bottom)              {                  uRow = 2; // bottom              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_HitTestNca,The following statement contains a magic number: if (mousePosition.X >= windowPosition.Left && mousePosition.X < windowPosition.Left + (int)_chromeInfo.ResizeBorderThickness.Left)              {                  uCol = 0; // left side              }              else if (mousePosition.X < windowPosition.Right && mousePosition.X >= windowPosition.Right - _chromeInfo.ResizeBorderThickness.Right)              {                  uCol = 2; // right side              }
Magic Number,AvalonDock.Converters,AnchorSideToAngleConverter,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Converters\AnchorSideToAngleConverter.cs,Convert,The following statement contains a magic number: if (side == AnchorSide.Left ||                  side == AnchorSide.Right)                  return 90.0;
Magic Number,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,AttachAnchorablesSource,The following statement contains a magic number: foreach (var anchorableContentToImport in listOfAnchorablesToImport)              {                  var anchorableToImport = new LayoutAnchorable()                  {                      Content = anchorableContentToImport                  };                    bool added = false;                  if (LayoutUpdateStrategy != null)                  {                      added = LayoutUpdateStrategy.BeforeInsertAnchorable(layout' anchorableToImport' anchorablePane);                  }                    if (!added)                  {                      if (anchorablePane == null)                      {                          var mainLayoutPanel = new LayoutPanel() { Orientation = Orientation.Horizontal };                          if (layout.RootPanel != null)                          {                              mainLayoutPanel.Children.Add(layout.RootPanel);                          }                            layout.RootPanel = mainLayoutPanel;                          anchorablePane = new LayoutAnchorablePane() { DockWidth = new GridLength(200.0' GridUnitType.Pixel) };                          mainLayoutPanel.Children.Add(anchorablePane);                      }                        anchorablePane.Children.Add(anchorableToImport);                      added = true;                  }                    if (LayoutUpdateStrategy != null)                      LayoutUpdateStrategy.AfterInsertAnchorable(layout' anchorableToImport);                      CreateAnchorableLayoutItem(anchorableToImport);                }
Magic Number,AvalonDock,DockingManager,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\DockingManager.cs,anchorablesSourceElementsChanged,The following statement contains a magic number: if (e.NewItems != null &&                  (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add ||                  e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace))              {                  if (e.NewItems != null)                  {                      LayoutAnchorablePane anchorablePane = null;                        if (Layout.ActiveContent != null)                      {                          //look for active content parent pane                          anchorablePane = Layout.ActiveContent.Parent as LayoutAnchorablePane;                      }                        if (anchorablePane == null)                      {                          //look for a pane on the right side                          anchorablePane = Layout.Descendents().OfType<LayoutAnchorablePane>().Where(pane => !pane.IsHostedInFloatingWindow && pane.GetSide() == AnchorSide.Right).FirstOrDefault();                      }                        if (anchorablePane == null)                      {                          //look for an available pane                          anchorablePane = Layout.Descendents().OfType<LayoutAnchorablePane>().FirstOrDefault();                      }                        _suspendLayoutItemCreation = true;                      foreach (var anchorableContentToImport in e.NewItems)                      {                          var anchorableToImport = new LayoutAnchorable()                          {                              Content = anchorableContentToImport                          };                            bool added = false;                          if (LayoutUpdateStrategy != null)                          {                              added = LayoutUpdateStrategy.BeforeInsertAnchorable(Layout' anchorableToImport' anchorablePane);                          }                            if (!added)                          {                              if (anchorablePane == null)                              {                                  var mainLayoutPanel = new LayoutPanel() { Orientation = Orientation.Horizontal };                                  if (Layout.RootPanel != null)                                  {                                      mainLayoutPanel.Children.Add(Layout.RootPanel);                                  }                                    Layout.RootPanel = mainLayoutPanel;                                  anchorablePane = new LayoutAnchorablePane() { DockWidth = new GridLength(200.0' GridUnitType.Pixel) };                                  mainLayoutPanel.Children.Add(anchorablePane);                              }                                anchorablePane.Children.Add(anchorableToImport);                              added = true;                          }                            if (LayoutUpdateStrategy != null)                          {                              LayoutUpdateStrategy.AfterInsertAnchorable(Layout' anchorableToImport);                          }                            var root = anchorableToImport.Root;                            if (root != null && root.Manager == this)                          {                              CreateAnchorableLayoutItem(anchorableToImport);                          }                        }                      _suspendLayoutItemCreation = false;                  }              }
Magic Number,AvalonDock,Win32Helper,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,MakeLParam,The following statement contains a magic number: return (int) ((HiWord << 16) | (LoWord & 0xffff));
Magic Number,AvalonDock,Win32Helper,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,SetOwner,The following statement contains a magic number: SetWindowLong(                  childHandle'                  -8' // GWL_HWNDPARENT                  ownerHandle.ToInt32());
Magic Number,AvalonDock,Win32Helper,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,GetOwner,The following statement contains a magic number: return new IntPtr(GetWindowLong(childHandle' -8));
Magic Number,AvalonDock,RECT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,GetHashCode,The following statement contains a magic number: return Left ^ ((Top << 13) | (Top >> 0x13)) ^ ((Width << 0x1a) | (Width >> 6)) ^ ((Height << 7) | (Height >> 0x19));
Magic Number,AvalonDock,RECT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,GetHashCode,The following statement contains a magic number: return Left ^ ((Top << 13) | (Top >> 0x13)) ^ ((Width << 0x1a) | (Width >> 6)) ^ ((Height << 7) | (Height >> 0x19));
Magic Number,AvalonDock,RECT,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Win32Helper.cs,GetHashCode,The following statement contains a magic number: return Left ^ ((Top << 13) | (Top >> 0x13)) ^ ((Width << 0x1a) | (Width >> 6)) ^ ((Height << 7) | (Height >> 0x19));
Magic Number,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,InternalDock,The following statement contains a magic number: if (!added)              {                  if (anchorablePane == null)                  {                      var mainLayoutPanel = new LayoutPanel() { Orientation = Orientation.Horizontal };                      if (root.RootPanel != null)                      {                          mainLayoutPanel.Children.Add(root.RootPanel);                      }                        root.RootPanel = mainLayoutPanel;                      anchorablePane = new LayoutAnchorablePane() { DockWidth = new GridLength(200.0' GridUnitType.Pixel) };                      mainLayoutPanel.Children.Add(anchorablePane);                  }                    anchorablePane.Children.Add(this);                  added = true;              }
Magic Number,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,WriteXml,The following statement contains a magic number: if (AutoHideMinWidth != 25.0)                  writer.WriteAttributeString("AutoHideMinWidth"' AutoHideMinWidth.ToString(CultureInfo.InvariantCulture));
Magic Number,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,WriteXml,The following statement contains a magic number: if (AutoHideMinHeight != 25.0)                  writer.WriteAttributeString("AutoHideMinHeight"' AutoHideMinHeight.ToString(CultureInfo.InvariantCulture));
Magic Number,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutAnchorableFloatingWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorableFloatingWindow.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutAnchorablePane,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorablePane.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutAnchorablePaneGroup,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorablePaneGroup.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutDocument,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutDocument.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutDocumentFloatingWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutDocumentFloatingWindow.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutDocumentPane,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutDocumentPane.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutDocumentPaneGroup,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutDocumentPaneGroup.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutElement,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutElement.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new String(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutPanel,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutPanel.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutPositionableGroup<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutPositionableGroup.cs,WriteXml,The following statement contains a magic number: if (DockMinWidth != 25.0)                  writer.WriteAttributeString("DocMinWidth"' DockMinWidth.ToString(CultureInfo.InvariantCulture));
Magic Number,AvalonDock.Layout,LayoutPositionableGroup<T>,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutPositionableGroup.cs,WriteXml,The following statement contains a magic number: if (DockMinHeight != 25.0)                  writer.WriteAttributeString("DockMinHeight"' DockMinHeight.ToString(CultureInfo.InvariantCulture));
Magic Number,AvalonDock.Layout,LayoutRoot,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutRoot,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Magic Number,AvalonDock.Layout,LayoutRoot,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutRoot.cs,ConsoleDump,The following statement contains a magic number: System.Diagnostics.Debug.Write(new string(' '' tab * 4));
Missing Default,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.AnchorablePaneDockBottom:                      #region DropTargetType.AnchorablePaneDockBottom                      {                          var parentModel = targetModel.Parent as ILayoutGroup;                          var parentModelOrientable = targetModel.Parent as ILayoutOrientableGroup;                          int insertToIndex = parentModel.IndexOfChild(targetModel);                            if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Vertical &&                              parentModel.ChildrenCount == 1)                              parentModelOrientable.Orientation = System.Windows.Controls.Orientation.Vertical;                            if (parentModelOrientable.Orientation == System.Windows.Controls.Orientation.Vertical)                          {                              var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                              if (layoutAnchorablePaneGroup != null &&                                  (layoutAnchorablePaneGroup.Children.Count == 1 ||                                      layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical))                              {                                  var anchorablesToMove = layoutAnchorablePaneGroup.Children.ToArray();                                  for (int i = 0; i < anchorablesToMove.Length; i++)                                      parentModel.InsertChildAt(insertToIndex + 1 + i' anchorablesToMove[i]);                              }                              else                                  parentModel.InsertChildAt(insertToIndex + 1' floatingWindow.RootPanel);                          }                          else                          {                              var targetModelAsPositionableElement = targetModel as ILayoutPositionableElement;                              var newOrientedPanel = new LayoutAnchorablePaneGroup()                              {                                  Orientation = System.Windows.Controls.Orientation.Vertical'                                  DockWidth = targetModelAsPositionableElement.DockWidth'                                  DockHeight = targetModelAsPositionableElement.DockHeight'                              };                                parentModel.InsertChildAt(insertToIndex' newOrientedPanel);                              newOrientedPanel.Children.Add(targetModel);                              newOrientedPanel.Children.Add(floatingWindow.RootPanel);                            }                      }                      break;                      #endregion                  case DropTargetType.AnchorablePaneDockTop:                      #region DropTargetType.AnchorablePaneDockTop                      {                          var parentModel = targetModel.Parent as ILayoutGroup;                          var parentModelOrientable = targetModel.Parent as ILayoutOrientableGroup;                          int insertToIndex = parentModel.IndexOfChild(targetModel);                            if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Vertical &&                              parentModel.ChildrenCount == 1)                              parentModelOrientable.Orientation = System.Windows.Controls.Orientation.Vertical;                            if (parentModelOrientable.Orientation == System.Windows.Controls.Orientation.Vertical)                          {                              var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                              if (layoutAnchorablePaneGroup != null &&                                  (layoutAnchorablePaneGroup.Children.Count == 1 ||                                      layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical))                              {                                  var anchorablesToMove = layoutAnchorablePaneGroup.Children.ToArray();                                  for (int i = 0; i < anchorablesToMove.Length; i++)                                      parentModel.InsertChildAt(insertToIndex + i' anchorablesToMove[i]);                              }                              else                                  parentModel.InsertChildAt(insertToIndex' floatingWindow.RootPanel);                          }                          else                          {                              var targetModelAsPositionableElement = targetModel as ILayoutPositionableElement;                              var newOrientedPanel = new LayoutAnchorablePaneGroup()                              {                                  Orientation = System.Windows.Controls.Orientation.Vertical'                                  DockWidth = targetModelAsPositionableElement.DockWidth'                                  DockHeight = targetModelAsPositionableElement.DockHeight'                              };                                parentModel.InsertChildAt(insertToIndex' newOrientedPanel);                              //the floating window must be added after the target modal as it could be raise a CollectGarbage call                              newOrientedPanel.Children.Add(targetModel);                              newOrientedPanel.Children.Insert(0' floatingWindow.RootPanel);                            }                      }                      break;                      #endregion                  case DropTargetType.AnchorablePaneDockLeft:                      #region DropTargetType.AnchorablePaneDockLeft                      {                          var parentModel = targetModel.Parent as ILayoutGroup;                          var parentModelOrientable = targetModel.Parent as ILayoutOrientableGroup;                          int insertToIndex = parentModel.IndexOfChild(targetModel);                            if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Horizontal &&                              parentModel.ChildrenCount == 1)                              parentModelOrientable.Orientation = System.Windows.Controls.Orientation.Horizontal;                            if (parentModelOrientable.Orientation == System.Windows.Controls.Orientation.Horizontal)                          {                              var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                              if (layoutAnchorablePaneGroup != null &&                                  (layoutAnchorablePaneGroup.Children.Count == 1 ||                                      layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal))                              {                                  var anchorablesToMove = layoutAnchorablePaneGroup.Children.ToArray();                                  for (int i = 0; i < anchorablesToMove.Length; i++)                                      parentModel.InsertChildAt(insertToIndex + i' anchorablesToMove[i]);                              }                              else                                  parentModel.InsertChildAt(insertToIndex' floatingWindow.RootPanel);                          }                          else                          {                              var targetModelAsPositionableElement = targetModel as ILayoutPositionableElement;                              var newOrientedPanel = new LayoutAnchorablePaneGroup()                              {                                  Orientation = System.Windows.Controls.Orientation.Horizontal'                                  DockWidth = targetModelAsPositionableElement.DockWidth'                                  DockHeight = targetModelAsPositionableElement.DockHeight'                              };                                parentModel.InsertChildAt(insertToIndex' newOrientedPanel);                              //the floating window must be added after the target modal as it could be raise a CollectGarbage call                              newOrientedPanel.Children.Add(targetModel);                              newOrientedPanel.Children.Insert(0' floatingWindow.RootPanel);                            }                      }                      break;                      #endregion                  case DropTargetType.AnchorablePaneDockRight:                      #region DropTargetType.AnchorablePaneDockRight                      {                          var parentModel = targetModel.Parent as ILayoutGroup;                          var parentModelOrientable = targetModel.Parent as ILayoutOrientableGroup;                          int insertToIndex = parentModel.IndexOfChild(targetModel);                            if (parentModelOrientable.Orientation != System.Windows.Controls.Orientation.Horizontal &&                              parentModel.ChildrenCount == 1)                              parentModelOrientable.Orientation = System.Windows.Controls.Orientation.Horizontal;                            if (parentModelOrientable.Orientation == System.Windows.Controls.Orientation.Horizontal)                          {                              var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                              if (layoutAnchorablePaneGroup != null &&                                  (layoutAnchorablePaneGroup.Children.Count == 1 ||                                      layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal))                              {                                  var anchorablesToMove = layoutAnchorablePaneGroup.Children.ToArray();                                  for (int i = 0; i < anchorablesToMove.Length; i++)                                      parentModel.InsertChildAt(insertToIndex + 1 + i' anchorablesToMove[i]);                              }                              else                                  parentModel.InsertChildAt(insertToIndex + 1' floatingWindow.RootPanel);                          }                          else                          {                              var targetModelAsPositionableElement = targetModel as ILayoutPositionableElement;                              var newOrientedPanel = new LayoutAnchorablePaneGroup()                              {                                  Orientation = System.Windows.Controls.Orientation.Horizontal'                                  DockWidth = targetModelAsPositionableElement.DockWidth'                                  DockHeight = targetModelAsPositionableElement.DockHeight'                              };                                parentModel.InsertChildAt(insertToIndex' newOrientedPanel);                              newOrientedPanel.Children.Add(targetModel);                              newOrientedPanel.Children.Add(floatingWindow.RootPanel);                            }                      }                      break;                      #endregion                      case DropTargetType.AnchorablePaneDockInside:                      #region DropTargetType.AnchorablePaneDockInside                      {                          var paneModel = targetModel as LayoutAnchorablePane;                          var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                            int i = _tabIndex == -1 ? 0 : _tabIndex;                          foreach (var anchorableToImport in                               layoutAnchorablePaneGroup.Descendents().OfType<LayoutAnchorable>().ToArray())                          {                              paneModel.Children.Insert(i' anchorableToImport);                              i++;                          }                        }                      break;                      #endregion                  }
Missing Default,AvalonDock.Controls,AnchorablePaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\AnchorablePaneDropTarget.cs,GetPreviewPath,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.AnchorablePaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Height /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                            return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.AnchorablePaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                              var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.TopLeft;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Top) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.TopRight });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }              }
Missing Default,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,Drop,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.DocumentPaneDockAsAnchorableBottom:                      #region DropTargetType.DocumentPaneDockAsAnchorableBottom                      {                          if (parentGroupPanel != null &&                              parentGroupPanel.ChildrenCount == 1)                              parentGroupPanel.Orientation = System.Windows.Controls.Orientation.Vertical;                            if (parentGroupPanel != null &&                              parentGroupPanel.Orientation == System.Windows.Controls.Orientation.Vertical)                          {                              parentGroupPanel.Children.Insert(                                  parentGroupPanel.IndexOfChild(parentGroup != null ? parentGroup : targetModel) + 1'                                  floatingWindow.RootPanel);                          }                          else if (parentGroupPanel != null)                          {                              var newParentPanel = new LayoutPanel() { Orientation = System.Windows.Controls.Orientation.Vertical };                              parentGroupPanel.ReplaceChild(parentGroup != null ? parentGroup : targetModel' newParentPanel);                              newParentPanel.Children.Add(parentGroup != null ? parentGroup : targetModel);                              newParentPanel.Children.Add(floatingWindow.RootPanel);                          }                          else                          {                              throw new NotImplementedException();                          }                          }                      break;                      #endregion                  case DropTargetType.DocumentPaneDockAsAnchorableTop:                      #region DropTargetType.DocumentPaneDockAsAnchorableTop                      {                          if (parentGroupPanel != null &&                              parentGroupPanel.ChildrenCount == 1)                              parentGroupPanel.Orientation = System.Windows.Controls.Orientation.Vertical;                            if (parentGroupPanel != null &&                              parentGroupPanel.Orientation == System.Windows.Controls.Orientation.Vertical)                          {                              parentGroupPanel.Children.Insert(                                  parentGroupPanel.IndexOfChild(parentGroup != null ? parentGroup : targetModel)'                                  floatingWindow.RootPanel);                          }                          else if (parentGroupPanel != null)                          {                              var newParentPanel = new LayoutPanel() { Orientation = System.Windows.Controls.Orientation.Vertical };                              parentGroupPanel.ReplaceChild(parentGroup != null ? parentGroup : targetModel' newParentPanel);                              newParentPanel.Children.Add(parentGroup != null ? parentGroup : targetModel);                              newParentPanel.Children.Insert(0' floatingWindow.RootPanel);                          }                          else                          {                              throw new NotImplementedException();                          }                        }                      break;                      #endregion                  case DropTargetType.DocumentPaneDockAsAnchorableLeft:                      #region DropTargetType.DocumentPaneDockAsAnchorableLeft                      {                          if (parentGroupPanel != null &&                              parentGroupPanel.ChildrenCount == 1)                              parentGroupPanel.Orientation = System.Windows.Controls.Orientation.Horizontal;                            if (parentGroupPanel != null &&                              parentGroupPanel.Orientation == System.Windows.Controls.Orientation.Horizontal)                          {                              parentGroupPanel.Children.Insert(                                  parentGroupPanel.IndexOfChild(parentGroup != null ? parentGroup : targetModel)'                                  floatingWindow.RootPanel);                          }                          else if (parentGroupPanel != null)                          {                              var newParentPanel = new LayoutPanel() { Orientation = System.Windows.Controls.Orientation.Horizontal };                              parentGroupPanel.ReplaceChild(parentGroup != null ? parentGroup : targetModel' newParentPanel);                              newParentPanel.Children.Add(parentGroup != null ? parentGroup : targetModel);                              newParentPanel.Children.Insert(0' floatingWindow.RootPanel);                          }                          else                          {                              throw new NotImplementedException();                          }                      }                      break;                      #endregion                  case DropTargetType.DocumentPaneDockAsAnchorableRight:                      #region DropTargetType.DocumentPaneDockAsAnchorableRight                      {                          if (parentGroupPanel != null &&                              parentGroupPanel.ChildrenCount == 1)                              parentGroupPanel.Orientation = System.Windows.Controls.Orientation.Horizontal;                            if (parentGroupPanel != null &&                              parentGroupPanel.Orientation == System.Windows.Controls.Orientation.Horizontal)                          {                              parentGroupPanel.Children.Insert(                                  parentGroupPanel.IndexOfChild(parentGroup != null ? parentGroup : targetModel) + 1'                                  floatingWindow.RootPanel);                          }                          else if (parentGroupPanel != null)                          {                              var newParentPanel = new LayoutPanel() { Orientation = System.Windows.Controls.Orientation.Horizontal };                              parentGroupPanel.ReplaceChild(parentGroup != null ? parentGroup : targetModel' newParentPanel);                              newParentPanel.Children.Add(parentGroup != null ? parentGroup : targetModel);                              newParentPanel.Children.Add(floatingWindow.RootPanel);                          }                          else                          {                              throw new NotImplementedException();                          }                      }                      break;                      #endregion              }
Missing Default,AvalonDock.Controls,DocumentPaneDropAsAnchorableTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropAsAnchorableTarget.cs,GetPreviewPath,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.DocumentPaneDockAsAnchorableBottom:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height - targetScreenRect.Height / 3.0);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableTop:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableRight:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width - targetScreenRect.Width / 3.0' 0.0);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockAsAnchorableLeft:                      {                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 3.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Missing Default,AvalonDock.Controls,DocumentPaneGroupDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneGroupDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.DocumentPaneGroupDockInside:                      #region DropTargetType.DocumentPaneGroupDockInside                      {                          var paneGroupModel = targetModel as LayoutDocumentPaneGroup;                          var paneModel = paneGroupModel.Children[0] as LayoutDocumentPane;                          var sourceModel = floatingWindow.RootDocument;                            paneModel.Children.Insert(0' sourceModel);                      }                      break;                      #endregion              }
Missing Default,AvalonDock.Controls,DocumentPaneGroupDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneGroupDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.DocumentPaneGroupDockInside:                      #region DropTargetType.DocumentPaneGroupDockInside                      {                          var paneGroupModel = targetModel as LayoutDocumentPaneGroup;                          var paneModel = paneGroupModel.Children[0] as LayoutDocumentPane;                          var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                            int i = 0;                          foreach (var anchorableToImport in layoutAnchorablePaneGroup.Descendents().OfType<LayoutAnchorable>().ToArray())                          {                              paneModel.Children.Insert(i' anchorableToImport);                              i++;                          }                      }                      break;                      #endregion              }
Missing Default,AvalonDock.Controls,DocumentPaneGroupDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneGroupDropTarget.cs,GetPreviewPath,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.DocumentPaneGroupDockInside:                      #region DropTargetType.DocumentPaneGroupDockInside                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            return new RectangleGeometry(targetScreenRect);                      }                       #endregion              }
Missing Default,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.DockingManagerDockLeft:                      #region DropTargetType.DockingManagerDockLeft                      {                          if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Horizontal &&                              _manager.Layout.RootPanel.Children.Count == 1)                              _manager.Layout.RootPanel.Orientation = System.Windows.Controls.Orientation.Horizontal;                            if (_manager.Layout.RootPanel.Orientation == System.Windows.Controls.Orientation.Horizontal)                          {                              var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                              if (layoutAnchorablePaneGroup != null &&                                  layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal)                              {                                  var childrenToTransfer = layoutAnchorablePaneGroup.Children.ToArray();                                  for (int i = 0; i < childrenToTransfer.Length; i++)                                      _manager.Layout.RootPanel.Children.Insert(i' childrenToTransfer[i]);                              }                              else                                  _manager.Layout.RootPanel.Children.Insert(0' floatingWindow.RootPanel);                          }                          else                          {                              var newOrientedPanel = new LayoutPanel()                              {                                  Orientation = System.Windows.Controls.Orientation.Horizontal                              };                                newOrientedPanel.Children.Add(floatingWindow.RootPanel);                              newOrientedPanel.Children.Add(_manager.Layout.RootPanel);                                _manager.Layout.RootPanel = newOrientedPanel;                          }                      }                      break;                      #endregion                  case DropTargetType.DockingManagerDockRight:                      #region DropTargetType.DockingManagerDockRight                      {                          if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Horizontal &&                              _manager.Layout.RootPanel.Children.Count == 1)                              _manager.Layout.RootPanel.Orientation = System.Windows.Controls.Orientation.Horizontal;                            if (_manager.Layout.RootPanel.Orientation == System.Windows.Controls.Orientation.Horizontal)                          {                              var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                              if (layoutAnchorablePaneGroup != null &&                                  layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Horizontal)                              {                                  var childrenToTransfer = layoutAnchorablePaneGroup.Children.ToArray();                                  for (int i = 0; i < childrenToTransfer.Length; i++)                                      _manager.Layout.RootPanel.Children.Add(childrenToTransfer[i]);                              }                              else                                  _manager.Layout.RootPanel.Children.Add(floatingWindow.RootPanel);                          }                          else                          {                              var newOrientedPanel = new LayoutPanel()                              {                                  Orientation = System.Windows.Controls.Orientation.Horizontal                              };                                newOrientedPanel.Children.Add(_manager.Layout.RootPanel);                              newOrientedPanel.Children.Add(floatingWindow.RootPanel);                                _manager.Layout.RootPanel = newOrientedPanel;                          }                      }                      break;                      #endregion                  case DropTargetType.DockingManagerDockTop:                      #region DropTargetType.DockingManagerDockTop                      {                          if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Vertical &&                              _manager.Layout.RootPanel.Children.Count == 1)                              _manager.Layout.RootPanel.Orientation = System.Windows.Controls.Orientation.Vertical;                            if (_manager.Layout.RootPanel.Orientation == System.Windows.Controls.Orientation.Vertical)                          {                              var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                              if (layoutAnchorablePaneGroup != null &&                                  layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical)                              {                                  var childrenToTransfer = layoutAnchorablePaneGroup.Children.ToArray();                                  for (int i = 0; i < childrenToTransfer.Length; i++)                                      _manager.Layout.RootPanel.Children.Insert(i' childrenToTransfer[i]);                              }                              else                                  _manager.Layout.RootPanel.Children.Insert(0' floatingWindow.RootPanel);                          }                          else                          {                              var newOrientedPanel = new LayoutPanel()                              {                                  Orientation = System.Windows.Controls.Orientation.Vertical                              };                                newOrientedPanel.Children.Add(floatingWindow.RootPanel);                              newOrientedPanel.Children.Add(_manager.Layout.RootPanel);                                _manager.Layout.RootPanel = newOrientedPanel;                          }                      }                      break;                      #endregion                  case DropTargetType.DockingManagerDockBottom:                      #region DropTargetType.DockingManagerDockBottom                      {                          if (_manager.Layout.RootPanel.Orientation != System.Windows.Controls.Orientation.Vertical &&                              _manager.Layout.RootPanel.Children.Count == 1)                              _manager.Layout.RootPanel.Orientation = System.Windows.Controls.Orientation.Vertical;                            if (_manager.Layout.RootPanel.Orientation == System.Windows.Controls.Orientation.Vertical)                          {                              var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                              if (layoutAnchorablePaneGroup != null &&                                  layoutAnchorablePaneGroup.Orientation == System.Windows.Controls.Orientation.Vertical)                              {                                  var childrenToTransfer = layoutAnchorablePaneGroup.Children.ToArray();                                  for (int i = 0; i < childrenToTransfer.Length; i++)                                      _manager.Layout.RootPanel.Children.Add(childrenToTransfer[i]);                                }                              else                                  _manager.Layout.RootPanel.Children.Add(floatingWindow.RootPanel);                          }                          else                          {                              var newOrientedPanel = new LayoutPanel()                              {                                  Orientation = System.Windows.Controls.Orientation.Vertical                              };                                newOrientedPanel.Children.Add(_manager.Layout.RootPanel);                              newOrientedPanel.Children.Add(floatingWindow.RootPanel);                                _manager.Layout.RootPanel = newOrientedPanel;                          }                      }                      break;                      #endregion              }
Missing Default,AvalonDock.Controls,DockingManagerDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DockingManagerDropTarget.cs,GetPreviewPath,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.DockingManagerDockLeft:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockTop:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Top - overlayWindow.Top'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockRight:                      {                          var desideredWidth = layoutAnchorablePane.DockWidth.IsAbsolute ? layoutAnchorablePane.DockWidth.Value : layoutAnchorablePaneWithActualSize.ActualWidth;                          var previewBoxRect = new Rect(                              targetScreenRect.Right - overlayWindow.Left - Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Top - overlayWindow.Top'                              Math.Min(desideredWidth' targetScreenRect.Width / 2.0)'                              targetScreenRect.Height);                            return new RectangleGeometry(previewBoxRect);                      }                  case DropTargetType.DockingManagerDockBottom:                      {                          var desideredHeight = layoutAnchorablePane.DockHeight.IsAbsolute ? layoutAnchorablePane.DockHeight.Value : layoutAnchorablePaneWithActualSize.ActualHeight;                          var previewBoxRect = new Rect(                              targetScreenRect.Left - overlayWindow.Left'                              targetScreenRect.Bottom - overlayWindow.Top - Math.Min(desideredHeight' targetScreenRect.Height / 2.0)'                              targetScreenRect.Width'                              Math.Min(desideredHeight' targetScreenRect.Height / 2.0));                            return new RectangleGeometry(previewBoxRect);                      }              }
Missing Default,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.DocumentPaneDockBottom:                      #region DropTargetType.DocumentPaneDockBottom                      {                          var newLayoutDocumentPane = new LayoutDocumentPane(floatingWindow.RootDocument);                          var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;                            if (parentModel == null)                          {                              var parentContainer = targetModel.Parent as ILayoutContainer;                              var newParentModel = new LayoutDocumentPaneGroup() { Orientation = System.Windows.Controls.Orientation.Vertical};                              parentContainer.ReplaceChild(targetModel' newParentModel);                              newParentModel.Children.Add(targetModel as LayoutDocumentPane);                              newParentModel.Children.Add(newLayoutDocumentPane);                          }                          else                          {                              var manager = parentModel.Root.Manager;                              if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Vertical)                              {                                  parentModel.Orientation = System.Windows.Controls.Orientation.Vertical;                                  int targetPaneIndex = parentModel.IndexOfChild(targetModel);                                  parentModel.Children.Insert(targetPaneIndex + 1' newLayoutDocumentPane);                              }                              else                              {                                  LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup();                                  newChildGroup.Orientation = System.Windows.Controls.Orientation.Vertical;                                  parentModel.ReplaceChild(targetModel' newChildGroup);                                  newChildGroup.Children.Add(targetModel);                                  newChildGroup.Children.Add(newLayoutDocumentPane);                              }                            }                      }                      break;                      #endregion                  case DropTargetType.DocumentPaneDockTop:                      #region DropTargetType.DocumentPaneDockTop                      {                          var newLayoutDocumentPane = new LayoutDocumentPane(floatingWindow.RootDocument);                          var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;                            if (parentModel == null)                          {                              var parentContainer = targetModel.Parent as ILayoutContainer;                              var newParentModel = new LayoutDocumentPaneGroup() { Orientation = System.Windows.Controls.Orientation.Vertical };                              parentContainer.ReplaceChild(targetModel' newParentModel);                              newParentModel.Children.Add(targetModel as LayoutDocumentPane);                              newParentModel.Children.Insert(0' newLayoutDocumentPane);                          }                          else                          {                              var manager = parentModel.Root.Manager;                              if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Vertical)                              {                                  parentModel.Orientation = System.Windows.Controls.Orientation.Vertical;                                  int targetPaneIndex = parentModel.IndexOfChild(targetModel);                                  parentModel.Children.Insert(targetPaneIndex' newLayoutDocumentPane);                              }                              else                              {                                  LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup();                                  newChildGroup.Orientation = System.Windows.Controls.Orientation.Vertical;                                  parentModel.ReplaceChild(targetModel' newChildGroup);                                  newChildGroup.Children.Add(newLayoutDocumentPane);                                  newChildGroup.Children.Add(targetModel);                              }                            }                      }                      break;                      #endregion                  case DropTargetType.DocumentPaneDockLeft:                      #region DropTargetType.DocumentPaneDockLeft                      {                          var newLayoutDocumentPane = new LayoutDocumentPane(floatingWindow.RootDocument);                          var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;                            if (parentModel == null)                          {                              var parentContainer = targetModel.Parent as ILayoutContainer;                              var newParentModel = new LayoutDocumentPaneGroup() { Orientation = System.Windows.Controls.Orientation.Horizontal };                              parentContainer.ReplaceChild(targetModel' newParentModel);                              newParentModel.Children.Add(targetModel);                              newParentModel.Children.Insert(0' newLayoutDocumentPane);                          }                          else                          {                              var manager = parentModel.Root.Manager;                              if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Horizontal)                              {                                  parentModel.Orientation = System.Windows.Controls.Orientation.Horizontal;                                  int targetPaneIndex = parentModel.IndexOfChild(targetModel);                                  parentModel.Children.Insert(targetPaneIndex' newLayoutDocumentPane);                              }                              else                              {                                  LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup();                                  newChildGroup.Orientation = System.Windows.Controls.Orientation.Horizontal;                                  parentModel.ReplaceChild(targetModel' newChildGroup);                                  newChildGroup.Children.Add(newLayoutDocumentPane);                                  newChildGroup.Children.Add(targetModel);                              }                          }                      }                      break;                      #endregion                  case DropTargetType.DocumentPaneDockRight:                      #region DropTargetType.DocumentPaneDockRight                      {                          var newLayoutDocumentPane = new LayoutDocumentPane(floatingWindow.RootDocument);                          var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;                            if (parentModel == null)                          {                              var parentContainer = targetModel.Parent as ILayoutContainer;                              var newParentModel = new LayoutDocumentPaneGroup() { Orientation = System.Windows.Controls.Orientation.Horizontal };                              parentContainer.ReplaceChild(targetModel' newParentModel);                              newParentModel.Children.Add(targetModel as LayoutDocumentPane);                              newParentModel.Children.Add(newLayoutDocumentPane);                          }                          else                          {                              var manager = parentModel.Root.Manager;                              if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Horizontal)                              {                                  parentModel.Orientation = System.Windows.Controls.Orientation.Horizontal;                                  int targetPaneIndex = parentModel.IndexOfChild(targetModel);                                  parentModel.Children.Insert(targetPaneIndex + 1' newLayoutDocumentPane);                              }                              else                              {                                  LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup();                                  newChildGroup.Orientation = System.Windows.Controls.Orientation.Horizontal;                                  parentModel.ReplaceChild(targetModel' newChildGroup);                                  newChildGroup.Children.Add(targetModel);                                  newChildGroup.Children.Add(newLayoutDocumentPane);                              }                            }                      }                      break;                      #endregion                    case DropTargetType.DocumentPaneDockInside:                      #region DropTargetType.DocumentPaneDockInside                      {                          var paneModel = targetModel as LayoutDocumentPane;                          var sourceModel = floatingWindow.RootDocument;                            int i = _tabIndex == -1 ? 0 : _tabIndex;                          sourceModel.IsActive = false;                          paneModel.Children.Insert(i' sourceModel);                          sourceModel.IsActive = true;                      }                      break;                      #endregion                  }
Missing Default,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,Drop,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.DocumentPaneDockBottom:                      #region DropTargetType.DocumentPaneDockBottom                      {                          var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;                          var newLayoutDocumentPane = new LayoutDocumentPane();                            if (parentModel == null)                          {                              var parentContainer = targetModel.Parent as ILayoutContainer;                              var newParentModel = new LayoutDocumentPaneGroup() { Orientation = System.Windows.Controls.Orientation.Vertical };                              parentContainer.ReplaceChild(targetModel' newParentModel);                              newParentModel.Children.Add(targetModel as LayoutDocumentPane);                              newParentModel.Children.Add(newLayoutDocumentPane);                          }                          else                          {                              var manager = parentModel.Root.Manager;                              if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Vertical)                              {                                  parentModel.Orientation = System.Windows.Controls.Orientation.Vertical;                                  int targetPaneIndex = parentModel.IndexOfChild(targetModel);                                  parentModel.Children.Insert(targetPaneIndex + 1' newLayoutDocumentPane);                              }                              else                              {                                  LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup();                                  newChildGroup.Orientation = System.Windows.Controls.Orientation.Vertical;                                  parentModel.ReplaceChild(targetModel' newChildGroup);                                  newChildGroup.Children.Add(targetModel);                                  newChildGroup.Children.Add(newLayoutDocumentPane);                              }                          }                            foreach (var cntToTransfer in floatingWindow.RootPanel.Descendents().OfType<LayoutAnchorable>().ToArray())                              newLayoutDocumentPane.Children.Add(cntToTransfer);                        }                      break;                      #endregion                  case DropTargetType.DocumentPaneDockTop:                      #region DropTargetType.DocumentPaneDockTop                      {                          var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;                          var newLayoutDocumentPane = new LayoutDocumentPane();                            if (parentModel == null)                          {                              var parentContainer = targetModel.Parent as ILayoutContainer;                              var newParentModel = new LayoutDocumentPaneGroup() { Orientation = System.Windows.Controls.Orientation.Vertical };                              parentContainer.ReplaceChild(targetModel' newParentModel);                              newParentModel.Children.Add(newLayoutDocumentPane);                              newParentModel.Children.Add(targetModel as LayoutDocumentPane);                          }                          else                          {                              var manager = parentModel.Root.Manager;                              if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Vertical)                              {                                  parentModel.Orientation = System.Windows.Controls.Orientation.Vertical;                                  int targetPaneIndex = parentModel.IndexOfChild(targetModel);                                  parentModel.Children.Insert(targetPaneIndex' newLayoutDocumentPane);                              }                              else                              {                                  LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup();                                  newChildGroup.Orientation = System.Windows.Controls.Orientation.Vertical;                                  parentModel.ReplaceChild(targetModel' newChildGroup);                                  newChildGroup.Children.Add(newLayoutDocumentPane);                                  newChildGroup.Children.Add(targetModel);                              }                          }                            foreach (var cntToTransfer in floatingWindow.RootPanel.Descendents().OfType<LayoutAnchorable>().ToArray())                              newLayoutDocumentPane.Children.Add(cntToTransfer);                        }                      break;                      #endregion                  case DropTargetType.DocumentPaneDockLeft:                      #region DropTargetType.DocumentPaneDockLeft                      {                          var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;                          var newLayoutDocumentPane = new LayoutDocumentPane();                            if (parentModel == null)                          {                              var parentContainer = targetModel.Parent as ILayoutContainer;                              var newParentModel = new LayoutDocumentPaneGroup() { Orientation = System.Windows.Controls.Orientation.Horizontal };                              parentContainer.ReplaceChild(targetModel' newParentModel);                              newParentModel.Children.Add(newLayoutDocumentPane);                              newParentModel.Children.Add(targetModel as LayoutDocumentPane);                          }                          else                          {                              var manager = parentModel.Root.Manager;                              if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Horizontal)                              {                                  parentModel.Orientation = System.Windows.Controls.Orientation.Horizontal;                                  int targetPaneIndex = parentModel.IndexOfChild(targetModel);                                  parentModel.Children.Insert(targetPaneIndex' newLayoutDocumentPane);                              }                              else                              {                                  LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup();                                  newChildGroup.Orientation = System.Windows.Controls.Orientation.Horizontal;                                  parentModel.ReplaceChild(targetModel' newChildGroup);                                  newChildGroup.Children.Add(newLayoutDocumentPane);                                  newChildGroup.Children.Add(targetModel);                              }                            }                            foreach (var cntToTransfer in floatingWindow.RootPanel.Descendents().OfType<LayoutAnchorable>().ToArray())                              newLayoutDocumentPane.Children.Add(cntToTransfer);                        }                      break;                      #endregion                  case DropTargetType.DocumentPaneDockRight:                      #region DropTargetType.DocumentPaneDockRight                      {                          var parentModel = targetModel.Parent as LayoutDocumentPaneGroup;                          var newLayoutDocumentPane = new LayoutDocumentPane();                            if (parentModel == null)                          {                              var parentContainer = targetModel.Parent as ILayoutContainer;                              var newParentModel = new LayoutDocumentPaneGroup() { Orientation = System.Windows.Controls.Orientation.Horizontal };                              parentContainer.ReplaceChild(targetModel' newParentModel);                              newParentModel.Children.Add(targetModel as LayoutDocumentPane);                              newParentModel.Children.Add(newLayoutDocumentPane);                          }                          else                          {                              var manager = parentModel.Root.Manager;                              if (!manager.AllowMixedOrientation || parentModel.Orientation == System.Windows.Controls.Orientation.Horizontal)                              {                                  parentModel.Orientation = System.Windows.Controls.Orientation.Horizontal;                                  int targetPaneIndex = parentModel.IndexOfChild(targetModel);                                  parentModel.Children.Insert(targetPaneIndex + 1' newLayoutDocumentPane);                              }                              else                              {                                  LayoutDocumentPaneGroup newChildGroup = new LayoutDocumentPaneGroup();                                  newChildGroup.Orientation = System.Windows.Controls.Orientation.Horizontal;                                  parentModel.ReplaceChild(targetModel' newChildGroup);                                  newChildGroup.Children.Add(targetModel);                                  newChildGroup.Children.Add(newLayoutDocumentPane);                              }                          }                            foreach (var cntToTransfer in floatingWindow.RootPanel.Descendents().OfType<LayoutAnchorable>().ToArray())                              newLayoutDocumentPane.Children.Add(cntToTransfer);                        }                      break;                      #endregion                  case DropTargetType.DocumentPaneDockInside:                      #region DropTargetType.DocumentPaneDockInside                      {                          var paneModel = targetModel as LayoutDocumentPane;                          var layoutAnchorablePaneGroup = floatingWindow.RootPanel as LayoutAnchorablePaneGroup;                            int i = _tabIndex == -1 ? 0 : _tabIndex;                          LayoutAnchorable anchorableToActivate = null;                          foreach (var anchorableToImport in layoutAnchorablePaneGroup.Descendents().OfType<LayoutAnchorable>().ToArray())                          {                              paneModel.Children.Insert(i' anchorableToImport);                              i++;                              anchorableToActivate = anchorableToImport;                          }                            anchorableToActivate.IsActive = true;                      }                      break;                      #endregion              }
Missing Default,AvalonDock.Controls,DocumentPaneDropTarget,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\DocumentPaneDropTarget.cs,GetPreviewPath,The following switch statement is missing a default case: switch (Type)              {                  case DropTargetType.DocumentPaneDockInside:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                            if (_tabIndex == -1)                          {                              return new RectangleGeometry(targetScreenRect);                          }                          else                          {                              var translatedDetectionRect = new Rect(DetectionRects[0].TopLeft' DetectionRects[0].BottomRight);                              translatedDetectionRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                                                            var pathFigure = new PathFigure();                              pathFigure.StartPoint = targetScreenRect.BottomRight;                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Right' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopRight });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.TopLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = translatedDetectionRect.BottomLeft });                              pathFigure.Segments.Add(new LineSegment() { Point = new Point(targetScreenRect.Left' translatedDetectionRect.Bottom) });                              pathFigure.Segments.Add(new LineSegment() { Point = targetScreenRect.BottomLeft });                              pathFigure.IsClosed = true;                              pathFigure.IsFilled = true;                              pathFigure.Freeze();                              return new PathGeometry(new PathFigure[] { pathFigure });                          }                      }                  case DropTargetType.DocumentPaneDockBottom:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(0.0' targetScreenRect.Height / 2.0);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockTop:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Height /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockLeft:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }                  case DropTargetType.DocumentPaneDockRight:                      {                          var targetScreenRect = TargetElement.GetScreenArea();                          targetScreenRect.Offset(-overlayWindow.Left' -overlayWindow.Top);                          targetScreenRect.Offset(targetScreenRect.Width / 2.0' 0.0);                          targetScreenRect.Width /= 2.0;                          return new RectangleGeometry(targetScreenRect);                      }              }
Missing Default,AvalonDock.Controls,LayoutAnchorableFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorableFloatingWindowControl.cs,FilterMessage,The following switch statement is missing a default case: switch (msg)              {                  case Win32Helper.WM_NCLBUTTONDOWN: //Left button down on title -> start dragging over docking manager                      if (wParam.ToInt32() == Win32Helper.HT_CAPTION)                      {                          _model.Descendents().OfType<LayoutAnchorablePane>().First(p => p.ChildrenCount > 0 && p.SelectedContent != null).SelectedContent.IsActive = true;                          handled = true;                      }                      break;                  case Win32Helper.WM_NCRBUTTONUP:                      if (wParam.ToInt32() == Win32Helper.HT_CAPTION)                      {                          if (OpenContextMenu())                              handled = true;                            if (_model.Root.Manager.ShowSystemMenu)                              WindowChrome.GetWindowChrome(this).ShowSystemMenu = !handled;                          else                              WindowChrome.GetWindowChrome(this).ShowSystemMenu = false;                      }                      break;                }
Missing Default,AvalonDock.Controls,LayoutAnchorSideControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutAnchorSideControl.cs,UpdateSide,The following switch statement is missing a default case: switch (_model.Side)              {                  case AnchorSide.Left:                      SetIsLeftSide(true);                      break;                  case AnchorSide.Top:                      SetIsTopSide(true);                      break;                  case AnchorSide.Right:                      SetIsRightSide(true);                      break;                  case AnchorSide.Bottom:                      SetIsBottomSide(true);                      break;              }
Missing Default,AvalonDock.Controls,LayoutDocumentFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutDocumentFloatingWindowControl.cs,FilterMessage,The following switch statement is missing a default case: switch (msg)              {                  case Win32Helper.WM_NCLBUTTONDOWN: //Left button down on title -> start dragging over docking manager                      if (wParam.ToInt32() == Win32Helper.HT_CAPTION)                      {                          if (_model.RootDocument != null)                              _model.RootDocument.IsActive = true;                      }                      break;                  case Win32Helper.WM_NCRBUTTONUP:                      if (wParam.ToInt32() == Win32Helper.HT_CAPTION)                      {                          if (OpenContextMenu())                              handled = true;                          if (_model.Root.Manager.ShowSystemMenu)                              WindowChrome.GetWindowChrome(this).ShowSystemMenu = !handled;                          else                              WindowChrome.GetWindowChrome(this).ShowSystemMenu = false;                      }                      break;                }
Missing Default,AvalonDock.Controls,LayoutFloatingWindowControl,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,FilterMessage,The following switch statement is missing a default case: switch (msg)              {                  case Win32Helper.WM_ACTIVATE:                      if (((int)wParam & 0xFFFF) == Win32Helper.WA_INACTIVE)                      {                          if (lParam == this.GetParentWindowHandle())                          {                              Win32Helper.SetActiveWindow(_hwndSrc.Handle);                              handled = true;                          }                      }                      break;                  case Win32Helper.WM_EXITSIZEMOVE:                      UpdatePositionAndSizeOfPanes();                        if (_dragService != null)                      {                          bool dropFlag;                          var mousePosition = this.TransformToDeviceDPI(Win32Helper.GetMousePosition());                          _dragService.Drop(mousePosition' out dropFlag);                          _dragService = null;                          SetIsDragging(false);                            if (dropFlag)                              InternalClose();                      }                                            break;                  case Win32Helper.WM_MOVING:                      {                          UpdateDragPosition();                      }                      break;                  case Win32Helper.WM_LBUTTONUP: //set as handled right button click on title area (after showing context menu)                      if (_dragService != null && Mouse.LeftButton == MouseButtonState.Released)                      {                          _dragService.Abort();                          _dragService = null;                          SetIsDragging(false);                      }                      break;              }
Missing Default,AvalonDock.Controls,FloatingWindowContentHost,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\LayoutFloatingWindowControl.cs,WndProc,The following switch statement is missing a default case: switch (msg)                  {                      case Win32Helper.WM_SETFOCUS:                          Debug.WriteLine("FloatingWindowContentHost.WM_SETFOCUS");                          break;                      case Win32Helper.WM_KILLFOCUS:                          Debug.WriteLine("FloatingWindowContentHost.WM_KILLFOCUS");                          break;                  }
Missing Default,AvalonDock.Controls,OverlayWindow,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\OverlayWindow.cs,GetTargets,The following switch statement is missing a default case: switch (visibleArea.Type)                  {                      case DropAreaType.DockingManager:                          {                              var dropAreaDockingManager = visibleArea as DropArea<DockingManager>;                              yield return new DockingManagerDropTarget(dropAreaDockingManager.AreaElement' _dockingManagerDropTargetLeft.GetScreenArea()' DropTargetType.DockingManagerDockLeft);                              yield return new DockingManagerDropTarget(dropAreaDockingManager.AreaElement' _dockingManagerDropTargetTop.GetScreenArea()' DropTargetType.DockingManagerDockTop);                              yield return new DockingManagerDropTarget(dropAreaDockingManager.AreaElement' _dockingManagerDropTargetBottom.GetScreenArea()' DropTargetType.DockingManagerDockBottom);                              yield return new DockingManagerDropTarget(dropAreaDockingManager.AreaElement' _dockingManagerDropTargetRight.GetScreenArea()' DropTargetType.DockingManagerDockRight);                          }                          break;                      case DropAreaType.AnchorablePane:                          {                              var dropAreaAnchorablePane = visibleArea as DropArea<LayoutAnchorablePaneControl>;                              yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetLeft.GetScreenArea()' DropTargetType.AnchorablePaneDockLeft);                              yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetTop.GetScreenArea()' DropTargetType.AnchorablePaneDockTop);                              yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetRight.GetScreenArea()' DropTargetType.AnchorablePaneDockRight);                              yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetBottom.GetScreenArea()' DropTargetType.AnchorablePaneDockBottom);                              yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' _anchorablePaneDropTargetInto.GetScreenArea()' DropTargetType.AnchorablePaneDockInside);                                var parentPaneModel = dropAreaAnchorablePane.AreaElement.Model as LayoutAnchorablePane;                              LayoutAnchorableTabItem lastAreaTabItem = null;                              foreach (var dropAreaTabItem in dropAreaAnchorablePane.AreaElement.FindVisualChildren<LayoutAnchorableTabItem>())                              {                                  var tabItemModel = dropAreaTabItem.Model as LayoutAnchorable;                                  lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea().Right < dropAreaTabItem.GetScreenArea().Right ?                                      dropAreaTabItem : lastAreaTabItem;                                  int tabIndex = parentPaneModel.Children.IndexOf(tabItemModel);                                  yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' dropAreaTabItem.GetScreenArea()' DropTargetType.AnchorablePaneDockInside' tabIndex);                              }                                if (lastAreaTabItem != null)                              {                                  var lastAreaTabItemScreenArea = lastAreaTabItem.GetScreenArea();                                  var newAreaTabItemScreenArea = new Rect(lastAreaTabItemScreenArea.TopRight' new Point(lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom));                                  if (newAreaTabItemScreenArea.Right < dropAreaAnchorablePane.AreaElement.GetScreenArea().Right)                                      yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' newAreaTabItemScreenArea' DropTargetType.AnchorablePaneDockInside' parentPaneModel.Children.Count);                              }                                var dropAreaTitle = dropAreaAnchorablePane.AreaElement.FindVisualChildren<AnchorablePaneTitle>().FirstOrDefault();                              if (dropAreaTitle != null)                                  yield return new AnchorablePaneDropTarget(dropAreaAnchorablePane.AreaElement' dropAreaTitle.GetScreenArea()' DropTargetType.AnchorablePaneDockInside);                          }                          break;                      case DropAreaType.DocumentPane:                          {                              bool isDraggingAnchorables = _floatingWindow.Model is LayoutAnchorableFloatingWindow;                              if (isDraggingAnchorables && _gridDocumentPaneFullDropTargets != null)                              {                                  var dropAreaDocumentPane = visibleArea as DropArea<LayoutDocumentPaneControl>;                                  if (_documentPaneFullDropTargetLeft.IsVisible)                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetLeft.GetScreenArea()' DropTargetType.DocumentPaneDockLeft);                                  if (_documentPaneFullDropTargetTop.IsVisible)                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetTop.GetScreenArea()' DropTargetType.DocumentPaneDockTop);                                  if (_documentPaneFullDropTargetRight.IsVisible)                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetRight.GetScreenArea()' DropTargetType.DocumentPaneDockRight);                                  if (_documentPaneFullDropTargetBottom.IsVisible)                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetBottom.GetScreenArea()' DropTargetType.DocumentPaneDockBottom);                                  if (_documentPaneFullDropTargetInto.IsVisible)                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneFullDropTargetInto.GetScreenArea()' DropTargetType.DocumentPaneDockInside);                                    var parentPaneModel = dropAreaDocumentPane.AreaElement.Model as LayoutDocumentPane;                                  LayoutDocumentTabItem lastAreaTabItem = null;                                  foreach (var dropAreaTabItem in dropAreaDocumentPane.AreaElement.FindVisualChildren<LayoutDocumentTabItem>())                                  {                                      var tabItemModel = dropAreaTabItem.Model;                                      lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea().Right < dropAreaTabItem.GetScreenArea().Right ?                                          dropAreaTabItem : lastAreaTabItem;                                      int tabIndex = parentPaneModel.Children.IndexOf(tabItemModel);                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' dropAreaTabItem.GetScreenArea()' DropTargetType.DocumentPaneDockInside' tabIndex);                                  }                                    if (lastAreaTabItem != null)                                  {                                      var lastAreaTabItemScreenArea = lastAreaTabItem.GetScreenArea();                                      var newAreaTabItemScreenArea = new Rect(lastAreaTabItemScreenArea.TopRight' new Point(lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom));                                      if (newAreaTabItemScreenArea.Right < dropAreaDocumentPane.AreaElement.GetScreenArea().Right)                                          yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' newAreaTabItemScreenArea' DropTargetType.DocumentPaneDockInside' parentPaneModel.Children.Count);                                  }                                    if (_documentPaneDropTargetLeftAsAnchorablePane.IsVisible)                                      yield return new DocumentPaneDropAsAnchorableTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetLeftAsAnchorablePane.GetScreenArea()' DropTargetType.DocumentPaneDockAsAnchorableLeft);                                  if (_documentPaneDropTargetTopAsAnchorablePane.IsVisible)                                      yield return new DocumentPaneDropAsAnchorableTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetTopAsAnchorablePane.GetScreenArea()' DropTargetType.DocumentPaneDockAsAnchorableTop);                                  if (_documentPaneDropTargetRightAsAnchorablePane.IsVisible)                                      yield return new DocumentPaneDropAsAnchorableTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetRightAsAnchorablePane.GetScreenArea()' DropTargetType.DocumentPaneDockAsAnchorableRight);                                  if (_documentPaneDropTargetBottomAsAnchorablePane.IsVisible)                                      yield return new DocumentPaneDropAsAnchorableTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetBottomAsAnchorablePane.GetScreenArea()' DropTargetType.DocumentPaneDockAsAnchorableBottom);                              }                              else                              {                                    var dropAreaDocumentPane = visibleArea as DropArea<LayoutDocumentPaneControl>;                                  if (_documentPaneDropTargetLeft.IsVisible)                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetLeft.GetScreenArea()' DropTargetType.DocumentPaneDockLeft);                                  if (_documentPaneDropTargetTop.IsVisible)                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetTop.GetScreenArea()' DropTargetType.DocumentPaneDockTop);                                  if (_documentPaneDropTargetRight.IsVisible)                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetRight.GetScreenArea()' DropTargetType.DocumentPaneDockRight);                                  if (_documentPaneDropTargetBottom.IsVisible)                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetBottom.GetScreenArea()' DropTargetType.DocumentPaneDockBottom);                                  if (_documentPaneDropTargetInto.IsVisible)                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetInto.GetScreenArea()' DropTargetType.DocumentPaneDockInside);                                    var parentPaneModel = dropAreaDocumentPane.AreaElement.Model as LayoutDocumentPane;                                  LayoutDocumentTabItem lastAreaTabItem = null;                                  foreach (var dropAreaTabItem in dropAreaDocumentPane.AreaElement.FindVisualChildren<LayoutDocumentTabItem>())                                  {                                      var tabItemModel = dropAreaTabItem.Model;                                      lastAreaTabItem = lastAreaTabItem == null || lastAreaTabItem.GetScreenArea().Right < dropAreaTabItem.GetScreenArea().Right ?                                          dropAreaTabItem : lastAreaTabItem;                                      int tabIndex = parentPaneModel.Children.IndexOf(tabItemModel);                                      yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' dropAreaTabItem.GetScreenArea()' DropTargetType.DocumentPaneDockInside' tabIndex);                                  }                                    if (lastAreaTabItem != null)                                  {                                      var lastAreaTabItemScreenArea = lastAreaTabItem.GetScreenArea();                                      var newAreaTabItemScreenArea = new Rect(lastAreaTabItemScreenArea.TopRight' new Point(lastAreaTabItemScreenArea.Right + lastAreaTabItemScreenArea.Width' lastAreaTabItemScreenArea.Bottom));                                      if (newAreaTabItemScreenArea.Right < dropAreaDocumentPane.AreaElement.GetScreenArea().Right)                                          yield return new DocumentPaneDropTarget(dropAreaDocumentPane.AreaElement' newAreaTabItemScreenArea' DropTargetType.DocumentPaneDockInside' parentPaneModel.Children.Count);                                  }                              }                          }                          break;                      case DropAreaType.DocumentPaneGroup:                          {                              var dropAreaDocumentPane = visibleArea as DropArea<LayoutDocumentPaneGroupControl>;                              if (_documentPaneDropTargetInto.IsVisible)                                  yield return new DocumentPaneGroupDropTarget(dropAreaDocumentPane.AreaElement' _documentPaneDropTargetInto.GetScreenArea()' DropTargetType.DocumentPaneGroupDockInside);                          }                          break;                  }
Missing Default,Standard,Utility,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\Standard\Utilities.cs,_UrlEncodeIsSafe,The following switch statement is missing a default case: switch ((char)b)              {                  case '-':                  case '_':                  case '.':                  case '!':                  //case '~':                  case '*':                  case '\'':                  case '(':                  case ')':                      return true;              }
Missing Default,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Controls\Shell\WindowChromeWorker.cs,_GetHwndState,The following switch statement is missing a default case: switch (wpl.showCmd)              {                  case SW.SHOWMINIMIZED: return WindowState.Minimized;                  case SW.SHOWMAXIMIZED: return WindowState.Maximized;              }
Missing Default,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ToggleAutoHide,The following switch statement is missing a default case: switch (side)                      {                          case AnchorSide.Right:                              if (parentGroup.Root.RootPanel.Orientation == Orientation.Horizontal)                              {                                  previousContainer = new LayoutAnchorablePane();                                  parentGroup.Root.RootPanel.Children.Add(previousContainer);                              }                              else                              {                                  previousContainer = new LayoutAnchorablePane();                                  LayoutPanel panel = new LayoutPanel() { Orientation = Orientation.Horizontal };                                  LayoutRoot root = parentGroup.Root as LayoutRoot;                                  LayoutPanel oldRootPanel = parentGroup.Root.RootPanel as LayoutPanel;                                  root.RootPanel = panel;                                  panel.Children.Add(oldRootPanel);                                  panel.Children.Add(previousContainer);                              }                              break;                          case AnchorSide.Left:                              if (parentGroup.Root.RootPanel.Orientation == Orientation.Horizontal)                              {                                  previousContainer = new LayoutAnchorablePane();                                  parentGroup.Root.RootPanel.Children.Insert(0' previousContainer);                              }                              else                              {                                  previousContainer = new LayoutAnchorablePane();                                  LayoutPanel panel = new LayoutPanel() { Orientation = Orientation.Horizontal };                                  LayoutRoot root = parentGroup.Root as LayoutRoot;                                  LayoutPanel oldRootPanel = parentGroup.Root.RootPanel as LayoutPanel;                                  root.RootPanel = panel;                                  panel.Children.Add(previousContainer);                                  panel.Children.Add(oldRootPanel);                              }                              break;                          case AnchorSide.Top:                              if (parentGroup.Root.RootPanel.Orientation == Orientation.Vertical)                              {                                  previousContainer = new LayoutAnchorablePane();                                  parentGroup.Root.RootPanel.Children.Insert(0' previousContainer);                              }                              else                              {                                  previousContainer = new LayoutAnchorablePane();                                  LayoutPanel panel = new LayoutPanel() { Orientation = Orientation.Vertical };                                  LayoutRoot root = parentGroup.Root as LayoutRoot;                                  LayoutPanel oldRootPanel = parentGroup.Root.RootPanel as LayoutPanel;                                  root.RootPanel = panel;                                  panel.Children.Add(previousContainer);                                  panel.Children.Add(oldRootPanel);                              }                              break;                          case AnchorSide.Bottom:                              if (parentGroup.Root.RootPanel.Orientation == Orientation.Vertical)                              {                                  previousContainer = new LayoutAnchorablePane();                                  parentGroup.Root.RootPanel.Children.Add(previousContainer);                              }                              else                              {                                  previousContainer = new LayoutAnchorablePane();                                  LayoutPanel panel = new LayoutPanel() { Orientation = Orientation.Vertical };                                  LayoutRoot root = parentGroup.Root as LayoutRoot;                                  LayoutPanel oldRootPanel = parentGroup.Root.RootPanel as LayoutPanel;                                  root.RootPanel = panel;                                  panel.Children.Add(oldRootPanel);                                  panel.Children.Add(previousContainer);                              }                              break;                      }
Missing Default,AvalonDock.Layout,LayoutAnchorable,C:\repos\Emudofus_BehaviorIsManaged\Librairies\AvalonDock\Layout\LayoutAnchorable.cs,ToggleAutoHide,The following switch statement is missing a default case: switch (anchorSide)                  {                      case AnchorSide.Right:                          root.RightSide.Children.Add(newAnchorGroup);                          break;                      case AnchorSide.Left:                          root.LeftSide.Children.Add(newAnchorGroup);                          break;                      case AnchorSide.Top:                          root.TopSide.Children.Add(newAnchorGroup);                          break;                      case AnchorSide.Bottom:                          root.BottomSide.Children.Add(newAnchorGroup);                          break;                  }
