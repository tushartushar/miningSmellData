Implementation smell,Namespace,Class,File,Method,Description
Long Method,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The method has 108 lines of code.
Long Method,ImageResizer.Resizing,ImageLayoutEngine,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageLayoutEngine.cs,ApplySettings,The method has 127 lines of code.
Complex Method,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,CheckRequest_PostAuthorizeRequest_Async,Cyclomatic complexity of the method is 10
Complex Method,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,LoadImage,Cyclomatic complexity of the method is 10
Complex Method,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,GetStreamFromSource,Cyclomatic complexity of the method is 16
Complex Method,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,BuildJob,Cyclomatic complexity of the method is 11
Complex Method,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PrepareSourceBitmap,Cyclomatic complexity of the method is 9
Complex Method,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PostDecodeStream,Cyclomatic complexity of the method is 11
Complex Method,ImageResizer,InterceptModule,F:\newReposMay17\imazen_resizer\Core\InterceptModule.cs,CheckRequest_PostAuthorizeRequest,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Configuration.Performance,DictionaryCounter,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\DictionaryCounter.cs,GetOrAddInternal,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,Cyclomatic complexity of the method is 14
Complex Method,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,Check,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,CheckFor45PlusVersion,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.ExtensionMethods,EnumExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\Enum.cs,LoadValues,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.ExtensionMethods,StreamExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\Stream.cs,CopyToStream,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Configuration,PluginLoadingHints,F:\newReposMay17\imazen_resizer\Core\PluginLoadingHints.cs,LoadHints,Cyclomatic complexity of the method is 15
Complex Method,ImageResizer.Configuration,PipelineConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PipelineConfig.cs,_cacheUrlData,Cyclomatic complexity of the method is 16
Complex Method,ImageResizer.Configuration,PipelineConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PipelineConfig.cs,GetFile,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,clear_plugins_by_type,Cyclomatic complexity of the method is 9
Complex Method,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,Cyclomatic complexity of the method is 25
Complex Method,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,CreatePluginByType,Cyclomatic complexity of the method is 9
Complex Method,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,remove_plugin,Cyclomatic complexity of the method is 12
Complex Method,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,add_plugin,Cyclomatic complexity of the method is 12
Complex Method,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,RemoveAll,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,Cyclomatic complexity of the method is 13
Complex Method,ImageResizer.Plugins.Basic,Image404,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Image404.cs,CreateRemovalMatcher,Cyclomatic complexity of the method is 12
Complex Method,ImageResizer.Plugins.Basic,Presets,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Presets.cs,Modify,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.Basic,SpeedOrQuality,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\SpeedOrQuality.cs,RenderImage,Cyclomatic complexity of the method is 15
Complex Method,ImageResizer.Plugins,MultiFolderStorage,F:\newReposMay17\imazen_resizer\Core\Plugins\MultiFolderStorage.cs,TryDiskWrite,Cyclomatic complexity of the method is 9
Complex Method,ImageResizer.Configuration.Issues,ConfigChecker,F:\newReposMay17\imazen_resizer\Core\Configuration\Issues\ConfigChecker.cs,GetIssues,Cyclomatic complexity of the method is 12
Complex Method,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,Cyclomatic complexity of the method is 15
Complex Method,ImageResizer.Caching,ResponseHeaders,F:\newReposMay17\imazen_resizer\Core\Caching\ResponseHeaders.cs,DefaultApplyToResponseMethod,Cyclomatic complexity of the method is 18
Complex Method,ImageResizer.Configuration.Xml,Node,F:\newReposMay17\imazen_resizer\Core\Configuration\Xml\Node.cs,Node,Cyclomatic complexity of the method is 10
Complex Method,ImageResizer.Resizing,ImageLayoutEngine,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageLayoutEngine.cs,ApplySettings,Cyclomatic complexity of the method is 19
Complex Method,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ForEach,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCroppingRectangle,Cyclomatic complexity of the method is 20
Long Parameter List,ImageResizer,ImageJob,F:\newReposMay17\imazen_resizer\Core\ImageJob.cs,ImageJob,The method has 5 parameters.
Long Parameter List,ImageResizer,ImageJob,F:\newReposMay17\imazen_resizer\Core\ImageJob.cs,ImageJob,The method has 5 parameters.
Long Parameter List,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,GetStreamFromSource,The method has 5 parameters.
Long Parameter List,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,Build,The method has 5 parameters.
Long Parameter List,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,InternalGraphicsDrawImage,The method has 6 parameters.
Long Parameter List,ImageResizer.ExtensionMethods,NameValueCollectionExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\NameValueCollection.cs,SetList,The method has 5 parameters.
Long Parameter List,ImageResizer.Plugins.Basic,DropShadow,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DropShadow.cs,DrawOuterGradient,The method has 5 parameters.
Long Parameter List,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,DrawString,The method has 5 parameters.
Long Parameter List,ImageResizer.Plugins,MultiFolderStorage,F:\newReposMay17\imazen_resizer\Core\Plugins\MultiFolderStorage.cs,MultiFolderStorage,The method has 5 parameters.
Long Parameter List,ImageResizer.Resizing,AbstractImageProcessor,F:\newReposMay17\imazen_resizer\Core\Resizing\AbstractImageProcessor.cs,GetStream,The method has 5 parameters.
Long Parameter List,ImageResizer.Resizing,AbstractImageProcessor,F:\newReposMay17\imazen_resizer\Core\Resizing\AbstractImageProcessor.cs,InternalGraphicsDrawImage,The method has 6 parameters.
Long Parameter List,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,BuildQueryString,The method has 6 parameters.
Long Parameter List,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,DrawOuterGradient,The method has 5 parameters.
Long Statement,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The length of the statement  "	var modDate = (vf == null) ? System.IO.File.GetLastWriteTimeUtc (ra.RewrittenMappedPath) : (vf is IVirtualFileWithModifiedDateAsync ? await((IVirtualFileWithModifiedDateAsync)vf).GetModifiedDateUTCAsync () : DateTime.MinValue); " is 227.
Long Statement,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The length of the statement  "		return (vf != null) ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read); " is 129.
Long Statement,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The length of the statement  "				using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) { " is 148.
Long Statement,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The length of the statement  "				await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ()); " is 172.
Long Statement,ImageResizer,BoxEdges,F:\newReposMay17\imazen_resizer\Core\BoxEdges.cs,ToString,The length of the statement  "	return "(" + Left.ToString (NumberFormatInfo.InvariantInfo) + "'" + Top.ToString (NumberFormatInfo.InvariantInfo) + "'" + Right.ToString (NumberFormatInfo.InvariantInfo) + "'" + Bottom.ToString (NumberFormatInfo.InvariantInfo) + ")"; " is 233.
Long Statement,ImageResizer,ImageJob,F:\newReposMay17\imazen_resizer\Core\ImageJob.cs,ResolveTemplatedPath,The length of the statement  "				throw new ImageProcessingException ("You cannot use the <filename> variable in a job that does not have a source filename' such as with a Stream or Bitmap instance"); " is 166.
Long Statement,ImageResizer,ImageJob,F:\newReposMay17\imazen_resizer\Core\ImageJob.cs,ResolveTemplatedPath,The length of the statement  "				throw new ImageProcessingException ("You cannot use the <dir> variable in a job that does not have a source filename' such as with a Stream or Bitmap instance"); " is 161.
Long Statement,ImageResizer,ImageJob,F:\newReposMay17\imazen_resizer\Core\ImageJob.cs,ResolveTemplatedPath,The length of the statement  "				throw new ImageProcessingException ("You cannot use the <path> variable in a job that does not have a source filename' such as with a Stream or Bitmap instance"); " is 162.
Long Statement,ImageResizer,ImageJob,F:\newReposMay17\imazen_resizer\Core\ImageJob.cs,ResolveTemplatedPath,The length of the statement  "				throw new ImageProcessingException ("You cannot use the <originalext> variable in a job that does not have a source filename' such as with a Stream or Bitmap instance"); " is 169.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,LoadImage,The length of the statement  "		throw new ArgumentNullException ("source"' "The source argument cannot be null; how do you load an image from a null value?"); " is 126.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,LoadImage,The length of the statement  "	string loadFailureReasons = "File may be corrupted' empty' or may contain a PNG image with a single dimension greater than 65'535 pixels."; " is 139.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,LoadImage,The length of the statement  "		throw new ArgumentException ("Source may only be an instance of string' VirtualFile' IVirtualBitmapFile' HttpPostedFile' HttpPostedFileBase' Bitmap' Image' or Stream."' "source"); " is 179.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,LoadImage,The length of the statement  "		//Make sure the bitmap is tagged with its path. DecodeStream usually handles this' only relevant for extension decoders. " is 120.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,GetStreamFromSource,The length of the statement  "		throw new ArgumentNullException ("source"' "The source argument cannot be null; how do you load an image from a null value?"); " is 126.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,GetStreamFromSource,The length of the statement  "			string virtualPath = HostingEnvironment.ApplicationVirtualPath == null ? path.TrimStart ('~') : PathUtils.ResolveAppRelative (path); " is 132.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,GetStreamFromSource,The length of the statement  "			throw new ImageProcessingException ("The source stream is at the end (have you already read it?). You must call stream.Seek(0' SeekOrigin.Begin); before re-using a stream' or use ImageJob with ResetSourceStream=true the first time the stream is read."); " is 253.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,GetStreamFromSource,The length of the statement  "			throw new ImageProcessingException ("Source stream is empty; it has a length of 0. No bytes' no data. We can't work with this."); " is 129.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,BuildJob,The length of the statement  "					return GetFinalSize (new System.Drawing.Size (b.Width' b.Height)' new ResizeSettings (job.Settings)).Width.ToString (NumberFormatInfo.InvariantInfo); " is 149.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,BuildJob,The length of the statement  "					return GetFinalSize (new System.Drawing.Size (b.Width' b.Height)' new ResizeSettings (job.Settings)).Height.ToString (NumberFormatInfo.InvariantInfo); " is 150.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PrepareSourceBitmap,The length of the statement  "	if (!string.IsNullOrEmpty (q ["page"]) && !int.TryParse (q ["page"]' NumberStyles.Integer' NumberFormatInfo.InvariantInfo' out page)) " is 133.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PrepareSourceBitmap,The length of the statement  "	if (!string.IsNullOrEmpty (q ["frame"]) && !int.TryParse (q ["frame"]' NumberStyles.Integer' NumberFormatInfo.InvariantInfo' out frame)) " is 136.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PrepareSourceBitmap,The length of the statement  "	//Flipping has to be done on the original - it can't be done as part of the DrawImage or later' after the borders are drawn. " is 124.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PrepareSourceBitmap,The length of the statement  "	if (s.sourceBitmap != null && (s.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone || !string.IsNullOrEmpty (s.settings ["sRotate"]))) { " is 143.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,EndLayout,The length of the statement  "	//Calculates a bounding box around all the rings in the layout' then rounds that size. Creates a 1x1 pixel destSize value at minimum. " is 133.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBackground,The length of the statement  "	//Find out if we can safely know that nothing will be showing from behind the image (no margin' padding' etc' and source format doesn't have alpha channel). " is 156.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBackground,The length of the statement  "	bool nothingToShow = (s.sourceBitmap != null && (s.sourceBitmap.PixelFormat == PixelFormat.Format24bppRgb || s.sourceBitmap.PixelFormat == PixelFormat.Format32bppRgb || s.sourceBitmap.PixelFormat == PixelFormat.Format48bppRgb) && PolygonMath.ArraysEqual (s.layout ["image"]' s.layout.LastRing.points) && PolygonMath.IsUnrotated (s.layout ["image"]) && string.IsNullOrEmpty (s.settings ["s.alpha"]) && string.IsNullOrEmpty (s.settings ["s.roundcorners"]) && string.IsNullOrEmpty (s.settings ["filter"])); " is 503.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBackground,The length of the statement  "	//Set the background to white if the background will be showing and the destination format doesn't support transparency. " is 120.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderImage,The length of the statement  "			this.InternalGraphicsDrawImage (s' s.destBitmap' s.preRenderBitmap' PolygonMath.getParallelogram (s.layout ["image"])' s.copyRect' s.colorMatrix); " is 146.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderImage,The length of the statement  "		this.InternalGraphicsDrawImage (s' s.destBitmap' s.sourceBitmap' PolygonMath.getParallelogram (s.layout ["image"])' s.copyRect' s.colorMatrix); " is 143.
Long Statement,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,InternalGraphicsDrawImage,The length of the statement  "	if (base.InternalGraphicsDrawImage (state' dest' source' targetArea' sourceArea' colorMatrix) == RequestedAction.Cancel) " is 120.
Long Statement,ImageResizer,InterceptModule,F:\newReposMay17\imazen_resizer\Core\InterceptModule.cs,CheckRequest_PostAuthorizeRequest,The length of the statement  "		IVirtualFile vf = (conf.VppUsage != VppUsageOption.Never && !existsPhysically) ? conf.GetFile (ra.RewrittenVirtualPath' ra.RewrittenQuery) : null; " is 146.
Long Statement,ImageResizer,InterceptModule,F:\newReposMay17\imazen_resizer\Core\InterceptModule.cs,HandleRequest,The length of the statement  "	var modDate = (vf == null) ? System.IO.File.GetLastWriteTimeUtc (ra.RewrittenMappedPath) : (vf is IVirtualFileWithModifiedDate ? ((IVirtualFileWithModifiedDate)vf).ModifiedDateUTC : DateTime.MinValue); " is 201.
Long Statement,ImageResizer,InterceptModule,F:\newReposMay17\imazen_resizer\Core\InterceptModule.cs,context_PreSendRequestHeaders,The length of the statement  "	if (app == null || app.Context == null || app.Context.Items == null || app.Context.Request == null || app.Context.Response == null) " is 131.
Long Statement,ImageResizer,ResizeSettings,F:\newReposMay17\imazen_resizer\Core\ResizeSettings.cs,Normalize,The length of the statement  "	this.Normalize ("width"' "w").Normalize ("height"' "h").Normalize ("sFlip"' "sourceFlip").Normalize ("format"' "thumbnail"); " is 124.
Long Statement,ImageResizer,ResizeSettings,F:\newReposMay17\imazen_resizer\Core\ResizeSettings.cs,Normalize,The length of the statement  "	return (ResizeSettings)ImageResizer.ExtensionMethods.NameValueCollectionExtensions.Normalize (this' primary' secondary); " is 120.
Long Statement,ImageResizer.Configuration.Performance,InfoAccumuatorExtensions,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\InfoAccumulators\IInfoAccumulatorExtensions.cs,ToQueryString,The length of the statement  "	var pairs = a.GetInfo ().Where (pair => pair.Value != null && pair.Key != null).Select (pair => Uri.EscapeDataString (pair.Key) + "=" + Uri.EscapeDataString (pair.Value)); " is 171.
Long Statement,ImageResizer.Configuration.Performance,CircularTimeBuffer,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\RateTracking\CircularTimeBuffer.cs,DequeueValues,The length of the statement  "	return enumerableResults == Enumerable.Empty<TimeSlotResult> () ? Enumerable.Empty<long> () : enumerableResults.Select (r => r.Value.Value); " is 140.
Long Statement,ImageResizer.Configuration.Performance,SegmentClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\SegmentClamping.cs,Validate,The length of the statement  "		throw new ArgumentException ("This clamping function produces over " + count + " unique values' which exceeds your configured MaxPossibleValues limit"); " is 152.
Long Statement,ImageResizer.Configuration.Performance,MachineStorage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MachineStorage.cs,GetMachineWideStorageLocations,The length of the statement  "	yield return Environment.GetFolderPath (Environment.SpecialFolder.CommonApplicationData' Environment.SpecialFolderOption.Create); " is 129.
Long Statement,ImageResizer.Configuration.Performance,CountMinSketch,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\CountMinSketch.cs,GetAllValues,The length of the statement  "	return clamp.PossibleValues ().SelectMany (v => Enumerable.Repeat (v' (int)Estimate ((uint)v))).OrderBy (n => n).ToArray (); " is 124.
Long Statement,ImageResizer.Configuration.Performance,CpuInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\CpuInfo.cs,Invoke,The length of the statement  "		codePointer = VirtualAlloc (IntPtr.Zero' new UIntPtr ((uint)codeBytes.Length)' AllocationType.Commit | AllocationType.Reserve' MemoryProtection.ExecuteReadwrite); " is 162.
Long Statement,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,init_genrand,The length of the statement  "		/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. *//* In the previous versions' MSBs of the seed affect   *//* only MSBs of the array mt[].                        *//* 2002/01/09 modified by Makoto Matsumoto             */mt [mti] &= 0xffffffffUL; " is 253.
Long Statement,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,CountLimitedUniqueValuesIgnoreCase,The length of the statement  "	return uniques.GetOrAdd (category' k => new DictionaryCounter<string> (limit' otherBucketValue' StringComparer.OrdinalIgnoreCase)).Increment (value ?? "null"); " is 159.
Long Statement,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GetPopularUniqueValues,The length of the statement  "	return uniques.TryGetValue (category' out v) ? v.GetCounts ().Where (pair => pair.Value > 0).OrderByDescending (pair => pair.Value).Take (limit).Select (pair => pair.Key) : Enumerable.Empty<string> (); " is 201.
Long Statement,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GetReportPairs,The length of the statement  "		q.Add (values.Zip (Percentiles' (result' percent) => new KeyValuePair<string' string> (d.Key + "_" + percent.ToString () + "th"' result.ToString ()))); " is 151.
Long Statement,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GetReportPairs,The length of the statement  "	q.Add ("extra_job_query_keys"' string.Join ("'"' GetPopularUniqueValues ("job_query_keys"' 40).Except (originalKeys).Take (2))); " is 128.
Long Statement,ImageResizer.Configuration.Performance,PluginInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,GetPluginsUsedShorthand,The length of the statement  "	var shorthandPlugins = pluginUsage.GetPluginsInstalled ().Select (t => t.FullName).Select (s => pluginShorthand.Value.ContainsKey (s) ? pluginShorthand.Value [s] : s).Where (s => !s.Contains ("LicenseEnforcer")).Distinct (); " is 224.
Long Statement,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,GetHttpModules,The length of the statement  "		return modules.AllKeys.Select (key => modules.Get (key).GetType ().FullName.Replace ("System.Web.Security"' "").Replace ("System.Web"' "")).ToArray (); " is 151.
Long Statement,ImageResizer.Configuration.Performance,PercentileExtensions,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Utilities.cs,GetPercentile,The length of the statement  "	return (data [(int)Math.Max (0' Math.Ceiling (index - 1.5))] + data [(int)Math.Min (Math.Ceiling (index - 0.5)' data.Length - 1)]) / 2; " is 135.
Long Statement,ImageResizer.ExtensionMethods,EnumExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\Enum.cs,LoadValues,The length of the statement  "	var prefixes = t.GetCustomAttributes (typeof(EnumRemovePrefixAttribute)' false).Where (attr => attr is EnumRemovePrefixAttribute).Select (attr => ((EnumRemovePrefixAttribute)attr).Name); " is 186.
Long Statement,ImageResizer.ExtensionMethods,EnumExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\Enum.cs,LoadValues,The length of the statement  "		foreach (String unprefixed in prefixes.Where (prefix => name.StartsWith (prefix' StringComparison.OrdinalIgnoreCase)).Select (prefix => name.Remove (0' prefix.Length))) { " is 170.
Long Statement,ImageResizer.ExtensionMethods,EnumExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\Enum.cs,Parse,The length of the statement  "		if ((char.IsDigit (p [0]) || p [0] == '-' || p [0] == '+') && long.TryParse (p' NumberStyles.Integer' NumberFormatInfo.InvariantInfo' out temp)) { " is 146.
Long Statement,ImageResizer.ExtensionMethods,NameValueCollectionExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\NameValueCollection.cs,ParsePrimitive,The length of the statement  "		if ("true".Equals (s' StringComparison.OrdinalIgnoreCase) || "1".Equals (s' StringComparison.OrdinalIgnoreCase) || "yes".Equals (s' StringComparison.OrdinalIgnoreCase) || "on".Equals (s' StringComparison.OrdinalIgnoreCase)) " is 223.
Long Statement,ImageResizer.ExtensionMethods,NameValueCollectionExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\NameValueCollection.cs,ParsePrimitive,The length of the statement  "		else if ("false".Equals (s' StringComparison.OrdinalIgnoreCase) || "0".Equals (s' StringComparison.OrdinalIgnoreCase) || "no".Equals (s' StringComparison.OrdinalIgnoreCase) || "off".Equals (s' StringComparison.OrdinalIgnoreCase)) " is 229.
Long Statement,ImageResizer.ExtensionMethods,NameValueCollectionExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\NameValueCollection.cs,SetList,The length of the statement  "			throw new ArgumentOutOfRangeException ("values"' "The specified array is not a valid length. Valid lengths are " + JoinPrimitives<int> (allowedSizes' ''')); " is 156.
Long Statement,ImageResizer.ExtensionMethods,StreamExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\Stream.cs,CopyToMemoryStream,The length of the statement  "	MemoryStream ms = new MemoryStream (s.CanSeek ? ((int)s.Length + 8 - (entireStream ? 0 : (int)s.Position)) : chunkSize); " is 120.
Long Statement,ImageResizer.Configuration,PluginLoadingHints,F:\newReposMay17\imazen_resizer\Core\PluginLoadingHints.cs,LoadHints,The length of the statement  "		AddHint (normalNoSuffix' "ImageResizer.Plugins." + normalNoSuffix + "." + normalNoSuffix + "' ImageResizer.Plugins." + normalNoSuffix); " is 135.
Long Statement,ImageResizer.Configuration,PluginLoadingHints,F:\newReposMay17\imazen_resizer\Core\PluginLoadingHints.cs,LoadHints,The length of the statement  "		AddHint (normalWithSuffix' "ImageResizer.Plugins." + normalWithSuffix + "." + normalWithSuffix + "Plugin' ImageResizer.Plugins." + normalWithSuffix); " is 149.
Long Statement,ImageResizer.Configuration,Config,F:\newReposMay17\imazen_resizer\Core\Configuration\Config.cs,get,The length of the statement  "		configurationSectionIssues.AcceptIssue (new Issue ("Invalid integer value in imageresizer configuration section' " + selector + ":" + s' IssueSeverity.ConfigurationError)); " is 172.
Long Statement,ImageResizer.Configuration,Config,F:\newReposMay17\imazen_resizer\Core\Configuration\Config.cs,get,The length of the statement  "	if ("true".Equals (s' StringComparison.OrdinalIgnoreCase) || "1".Equals (s' StringComparison.OrdinalIgnoreCase) || "yes".Equals (s' StringComparison.OrdinalIgnoreCase) || "on".Equals (s' StringComparison.OrdinalIgnoreCase)) " is 223.
Long Statement,ImageResizer.Configuration,Config,F:\newReposMay17\imazen_resizer\Core\Configuration\Config.cs,get,The length of the statement  "	else if ("false".Equals (s' StringComparison.OrdinalIgnoreCase) || "0".Equals (s' StringComparison.OrdinalIgnoreCase) || "no".Equals (s' StringComparison.OrdinalIgnoreCase) || "off".Equals (s' StringComparison.OrdinalIgnoreCase)) " is 229.
Long Statement,ImageResizer.Configuration,Config,F:\newReposMay17\imazen_resizer\Core\Configuration\Config.cs,get,The length of the statement  "		configurationSectionIssues.AcceptIssue (new Issue ("Invalid boolean value in imageresizer configuration section' " + selector + ":" + s' IssueSeverity.ConfigurationError)); " is 172.
Long Statement,ImageResizer.Configuration,Config,F:\newReposMay17\imazen_resizer\Core\Configuration\Config.cs,get,The length of the statement  "		configurationSectionIssues.AcceptIssue (new Issue ("Failed to parse " + selector + ". Invalid value \"" + value + "\"."' "Valid values are " + valid' IssueSeverity.ConfigurationError)); " is 185.
Long Statement,ImageResizer.Configuration,PipelineConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PipelineConfig.cs,GetFile,The length of the statement  "	if (f == null && HostingEnvironment.VirtualPathProvider != null && HostingEnvironment.VirtualPathProvider.FileExists (virtualPath)) { " is 133.
Long Statement,ImageResizer.Configuration,PipelineConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PipelineConfig.cs,GetFile,The length of the statement  "		//We must abstract the differences in thrown exception as much as possible.  Start with FileNotFound & DirectoryNotFound " is 120.
Long Statement,ImageResizer.Configuration,PipelineConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PipelineConfig.cs,FileExists,The length of the statement  "	return HostingEnvironment.VirtualPathProvider != null ? HostingEnvironment.VirtualPathProvider.FileExists (virtualPath) : false; " is 128.
Long Statement,ImageResizer.Configuration,PipelineConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PipelineConfig.cs,FireHeartbeatViaAspNetCache,The length of the statement  "	HttpRuntime.Cache.Insert ("FireHeartbeat_for_PipelineConfig_" + GetHashCode ()' intervalSeconds' null' DateTime.Now.AddSeconds (intervalSeconds)' System.Web.Caching.Cache.NoSlidingExpiration' System.Web.Caching.CacheItemPriority.NotRemovable' (k' v' r) => { " is 257.
Long Statement,ImageResizer.Configuration,PipelineConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PipelineConfig.cs,IsAppDomainUnrestricted,The length of the statement  "	permissionSet.AddPermission (new System.Security.Permissions.SecurityPermission (System.Security.Permissions.PermissionState.Unrestricted)); " is 140.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,loadPluginsInternal,The length of the statement  "			this.AcceptIssue (new Issue ("Plugins"' "Unexpected element <" + n.Name + "> in <plugins></plugins>."' "Element XML: " + n.ToXmlElement ().OuterXml' IssueSeverity.Warning)); " is 173.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,remove_plugins_by_name,The length of the statement  "			AcceptIssue (new Issue ("Plugin " + t.FullName + " reported a failed uninstall attempt triggered by a <remove name=\"" + name + "\" />."' IssueSeverity.Error)); " is 160.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,add_plugin_by_name,The length of the statement  "		AcceptIssue (new Issue ("An instance of the specified plugin (" + p.GetType ().ToString () + ") has already been added. Implement IMultiInstancePlugin if the plugin supports multiple instances."' IssueSeverity.ConfigurationError)); " is 231.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,AddPluginByName,The length of the statement  "		AcceptIssue (new Issue ("An instance of the specified plugin (" + p.GetType ().ToString () + ") has already been added. Implement IMultiInstancePlugin if the plugin supports multiple instances."' IssueSeverity.ConfigurationError)); " is 231.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,clear_plugins_by_type,The length of the statement  "		this.AcceptIssue (new Issue ("Unrecognized type value \"" + type + "\" in <clear type=\"" + type + "\" />."' IssueSeverity.ConfigurationError)); " is 144.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,clear_plugins_by_type,The length of the statement  "				AcceptIssue (new Issue ("Plugin " + p.GetType ().FullName + " reported a failed uninstall attempt triggered by a <clear type=\"" + type + "\" />."' IssueSeverity.Error)); " is 170.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The length of the statement  "			var searchedAssemblies = officialExpansions.Select (s => s.IndexOf (''') > -1 ? s.Substring (s.IndexOf (''') + 1).Trim () : "").Distinct (); " is 140.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The length of the statement  "			this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "Verify that " + assemblyNames.ToString () + " is located in /bin. \n" + "Attempted using \"" + searchName + "\"" + attempts.ToString () + "."' IssueSeverity.ConfigurationError)); " is 264.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The length of the statement  "			this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "Verify that \"" + searchName.Item2 + "\".dll is located in /bin' and that the name is spelled correctly."' IssueSeverity.ConfigurationError)); " is 228.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The length of the statement  "				this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "This is not a recognized plugin name. Check spelling. \n" + "Attempted using \"" + searchName + "\"" + attempts.ToString () + "."' IssueSeverity.ConfigurationError)); " is 252.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The length of the statement  "		this.AcceptIssue (new Issue ("Failed to load plugin \"" + searchNameString + "\" due to ASP.NET trust configuration. "' "You may need to increase the trust level for this plugin to load properly. Error details: \n" + sx.Message + "\n" + sx.StackTrace' IssueSeverity.Error)); " is 274.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,CreatePluginByType,The length of the statement  "		this.AcceptIssue (new Issue ("Plugins"' "The plugin " + t.ToString () + " doesn't support constructor arguments."' "To support arguments in the <add> element' the plugin must have a public constructor that accepts a NameValueCollection argument."' IssueSeverity.ConfigurationError)); " is 283.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,CreatePluginByType,The length of the statement  "			this.AcceptIssue (new Issue ("Plugins"' "The plugin " + t.ToString () + " requires arguments in the <add> element. Refer to the plugin documentation for details."' null' IssueSeverity.ConfigurationError)); " is 205.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,CreatePluginByType,The length of the statement  "			this.AcceptIssue (new Issue ("Plugins"' "The plugin " + t.ToString () + " does not have a constructor Constructor() or Constructor(NameValueCollection args)."' "To be compatible with the <plugins> section' a plugin must implement IPlugin and define one or more of the above constructors publicly."' IssueSeverity.Critical)); " is 324.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,CreatePluginByType,The length of the statement  "			this.AcceptIssue (new Issue ("Plugins"' "Specified plugin doesn't implement IPlugin as required: " + t.ToString ()' null' IssueSeverity.ConfigurationError)); " is 157.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,add_plugin,The length of the statement  "		AcceptIssue (new Issue ("An instance of the specified plugin (" + plugin.GetType ().ToString () + ") has already been registered."' "The plugin should implement IMultiInstancePlugin to support multiple instances."' IssueSeverity.Error)); " is 237.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,RemoveAll,The length of the statement  "			this.AcceptIssue (new Issue ("Collection " + coll.ToString () + " was not empty after RemoveAllPlugins() executed!"' "Remaining items: " + items' IssueSeverity.Error)); " is 168.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("NoCache is only for development usage' and cannot scale to production use."' "Add DiskCache or CloudFront for production use"' IssueSeverity.Warning)); " is 175.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("NoCache should not be removed from the plugins collection."' "Simply add the new ICache plugin later for it to take precedence. NoCache is still required as a fallback by most caching plugins."' IssueSeverity.Error)); " is 241.
Long Statement,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("No encoders are registered! Without an image encoder' the pipeline cannot function."' IssueSeverity.Error)); " is 132.
Long Statement,ImageResizer.Configuration,HttpModuleRequestAssistant,F:\newReposMay17\imazen_resizer\Core\HttpModuleRequestAssistant.cs,PostAuthorize,The length of the statement  "		//By default' we process it if is both (a) a recognized image extension' and (b) has a resizing directive (not just 'cache'). " is 125.
Long Statement,ImageResizer.Configuration,HttpModuleRequestAssistant,F:\newReposMay17\imazen_resizer\Core\HttpModuleRequestAssistant.cs,PostAuthorize,The length of the statement  "		ProcessingIndicated = RewrittenInstructions.Process == ProcessWhen.Always || ((RewrittenInstructions.Process == ProcessWhen.Default || RewrittenInstructions.Process == null) && RewrittenVirtualPathIsAcceptedImageType && conf.HasPipelineDirective (RewrittenInstructions.Exclude ("cache"' "process"' "useresizingpipeline"' "404"' "404.filterMode"' "404.except"))); " is 362.
Long Statement,ImageResizer.Configuration,HttpModuleRequestAssistant,F:\newReposMay17\imazen_resizer\Core\HttpModuleRequestAssistant.cs,PostAuthorize,The length of the statement  "		CachingIndicated = RewrittenInstructions.Cache == ServerCacheMode.Always || ((RewrittenInstructions.Cache == ServerCacheMode.Default || RewrittenInstructions.Cache == null) && ProcessingIndicated); " is 197.
Long Statement,ImageResizer.Configuration,HttpModuleRequestAssistant,F:\newReposMay17\imazen_resizer\Core\HttpModuleRequestAssistant.cs,GenerateRequestCachingKey,The length of the statement  "	string modified = modifiedData != null && modifiedData != DateTime.MinValue && modifiedData != DateTime.MaxValue ? modifiedData.Value.Ticks.ToString (NumberFormatInfo.InvariantInfo) : ""; " is 187.
Long Statement,ImageResizer.Configuration,HttpModuleRequestAssistant,F:\newReposMay17\imazen_resizer\Core\HttpModuleRequestAssistant.cs,EstimateResponseInfo,The length of the statement  "		guessedEncoder = conf.GetImageBuilder ().EncoderProvider.GetEncoder (new ResizeSettings (this.RewrittenInstructions)' this.RewrittenVirtualPath); " is 145.
Long Statement,ImageResizer.Configuration,HttpModuleRequestAssistant,F:\newReposMay17\imazen_resizer\Core\HttpModuleRequestAssistant.cs,EstimateResponseInfo,The length of the statement  "	System.Drawing.Imaging.ImageFormat recognizedExtension = DefaultEncoder.GetImageFormatFromExtension (fallbackExtension); " is 120.
Long Statement,ImageResizer.Configuration,HttpModuleRequestAssistant,F:\newReposMay17\imazen_resizer\Core\HttpModuleRequestAssistant.cs,FireMissing,The length of the statement  "	conf.FireImageMissing (sender' context' new UrlEventArgs (this.RewrittenVirtualPath' new NameValueCollection (this.RewrittenQuery))); " is 133.
Long Statement,ImageResizer.Plugins.Basic,LicenseDisplay,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\LicenseDisplay.cs,GetPageText,The length of the statement  "	return string.Join ("\n\n"' c.Plugins.GetAll<ILicenseDiagnosticsProvider> ().Concat (c.Plugins.GetAll<IDiagnosticsProviderFactory> ().Select (f => f.GetDiagnosticsProvider () as ILicenseDiagnosticsProvider)).Where (p => p != null).Select (p => p.ProvidePublicText ()).Distinct ()); " is 281.
Long Statement,ImageResizer.Plugins.Basic,DefaultSettings,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DefaultSettings.cs,Modify,The length of the statement  "	bool explicitSize = (!string.IsNullOrEmpty (settings ["width"]) || !string.IsNullOrEmpty (settings ["height"]) || !string.IsNullOrEmpty (settings ["w"]) || !string.IsNullOrEmpty (settings ["h"])); " is 196.
Long Statement,ImageResizer.Plugins.Basic,IEPngFix,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\IEPngFix.cs,Pipeline_RewriteDefaults,The length of the statement  "	//If this is IE 6 or earlier' and catchall is enabled' add iefix=true to all requests' regardless of (current) file type.  " is 121.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "	if (c.Pipeline.PreRewritePath.Equals (prefix + "ImageHandler.ashx"' StringComparison.OrdinalIgnoreCase) && !string.IsNullOrEmpty (context.Request.QueryString ["src"])) { " is 169.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "                zoom: Invariant Culture floating point number indicating scale value. If 2 is specified the output will be double the original size.*///Fix path " is 144.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "		if (string.IsNullOrEmpty (c.Pipeline.ModifiedQueryString ["s.grayscale"]) && !string.IsNullOrEmpty (c.Pipeline.ModifiedQueryString ["greyscale"])) " is 146.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "		if (string.IsNullOrEmpty (c.Pipeline.ModifiedQueryString ["s.invert"]) && !string.IsNullOrEmpty (c.Pipeline.ModifiedQueryString ["invert"])) " is 140.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "		if (string.IsNullOrEmpty (c.Pipeline.ModifiedQueryString ["stretch"]) && string.IsNullOrEmpty (c.Pipeline.ModifiedQueryString ["mode"])) " is 136.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "	} else if ((c.Pipeline.PreRewritePath.Equals (prefix + "imghandler.ashx"' StringComparison.OrdinalIgnoreCase) || c.Pipeline.PreRewritePath.EndsWith ("DAMP_ImagePreview.ashx"' StringComparison.OrdinalIgnoreCase)) && !string.IsNullOrEmpty (context.Request.QueryString ["img"])) { " is 277.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "		if (!isDAMP && string.IsNullOrEmpty (c.Pipeline.ModifiedQueryString ["mode"]) && string.IsNullOrEmpty (c.Pipeline.ModifiedQueryString ["stretch"])) " is 147.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "	} else if (c.Pipeline.PreRewritePath.Equals (prefix + "bbimagehandler.ashx"' StringComparison.OrdinalIgnoreCase) && !string.IsNullOrEmpty (context.Request.QueryString ["file"])) { " is 179.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "                fit: Fit mode maintains the aspect ratio of the original image while ensuring that the dimensions of the result do not exceed the maximum values for the resize transformation. (Needs width or height parameter)" is 209.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "                fitsquare: Resizes the image with the given width as its longest side (depending on image direction) and maintains the aspect ratio. The image will be centered in a square area of the chosen background color (Needs width parameter' backcolor optional)" is 251.
Long Statement,ImageResizer.Plugins.Basic,ImageHandlerSyntax,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ImageHandlerSyntax.cs,Pipeline_PostAuthorizeRequestStart,The length of the statement  "                crop: Crop resizes the image and removes parts of it to ensure that the dimensions of the result are exactly as specified by the transformation.(Needs width and height parameter)" is 178.
Long Statement,ImageResizer.Plugins.Basic,ClientCache,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\ClientCache.cs,Pipeline_PreHandleImage,The length of the statement  "	//NDJ Jan-16-2013. The last modified date sent in the headers should NOT match the source modified date when using DiskCaching. " is 127.
Long Statement,ImageResizer.Plugins.Basic,Image404,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Image404.cs,Pipeline_ImageMissing,The length of the statement  "		////    filterMode = NameValueCollectionExtensions.Get(e.QueryString' "404.filterMode"' FilterMode.ExcludeUnknownCommands); " is 123.
Long Statement,ImageResizer.Plugins.Basic,NoCacheHandler,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\NoCacheHandler.cs,ProcessRequest,The length of the statement  "	//Generally' it's OK to send the source file's last-modified date. But that causes problems with watermarks and other dependencies.  " is 131.
Long Statement,ImageResizer.Plugins.Basic,NoCacheHandler,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\NoCacheHandler.cs,ProcessRequest,The length of the statement  "	//if (lastModified != DateTime.MinValue && e.ResponseHeaders.LastModified == DateTime.MinValue) e.ResponseHeaders.LastModified = lastModified; " is 142.
Long Statement,ImageResizer.Plugins.Basic,Presets,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Presets.cs,ParseXml,The length of the statement  "				conf.configurationSectionIssues.AcceptIssue (new Issue ("Presets"' "The name attribute for each preset must be specified' and must be unique."' "XML: " + c.ToString ()' IssueSeverity.ConfigurationError)); " is 204.
Long Statement,ImageResizer.Plugins.Basic,Presets,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Presets.cs,GetIssues,The length of the statement  "			new Issue ("Presets"' "The FolderResizeSyntax allows clients to circumvent the 'onlyAllowPresets' setting by pulling values from the path into the querystring."' "You should remove the FolderResizeSyntax to ensure 'onlyAllowPresets' can be enforced."' IssueSeverity.Critical) " is 275.
Long Statement,ImageResizer.Plugins.Basic,Presets,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Presets.cs,GetIssues,The length of the statement  "			new Issue ("Presets"' "Standard resizing commands are currently disabled; only presets are enabled."' "To fix' set <presets onlyAllowPresets=\"false\"> (it is currently set to true)."' IssueSeverity.Warning) " is 207.
Long Statement,ImageResizer.Plugins.Basic,SpeedOrQuality,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\SpeedOrQuality.cs,RenderImage,The length of the statement  "	if (string.IsNullOrEmpty (s.settings ["speed"]) || !int.TryParse (s.settings ["speed"]' NumberStyles.Integer' NumberFormatInfo.InvariantInfo' out speed)) " is 153.
Long Statement,ImageResizer.Plugins.Basic,SpeedOrQuality,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\SpeedOrQuality.cs,RenderImage,The length of the statement  "			s.destGraphics.DrawImage (s.sourceBitmap' PolygonMath.getParallelogram (s.layout ["image"])' s.copyRect' GraphicsUnit.Pixel' ia); " is 129.
Long Statement,ImageResizer.Plugins.Basic,SpeedOrQuality,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\SpeedOrQuality.cs,RenderImage,The length of the statement  "			RectangleF copyPart = new RectangleF ((float)(s.copyRect.Left * xfactor)' (float)(s.copyRect.Top * yfactor)' (float)(s.copyRect.Width * xfactor)' (float)(s.copyRect.Height * yfactor)); " is 184.
Long Statement,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,PreFlushChanges,The length of the statement  "	DrawString (PolygonMath.GetBoundingBox (s.layout ["image"])' s.destGraphics' "Unlicensed"' FontFamily.GenericSansSerif' Color.FromArgb (70' Color.White)); " is 154.
Long Statement,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,DrawString,The length of the statement  "	g.DrawString (text' new Font (ff' finalFontSize)' new SolidBrush (c)' new PointF ((area.Width - finalSize.Width) / 2 + area.Left' (area.Height - finalSize.Height) / 2 + area.Height)); " is 183.
Long Statement,ImageResizer.Plugins.Basic,Diagnostic,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Diagnostic.cs,DisabledNotice,The length of the statement  "	var mode = (WebConfigurationManager.OpenWebConfiguration (null).GetSection ("system.web/customErrors") as CustomErrorsSection).Mode ?? CustomErrorsMode.RemoteOnly; " is 163.
Long Statement,ImageResizer.Plugins.Basic,Diagnostic,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Diagnostic.cs,DisabledNotice,The length of the statement  "	sb.Append ("\n\nTo override for localhost access' add <diagnostics enableFor=\"localhost\" /> in the <resizer> section of Web.config.\n\n" + "To override for remote access' add <diagnostics enableFor=\"allhosts\" /> in the <resizer> section of Web.config.\n\n"); " is 262.
Long Statement,ImageResizer.Plugins.Basic,Diagnostic,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Diagnostic.cs,AllowResponse,The length of the statement  "	switch (c.get ("diagnostics.enableFor"' context.IsCustomErrorEnabled ? DiagnosticMode.None : DiagnosticMode.AllHosts)) { " is 120.
Long Statement,ImageResizer.Plugins.Basic,WebConfigLicenseReader,F:\newReposMay17\imazen_resizer\Core\Plugins\WebConfigLicenseReader.cs,Install,The length of the statement  "	foreach (var child in c.getNode ("licenses").childrenByName ("license").Where (n => !string.IsNullOrWhiteSpace (n.TextContents)) ?? Enumerable.Empty<Node> ()) { " is 160.
Long Statement,ImageResizer.Plugins.Basic,WebConfigLicenseReader,F:\newReposMay17\imazen_resizer\Core\Plugins\WebConfigLicenseReader.cs,RedactFrom,The length of the statement  "	foreach (Node n in resizer.queryUncached ("licenses.license").Where (n => !string.IsNullOrWhiteSpace (n.TextContents)) ?? Enumerable.Empty<Node> ()) { " is 150.
Long Statement,ImageResizer.Plugins.Basic,SizeLimits,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\SizeLimits.cs,ValidateTotalSize,The length of the statement  "		throw new SizeLimitException ("The dimensions of the output image (" + total.Width + "x" + total.Height + ") exceed the configured maximum dimensions of " + TotalSize.Width + "x" + TotalSize.Height + ". You can change these limits in Web.config through the SizeLimiting plugin."); " is 280.
Long Statement,ImageResizer.Plugins.Basic,VirtualFolder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\VirtualFolder.cs,normalizeVirtualPath,The length of the statement  "		path = HostingEnvironment.ApplicationVirtualPath.TrimEnd ('/') + '/' + (path.StartsWith ("~") ? path.Substring (1) : path).TrimStart ('/'); " is 139.
Long Statement,ImageResizer.Plugins.Basic,VirtualFolder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\VirtualFolder.cs,LocalMapPath,The length of the statement  "		return Path.Combine (PhysicalPath' virtualPath.Substring (this.VirtualPath.Length).TrimStart ('/').Replace ('/'' Path.DirectorySeparatorChar)); " is 143.
Long Statement,ImageResizer.Plugins.Basic,VirtualFolder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\VirtualFolder.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("The VirtualFolder plugin cannot serve files from \"" + PhysicalPath + "\" until you increase the trust level or modify the trust configuration to permit read access to the directory."' IssueSeverity.Error)); " is 231.
Long Statement,ImageResizer.Plugins.Basic,VirtualFolder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\VirtualFolder.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("The VirtualFolder plugin failed to register itself as an app-wide VirtualPathProvider. It will only work for images processed by the image resizer."' IssueSeverity.Error)); " is 196.
Long Statement,ImageResizer.Plugins,MultiFolderStorage,F:\newReposMay17\imazen_resizer\Core\Plugins\MultiFolderStorage.cs,TryDelete,The length of the statement  "				sink.AcceptIssue (new Issue (this.issueSource' "Failed to delete " + dataKind + " at location " + path' e.ToString ()' IssueSeverity.Warning)); " is 143.
Long Statement,ImageResizer.Plugins,MultiFolderStorage,F:\newReposMay17\imazen_resizer\Core\Plugins\MultiFolderStorage.cs,TryDiskWrite,The length of the statement  "						AddBadWriteLocation (dest' new Issue (this.issueSource' "Failed to create directory " + dest' e.ToString ()' IssueSeverity.Warning)); " is 133.
Long Statement,ImageResizer.Plugins,MultiFolderStorage,F:\newReposMay17\imazen_resizer\Core\Plugins\MultiFolderStorage.cs,TryDiskWrite,The length of the statement  "						sec.AddAccessRule (new FileSystemAccessRule (everyone' FileSystemRights.Read' InheritanceFlags.None' PropagationFlags.None' AccessControlType.Allow)); " is 150.
Long Statement,ImageResizer.Plugins,MultiFolderStorage,F:\newReposMay17\imazen_resizer\Core\Plugins\MultiFolderStorage.cs,TryDiskWrite,The length of the statement  "						AddBadWriteLocation (dest' new Issue (this.issueSource' "Failed to write " + dataKind + " to location " + path' e.ToString ()' IssueSeverity.Warning)); " is 151.
Long Statement,ImageResizer.Plugins,MultiFolderStorage,F:\newReposMay17\imazen_resizer\Core\Plugins\MultiFolderStorage.cs,TryDiskWrite,The length of the statement  "		sink.AcceptIssue (new Issue (this.issueSource' "Unable to cache " + dataKind + " to disk in any location."' null' IssueSeverity.Error)); " is 136.
Long Statement,ImageResizer.Plugins,MultiFolderStorage,F:\newReposMay17\imazen_resizer\Core\Plugins\MultiFolderStorage.cs,TryDiskRead,The length of the statement  "					AddBadReadLocation (path' new Issue (this.issueSource' "Failed to read " + dataKind + " from location " + path' e.ToString ()' IssueSeverity.Warning)); " is 151.
Long Statement,ImageResizer.Plugins,MultiFolderStorage,F:\newReposMay17\imazen_resizer\Core\Plugins\MultiFolderStorage.cs,TryDiskRead,The length of the statement  "		sink.AcceptIssue (new Issue (this.issueSource' "Unable to read " + dataKind + " from disk despite its existence."' null' IssueSeverity.Error)); " is 143.
Long Statement,ImageResizer.Plugins,WriteThroughCache,F:\newReposMay17\imazen_resizer\Core\Plugins\PeristentGlobalStringCache.cs,TryPut,The length of the statement  "	return store.TryDiskWrite (FilenameKeyFor (key)' value) ? StringCachePutResult.WriteComplete : StringCachePutResult.WriteFailed; " is 128.
Long Statement,ImageResizer.Plugins,VirtualPathProviderShim,F:\newReposMay17\imazen_resizer\Core\Plugins\VirtualPathProvderShim.cs,normalizeVirtualPath,The length of the statement  "		path = HostingEnvironment.ApplicationVirtualPath.TrimEnd ('/') + '/' + (path.StartsWith ("~") ? path.Substring (1) : path).TrimStart ('/'); " is 139.
Long Statement,ImageResizer.Configuration.Issues,ConfigChecker,F:\newReposMay17\imazen_resizer\Core\Configuration\Issues\ConfigChecker.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("Use <sizelimits>' not <sizelimiting> to configure the SizeLimiting plugin"' IssueSeverity.ConfigurationError)); " is 135.
Long Statement,ImageResizer.Configuration.Issues,ConfigChecker,F:\newReposMay17\imazen_resizer\Core\Configuration\Issues\ConfigChecker.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("You have specified configuration settings for the SizeLimiting plugin' but it is not installed. "' "Use <add name=\"SizeLimiting\" /> inside <plugins> to install."' IssueSeverity.ConfigurationError)); " is 224.
Long Statement,ImageResizer.Configuration.Issues,ConfigChecker,F:\newReposMay17\imazen_resizer\Core\Configuration\Issues\ConfigChecker.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("To potentially see additional errors here' perform an image resize request."' IssueSeverity.Warning)); " is 126.
Long Statement,ImageResizer.Configuration.Issues,ConfigChecker,F:\newReposMay17\imazen_resizer\Core\Configuration\Issues\ConfigChecker.cs,GetIssues,The length of the statement  "			UrlAuthorizationModule.CheckUrlAccessForPrincipal (HostingEnvironment.ApplicationVirtualPath.TrimEnd ('/') + '/'' user' "GET"); " is 127.
Long Statement,ImageResizer.Configuration.Issues,ConfigChecker,F:\newReposMay17\imazen_resizer\Core\Configuration\Issues\ConfigChecker.cs,GetIssues,The length of the statement  "			issues.Add (new Issue ("UrlAuthorizationModule.CheckUrlAccessForPrincipal is not supported on this runtime (are you running Mono?)"' "It may be possible for users to bypass UrlAuthorization rules you have defined for your website' and access images that would otherwise be protected. If you do not use UrlAuthorization rules' this should not be a concern. " + "You may also re-implement your security rules (but only for *processed* images) by handling the Config.Current.Pipeline.AuthorizeImage event."' IssueSeverity.Warning)); " is 529.
Long Statement,ImageResizer.Configuration.Issues,ConfigChecker,F:\newReposMay17\imazen_resizer\Core\Configuration\Issues\ConfigChecker.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("Grant the website SecurityPermission to call UrlAuthorizationModule.CheckUrlAccessForPrincipal"' "Without this permission' it may be possible for users to bypass UrlAuthorization rules you have defined for your website' and access images that would otherwise be protected. If you do not use UrlAuthorization rules' this should not be a concern. " + "You may also re-implement your security rules by handling the Config.Current.Pipeline.AuthorizeImage event."' IssueSeverity.Critical)); " is 509.
Long Statement,ImageResizer.Configuration.Issues,ConfigChecker,F:\newReposMay17\imazen_resizer\Core\Configuration\Issues\ConfigChecker.cs,GetIssues,The length of the statement  "	if (HostingEnvironment.ApplicationPhysicalPath != null && File.Exists (Path.Combine (HostingEnvironment.ApplicationPhysicalPath' "PrecompiledApp.config"))) " is 155.
Long Statement,ImageResizer.Configuration.Issues,ConfigChecker,F:\newReposMay17\imazen_resizer\Core\Configuration\Issues\ConfigChecker.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("You are running a hotfix version of the ImageResizer."' "You should upgrade to a released version with an equal or higher version number as soon as possible. " + "Hotfix and release DLLs with the same version number are not the same - the release DLL should be used instead." + "\nAssemblies marked as hotfix versions: " + assembliesRunningHotfix' IssueSeverity.Warning)); " is 396.
Long Statement,ImageResizer.Configuration.Issues,IssueGatherer,F:\newReposMay17\imazen_resizer\Core\Configuration\Issues\IssueGatherer.cs,GetIssues,The length of the statement  "			l.Add (new Issue (p.GetType ().Name' "Error checking for issues: " + e.ToString ()' e.StackTrace' IssueSeverity.Error)); " is 120.
Long Statement,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The length of the statement  "			this.AcceptIssue (new Issues.Issue ("Plugin error - failed to find embedded resource " + resourceName' Issues.IssueSeverity.Error)); " is 132.
Long Statement,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The length of the statement  "		this.AcceptIssue (new Issue ("Application does not have IOPermission; Native dependencies for " + assemblyName + " will not be downloaded if missing")); " is 152.
Long Statement,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The length of the statement  "				this.AcceptIssue (new Issues.Issue ("Missing attribute 'name' in native dependency manifest for " + assemblyName' Issues.IssueSeverity.Warning)); " is 145.
Long Statement,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The length of the statement  "			if (c.Attrs ["fileBytes"] != null && !int.TryParse (c.Attrs ["fileBytes"]' System.Globalization.NumberStyles.Number' NumberFormatInfo.InvariantInfo' out fileBytes)) " is 164.
Long Statement,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The length of the statement  "				this.AcceptIssue (new Issues.Issue ("Failed to parse fileBytes value " + c.Attrs ["fileBytes"] + " in native dependency manifest for " + assemblyName' Issues.IssueSeverity.Warning)); " is 182.
Long Statement,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The length of the statement  "			this.AcceptIssue (new Issues.Issue ("Verifying native dependencies for " + assemblyName + " took " + sw.ElapsedMilliseconds + "ms."' Issues.IssueSeverity.Warning)); " is 164.
Long Statement,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The length of the statement  "			this.AcceptIssue (new Issues.Issue ("Some native dependencies for " + assemblyName + " were missing' but were downloaded successfully. This delayed startup time by " + (sw.ElapsedMilliseconds + dsw.ElapsedMilliseconds).ToString () + "ms."' message.ToString ()' Issues.IssueSeverity.Warning)); " is 292.
Long Statement,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,DownloadFile,The length of the statement  "				message.AppendLine (d.Name + " reported size of " + d.ExistingLength + " instead of expected " + d.ExpectedLength + " Re-downloaded from " + d.Url); " is 148.
Long Statement,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,DownloadFile,The length of the statement  "			this.AcceptIssue (new Issues.Issue ("Infinite dependency download! Expected file length " + d.ExpectedLength + " Downloaded file length " + downloadLength + ". Please notify support that the dependency manifest for " + d.RequestingAssembly + " needs to be updated.")); " is 268.
Long Statement,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,DownloadFile,The length of the statement  "		this.AcceptIssue (new Issues.Issue ("Failed to download native dependency " + d.Name + " for " + d.RequestingAssembly + " from " + d.Url' we.Message' Issues.IssueSeverity.Error)); " is 179.
Long Statement,ImageResizer.Caching,ResponseHeaders,F:\newReposMay17\imazen_resizer\Core\Caching\ResponseHeaders.cs,DefaultApplyToResponseMethod,The length of the statement  "	//The check against the current time is because  files served from another server may have a modified date in the future' if the clocks are not synchronized. " is 157.
Long Statement,ImageResizer.Configuration.Xml,Node,F:\newReposMay17\imazen_resizer\Core\Configuration\Xml\Node.cs,parseAttributeName,The length of the statement  "		throw new ArgumentException ("Selector must include an attribute name' like element.attrname. Was given '" + selector + "'"); " is 125.
Long Statement,ImageResizer.Configuration.Xml,Node,F:\newReposMay17\imazen_resizer\Core\Configuration\Xml\Node.cs,query,The length of the statement  "	ICollection<Node> results = _cachedResults [selector] = uncachedResults != null ? new ReadOnlyCollection<Node> (uncachedResults) : null; " is 136.
Long Statement,ImageResizer.Resizing,BoxPadding,F:\newReposMay17\imazen_resizer\Core\Resizing\BoxPadding.cs,ToString,The length of the statement  "	return "(" + Left.ToString (NumberFormatInfo.InvariantInfo) + "'" + Top.ToString (NumberFormatInfo.InvariantInfo) + "'" + Right.ToString (NumberFormatInfo.InvariantInfo) + "'" + Bottom.ToString (NumberFormatInfo.InvariantInfo) + ")"; " is 233.
Long Statement,ImageResizer.Resizing,ImageLayoutEngine,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageLayoutEngine.cs,determineFitMode,The length of the statement  "			else if (!string.IsNullOrEmpty (settings ["carve"]) && !"false".Equals (settings ["carve"]' StringComparison.OrdinalIgnoreCase) && !"none".Equals (settings ["carve"]' StringComparison.OrdinalIgnoreCase)) " is 203.
Long Statement,ImageResizer.Resizing,ImageLayoutEngine,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageLayoutEngine.cs,ApplySettings,The length of the statement  "		//Move max values to width/height. FitMode should already reflect the mode we are using' and we've already resolved mixed modes above. " is 134.
Long Statement,ImageResizer.Resizing,ImageLayoutEngine,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageLayoutEngine.cs,ApplySettings,The length of the statement  "		//We now have width & height' our target size. It will only be a different aspect ratio from the image if both 'width' and 'height' are specified. " is 146.
Long Statement,ImageResizer.Resizing,ImageLayoutEngine,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageLayoutEngine.cs,ApplySettings,The length of the statement  "			if ((scale == ScaleMode.DownscaleOnly && (cropWidthSmaller != cropHeightSmaller)) || (scale == ScaleMode.UpscaleCanvas && (cropHeightSmaller || cropWidthSmaller))) { " is 165.
Long Statement,ImageResizer.Resizing,ImageState,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageState.cs,EnsurePreRenderBitmap,The length of the statement  "		preRenderBitmap = sourceBitmap.Clone (new Rectangle (new Point (0' 0)' sourceBitmap.Size)' sourceBitmap.PixelFormat == PixelFormat.Format24bppRgb ? PixelFormat.Format24bppRgb : PixelFormat.Format32bppArgb); " is 206.
Long Statement,ImageResizer.Resizing,ImageState,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageState.cs,ValidateCropping,The length of the statement  "	if (copyRect.Bottom > bitmapSize.Height || copyRect.Right > bitmapSize.Width || copyRect.Left < 0 || copyRect.Right < 0) { " is 122.
Long Statement,ImageResizer.Resizing,ImageState,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageState.cs,ValidateCropping,The length of the statement  "	//    throw new ArgumentOutOfRangeException("cropRect"' string.Format("Crop rectangle includes zero pixels: {0}'{1}'{2}'{3}"' copyRect.X'copyRect.Y'copyRect.Right'copyRect.Bottom)); " is 181.
Long Statement,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The length of the statement  "			alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture); " is 131.
Long Statement,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,SetExtension,The length of the statement  "	return path.Substring (0' extensionStarts) + (!string.IsNullOrEmpty (newExtension) ? "." + newExtension.TrimStart ('.') : "") + path.Substring (query); " is 151.
Long Statement,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ResolveAppRelative,The length of the statement  "		return HostingEnvironment.ApplicationVirtualPath != null ? HostingEnvironment.ApplicationVirtualPath.TrimEnd ('/') + '/' + virtualPath.TrimStart ('~'' '/') : '/' + virtualPath.TrimStart ('~'' '/'); " is 197.
Long Statement,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ParseQueryOnly,The length of the statement  "			c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (value) : value; " is 122.
Long Statement,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ParseQueryOnly,The length of the statement  "			c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (namevalue [1]) : namevalue [1]; " is 138.
Long Statement,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ResolveVariablesInPath,The length of the statement  "			throw new ImageProcessingException ("Destination paths can only contain < and > in matched pairs to designate variables. Path \"" + pathWithVars + "\" has invalid syntax"); " is 172.
Long Statement,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ResolveVariablesInPath,The length of the statement  "			throw new ImageProcessingException ("Invalid variable name \"" + varName + "\" in templated path \"" + pathWithVars + "\". The variable name may be misspelled' or the variable may not be available with the pipeline you are using."); " is 232.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ScalePoint,The length of the statement  "	return new PointF ((float)((point.X - origin.X) * xfactor + origin.X)' (float)((point.Y - origin.Y) * yfactor + origin.Y)); " is 123.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,RotateVector,The length of the statement  "*/return new PointF ((float)(Math.Cos (radians) * v.X - Math.Sin (radians) * v.Y)' (float)(Math.Sin (radians) * v.X + Math.Cos (radians) * v.Y)); " is 145.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,RotateVector,The length of the statement  "*/return new PointF ((float)(Math.Cos (radians) * (v.X - origin.X) - Math.Sin (radians) * (v.Y - origin.Y)) + origin.X' (float)(Math.Sin (radians) * (v.X - origin.X) + Math.Cos (radians) * (v.Y - origin.Y)) + origin.Y); " is 219.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCorners,The length of the statement  "		PointF pP = ChangeMagnitude (RotateVector (new PointF (prev.X - current.X' prev.Y - current.Y)' Math.PI / 2)//rotate 90 clockwise. " is 130.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCorners,The length of the statement  "		PointF pN = ChangeMagnitude (RotateVector (new PointF (next.X - current.X' next.Y - current.Y)' Math.PI / -2)//rotate 90 counter-clockwise. " is 139.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CenterInside,The length of the statement  "	return MovePoly (NormalizePoly (inner)' new PointF ((outBox.Width - inBox.Width) / 2 + outBox.X' (outBox.Height - inBox.Height) / 2 + outBox.Y)); " is 145.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CenterInside,The length of the statement  "	return new RectangleF (bounds.Width / 2 + bounds.X - (size.Width / 2)' bounds.Height / 2 + bounds.Y - (size.Height / 2)' size.Width' size.Height); " is 146.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ToRectangle,The length of the statement  "	return new Rectangle ((int)Math.Round (r.X)' (int)Math.Round (r.Y)' (int)Math.Round (r.Right) - (int)Math.Round (r.X)' (int)Math.Round (r.Bottom) - (int)Math.Round (r.Y)); " is 171.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ToRectangleShrinkRound,The length of the statement  "	return new Rectangle ((int)Math.Ceiling (r.X)' (int)Math.Ceiling (r.Y)' (int)Math.Floor (r.Width - (Math.Ceiling (r.X) - r.X))' (int)Math.Floor (r.Height - (Math.Ceiling (r.Y) - r.Y))); " is 185.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,AlignWith,The length of the statement  "	if (align == ContentAlignment.BottomCenter || align == ContentAlignment.MiddleCenter || align == ContentAlignment.TopCenter) " is 124.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,AlignWith,The length of the statement  "	if (align == ContentAlignment.BottomRight || align == ContentAlignment.MiddleRight || align == ContentAlignment.TopRight) " is 121.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,AlignWith,The length of the statement  "	if (align == ContentAlignment.MiddleLeft || align == ContentAlignment.MiddleCenter || align == ContentAlignment.MiddleRight) " is 124.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,AlignWith,The length of the statement  "	if (align == ContentAlignment.BottomLeft || align == ContentAlignment.BottomCenter || align == ContentAlignment.BottomRight) " is 124.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The length of the statement  "	if (flip != (RotateFlipType)FlipMode.None && flip != (RotateFlipType)FlipMode.X && flip != (RotateFlipType)FlipMode.Y && flip != (RotateFlipType)FlipMode.XY) " is 157.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The length of the statement  "		throw new ArgumentException ("Valid flip values are RotateNoneFlipNone' RotateNoneFlipX' RotateNoneFlipY' and RotateNoneFlipXY. Rotation must be specified with Rotate or srcRotate instead. Received: " + flip.ToString ()); " is 221.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ClipRectangle,The length of the statement  "	var topleft = new PointF (Math.Min (bounds.Right' Math.Max (box.X' bounds.X))' Math.Min (bounds.Bottom' Math.Max (box.Y' bounds.Y))); " is 133.
Long Statement,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ClipRectangle,The length of the statement  "	var bottomright = new PointF (Math.Min (bounds.Right' Math.Max (box.Right' bounds.X))' Math.Min (bounds.Bottom' Math.Max (box.Bottom' bounds.Y))); " is 146.
Long Statement,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,getBool,The length of the statement  "		if ("true".Equals (s' StringComparison.OrdinalIgnoreCase) || "1".Equals (s' StringComparison.OrdinalIgnoreCase) || "yes".Equals (s' StringComparison.OrdinalIgnoreCase) || "on".Equals (s' StringComparison.OrdinalIgnoreCase)) " is 223.
Long Statement,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,getBool,The length of the statement  "		else if ("false".Equals (s' StringComparison.OrdinalIgnoreCase) || "0".Equals (s' StringComparison.OrdinalIgnoreCase) || "no".Equals (s' StringComparison.OrdinalIgnoreCase) || "off".Equals (s' StringComparison.OrdinalIgnoreCase)) " is 229.
Long Statement,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,writeFlip,The length of the statement  "	throw new ArgumentException ("Valid flip values are RotateNoneFlipNone' RotateNoneFlipX' RotateNoneFlipY' and RotateNoneFlipXY. Rotation must be specified with Rotate or srcRotate instead. Received: " + flip.ToString ()); " is 221.
Long Statement,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,writePadding,The length of the statement  "	return "(" + p.Left.ToString (NumberFormatInfo.InvariantInfo) + "'" + p.Top.ToString (NumberFormatInfo.InvariantInfo) + "'" + p.Right.ToString (NumberFormatInfo.InvariantInfo) + "'" + p.Bottom.ToString (NumberFormatInfo.InvariantInfo) + ")"; " is 241.
Complex Conditional,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,LoadImage,The conditional expression  "b != null && b.Tag != null && b.Tag is BitmapTag && ((BitmapTag)b.Tag).Source == s"  is complex.
Complex Conditional,ImageResizer,InterceptModule,F:\newReposMay17\imazen_resizer\Core\InterceptModule.cs,context_PreSendRequestHeaders,The conditional expression  "app == null || app.Context == null || app.Context.Items == null || app.Context.Request == null || app.Context.Response == null"  is complex.
Complex Conditional,ImageResizer.ExtensionMethods,EnumExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\Enum.cs,Parse,The conditional expression  "(char.IsDigit (p [0]) || p [0] == '-' || p [0] == '+') && long.TryParse (p' NumberStyles.Integer' NumberFormatInfo.InvariantInfo' out temp)"  is complex.
Complex Conditional,ImageResizer.ExtensionMethods,NameValueCollectionExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\NameValueCollection.cs,ParsePrimitive,The conditional expression  ""true".Equals (s' StringComparison.OrdinalIgnoreCase) || "1".Equals (s' StringComparison.OrdinalIgnoreCase) || "yes".Equals (s' StringComparison.OrdinalIgnoreCase) || "on".Equals (s' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,ImageResizer.ExtensionMethods,NameValueCollectionExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\NameValueCollection.cs,ParsePrimitive,The conditional expression  ""false".Equals (s' StringComparison.OrdinalIgnoreCase) || "0".Equals (s' StringComparison.OrdinalIgnoreCase) || "no".Equals (s' StringComparison.OrdinalIgnoreCase) || "off".Equals (s' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,ImageResizer.Configuration,Config,F:\newReposMay17\imazen_resizer\Core\Configuration\Config.cs,BuildImage,The conditional expression  "!string.IsNullOrEmpty (d) && !d.StartsWith ("~") && !(d.Contains ("/")) && d.Contains ("\\")"  is complex.
Complex Conditional,ImageResizer.Configuration,Config,F:\newReposMay17\imazen_resizer\Core\Configuration\Config.cs,get,The conditional expression  ""true".Equals (s' StringComparison.OrdinalIgnoreCase) || "1".Equals (s' StringComparison.OrdinalIgnoreCase) || "yes".Equals (s' StringComparison.OrdinalIgnoreCase) || "on".Equals (s' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,ImageResizer.Configuration,Config,F:\newReposMay17\imazen_resizer\Core\Configuration\Config.cs,get,The conditional expression  ""false".Equals (s' StringComparison.OrdinalIgnoreCase) || "0".Equals (s' StringComparison.OrdinalIgnoreCase) || "no".Equals (s' StringComparison.OrdinalIgnoreCase) || "off".Equals (s' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,ImageResizer.Resizing,ImageLayoutEngine,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageLayoutEngine.cs,ApplySettings,The conditional expression  "settings.Width != -1 || settings.Height != -1 || settings.MaxHeight != -1 || settings.MaxWidth != -1"  is complex.
Complex Conditional,ImageResizer.Resizing,ImageLayoutEngine,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageLayoutEngine.cs,ApplySettings,The conditional expression  "(scale == ScaleMode.DownscaleOnly && (cropWidthSmaller != cropHeightSmaller)) || (scale == ScaleMode.UpscaleCanvas && (cropHeightSmaller || cropWidthSmaller))"  is complex.
Complex Conditional,ImageResizer.Resizing,ImageState,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageState.cs,ApplyCropping,The conditional expression  "copyRect.X == 0 && copyRect.Y == 0 && copyRect.Width == latest.Width && copyRect.Height == latest.Height"  is complex.
Complex Conditional,ImageResizer.Resizing,ImageState,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageState.cs,ValidateCropping,The conditional expression  "copyRect.Bottom > bitmapSize.Height || copyRect.Right > bitmapSize.Width || copyRect.Left < 0 || copyRect.Right < 0"  is complex.
Complex Conditional,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ParseQueryStringFriendlyAllowSemicolons,The conditional expression  "eq >= 0 && //We have equals' which indicates a query  quest < 0 && //But no question mark!  (eq < semi || semi < 0)"  is complex.
Complex Conditional,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ResolveVariablesInPath,The conditional expression  "stop < 0 || (bugcheck > -1 && bugcheck < stop) || stop == start + 1"  is complex.
Complex Conditional,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The conditional expression  "flip != (RotateFlipType)FlipMode.None && flip != (RotateFlipType)FlipMode.X && flip != (RotateFlipType)FlipMode.Y && flip != (RotateFlipType)FlipMode.XY"  is complex.
Complex Conditional,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,getBool,The conditional expression  ""true".Equals (s' StringComparison.OrdinalIgnoreCase) || "1".Equals (s' StringComparison.OrdinalIgnoreCase) || "yes".Equals (s' StringComparison.OrdinalIgnoreCase) || "on".Equals (s' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,getBool,The conditional expression  ""false".Equals (s' StringComparison.OrdinalIgnoreCase) || "0".Equals (s' StringComparison.OrdinalIgnoreCase) || "no".Equals (s' StringComparison.OrdinalIgnoreCase) || "off".Equals (s' StringComparison.OrdinalIgnoreCase)"  is complex.
Virtual Method Call from Constructor,ImageResizer.Configuration,PipelineConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PipelineConfig.cs,PipelineConfig,The constructor "PipelineConfig" calls a virtual method "AcceptIssue".
Empty Catch Block,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,GetStreamFromSource,The method has an empty catch block.
Empty Catch Block,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,BuildJob,The method has an empty catch block.
Empty Catch Block,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PrepareSourceBitmap,The method has an empty catch block.
Empty Catch Block,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,GetIisVerFromRegistry,The method has an empty catch block.
Empty Catch Block,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,Get45PlusFromRegistry,The method has an empty catch block.
Empty Catch Block,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,HasFullTrust,The method has an empty catch block.
Empty Catch Block,ImageResizer.Configuration.Performance,AssemblyExtensions,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Utilities.cs,GetFirstAttribute,The method has an empty catch block.
Empty Catch Block,ImageResizer.Configuration.Performance,AssemblyExtensions,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Utilities.cs,GetFirstAttribute,The method has an empty catch block.
Empty Catch Block,ImageResizer.ExtensionMethods,StreamExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\Stream.cs,CopyToStream,The method has an empty catch block.
Empty Catch Block,ImageResizer.ExtensionMethods,StreamExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\Stream.cs,CopyToStream,The method has an empty catch block.
Empty Catch Block,ImageResizer.ExtensionMethods,StreamExtensions,F:\newReposMay17\imazen_resizer\Core\ExtensionMethods\Stream.cs,CopyMemoryStreamToBytes,The method has an empty catch block.
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,CheckRequest_PostAuthorizeRequest_Async,The following statement contains a magic number: if (result == HttpModuleRequestAssistant.PostAuthorizeResult.AccessDenied403) {  	ra.FireAccessDenied ();  	throw new ImageProcessingException (403' "Access denied"' "Access denied");  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,CheckRequest_PostAuthorizeRequest_Async,The following statement contains a magic number: throw new ImageProcessingException (403' "Access denied"' "Access denied");  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: e.CreateAndWriteResultAsync = async delegate (System.IO.Stream stream' IAsyncResponsePlan plan) {  	//This runs on a cache miss or cache invalid. This delegate is preventing from running in more  	//than one thread at a time for the specified cache key  	try {  		if (!ra.ProcessingIndicated) {  			//Just duplicate the data  			using (Stream source = await e.OpenSourceStreamAsync ())  				await source.CopyToAsync (stream);  			//4KiB buffer  		} else {  			//Handle I/O portions of work asynchronously.   			var j = new ImageJob ();  			j.Instructions = new Instructions (settings);  			j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  			var outBuffer = new MemoryStream (32 * 1024);  			j.Dest = outBuffer;  			MemoryStream inBuffer = null;  			using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  				inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  				await sourceStream.CopyToAsync (inBuffer);  			}  			inBuffer.Seek (0' SeekOrigin.Begin);  			j.Source = inBuffer;  			await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  			outBuffer.Seek (0' SeekOrigin.Begin);  			await outBuffer.CopyToAsync (stream);  		}  		ra.FireJobSuccess ();  		//Catch not found exceptions  	} catch (System.IO.FileNotFoundException notFound) {  		if (notFound.Message.Contains (" assembly "))  			throw;  		//If an assembly is missing' it should be a 500' not a 404  		//This will be called later' if at all.   		ra.FireMissing ();  		throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  	} catch (System.IO.DirectoryNotFoundException notFound) {  		ra.FireMissing ();  		throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  	} catch (Exception ex) {  		ra.FireJobException (ex);  		throw;  	}  };  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: e.CreateAndWriteResultAsync = async delegate (System.IO.Stream stream' IAsyncResponsePlan plan) {  	//This runs on a cache miss or cache invalid. This delegate is preventing from running in more  	//than one thread at a time for the specified cache key  	try {  		if (!ra.ProcessingIndicated) {  			//Just duplicate the data  			using (Stream source = await e.OpenSourceStreamAsync ())  				await source.CopyToAsync (stream);  			//4KiB buffer  		} else {  			//Handle I/O portions of work asynchronously.   			var j = new ImageJob ();  			j.Instructions = new Instructions (settings);  			j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  			var outBuffer = new MemoryStream (32 * 1024);  			j.Dest = outBuffer;  			MemoryStream inBuffer = null;  			using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  				inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  				await sourceStream.CopyToAsync (inBuffer);  			}  			inBuffer.Seek (0' SeekOrigin.Begin);  			j.Source = inBuffer;  			await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  			outBuffer.Seek (0' SeekOrigin.Begin);  			await outBuffer.CopyToAsync (stream);  		}  		ra.FireJobSuccess ();  		//Catch not found exceptions  	} catch (System.IO.FileNotFoundException notFound) {  		if (notFound.Message.Contains (" assembly "))  			throw;  		//If an assembly is missing' it should be a 500' not a 404  		//This will be called later' if at all.   		ra.FireMissing ();  		throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  	} catch (System.IO.DirectoryNotFoundException notFound) {  		ra.FireMissing ();  		throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  	} catch (Exception ex) {  		ra.FireJobException (ex);  		throw;  	}  };  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: e.CreateAndWriteResultAsync = async delegate (System.IO.Stream stream' IAsyncResponsePlan plan) {  	//This runs on a cache miss or cache invalid. This delegate is preventing from running in more  	//than one thread at a time for the specified cache key  	try {  		if (!ra.ProcessingIndicated) {  			//Just duplicate the data  			using (Stream source = await e.OpenSourceStreamAsync ())  				await source.CopyToAsync (stream);  			//4KiB buffer  		} else {  			//Handle I/O portions of work asynchronously.   			var j = new ImageJob ();  			j.Instructions = new Instructions (settings);  			j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  			var outBuffer = new MemoryStream (32 * 1024);  			j.Dest = outBuffer;  			MemoryStream inBuffer = null;  			using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  				inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  				await sourceStream.CopyToAsync (inBuffer);  			}  			inBuffer.Seek (0' SeekOrigin.Begin);  			j.Source = inBuffer;  			await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  			outBuffer.Seek (0' SeekOrigin.Begin);  			await outBuffer.CopyToAsync (stream);  		}  		ra.FireJobSuccess ();  		//Catch not found exceptions  	} catch (System.IO.FileNotFoundException notFound) {  		if (notFound.Message.Contains (" assembly "))  			throw;  		//If an assembly is missing' it should be a 500' not a 404  		//This will be called later' if at all.   		ra.FireMissing ();  		throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  	} catch (System.IO.DirectoryNotFoundException notFound) {  		ra.FireMissing ();  		throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  	} catch (Exception ex) {  		ra.FireJobException (ex);  		throw;  	}  };  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: e.CreateAndWriteResultAsync = async delegate (System.IO.Stream stream' IAsyncResponsePlan plan) {  	//This runs on a cache miss or cache invalid. This delegate is preventing from running in more  	//than one thread at a time for the specified cache key  	try {  		if (!ra.ProcessingIndicated) {  			//Just duplicate the data  			using (Stream source = await e.OpenSourceStreamAsync ())  				await source.CopyToAsync (stream);  			//4KiB buffer  		} else {  			//Handle I/O portions of work asynchronously.   			var j = new ImageJob ();  			j.Instructions = new Instructions (settings);  			j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  			var outBuffer = new MemoryStream (32 * 1024);  			j.Dest = outBuffer;  			MemoryStream inBuffer = null;  			using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  				inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  				await sourceStream.CopyToAsync (inBuffer);  			}  			inBuffer.Seek (0' SeekOrigin.Begin);  			j.Source = inBuffer;  			await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  			outBuffer.Seek (0' SeekOrigin.Begin);  			await outBuffer.CopyToAsync (stream);  		}  		ra.FireJobSuccess ();  		//Catch not found exceptions  	} catch (System.IO.FileNotFoundException notFound) {  		if (notFound.Message.Contains (" assembly "))  			throw;  		//If an assembly is missing' it should be a 500' not a 404  		//This will be called later' if at all.   		ra.FireMissing ();  		throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  	} catch (System.IO.DirectoryNotFoundException notFound) {  		ra.FireMissing ();  		throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  	} catch (Exception ex) {  		ra.FireJobException (ex);  		throw;  	}  };  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: try {  	if (!ra.ProcessingIndicated) {  		//Just duplicate the data  		using (Stream source = await e.OpenSourceStreamAsync ())  			await source.CopyToAsync (stream);  		//4KiB buffer  	} else {  		//Handle I/O portions of work asynchronously.   		var j = new ImageJob ();  		j.Instructions = new Instructions (settings);  		j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  		var outBuffer = new MemoryStream (32 * 1024);  		j.Dest = outBuffer;  		MemoryStream inBuffer = null;  		using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  			inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  			await sourceStream.CopyToAsync (inBuffer);  		}  		inBuffer.Seek (0' SeekOrigin.Begin);  		j.Source = inBuffer;  		await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  		outBuffer.Seek (0' SeekOrigin.Begin);  		await outBuffer.CopyToAsync (stream);  	}  	ra.FireJobSuccess ();  	//Catch not found exceptions  } catch (System.IO.FileNotFoundException notFound) {  	if (notFound.Message.Contains (" assembly "))  		throw;  	//If an assembly is missing' it should be a 500' not a 404  	//This will be called later' if at all.   	ra.FireMissing ();  	throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  } catch (System.IO.DirectoryNotFoundException notFound) {  	ra.FireMissing ();  	throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  } catch (Exception ex) {  	ra.FireJobException (ex);  	throw;  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: try {  	if (!ra.ProcessingIndicated) {  		//Just duplicate the data  		using (Stream source = await e.OpenSourceStreamAsync ())  			await source.CopyToAsync (stream);  		//4KiB buffer  	} else {  		//Handle I/O portions of work asynchronously.   		var j = new ImageJob ();  		j.Instructions = new Instructions (settings);  		j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  		var outBuffer = new MemoryStream (32 * 1024);  		j.Dest = outBuffer;  		MemoryStream inBuffer = null;  		using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  			inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  			await sourceStream.CopyToAsync (inBuffer);  		}  		inBuffer.Seek (0' SeekOrigin.Begin);  		j.Source = inBuffer;  		await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  		outBuffer.Seek (0' SeekOrigin.Begin);  		await outBuffer.CopyToAsync (stream);  	}  	ra.FireJobSuccess ();  	//Catch not found exceptions  } catch (System.IO.FileNotFoundException notFound) {  	if (notFound.Message.Contains (" assembly "))  		throw;  	//If an assembly is missing' it should be a 500' not a 404  	//This will be called later' if at all.   	ra.FireMissing ();  	throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  } catch (System.IO.DirectoryNotFoundException notFound) {  	ra.FireMissing ();  	throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  } catch (Exception ex) {  	ra.FireJobException (ex);  	throw;  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: try {  	if (!ra.ProcessingIndicated) {  		//Just duplicate the data  		using (Stream source = await e.OpenSourceStreamAsync ())  			await source.CopyToAsync (stream);  		//4KiB buffer  	} else {  		//Handle I/O portions of work asynchronously.   		var j = new ImageJob ();  		j.Instructions = new Instructions (settings);  		j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  		var outBuffer = new MemoryStream (32 * 1024);  		j.Dest = outBuffer;  		MemoryStream inBuffer = null;  		using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  			inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  			await sourceStream.CopyToAsync (inBuffer);  		}  		inBuffer.Seek (0' SeekOrigin.Begin);  		j.Source = inBuffer;  		await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  		outBuffer.Seek (0' SeekOrigin.Begin);  		await outBuffer.CopyToAsync (stream);  	}  	ra.FireJobSuccess ();  	//Catch not found exceptions  } catch (System.IO.FileNotFoundException notFound) {  	if (notFound.Message.Contains (" assembly "))  		throw;  	//If an assembly is missing' it should be a 500' not a 404  	//This will be called later' if at all.   	ra.FireMissing ();  	throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  } catch (System.IO.DirectoryNotFoundException notFound) {  	ra.FireMissing ();  	throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  } catch (Exception ex) {  	ra.FireJobException (ex);  	throw;  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: try {  	if (!ra.ProcessingIndicated) {  		//Just duplicate the data  		using (Stream source = await e.OpenSourceStreamAsync ())  			await source.CopyToAsync (stream);  		//4KiB buffer  	} else {  		//Handle I/O portions of work asynchronously.   		var j = new ImageJob ();  		j.Instructions = new Instructions (settings);  		j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  		var outBuffer = new MemoryStream (32 * 1024);  		j.Dest = outBuffer;  		MemoryStream inBuffer = null;  		using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  			inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  			await sourceStream.CopyToAsync (inBuffer);  		}  		inBuffer.Seek (0' SeekOrigin.Begin);  		j.Source = inBuffer;  		await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  		outBuffer.Seek (0' SeekOrigin.Begin);  		await outBuffer.CopyToAsync (stream);  	}  	ra.FireJobSuccess ();  	//Catch not found exceptions  } catch (System.IO.FileNotFoundException notFound) {  	if (notFound.Message.Contains (" assembly "))  		throw;  	//If an assembly is missing' it should be a 500' not a 404  	//This will be called later' if at all.   	ra.FireMissing ();  	throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  } catch (System.IO.DirectoryNotFoundException notFound) {  	ra.FireMissing ();  	throw new ImageMissingException ("The specified resource could not be located"' "File not found"' notFound);  } catch (Exception ex) {  	ra.FireJobException (ex);  	throw;  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: if (!ra.ProcessingIndicated) {  	//Just duplicate the data  	using (Stream source = await e.OpenSourceStreamAsync ())  		await source.CopyToAsync (stream);  	//4KiB buffer  } else {  	//Handle I/O portions of work asynchronously.   	var j = new ImageJob ();  	j.Instructions = new Instructions (settings);  	j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  	var outBuffer = new MemoryStream (32 * 1024);  	j.Dest = outBuffer;  	MemoryStream inBuffer = null;  	using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  		await sourceStream.CopyToAsync (inBuffer);  	}  	inBuffer.Seek (0' SeekOrigin.Begin);  	j.Source = inBuffer;  	await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  	outBuffer.Seek (0' SeekOrigin.Begin);  	await outBuffer.CopyToAsync (stream);  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: if (!ra.ProcessingIndicated) {  	//Just duplicate the data  	using (Stream source = await e.OpenSourceStreamAsync ())  		await source.CopyToAsync (stream);  	//4KiB buffer  } else {  	//Handle I/O portions of work asynchronously.   	var j = new ImageJob ();  	j.Instructions = new Instructions (settings);  	j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  	var outBuffer = new MemoryStream (32 * 1024);  	j.Dest = outBuffer;  	MemoryStream inBuffer = null;  	using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  		await sourceStream.CopyToAsync (inBuffer);  	}  	inBuffer.Seek (0' SeekOrigin.Begin);  	j.Source = inBuffer;  	await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  	outBuffer.Seek (0' SeekOrigin.Begin);  	await outBuffer.CopyToAsync (stream);  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: if (!ra.ProcessingIndicated) {  	//Just duplicate the data  	using (Stream source = await e.OpenSourceStreamAsync ())  		await source.CopyToAsync (stream);  	//4KiB buffer  } else {  	//Handle I/O portions of work asynchronously.   	var j = new ImageJob ();  	j.Instructions = new Instructions (settings);  	j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  	var outBuffer = new MemoryStream (32 * 1024);  	j.Dest = outBuffer;  	MemoryStream inBuffer = null;  	using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  		await sourceStream.CopyToAsync (inBuffer);  	}  	inBuffer.Seek (0' SeekOrigin.Begin);  	j.Source = inBuffer;  	await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  	outBuffer.Seek (0' SeekOrigin.Begin);  	await outBuffer.CopyToAsync (stream);  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: if (!ra.ProcessingIndicated) {  	//Just duplicate the data  	using (Stream source = await e.OpenSourceStreamAsync ())  		await source.CopyToAsync (stream);  	//4KiB buffer  } else {  	//Handle I/O portions of work asynchronously.   	var j = new ImageJob ();  	j.Instructions = new Instructions (settings);  	j.SourcePathData = vf != null ? vf.VirtualPath : ra.RewrittenVirtualPath;  	var outBuffer = new MemoryStream (32 * 1024);  	j.Dest = outBuffer;  	MemoryStream inBuffer = null;  	using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  		await sourceStream.CopyToAsync (inBuffer);  	}  	inBuffer.Seek (0' SeekOrigin.Begin);  	j.Source = inBuffer;  	await Task.Factory.StartNew (() => conf.GetImageBuilder ().Build (j)' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  	outBuffer.Seek (0' SeekOrigin.Begin);  	await outBuffer.CopyToAsync (stream);  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  	await sourceStream.CopyToAsync (inBuffer);  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: using (var sourceStream = vf != null ? await vf.OpenAsync () : File.Open (ra.RewrittenMappedPath' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  	await sourceStream.CopyToAsync (inBuffer);  }  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  
Magic Number,ImageResizer,AsyncInterceptModule,F:\newReposMay17\imazen_resizer\Core\AsyncInterceptModule.cs,HandleRequest,The following statement contains a magic number: inBuffer = new MemoryStream (sourceStream.CanSeek ? (int)sourceStream.Length : 128 * 1024);  
Magic Number,ImageResizer,BoxEdges,F:\newReposMay17\imazen_resizer\Core\BoxEdges.cs,Parse,The following statement contains a magic number: if (coords.Length == 4)  	return new BoxEdges (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer,BoxEdges,F:\newReposMay17\imazen_resizer\Core\BoxEdges.cs,Parse,The following statement contains a magic number: if (coords.Length == 4)  	return new BoxEdges (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer,BoxEdges,F:\newReposMay17\imazen_resizer\Core\BoxEdges.cs,Parse,The following statement contains a magic number: if (coords.Length == 4)  	return new BoxEdges (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer,BoxEdges,F:\newReposMay17\imazen_resizer\Core\BoxEdges.cs,Parse,The following statement contains a magic number: return new BoxEdges (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer,BoxEdges,F:\newReposMay17\imazen_resizer\Core\BoxEdges.cs,Parse,The following statement contains a magic number: return new BoxEdges (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PostDecodeStream,The following statement contains a magic number: if (total == 8)  	b.RotateFlip (RotateFlipType.Rotate270FlipNone);  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PostDecodeStream,The following statement contains a magic number: if (total == 3)  	b.RotateFlip (RotateFlipType.Rotate180FlipNone);  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PostDecodeStream,The following statement contains a magic number: if (total == 6)  	b.RotateFlip (RotateFlipType.Rotate90FlipNone);  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PostDecodeStream,The following statement contains a magic number: if (total == 2)  	b.RotateFlip (RotateFlipType.RotateNoneFlipX);  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PostDecodeStream,The following statement contains a magic number: if (total == 4)  	b.RotateFlip (RotateFlipType.Rotate180FlipX);  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PostDecodeStream,The following statement contains a magic number: if (total == 5)  	b.RotateFlip (RotateFlipType.Rotate270FlipY);  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,PostDecodeStream,The following statement contains a magic number: if (total == 7)  	b.RotateFlip (RotateFlipType.Rotate90FlipY);  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBorder,The following statement contains a magic number: if (double.IsNaN (s.settings.Border.All)) {  	float[] widths = new float[] {  		(float)s.settings.Border.Top * -1'  		(float)s.settings.Border.Right * -1'  		(float)s.settings.Border.Bottom * -1'  		(float)s.settings.Border.Left * -1  	};  	PointF['] corners = PolygonMath.GetCorners (s.layout ["border"]' widths);  	for (int i = 0; i <= corners.GetUpperBound (0); i++) {  		int last = i == 0 ? corners.GetUpperBound (0) : i - 1;  		PointF start = PolygonMath.Average (corners [last' 3]' corners [last' 0]);  		PointF end = PolygonMath.Average (corners [i' 0]' corners [i' 1]);  		using (Pen p = new Pen (s.settings.BorderColor' widths [i < 1 ? 3 : i - 1] * -1)) {  			p.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;  			//PenAlignment.Center is the only supported mode.  			p.LineJoin = System.Drawing.Drawing2D.LineJoin.Miter;  			s.destGraphics.DrawLine (p' start' end);  		}  	}  } else {  	using (Pen p = new Pen (s.settings.BorderColor' (float)s.settings.Border.All)) {  		p.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;  		//PenAlignment.Center is the only supported mode.  		p.LineJoin = System.Drawing.Drawing2D.LineJoin.Miter;  		s.destGraphics.DrawPolygon (p' PolygonMath.InflatePoly (s.layout ["border"]' (float)(s.settings.Border.All / -2.0)));  		//I hope GDI rounds the same way as .NET.. Otherwise there may be an off-by-one error..  	}  }  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBorder,The following statement contains a magic number: if (double.IsNaN (s.settings.Border.All)) {  	float[] widths = new float[] {  		(float)s.settings.Border.Top * -1'  		(float)s.settings.Border.Right * -1'  		(float)s.settings.Border.Bottom * -1'  		(float)s.settings.Border.Left * -1  	};  	PointF['] corners = PolygonMath.GetCorners (s.layout ["border"]' widths);  	for (int i = 0; i <= corners.GetUpperBound (0); i++) {  		int last = i == 0 ? corners.GetUpperBound (0) : i - 1;  		PointF start = PolygonMath.Average (corners [last' 3]' corners [last' 0]);  		PointF end = PolygonMath.Average (corners [i' 0]' corners [i' 1]);  		using (Pen p = new Pen (s.settings.BorderColor' widths [i < 1 ? 3 : i - 1] * -1)) {  			p.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;  			//PenAlignment.Center is the only supported mode.  			p.LineJoin = System.Drawing.Drawing2D.LineJoin.Miter;  			s.destGraphics.DrawLine (p' start' end);  		}  	}  } else {  	using (Pen p = new Pen (s.settings.BorderColor' (float)s.settings.Border.All)) {  		p.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;  		//PenAlignment.Center is the only supported mode.  		p.LineJoin = System.Drawing.Drawing2D.LineJoin.Miter;  		s.destGraphics.DrawPolygon (p' PolygonMath.InflatePoly (s.layout ["border"]' (float)(s.settings.Border.All / -2.0)));  		//I hope GDI rounds the same way as .NET.. Otherwise there may be an off-by-one error..  	}  }  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBorder,The following statement contains a magic number: if (double.IsNaN (s.settings.Border.All)) {  	float[] widths = new float[] {  		(float)s.settings.Border.Top * -1'  		(float)s.settings.Border.Right * -1'  		(float)s.settings.Border.Bottom * -1'  		(float)s.settings.Border.Left * -1  	};  	PointF['] corners = PolygonMath.GetCorners (s.layout ["border"]' widths);  	for (int i = 0; i <= corners.GetUpperBound (0); i++) {  		int last = i == 0 ? corners.GetUpperBound (0) : i - 1;  		PointF start = PolygonMath.Average (corners [last' 3]' corners [last' 0]);  		PointF end = PolygonMath.Average (corners [i' 0]' corners [i' 1]);  		using (Pen p = new Pen (s.settings.BorderColor' widths [i < 1 ? 3 : i - 1] * -1)) {  			p.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;  			//PenAlignment.Center is the only supported mode.  			p.LineJoin = System.Drawing.Drawing2D.LineJoin.Miter;  			s.destGraphics.DrawLine (p' start' end);  		}  	}  } else {  	using (Pen p = new Pen (s.settings.BorderColor' (float)s.settings.Border.All)) {  		p.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;  		//PenAlignment.Center is the only supported mode.  		p.LineJoin = System.Drawing.Drawing2D.LineJoin.Miter;  		s.destGraphics.DrawPolygon (p' PolygonMath.InflatePoly (s.layout ["border"]' (float)(s.settings.Border.All / -2.0)));  		//I hope GDI rounds the same way as .NET.. Otherwise there may be an off-by-one error..  	}  }  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBorder,The following statement contains a magic number: for (int i = 0; i <= corners.GetUpperBound (0); i++) {  	int last = i == 0 ? corners.GetUpperBound (0) : i - 1;  	PointF start = PolygonMath.Average (corners [last' 3]' corners [last' 0]);  	PointF end = PolygonMath.Average (corners [i' 0]' corners [i' 1]);  	using (Pen p = new Pen (s.settings.BorderColor' widths [i < 1 ? 3 : i - 1] * -1)) {  		p.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;  		//PenAlignment.Center is the only supported mode.  		p.LineJoin = System.Drawing.Drawing2D.LineJoin.Miter;  		s.destGraphics.DrawLine (p' start' end);  	}  }  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBorder,The following statement contains a magic number: for (int i = 0; i <= corners.GetUpperBound (0); i++) {  	int last = i == 0 ? corners.GetUpperBound (0) : i - 1;  	PointF start = PolygonMath.Average (corners [last' 3]' corners [last' 0]);  	PointF end = PolygonMath.Average (corners [i' 0]' corners [i' 1]);  	using (Pen p = new Pen (s.settings.BorderColor' widths [i < 1 ? 3 : i - 1] * -1)) {  		p.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;  		//PenAlignment.Center is the only supported mode.  		p.LineJoin = System.Drawing.Drawing2D.LineJoin.Miter;  		s.destGraphics.DrawLine (p' start' end);  	}  }  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBorder,The following statement contains a magic number: using (Pen p = new Pen (s.settings.BorderColor' widths [i < 1 ? 3 : i - 1] * -1)) {  	p.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;  	//PenAlignment.Center is the only supported mode.  	p.LineJoin = System.Drawing.Drawing2D.LineJoin.Miter;  	s.destGraphics.DrawLine (p' start' end);  }  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBorder,The following statement contains a magic number: using (Pen p = new Pen (s.settings.BorderColor' (float)s.settings.Border.All)) {  	p.Alignment = System.Drawing.Drawing2D.PenAlignment.Center;  	//PenAlignment.Center is the only supported mode.  	p.LineJoin = System.Drawing.Drawing2D.LineJoin.Miter;  	s.destGraphics.DrawPolygon (p' PolygonMath.InflatePoly (s.layout ["border"]' (float)(s.settings.Border.All / -2.0)));  	//I hope GDI rounds the same way as .NET.. Otherwise there may be an off-by-one error..  }  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,RenderBorder,The following statement contains a magic number: s.destGraphics.DrawPolygon (p' PolygonMath.InflatePoly (s.layout ["border"]' (float)(s.settings.Border.All / -2.0)));  
Magic Number,ImageResizer,ImageBuilder,F:\newReposMay17\imazen_resizer\Core\ImageBuilder.cs,ProcessFinalBitmap,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["dpi"])) {  	int dpi = s.settings.Get<int> ("dpi"' 96);  	s.destBitmap.SetResolution (dpi' dpi);  }  
Magic Number,ImageResizer,InterceptModule,F:\newReposMay17\imazen_resizer\Core\InterceptModule.cs,CheckRequest_PostAuthorizeRequest,The following statement contains a magic number: if (result == HttpModuleRequestAssistant.PostAuthorizeResult.AccessDenied403) {  	ra.FireAccessDenied ();  	throw new ImageProcessingException (403' "Access denied"' "Access denied");  }  
Magic Number,ImageResizer,InterceptModule,F:\newReposMay17\imazen_resizer\Core\InterceptModule.cs,CheckRequest_PostAuthorizeRequest,The following statement contains a magic number: throw new ImageProcessingException (403' "Access denied"' "Access denied");  
Magic Number,ImageResizer.Configuration.Performance,AddMulModHash,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\AddMulModHash.cs,AddMulModHash,The following statement contains a magic number: this.a = (ulong)(r.NextDouble () * (prime - 2)) + 1;  
Magic Number,ImageResizer.Configuration.Performance,AddMulModHash,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\AddMulModHash.cs,AddMulModHash,The following statement contains a magic number: this.b = (ulong)(r.NextDouble () * (prime - 2)) + 1;  
Magic Number,ImageResizer.Configuration.Performance,AddMulModHash,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\AddMulModHash.cs,DeterministicDefault,The following statement contains a magic number: return new AddMulModHash (new MersenneTwister (1499840347));  
Magic Number,ImageResizer.Configuration.Performance,CircularTimeBuffer,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\RateTracking\CircularTimeBuffer.cs,CircularTimeBuffer,The following statement contains a magic number: maxResultQueueLength = buckets * 3;  
Magic Number,ImageResizer.Configuration.Performance,DictionaryCounter,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\DictionaryCounter.cs,GetOrAddInternal,The following statement contains a magic number: for (var retryCount = 0; retryCount < 10; retryCount++) {  	Counter result;  	if (dict.TryGetValue (key' out result)) {  		return result;  	} else {  		if (!applyLimitSwap) {  			count.Increment ();  			var newValue = new Counter (initialValue);  			result = dict.GetOrAdd (key' newValue);  			if (result != newValue) {  				count.Decrement ();  			}  			return result;  		} else {  			var existingSize = count.Value;  			if (existingSize < MaxKeyCount) {  				if (count.IncrementIfMatches (existingSize)) {  					var newValue = new Counter (initialValue);  					result = dict.GetOrAdd (key' newValue);  					if (result != newValue) {  						count.Decrement ();  					}  					return result;  				} else {  					continue;  					//Let's retry  				}  			} else {  				return otherCount;  			}  		}  	}  }  
Magic Number,ImageResizer.Configuration.Performance,CpuInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\CpuInfo.cs,Invoke,The following statement contains a magic number: try {  	// compile  	byte[] codeBytes = IntPtr.Size == 4 ? X86CodeBytes : X64CodeBytes;  	codePointer = VirtualAlloc (IntPtr.Zero' new UIntPtr ((uint)codeBytes.Length)' AllocationType.Commit | AllocationType.Reserve' MemoryProtection.ExecuteReadwrite);  	Marshal.Copy (codeBytes' 0' codePointer' codeBytes.Length);  	var cpuIdDelg = (CpuIdDelegate)Marshal.GetDelegateForFunctionPointer (codePointer' typeof(CpuIdDelegate));  	// invoke  	var handle = default(GCHandle);  	var buffer = new byte[16];  	try {  		handle = GCHandle.Alloc (buffer' GCHandleType.Pinned);  		cpuIdDelg (level' buffer);  	} finally {  		if (handle != default(GCHandle)) {  			handle.Free ();  		}  	}  	return buffer;  } finally {  	if (codePointer != IntPtr.Zero) {  		VirtualFree (codePointer' 0' 0x8000);  		codePointer = IntPtr.Zero;  	}  }  
Magic Number,ImageResizer.Configuration.Performance,CpuInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\CpuInfo.cs,Invoke,The following statement contains a magic number: try {  	// compile  	byte[] codeBytes = IntPtr.Size == 4 ? X86CodeBytes : X64CodeBytes;  	codePointer = VirtualAlloc (IntPtr.Zero' new UIntPtr ((uint)codeBytes.Length)' AllocationType.Commit | AllocationType.Reserve' MemoryProtection.ExecuteReadwrite);  	Marshal.Copy (codeBytes' 0' codePointer' codeBytes.Length);  	var cpuIdDelg = (CpuIdDelegate)Marshal.GetDelegateForFunctionPointer (codePointer' typeof(CpuIdDelegate));  	// invoke  	var handle = default(GCHandle);  	var buffer = new byte[16];  	try {  		handle = GCHandle.Alloc (buffer' GCHandleType.Pinned);  		cpuIdDelg (level' buffer);  	} finally {  		if (handle != default(GCHandle)) {  			handle.Free ();  		}  	}  	return buffer;  } finally {  	if (codePointer != IntPtr.Zero) {  		VirtualFree (codePointer' 0' 0x8000);  		codePointer = IntPtr.Zero;  	}  }  
Magic Number,ImageResizer.Configuration.Performance,HardwareInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\HardwareInfo.cs,HardwareInfo,The following statement contains a magic number: try {  	var sortedMacAddresses = NetworkInterface.GetAllNetworkInterfaces ().Select (nic => nic.GetPhysicalAddress ().ToString ().ToLowerInvariant ()).OrderBy (s => s).ToArray ();  	MachineDigest = Utilities.Sha256TruncatedBase64 (string.Join ("|"' sortedMacAddresses)' 16);  } catch (NetworkInformationException e) {  	sink.AcceptIssue (new Issue ("Failed to query network interface. Function not affected."' e.ToString ()' IssueSeverity.Warning));  	MachineDigest = "none";  }  
Magic Number,ImageResizer.Configuration.Performance,HardwareInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\HardwareInfo.cs,HardwareInfo,The following statement contains a magic number: MachineDigest = Utilities.Sha256TruncatedBase64 (string.Join ("|"' sortedMacAddresses)' 16);  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,init_genrand,The following statement contains a magic number: for (mti = 1; mti < N; mti++) {  	mt [mti] = (1812433253UL * (mt [mti - 1] ^ (mt [mti - 1] >> 30)) + (ulong)mti);  	/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. *//* In the previous versions' MSBs of the seed affect   *//* only MSBs of the array mt[].                        *//* 2002/01/09 modified by Makoto Matsumoto             */mt [mti] &= 0xffffffffUL;  	/* for >32 bit machines */}  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,init_genrand,The following statement contains a magic number: mt [mti] = (1812433253UL * (mt [mti - 1] ^ (mt [mti - 1] >> 30)) + (ulong)mti);  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,init_by_array,The following statement contains a magic number: for (; k != 0; k--) {  	mt [i] = (mt [i] ^ ((mt [i - 1] ^ (mt [i - 1] >> 30)) * 1664525UL)) + init_key [j] + (ulong)j;  	/* non linear */mt [i] &= 0xffffffffUL;  	/* for WORDSIZE > 32 machines */i++;  	j++;  	if (i >= N) {  		mt [0] = mt [N - 1];  		i = 1;  	}  	if (j >= init_key.Length) {  		j = 0;  	}  }  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,init_by_array,The following statement contains a magic number: mt [i] = (mt [i] ^ ((mt [i - 1] ^ (mt [i - 1] >> 30)) * 1664525UL)) + init_key [j] + (ulong)j;  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,init_by_array,The following statement contains a magic number: for (k = N - 1; k != 0; k--) {  	mt [i] = (mt [i] ^ ((mt [i - 1] ^ (mt [i - 1] >> 30)) * 1566083941UL)) - (ulong)i;  	// non linear  	mt [i] &= 0xffffffffUL;  	// for WORDSIZE > 32 machines  	i++;  	if (i >= N) {  		mt [0] = mt [N - 1];  		i = 1;  	}  }  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,init_by_array,The following statement contains a magic number: mt [i] = (mt [i] ^ ((mt [i - 1] ^ (mt [i - 1] >> 30)) * 1566083941UL)) - (ulong)i;  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,NextUint32,The following statement contains a magic number: y ^= (y >> 11);  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,NextUint32,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680UL;  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,NextUint32,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000UL;  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,NextUint32,The following statement contains a magic number: y ^= (y >> 18);  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,genrand_real1,The following statement contains a magic number: return NextUint32 () * (1.0 / 4294967295.0);  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,NextDouble,The following statement contains a magic number: return NextUint32 () * (1.0 / 4294967296.0);  
Magic Number,ImageResizer.Configuration.Performance,MersenneTwister,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\MersenneTwister.cs,genrand_N,The following statement contains a magic number: return (int)(NextUint32 () * (iN / 4294967296.0));  
Magic Number,ImageResizer.Configuration.Performance,PixelCountSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\PixelCountSink.cs,PixelCountSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 1000000 * 400'  	//400 megapixels  	Segments = new[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 100000  		}'  		// 0.1mp up to 8mp (80)  		new SegmentPrecision {  			Above = 8000000'  			Loss = 500000  		}'  		// 0.5mp up to 40mp (64)  		new SegmentPrecision {  			Above = 40000000'  			Loss = 5000000  		}  	//5mp (~100)  	}  };  
Magic Number,ImageResizer.Configuration.Performance,PixelCountSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\PixelCountSink.cs,PixelCountSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 1000000 * 400'  	//400 megapixels  	Segments = new[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 100000  		}'  		// 0.1mp up to 8mp (80)  		new SegmentPrecision {  			Above = 8000000'  			Loss = 500000  		}'  		// 0.5mp up to 40mp (64)  		new SegmentPrecision {  			Above = 40000000'  			Loss = 5000000  		}  	//5mp (~100)  	}  };  
Magic Number,ImageResizer.Configuration.Performance,PixelCountSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\PixelCountSink.cs,PixelCountSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 1000000 * 400'  	//400 megapixels  	Segments = new[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 100000  		}'  		// 0.1mp up to 8mp (80)  		new SegmentPrecision {  			Above = 8000000'  			Loss = 500000  		}'  		// 0.5mp up to 40mp (64)  		new SegmentPrecision {  			Above = 40000000'  			Loss = 5000000  		}  	//5mp (~100)  	}  };  
Magic Number,ImageResizer.Configuration.Performance,PixelCountSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\PixelCountSink.cs,PixelCountSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 1000000 * 400'  	//400 megapixels  	Segments = new[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 100000  		}'  		// 0.1mp up to 8mp (80)  		new SegmentPrecision {  			Above = 8000000'  			Loss = 500000  		}'  		// 0.5mp up to 40mp (64)  		new SegmentPrecision {  			Above = 40000000'  			Loss = 5000000  		}  	//5mp (~100)  	}  };  
Magic Number,ImageResizer.Configuration.Performance,PixelCountSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\PixelCountSink.cs,PixelCountSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 1000000 * 400'  	//400 megapixels  	Segments = new[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 100000  		}'  		// 0.1mp up to 8mp (80)  		new SegmentPrecision {  			Above = 8000000'  			Loss = 500000  		}'  		// 0.5mp up to 40mp (64)  		new SegmentPrecision {  			Above = 40000000'  			Loss = 5000000  		}  	//5mp (~100)  	}  };  
Magic Number,ImageResizer.Configuration.Performance,PixelCountSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\PixelCountSink.cs,PixelCountSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 1000000 * 400'  	//400 megapixels  	Segments = new[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 100000  		}'  		// 0.1mp up to 8mp (80)  		new SegmentPrecision {  			Above = 8000000'  			Loss = 500000  		}'  		// 0.5mp up to 40mp (64)  		new SegmentPrecision {  			Above = 40000000'  			Loss = 5000000  		}  	//5mp (~100)  	}  };  
Magic Number,ImageResizer.Configuration.Performance,PixelCountSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\PixelCountSink.cs,PixelCountSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 1000000 * 400'  	//400 megapixels  	Segments = new[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 100000  		}'  		// 0.1mp up to 8mp (80)  		new SegmentPrecision {  			Above = 8000000'  			Loss = 500000  		}'  		// 0.5mp up to 40mp (64)  		new SegmentPrecision {  			Above = 40000000'  			Loss = 5000000  		}  	//5mp (~100)  	}  };  
Magic Number,ImageResizer.Configuration.Performance,ResolutionsSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\ResolutionsSink.cs,ResolutionsSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 16000'  	Segments = new SegmentPrecision[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 8  		}'  		new SegmentPrecision {  			Above = 600'  			Loss = 16  		}'  		new SegmentPrecision {  			Above = 3200'  			Loss = 100  		}  	}  };  
Magic Number,ImageResizer.Configuration.Performance,ResolutionsSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\ResolutionsSink.cs,ResolutionsSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 16000'  	Segments = new SegmentPrecision[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 8  		}'  		new SegmentPrecision {  			Above = 600'  			Loss = 16  		}'  		new SegmentPrecision {  			Above = 3200'  			Loss = 100  		}  	}  };  
Magic Number,ImageResizer.Configuration.Performance,ResolutionsSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\ResolutionsSink.cs,ResolutionsSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 16000'  	Segments = new SegmentPrecision[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 8  		}'  		new SegmentPrecision {  			Above = 600'  			Loss = 16  		}'  		new SegmentPrecision {  			Above = 3200'  			Loss = 100  		}  	}  };  
Magic Number,ImageResizer.Configuration.Performance,ResolutionsSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\ResolutionsSink.cs,ResolutionsSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 16000'  	Segments = new SegmentPrecision[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 8  		}'  		new SegmentPrecision {  			Above = 600'  			Loss = 16  		}'  		new SegmentPrecision {  			Above = 3200'  			Loss = 100  		}  	}  };  
Magic Number,ImageResizer.Configuration.Performance,ResolutionsSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\ResolutionsSink.cs,ResolutionsSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 16000'  	Segments = new SegmentPrecision[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 8  		}'  		new SegmentPrecision {  			Above = 600'  			Loss = 16  		}'  		new SegmentPrecision {  			Above = 3200'  			Loss = 100  		}  	}  };  
Magic Number,ImageResizer.Configuration.Performance,ResolutionsSink,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\PercentileSinks\ResolutionsSink.cs,ResolutionsSink,The following statement contains a magic number: clamp = new SegmentClamping () {  	MinValue = 0'  	MaxValue = 16000'  	Segments = new SegmentPrecision[] {  		new SegmentPrecision {  			Above = 0'  			Loss = 8  		}'  		new SegmentPrecision {  			Above = 600'  			Loss = 16  		}'  		new SegmentPrecision {  			Above = 3200'  			Loss = 100  		}  	}  };  
Magic Number,ImageResizer.Configuration.Performance,PerIntervalSampling,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\RateTracking\PerIntervalSampling.cs,PerIntervalSampling,The following statement contains a magic number: for (var ix = 0; ix < RingCount; ix++) {  	var offset = (long)Math.Round (ix * 0.1 * intervalTicks);  	offsets [ix] = offset;  	rings [ix] = new CircularTimeBuffer (intervalTicks' buckets);  }  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,DurationClamping,The following statement contains a magic number: MaxValue = 600 * 1000 * 1000;  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,DurationClamping,The following statement contains a magic number: MaxValue = 600 * 1000 * 1000;  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,DurationClamping,The following statement contains a magic number: MaxValue = 600 * 1000 * 1000;  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.MaxValue = 600 * 1000 * 1000;  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.MaxValue = 600 * 1000 * 1000;  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.MaxValue = 600 * 1000 * 1000;  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,Default600Seconds,The following statement contains a magic number: d.Segments = new[] {  	new SegmentPrecision {  		Above = 0'  		Loss = 100  	}'  	//0.0-20.0ms (0.1ms) (200 distinct)  	new SegmentPrecision {  		Above = 20000'  		Loss = 1000  	}'  	//20-200ms (1ms) (180 distinct)  	new SegmentPrecision {  		Above = 200000'  		Loss = 10000  	}'  	//200-1000ms (10ms) (80 distinct)  	new SegmentPrecision {  		Above = 1000000'  		Loss = 50000  	}'  	//1000ms-10sec? (50ms) (200 distinct)  	new SegmentPrecision {  		Above = 10000000'  		Loss = 1000000  	}'  	//10s-100s (1000ms) (90 distinct)  	new SegmentPrecision {  		Above = 100000000'  		Loss = 50000000  	}'  //100s-600s? (50s) (10 distinct)  };  
Magic Number,ImageResizer.Configuration.Performance,DurationClamping,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Clamping\DurationClamping.cs,ClampStopwatchTicksToMicroseconds,The following statement contains a magic number: return ClampMicroseconds (ticks * 1000000 / Stopwatch.Frequency);  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GlobalPerf,The following statement contains a magic number: scalingRatios = percentiles.GetOrAdd ("scaling_ratio"' new FlatSink (1000));  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GlobalPerf,The following statement contains a magic number: sourceAspectRatios = percentiles.GetOrAdd ("source_aspect_ratio"' new FlatSink (1000));  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GlobalPerf,The following statement contains a magic number: outputAspectRatios = percentiles.GetOrAdd ("output_aspect_ratio"' new FlatSink (1000));  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (job.SourceWidth.HasValue && job.SourceHeight.HasValue) {  	var prefix = "source_multiple_";  	if (s_w % 4 == 0 && s_h % 4 == 0) {  		counters.Increment (prefix + "4x4");  	}  	if (s_w % 8 == 0 && s_h % 8 == 0) {  		counters.Increment (prefix + "8x8");  	}  	if (s_w % 8 == 0) {  		counters.Increment (prefix + "8x");  	}  	if (s_h % 8 == 0) {  		counters.Increment (prefix + "x8");  	}  	if (s_w % 16 == 0 && s_h % 16 == 0) {  		counters.Increment (prefix + "16x16");  	}  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (job.SourceWidth.HasValue && job.SourceHeight.HasValue) {  	var prefix = "source_multiple_";  	if (s_w % 4 == 0 && s_h % 4 == 0) {  		counters.Increment (prefix + "4x4");  	}  	if (s_w % 8 == 0 && s_h % 8 == 0) {  		counters.Increment (prefix + "8x8");  	}  	if (s_w % 8 == 0) {  		counters.Increment (prefix + "8x");  	}  	if (s_h % 8 == 0) {  		counters.Increment (prefix + "x8");  	}  	if (s_w % 16 == 0 && s_h % 16 == 0) {  		counters.Increment (prefix + "16x16");  	}  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (job.SourceWidth.HasValue && job.SourceHeight.HasValue) {  	var prefix = "source_multiple_";  	if (s_w % 4 == 0 && s_h % 4 == 0) {  		counters.Increment (prefix + "4x4");  	}  	if (s_w % 8 == 0 && s_h % 8 == 0) {  		counters.Increment (prefix + "8x8");  	}  	if (s_w % 8 == 0) {  		counters.Increment (prefix + "8x");  	}  	if (s_h % 8 == 0) {  		counters.Increment (prefix + "x8");  	}  	if (s_w % 16 == 0 && s_h % 16 == 0) {  		counters.Increment (prefix + "16x16");  	}  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (job.SourceWidth.HasValue && job.SourceHeight.HasValue) {  	var prefix = "source_multiple_";  	if (s_w % 4 == 0 && s_h % 4 == 0) {  		counters.Increment (prefix + "4x4");  	}  	if (s_w % 8 == 0 && s_h % 8 == 0) {  		counters.Increment (prefix + "8x8");  	}  	if (s_w % 8 == 0) {  		counters.Increment (prefix + "8x");  	}  	if (s_h % 8 == 0) {  		counters.Increment (prefix + "x8");  	}  	if (s_w % 16 == 0 && s_h % 16 == 0) {  		counters.Increment (prefix + "16x16");  	}  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (job.SourceWidth.HasValue && job.SourceHeight.HasValue) {  	var prefix = "source_multiple_";  	if (s_w % 4 == 0 && s_h % 4 == 0) {  		counters.Increment (prefix + "4x4");  	}  	if (s_w % 8 == 0 && s_h % 8 == 0) {  		counters.Increment (prefix + "8x8");  	}  	if (s_w % 8 == 0) {  		counters.Increment (prefix + "8x");  	}  	if (s_h % 8 == 0) {  		counters.Increment (prefix + "x8");  	}  	if (s_w % 16 == 0 && s_h % 16 == 0) {  		counters.Increment (prefix + "16x16");  	}  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (job.SourceWidth.HasValue && job.SourceHeight.HasValue) {  	var prefix = "source_multiple_";  	if (s_w % 4 == 0 && s_h % 4 == 0) {  		counters.Increment (prefix + "4x4");  	}  	if (s_w % 8 == 0 && s_h % 8 == 0) {  		counters.Increment (prefix + "8x8");  	}  	if (s_w % 8 == 0) {  		counters.Increment (prefix + "8x");  	}  	if (s_h % 8 == 0) {  		counters.Increment (prefix + "x8");  	}  	if (s_w % 16 == 0 && s_h % 16 == 0) {  		counters.Increment (prefix + "16x16");  	}  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (job.SourceWidth.HasValue && job.SourceHeight.HasValue) {  	var prefix = "source_multiple_";  	if (s_w % 4 == 0 && s_h % 4 == 0) {  		counters.Increment (prefix + "4x4");  	}  	if (s_w % 8 == 0 && s_h % 8 == 0) {  		counters.Increment (prefix + "8x8");  	}  	if (s_w % 8 == 0) {  		counters.Increment (prefix + "8x");  	}  	if (s_h % 8 == 0) {  		counters.Increment (prefix + "x8");  	}  	if (s_w % 16 == 0 && s_h % 16 == 0) {  		counters.Increment (prefix + "16x16");  	}  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (job.SourceWidth.HasValue && job.SourceHeight.HasValue) {  	var prefix = "source_multiple_";  	if (s_w % 4 == 0 && s_h % 4 == 0) {  		counters.Increment (prefix + "4x4");  	}  	if (s_w % 8 == 0 && s_h % 8 == 0) {  		counters.Increment (prefix + "8x8");  	}  	if (s_w % 8 == 0) {  		counters.Increment (prefix + "8x");  	}  	if (s_h % 8 == 0) {  		counters.Increment (prefix + "x8");  	}  	if (s_w % 16 == 0 && s_h % 16 == 0) {  		counters.Increment (prefix + "16x16");  	}  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (s_w % 4 == 0 && s_h % 4 == 0) {  	counters.Increment (prefix + "4x4");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (s_w % 4 == 0 && s_h % 4 == 0) {  	counters.Increment (prefix + "4x4");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (s_w % 8 == 0 && s_h % 8 == 0) {  	counters.Increment (prefix + "8x8");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (s_w % 8 == 0 && s_h % 8 == 0) {  	counters.Increment (prefix + "8x8");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (s_w % 8 == 0) {  	counters.Increment (prefix + "8x");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (s_h % 8 == 0) {  	counters.Increment (prefix + "x8");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (s_w % 16 == 0 && s_h % 16 == 0) {  	counters.Increment (prefix + "16x16");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (s_w % 16 == 0 && s_h % 16 == 0) {  	counters.Increment (prefix + "16x16");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (readPixels > 0) {  	sourceMegapixels.Report (readPixels);  	sourceWidths.Report (s_w);  	sourceHeights.Report (s_h);  	sourceAspectRatios.Report (s_w * 100 / s_h);  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: sourceAspectRatios.Report (s_w * 100 / s_h);  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (wrotePixels > 0) {  	outputMegapixels.Report (wrotePixels);  	outputWidths.Report (f_w);  	outputHeights.Report (f_h);  	outputAspectRatios.Report (f_w * 100 / f_h);  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: outputAspectRatios.Report (f_w * 100 / f_h);  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (readPixels > 0 && wrotePixels > 0) {  	scalingRatios.Report (s_w * 100 / f_w);  	scalingRatios.Report (s_h * 100 / f_h);  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: if (readPixels > 0 && wrotePixels > 0) {  	scalingRatios.Report (s_w * 100 / f_w);  	scalingRatios.Report (s_h * 100 / f_h);  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: scalingRatios.Report (s_w * 100 / f_w);  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,JobComplete,The following statement contains a magic number: scalingRatios.Report (s_h * 100 / f_h);  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,NoticeDomains,The following statement contains a magic number: if (image_domain != null) {  	CountLimitedUniqueValuesIgnoreCase ("image_domains"' image_domain' 45' "_other_");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,NoticeDomains,The following statement contains a magic number: CountLimitedUniqueValuesIgnoreCase ("image_domains"' image_domain' 45' "_other_");  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,NoticeDomains,The following statement contains a magic number: if (page_domain != null) {  	CountLimitedUniqueValuesIgnoreCase ("page_domains"' page_domain' 45' "_other_");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,NoticeDomains,The following statement contains a magic number: CountLimitedUniqueValuesIgnoreCase ("page_domains"' page_domain' 45' "_other_");  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,PostJobQuery,The following statement contains a magic number: foreach (var key in q.AllKeys) {  	if (key != null) {  		CountLimitedUniqueValuesIgnoreCase ("job_query_keys"' key' 100' "_other_");  	}  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,PostJobQuery,The following statement contains a magic number: if (key != null) {  	CountLimitedUniqueValuesIgnoreCase ("job_query_keys"' key' 100' "_other_");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,PostJobQuery,The following statement contains a magic number: CountLimitedUniqueValuesIgnoreCase ("job_query_keys"' key' 100' "_other_");  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,PreRewriteQuery,The following statement contains a magic number: foreach (var key in q.AllKeys) {  	if (key != null) {  		CountLimitedUniqueValuesIgnoreCase ("original_query_keys"' key' 100' "_other_");  	}  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,PreRewriteQuery,The following statement contains a magic number: if (key != null) {  	CountLimitedUniqueValuesIgnoreCase ("original_query_keys"' key' 100' "_other_");  }  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,PreRewriteQuery,The following statement contains a magic number: CountLimitedUniqueValuesIgnoreCase ("original_query_keys"' key' 100' "_other_");  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GetReportPairs,The following statement contains a magic number: q.Add ("reporting_version"' 3);  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GetReportPairs,The following statement contains a magic number: q.Add ("image_domains"' string.Join ("'"' GetPopularUniqueValues ("image_domains"' 8)));  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GetReportPairs,The following statement contains a magic number: q.Add ("page_domains"' string.Join ("'"' GetPopularUniqueValues ("page_domains"' 8)));  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GetReportPairs,The following statement contains a magic number: q.Add ("extra_job_query_keys"' string.Join ("'"' GetPopularUniqueValues ("job_query_keys"' 40).Except (originalKeys).Take (2)));  
Magic Number,ImageResizer.Configuration.Performance,GlobalPerf,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\GlobalPerf.cs,GetReportPairs,The following statement contains a magic number: q.Add ("extra_job_query_keys"' string.Join ("'"' GetPopularUniqueValues ("job_query_keys"' 40).Except (originalKeys).Take (2)));  
Magic Number,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,PluginUsage,The following statement contains a magic number: queryRelevancies = new List<KeyValuePair<string' string>> (30);  
Magic Number,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,Check,The following statement contains a magic number: foreach (var p in plugins.AllPlugins) {  	var type = p.GetType ();  	if (!pluginTypes.Contains (type)) {  		// Record type  		if (newList == null) {  			newList = new List<Type> (pluginTypes.Count + 8);  			newList.AddRange (pluginTypes);  		}  		newList.Add (type);  		// Record querystring relevancies  		var info = p as IPluginInfo;  		if (info != null) {  			if (newPairs == null) {  				newPairs = new List<KeyValuePair<string' string>> (queryRelevancies.Count + 8);  				newPairs.AddRange (queryRelevancies);  			}  			//newPairs.AddRange(info.GetRelevantQueryPairs());  		}  	}  }  
Magic Number,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,Check,The following statement contains a magic number: foreach (var p in plugins.AllPlugins) {  	var type = p.GetType ();  	if (!pluginTypes.Contains (type)) {  		// Record type  		if (newList == null) {  			newList = new List<Type> (pluginTypes.Count + 8);  			newList.AddRange (pluginTypes);  		}  		newList.Add (type);  		// Record querystring relevancies  		var info = p as IPluginInfo;  		if (info != null) {  			if (newPairs == null) {  				newPairs = new List<KeyValuePair<string' string>> (queryRelevancies.Count + 8);  				newPairs.AddRange (queryRelevancies);  			}  			//newPairs.AddRange(info.GetRelevantQueryPairs());  		}  	}  }  
Magic Number,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,Check,The following statement contains a magic number: if (!pluginTypes.Contains (type)) {  	// Record type  	if (newList == null) {  		newList = new List<Type> (pluginTypes.Count + 8);  		newList.AddRange (pluginTypes);  	}  	newList.Add (type);  	// Record querystring relevancies  	var info = p as IPluginInfo;  	if (info != null) {  		if (newPairs == null) {  			newPairs = new List<KeyValuePair<string' string>> (queryRelevancies.Count + 8);  			newPairs.AddRange (queryRelevancies);  		}  		//newPairs.AddRange(info.GetRelevantQueryPairs());  	}  }  
Magic Number,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,Check,The following statement contains a magic number: if (!pluginTypes.Contains (type)) {  	// Record type  	if (newList == null) {  		newList = new List<Type> (pluginTypes.Count + 8);  		newList.AddRange (pluginTypes);  	}  	newList.Add (type);  	// Record querystring relevancies  	var info = p as IPluginInfo;  	if (info != null) {  		if (newPairs == null) {  			newPairs = new List<KeyValuePair<string' string>> (queryRelevancies.Count + 8);  			newPairs.AddRange (queryRelevancies);  		}  		//newPairs.AddRange(info.GetRelevantQueryPairs());  	}  }  
Magic Number,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,Check,The following statement contains a magic number: if (newList == null) {  	newList = new List<Type> (pluginTypes.Count + 8);  	newList.AddRange (pluginTypes);  }  
Magic Number,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,Check,The following statement contains a magic number: newList = new List<Type> (pluginTypes.Count + 8);  
Magic Number,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,Check,The following statement contains a magic number: if (info != null) {  	if (newPairs == null) {  		newPairs = new List<KeyValuePair<string' string>> (queryRelevancies.Count + 8);  		newPairs.AddRange (queryRelevancies);  	}  	//newPairs.AddRange(info.GetRelevantQueryPairs());  }  
Magic Number,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,Check,The following statement contains a magic number: if (newPairs == null) {  	newPairs = new List<KeyValuePair<string' string>> (queryRelevancies.Count + 8);  	newPairs.AddRange (queryRelevancies);  }  
Magic Number,ImageResizer.Configuration.Performance,PluginUsage,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\PluginInfo.cs,Check,The following statement contains a magic number: newPairs = new List<KeyValuePair<string' string>> (queryRelevancies.Count + 8);  
Magic Number,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,Add,The following statement contains a magic number: q.Add ("working_set_mb"' Environment.WorkingSet / 1000000);  
Magic Number,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,Add,The following statement contains a magic number: if (HostingEnvironment.ApplicationPhysicalPath != null) {  	q.Add ("apppath_hash"' Utilities.Sha256TruncatedBase64 (HostingEnvironment.ApplicationPhysicalPath' 6));  }  
Magic Number,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,Add,The following statement contains a magic number: q.Add ("apppath_hash"' Utilities.Sha256TruncatedBase64 (HostingEnvironment.ApplicationPhysicalPath' 6));  
Magic Number,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,CheckFor45PlusVersion,The following statement contains a magic number: if (releaseKey >= 460798) {  	return "4.7 or later";  }  
Magic Number,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,CheckFor45PlusVersion,The following statement contains a magic number: if (releaseKey >= 394802) {  	return "4.6.2";  }  
Magic Number,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,CheckFor45PlusVersion,The following statement contains a magic number: if (releaseKey >= 394254) {  	return "4.6.1";  }  
Magic Number,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,CheckFor45PlusVersion,The following statement contains a magic number: if (releaseKey >= 393295) {  	return "4.6";  }  
Magic Number,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,CheckFor45PlusVersion,The following statement contains a magic number: if ((releaseKey >= 379893)) {  	return "4.5.2";  }  
Magic Number,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,CheckFor45PlusVersion,The following statement contains a magic number: if ((releaseKey >= 378675)) {  	return "4.5.1";  }  
Magic Number,ImageResizer.Configuration.Performance,ProcessInfo,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\ProcessInfo.cs,CheckFor45PlusVersion,The following statement contains a magic number: if ((releaseKey >= 378389)) {  	return "4.5";  }  
Magic Number,ImageResizer.Configuration.Performance,Utilities,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Utilities.cs,Sha256hex,The following statement contains a magic number: return BitConverter.ToString (hash' 0' 4).Replace ("-"' "").ToLowerInvariant ();  
Magic Number,ImageResizer.Configuration.Performance,PercentileExtensions,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Utilities.cs,GetPercentile,The following statement contains a magic number: return (data [(int)Math.Max (0' Math.Ceiling (index - 1.5))] + data [(int)Math.Min (Math.Ceiling (index - 0.5)' data.Length - 1)]) / 2;  
Magic Number,ImageResizer.Configuration.Performance,PercentileExtensions,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Utilities.cs,GetPercentile,The following statement contains a magic number: return (data [(int)Math.Max (0' Math.Ceiling (index - 1.5))] + data [(int)Math.Min (Math.Ceiling (index - 0.5)' data.Length - 1)]) / 2;  
Magic Number,ImageResizer.Configuration.Performance,PercentileExtensions,F:\newReposMay17\imazen_resizer\Core\Configuration\Performance\Support\Utilities.cs,GetPercentile,The following statement contains a magic number: return (data [(int)Math.Max (0' Math.Ceiling (index - 1.5))] + data [(int)Math.Min (Math.Ceiling (index - 0.5)' data.Length - 1)]) / 2;  
Magic Number,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The following statement contains a magic number: try {  	var searchName = ParseName (searchNameString);  	bool preloadAssemblies = false;  	//Load the assembly if specified.  	if (preloadAssemblies & searchName.Item2 != null)  		Assembly.Load (searchName.Item2);  	int dotAt = searchName.Item1.IndexOf ('.');  	//If there is a dot or period' try the exact name first.  	if (dotAt > -1 || searchName.Item2 != null) {  		attemptedExpansions.Add (searchNameString);  		t = Type.GetType (searchNameString' false' true);  	}  	if (t != null)  		return t;  	var nameVariations = new[] {  		searchName.Item1'  		searchNameString'  		searchName.Item1.Replace ("Plugin"' "")'  		searchNameString.Replace ("Plugin"' "")  	}.Distinct (StringComparer.OrdinalIgnoreCase);  	List<string> officialExpansions = new List<string> ();  	foreach (string nameVariant in nameVariations) {  		var expansions = hints.GetExpansions (nameVariant);  		if (expansions != null)  			officialExpansions.AddRange (expansions);  	}  	if (officialExpansions.Count > 0) {  		foreach (string s in officialExpansions) {  			attemptedExpansions.Add (s);  			var parsedName = ParseName (s);  			if (preloadAssemblies && parsedName.Item2 != null) {  				Debug.WriteLine ("PluginConfig is loading assembly " + parsedName.Item2 + " to try " + parsedName.Item1);  				var a = Assembly.Load (parsedName.Item2);  				t = a.GetType (parsedName.Item1' false' true);  			} else {  				Debug.WriteLine ("Trying " + s);  				t = Type.GetType (s' false' true);  			}  			if (t != null) {  				Debug.WriteLine ("Success!");  				return t;  			}  		}  		var searchedAssemblies = officialExpansions.Select (s => s.IndexOf (''') > -1 ? s.Substring (s.IndexOf (''') + 1).Trim () : "").Distinct ();  		StringBuilder attempts = new StringBuilder ();  		foreach (string s in attemptedExpansions)  			attempts.Append ("' \"" + s + "\"");  		StringBuilder assemblyNames = new StringBuilder ();  		foreach (string s in searchedAssemblies)  			assemblyNames.Append ("\"" + s + "\" ");  		this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "Verify that " + assemblyNames.ToString () + " is located in /bin. \n" + "Attempted using \"" + searchName + "\"" + attempts.ToString () + "."' IssueSeverity.ConfigurationError));  	} else if (searchName.Item2 != null) {  		this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "Verify that \"" + searchName.Item2 + "\".dll is located in /bin' and that the name is spelled correctly."' IssueSeverity.ConfigurationError));  	} else {  		List<string> possibleExpansions = new List<string> ();  		//Split the name  apart  		string name = searchName.Item1;  		bool hasDot = name.IndexOf ('.') > -1;  		List<string> alternateNames = new List<string> ();  		//ImageResizer.Plugins.Basic.DefaultEncoder  		if (hasDot) {  			alternateNames.Add (name);  		} else {  			if (name.EndsWith ("Plugin")) {  				//Standard syntax  				alternateNames.Add ("ImageResizer.Plugins." + name.Substring (0' name.Length - 6).Trim ('.') + "." + name.Trim ('.'));  			} else {  				//Standard syntax  				alternateNames.Add ("ImageResizer.Plugins." + name.Trim ('.') + "." + name.Trim ('.') + "Plugin");  				//For the deprecated (but still used)convention of naming the plugin namespace and class the same.  				alternateNames.Add ("ImageResizer.Plugins." + name.Trim ('.') + "." + name.Trim ('.'));  			}  			//PluginWithNoNamespace  			alternateNames.Add (name);  		}  		//Get a list of assemblies' sorted by likelihood of a match  		List<string> assemblies = GetOptimizedAssemblyList (searchName.Item2' name);  		//Now multiply - For each assembly' try each namespace-qualified class name.  		foreach (string assemblyName in assemblies) {  			foreach (string className in alternateNames)  				possibleExpansions.Add (className + assemblyName);  		}  		foreach (string s in possibleExpansions) {  			attemptedExpansions.Add (s);  			Debug.WriteLine ("Trying " + s);  			t = Type.GetType (s' false' true);  			if (t != null) {  				Debug.WriteLine ("Success!");  				return t;  			}  		}  		//Ok' time to log problem.  		if (t == null) {  			StringBuilder attempts = new StringBuilder ();  			foreach (string s in attemptedExpansions)  				attempts.Append ("' \"" + s + "\"");  			this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "This is not a recognized plugin name. Check spelling. \n" + "Attempted using \"" + searchName + "\"" + attempts.ToString () + "."' IssueSeverity.ConfigurationError));  		}  	}  } catch (System.Security.SecurityException sx) {  	this.AcceptIssue (new Issue ("Failed to load plugin \"" + searchNameString + "\" due to ASP.NET trust configuration. "' "You may need to increase the trust level for this plugin to load properly. Error details: \n" + sx.Message + "\n" + sx.StackTrace' IssueSeverity.Error));  	return null;  }  
Magic Number,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The following statement contains a magic number: if (officialExpansions.Count > 0) {  	foreach (string s in officialExpansions) {  		attemptedExpansions.Add (s);  		var parsedName = ParseName (s);  		if (preloadAssemblies && parsedName.Item2 != null) {  			Debug.WriteLine ("PluginConfig is loading assembly " + parsedName.Item2 + " to try " + parsedName.Item1);  			var a = Assembly.Load (parsedName.Item2);  			t = a.GetType (parsedName.Item1' false' true);  		} else {  			Debug.WriteLine ("Trying " + s);  			t = Type.GetType (s' false' true);  		}  		if (t != null) {  			Debug.WriteLine ("Success!");  			return t;  		}  	}  	var searchedAssemblies = officialExpansions.Select (s => s.IndexOf (''') > -1 ? s.Substring (s.IndexOf (''') + 1).Trim () : "").Distinct ();  	StringBuilder attempts = new StringBuilder ();  	foreach (string s in attemptedExpansions)  		attempts.Append ("' \"" + s + "\"");  	StringBuilder assemblyNames = new StringBuilder ();  	foreach (string s in searchedAssemblies)  		assemblyNames.Append ("\"" + s + "\" ");  	this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "Verify that " + assemblyNames.ToString () + " is located in /bin. \n" + "Attempted using \"" + searchName + "\"" + attempts.ToString () + "."' IssueSeverity.ConfigurationError));  } else if (searchName.Item2 != null) {  	this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "Verify that \"" + searchName.Item2 + "\".dll is located in /bin' and that the name is spelled correctly."' IssueSeverity.ConfigurationError));  } else {  	List<string> possibleExpansions = new List<string> ();  	//Split the name  apart  	string name = searchName.Item1;  	bool hasDot = name.IndexOf ('.') > -1;  	List<string> alternateNames = new List<string> ();  	//ImageResizer.Plugins.Basic.DefaultEncoder  	if (hasDot) {  		alternateNames.Add (name);  	} else {  		if (name.EndsWith ("Plugin")) {  			//Standard syntax  			alternateNames.Add ("ImageResizer.Plugins." + name.Substring (0' name.Length - 6).Trim ('.') + "." + name.Trim ('.'));  		} else {  			//Standard syntax  			alternateNames.Add ("ImageResizer.Plugins." + name.Trim ('.') + "." + name.Trim ('.') + "Plugin");  			//For the deprecated (but still used)convention of naming the plugin namespace and class the same.  			alternateNames.Add ("ImageResizer.Plugins." + name.Trim ('.') + "." + name.Trim ('.'));  		}  		//PluginWithNoNamespace  		alternateNames.Add (name);  	}  	//Get a list of assemblies' sorted by likelihood of a match  	List<string> assemblies = GetOptimizedAssemblyList (searchName.Item2' name);  	//Now multiply - For each assembly' try each namespace-qualified class name.  	foreach (string assemblyName in assemblies) {  		foreach (string className in alternateNames)  			possibleExpansions.Add (className + assemblyName);  	}  	foreach (string s in possibleExpansions) {  		attemptedExpansions.Add (s);  		Debug.WriteLine ("Trying " + s);  		t = Type.GetType (s' false' true);  		if (t != null) {  			Debug.WriteLine ("Success!");  			return t;  		}  	}  	//Ok' time to log problem.  	if (t == null) {  		StringBuilder attempts = new StringBuilder ();  		foreach (string s in attemptedExpansions)  			attempts.Append ("' \"" + s + "\"");  		this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "This is not a recognized plugin name. Check spelling. \n" + "Attempted using \"" + searchName + "\"" + attempts.ToString () + "."' IssueSeverity.ConfigurationError));  	}  }  
Magic Number,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The following statement contains a magic number: if (searchName.Item2 != null) {  	this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "Verify that \"" + searchName.Item2 + "\".dll is located in /bin' and that the name is spelled correctly."' IssueSeverity.ConfigurationError));  } else {  	List<string> possibleExpansions = new List<string> ();  	//Split the name  apart  	string name = searchName.Item1;  	bool hasDot = name.IndexOf ('.') > -1;  	List<string> alternateNames = new List<string> ();  	//ImageResizer.Plugins.Basic.DefaultEncoder  	if (hasDot) {  		alternateNames.Add (name);  	} else {  		if (name.EndsWith ("Plugin")) {  			//Standard syntax  			alternateNames.Add ("ImageResizer.Plugins." + name.Substring (0' name.Length - 6).Trim ('.') + "." + name.Trim ('.'));  		} else {  			//Standard syntax  			alternateNames.Add ("ImageResizer.Plugins." + name.Trim ('.') + "." + name.Trim ('.') + "Plugin");  			//For the deprecated (but still used)convention of naming the plugin namespace and class the same.  			alternateNames.Add ("ImageResizer.Plugins." + name.Trim ('.') + "." + name.Trim ('.'));  		}  		//PluginWithNoNamespace  		alternateNames.Add (name);  	}  	//Get a list of assemblies' sorted by likelihood of a match  	List<string> assemblies = GetOptimizedAssemblyList (searchName.Item2' name);  	//Now multiply - For each assembly' try each namespace-qualified class name.  	foreach (string assemblyName in assemblies) {  		foreach (string className in alternateNames)  			possibleExpansions.Add (className + assemblyName);  	}  	foreach (string s in possibleExpansions) {  		attemptedExpansions.Add (s);  		Debug.WriteLine ("Trying " + s);  		t = Type.GetType (s' false' true);  		if (t != null) {  			Debug.WriteLine ("Success!");  			return t;  		}  	}  	//Ok' time to log problem.  	if (t == null) {  		StringBuilder attempts = new StringBuilder ();  		foreach (string s in attemptedExpansions)  			attempts.Append ("' \"" + s + "\"");  		this.AcceptIssue (new Issue ("Failed to load plugin by name \"" + searchName + "\""' "This is not a recognized plugin name. Check spelling. \n" + "Attempted using \"" + searchName + "\"" + attempts.ToString () + "."' IssueSeverity.ConfigurationError));  	}  }  
Magic Number,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The following statement contains a magic number: if (hasDot) {  	alternateNames.Add (name);  } else {  	if (name.EndsWith ("Plugin")) {  		//Standard syntax  		alternateNames.Add ("ImageResizer.Plugins." + name.Substring (0' name.Length - 6).Trim ('.') + "." + name.Trim ('.'));  	} else {  		//Standard syntax  		alternateNames.Add ("ImageResizer.Plugins." + name.Trim ('.') + "." + name.Trim ('.') + "Plugin");  		//For the deprecated (but still used)convention of naming the plugin namespace and class the same.  		alternateNames.Add ("ImageResizer.Plugins." + name.Trim ('.') + "." + name.Trim ('.'));  	}  	//PluginWithNoNamespace  	alternateNames.Add (name);  }  
Magic Number,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The following statement contains a magic number: if (name.EndsWith ("Plugin")) {  	//Standard syntax  	alternateNames.Add ("ImageResizer.Plugins." + name.Substring (0' name.Length - 6).Trim ('.') + "." + name.Trim ('.'));  } else {  	//Standard syntax  	alternateNames.Add ("ImageResizer.Plugins." + name.Trim ('.') + "." + name.Trim ('.') + "Plugin");  	//For the deprecated (but still used)convention of naming the plugin namespace and class the same.  	alternateNames.Add ("ImageResizer.Plugins." + name.Trim ('.') + "." + name.Trim ('.'));  }  
Magic Number,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,FindPluginType,The following statement contains a magic number: alternateNames.Add ("ImageResizer.Plugins." + name.Substring (0' name.Length - 6).Trim ('.') + "." + name.Trim ('.'));  
Magic Number,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,CreatePluginByType,The following statement contains a magic number: if (args != null && args ["downloadNativeDependencies"] != null) {  	downloadDependencies = "true".Equals (args ["downloadNativeDependencies"]' StringComparison.OrdinalIgnoreCase);  	if (args.Count == 2)  		args = null;  	//Don't require plugins to have an argument-supporting constructor just for downloadNativeDependencies  	//'name' is included in args' remember.  	ndeps.EnsureLoaded (t.Assembly);  }  
Magic Number,ImageResizer.Configuration,PluginConfig,F:\newReposMay17\imazen_resizer\Core\Configuration\PluginConfig.cs,CreatePluginByType,The following statement contains a magic number: if (args.Count == 2)  	args = null;  
Magic Number,ImageResizer.Plugins.Basic,EndpointPlugin,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\EndpointPlugin.cs,ProcessRequest,The following statement contains a magic number: context.Response.StatusCode = 200;  
Magic Number,ImageResizer.Plugins.Basic,NoCacheAsyncHandler,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\NoCacheAsyncHandler.cs,ProcessRequestAsync,The following statement contains a magic number: context.Response.StatusCode = 200;  
Magic Number,ImageResizer.Plugins.Basic,NoCacheHandler,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\NoCacheHandler.cs,ProcessRequest,The following statement contains a magic number: context.Response.StatusCode = 200;  
Magic Number,ImageResizer.Plugins.Basic,DropShadow,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DropShadow.cs,LayoutEffects,The following statement contains a magic number: if (shadowWidth != 0) {  	var offset = s.settings.GetList<float> ("shadowOffset"' 0' 2);  	PointF shadowOffset = offset == null ? new PointF (0' 0) : new PointF (offset [0]' offset [1]);  	//Clone last ring' then offset it - provides the inner bounds of the shadow later  	s.layout.AddInvisiblePolygon ("shadowInner"' PolygonMath.MovePoly (s.layout.LastRing.points' shadowOffset));  	//Determine the outer bound of the shadow  	s.layout.AddRing ("shadow"' PolygonMath.InflatePoly (s.layout.LastRing.points' new float[] {  		Math.Max (0' shadowWidth - shadowOffset.Y)'  		Math.Max (0' shadowWidth + shadowOffset.X)'  		Math.Max (0' shadowWidth + shadowOffset.Y)'  		Math.Max (0' shadowWidth - shadowOffset.X)  	}));  }  
Magic Number,ImageResizer.Plugins.Basic,DropShadow,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DropShadow.cs,DrawOuterGradient,The following statement contains a magic number: for (int i = 0; i <= sides.GetUpperBound (0); i++) {  	PointF[] pts = PolygonMath.GetSubArray (sides' i);  	using (LinearGradientBrush b = new LinearGradientBrush (pts [3]' pts [0]' inner' outer)) {  		b.SetSigmaBellShape (1);  		b.WrapMode = WrapMode.TileFlipXY;  		g.FillPolygon (b' pts);  	}  }  
Magic Number,ImageResizer.Plugins.Basic,DropShadow,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DropShadow.cs,DrawOuterGradient,The following statement contains a magic number: using (LinearGradientBrush b = new LinearGradientBrush (pts [3]' pts [0]' inner' outer)) {  	b.SetSigmaBellShape (1);  	b.WrapMode = WrapMode.TileFlipXY;  	g.FillPolygon (b' pts);  }  
Magic Number,ImageResizer.Plugins.Basic,SpeedOrQuality,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\SpeedOrQuality.cs,RenderImage,The following statement contains a magic number: if (speed < 3) {  	using (var ia = new ImageAttributes ()) {  		ia.SetWrapMode (WrapMode.TileFlipXY);  		if (s.colorMatrix != null)  			ia.SetColorMatrix (new ColorMatrix (s.colorMatrix));  		s.destGraphics.DrawImage (s.sourceBitmap' PolygonMath.getParallelogram (s.layout ["image"])' s.copyRect' GraphicsUnit.Pixel' ia);  	}  } else if (speed < 4) {  	Rectangle midsize = PolygonMath.ToRectangle (PolygonMath.GetBoundingBox (s.layout ["image"]));  	using (Image thumb = s.sourceBitmap.GetThumbnailImage (midsize.Width' midsize.Height' delegate () {  		return false;  	}' IntPtr.Zero)) {  		double xfactor = (double)thumb.Width / (double)s.sourceBitmap.Width;  		double yfactor = (double)thumb.Height / (double)s.sourceBitmap.Height;  		RectangleF copyPart = new RectangleF ((float)(s.copyRect.Left * xfactor)' (float)(s.copyRect.Top * yfactor)' (float)(s.copyRect.Width * xfactor)' (float)(s.copyRect.Height * yfactor));  		if (Math.Floor (copyPart.Height) == thumb.Height || Math.Ceiling (copyPart.Height) == thumb.Height)  			copyPart.Height = thumb.Height;  		if (Math.Floor (copyPart.Width) == thumb.Width || Math.Ceiling (copyPart.Width) == thumb.Width)  			copyPart.Width = thumb.Width;  		using (var ia = new ImageAttributes ()) {  			ia.SetWrapMode (WrapMode.TileFlipXY);  			if (s.colorMatrix != null)  				ia.SetColorMatrix (new ColorMatrix (s.colorMatrix));  			s.destGraphics.DrawImage (thumb' PolygonMath.getParallelogram (s.layout ["image"])' copyPart' GraphicsUnit.Pixel' ia);  		}  	}  } else {  	RectangleF box = PolygonMath.GetBoundingBox (PolygonMath.getParallelogram (s.layout ["image"]));  	s.destGraphics.CompositingMode = CompositingMode.SourceCopy;  	s.destGraphics.DrawImage (s.sourceBitmap' box.Left' box.Top' box.Width' box.Height);  }  
Magic Number,ImageResizer.Plugins.Basic,SpeedOrQuality,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\SpeedOrQuality.cs,RenderImage,The following statement contains a magic number: if (speed < 3) {  	using (var ia = new ImageAttributes ()) {  		ia.SetWrapMode (WrapMode.TileFlipXY);  		if (s.colorMatrix != null)  			ia.SetColorMatrix (new ColorMatrix (s.colorMatrix));  		s.destGraphics.DrawImage (s.sourceBitmap' PolygonMath.getParallelogram (s.layout ["image"])' s.copyRect' GraphicsUnit.Pixel' ia);  	}  } else if (speed < 4) {  	Rectangle midsize = PolygonMath.ToRectangle (PolygonMath.GetBoundingBox (s.layout ["image"]));  	using (Image thumb = s.sourceBitmap.GetThumbnailImage (midsize.Width' midsize.Height' delegate () {  		return false;  	}' IntPtr.Zero)) {  		double xfactor = (double)thumb.Width / (double)s.sourceBitmap.Width;  		double yfactor = (double)thumb.Height / (double)s.sourceBitmap.Height;  		RectangleF copyPart = new RectangleF ((float)(s.copyRect.Left * xfactor)' (float)(s.copyRect.Top * yfactor)' (float)(s.copyRect.Width * xfactor)' (float)(s.copyRect.Height * yfactor));  		if (Math.Floor (copyPart.Height) == thumb.Height || Math.Ceiling (copyPart.Height) == thumb.Height)  			copyPart.Height = thumb.Height;  		if (Math.Floor (copyPart.Width) == thumb.Width || Math.Ceiling (copyPart.Width) == thumb.Width)  			copyPart.Width = thumb.Width;  		using (var ia = new ImageAttributes ()) {  			ia.SetWrapMode (WrapMode.TileFlipXY);  			if (s.colorMatrix != null)  				ia.SetColorMatrix (new ColorMatrix (s.colorMatrix));  			s.destGraphics.DrawImage (thumb' PolygonMath.getParallelogram (s.layout ["image"])' copyPart' GraphicsUnit.Pixel' ia);  		}  	}  } else {  	RectangleF box = PolygonMath.GetBoundingBox (PolygonMath.getParallelogram (s.layout ["image"]));  	s.destGraphics.CompositingMode = CompositingMode.SourceCopy;  	s.destGraphics.DrawImage (s.sourceBitmap' box.Left' box.Top' box.Width' box.Height);  }  
Magic Number,ImageResizer.Plugins.Basic,SpeedOrQuality,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\SpeedOrQuality.cs,RenderImage,The following statement contains a magic number: if (speed < 4) {  	Rectangle midsize = PolygonMath.ToRectangle (PolygonMath.GetBoundingBox (s.layout ["image"]));  	using (Image thumb = s.sourceBitmap.GetThumbnailImage (midsize.Width' midsize.Height' delegate () {  		return false;  	}' IntPtr.Zero)) {  		double xfactor = (double)thumb.Width / (double)s.sourceBitmap.Width;  		double yfactor = (double)thumb.Height / (double)s.sourceBitmap.Height;  		RectangleF copyPart = new RectangleF ((float)(s.copyRect.Left * xfactor)' (float)(s.copyRect.Top * yfactor)' (float)(s.copyRect.Width * xfactor)' (float)(s.copyRect.Height * yfactor));  		if (Math.Floor (copyPart.Height) == thumb.Height || Math.Ceiling (copyPart.Height) == thumb.Height)  			copyPart.Height = thumb.Height;  		if (Math.Floor (copyPart.Width) == thumb.Width || Math.Ceiling (copyPart.Width) == thumb.Width)  			copyPart.Width = thumb.Width;  		using (var ia = new ImageAttributes ()) {  			ia.SetWrapMode (WrapMode.TileFlipXY);  			if (s.colorMatrix != null)  				ia.SetColorMatrix (new ColorMatrix (s.colorMatrix));  			s.destGraphics.DrawImage (thumb' PolygonMath.getParallelogram (s.layout ["image"])' copyPart' GraphicsUnit.Pixel' ia);  		}  	}  } else {  	RectangleF box = PolygonMath.GetBoundingBox (PolygonMath.getParallelogram (s.layout ["image"]));  	s.destGraphics.CompositingMode = CompositingMode.SourceCopy;  	s.destGraphics.DrawImage (s.sourceBitmap' box.Left' box.Top' box.Width' box.Height);  }  
Magic Number,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,PreFlushChanges,The following statement contains a magic number: if (m == TrialWatermarkMode.After500 && requestCount > 500)  	applyWatermark = true;  
Magic Number,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,PreFlushChanges,The following statement contains a magic number: if (m == TrialWatermarkMode.Randomly)  	applyWatermark = (new Random (requestCount).Next (0' 41) < 10);  
Magic Number,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,PreFlushChanges,The following statement contains a magic number: if (m == TrialWatermarkMode.Randomly)  	applyWatermark = (new Random (requestCount).Next (0' 41) < 10);  
Magic Number,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,PreFlushChanges,The following statement contains a magic number: applyWatermark = (new Random (requestCount).Next (0' 41) < 10);  
Magic Number,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,PreFlushChanges,The following statement contains a magic number: applyWatermark = (new Random (requestCount).Next (0' 41) < 10);  
Magic Number,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,PreFlushChanges,The following statement contains a magic number: DrawString (PolygonMath.GetBoundingBox (s.layout ["image"])' s.destGraphics' "Unlicensed"' FontFamily.GenericSansSerif' Color.FromArgb (70' Color.White));  
Magic Number,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,DrawString,The following statement contains a magic number: g.DrawString (text' new Font (ff' finalFontSize)' new SolidBrush (c)' new PointF ((area.Width - finalSize.Width) / 2 + area.Left' (area.Height - finalSize.Height) / 2 + area.Height));  
Magic Number,ImageResizer.Plugins.Basic,Trial,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Trial.cs,DrawString,The following statement contains a magic number: g.DrawString (text' new Font (ff' finalFontSize)' new SolidBrush (c)' new PointF ((area.Width - finalSize.Width) / 2 + area.Left' (area.Height - finalSize.Height) / 2 + area.Height));  
Magic Number,ImageResizer.Plugins.Basic,DefaultEncoder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DefaultEncoder.cs,SaveJpeg,The following statement contains a magic number: if (quality < 0)  	quality = 90;  
Magic Number,ImageResizer.Plugins.Basic,DefaultEncoder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DefaultEncoder.cs,SaveJpeg,The following statement contains a magic number: quality = 90;  
Magic Number,ImageResizer.Plugins.Basic,DefaultEncoder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DefaultEncoder.cs,SaveJpeg,The following statement contains a magic number: if (quality > 100)  	quality = 100;  
Magic Number,ImageResizer.Plugins.Basic,DefaultEncoder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DefaultEncoder.cs,SaveJpeg,The following statement contains a magic number: if (quality > 100)  	quality = 100;  
Magic Number,ImageResizer.Plugins.Basic,DefaultEncoder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DefaultEncoder.cs,SaveJpeg,The following statement contains a magic number: quality = 100;  
Magic Number,ImageResizer.Plugins.Basic,DefaultEncoder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DefaultEncoder.cs,SavePng,The following statement contains a magic number: if (!target.CanSeek) {  	//Write to an intermediate' seekable memory stream (PNG compression requires it)  	using (MemoryStream ms = new MemoryStream (4096)) {  		img.Save (ms' System.Drawing.Imaging.ImageFormat.Png);  		ms.WriteTo (target);  	}  } else {  	//image/png  	//  The parameter list requires 0 bytes.  	img.Save (target' System.Drawing.Imaging.ImageFormat.Png);  }  
Magic Number,ImageResizer.Plugins.Basic,DefaultEncoder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\DefaultEncoder.cs,SavePng,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (4096)) {  	img.Save (ms' System.Drawing.Imaging.ImageFormat.Png);  	ms.WriteTo (target);  }  
Magic Number,ImageResizer.Plugins.Basic,WebConfigLicenseReader,F:\newReposMay17\imazen_resizer\Core\Plugins\WebConfigLicenseReader.cs,TryRedact,The following statement contains a magic number: return segments.Count () > 1 ? string.Join (":"' segments.Take (segments.Count () - 2).Concat (new[] {  	"****redacted****"'  	segments.Last ()  })) : license;  
Magic Number,ImageResizer.Plugins.Basic,VirtualFolder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\VirtualFolder.cs,collapseOneLevel,The following statement contains a magic number: do {  	up = path.LastIndexOf (System.IO.Path.DirectorySeparatorChar + ".." + System.IO.Path.DirectorySeparatorChar' up);  	if (up < 0)  		return path;  	int prevSlash = path.LastIndexOf (System.IO.Path.DirectorySeparatorChar' up - 1);  	if (prevSlash < 0)  		return path;  	string segment = path.Substring (prevSlash + 1' up - prevSlash - 1);  	if (segment.Equals (".."' StringComparison.OrdinalIgnoreCase)) {  		//We can't combine \..\..\' just keep looking closer to the beginning of the string. We already adjusted 'up'  	} else if (segment.Equals ("."' StringComparison.OrdinalIgnoreCase)) {  		return path.Substring (0' prevSlash) + path.Substring (up);  		//Just remove \.\ sections  	} else {  		return path.Substring (0' prevSlash) + path.Substring (up + 3);  		//If it's not \.\ or \..\' remove both it and the following \..\  	}  } while (up > 0);  
Magic Number,ImageResizer.Plugins.Basic,VirtualFolder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\VirtualFolder.cs,collapseOneLevel,The following statement contains a magic number: if (segment.Equals (".."' StringComparison.OrdinalIgnoreCase)) {  	//We can't combine \..\..\' just keep looking closer to the beginning of the string. We already adjusted 'up'  } else if (segment.Equals ("."' StringComparison.OrdinalIgnoreCase)) {  	return path.Substring (0' prevSlash) + path.Substring (up);  	//Just remove \.\ sections  } else {  	return path.Substring (0' prevSlash) + path.Substring (up + 3);  	//If it's not \.\ or \..\' remove both it and the following \..\  }  
Magic Number,ImageResizer.Plugins.Basic,VirtualFolder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\VirtualFolder.cs,collapseOneLevel,The following statement contains a magic number: if (segment.Equals ("."' StringComparison.OrdinalIgnoreCase)) {  	return path.Substring (0' prevSlash) + path.Substring (up);  	//Just remove \.\ sections  } else {  	return path.Substring (0' prevSlash) + path.Substring (up + 3);  	//If it's not \.\ or \..\' remove both it and the following \..\  }  
Magic Number,ImageResizer.Plugins.Basic,VirtualFolder,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\VirtualFolder.cs,collapseOneLevel,The following statement contains a magic number: return path.Substring (0' prevSlash) + path.Substring (up + 3);  
Magic Number,ImageResizer.Plugins,WriteThroughCache,F:\newReposMay17\imazen_resizer\Core\Plugins\PeristentGlobalStringCache.cs,hashToBase16,The following statement contains a magic number: foreach (byte b in bytes)  	sb.Append (b.ToString ("x"' NumberFormatInfo.InvariantInfo).PadLeft (2' '0'));  
Magic Number,ImageResizer.Plugins,WriteThroughCache,F:\newReposMay17\imazen_resizer\Core\Plugins\PeristentGlobalStringCache.cs,hashToBase16,The following statement contains a magic number: sb.Append (b.ToString ("x"' NumberFormatInfo.InvariantInfo).PadLeft (2' '0'));  
Magic Number,ImageResizer.Plugins,WriteThroughCache,F:\newReposMay17\imazen_resizer\Core\Plugins\PeristentGlobalStringCache.cs,FilenameKeyFor,The following statement contains a magic number: if (key.Any (c => !Char.IsLetterOrDigit (c) && c != '_') || key.Length + prefix.Length > 200) {  	return this.prefix + hashToBase16 (key) + ".txt";  } else {  	return this.prefix + key + ".txt";  }  
Magic Number,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The following statement contains a magic number: try {  	foreach (Node c in manifest.childrenByName ("file")) {  		string bitness = c.Attrs ["bitness"];  		//Skip files with the wrong bitness  		if (bitness != null && !bitness.Equals (platform' StringComparison.OrdinalIgnoreCase))  			continue;  		string name = c.Attrs ["name"];  		//Skip duplicate names  		if (string.IsNullOrEmpty (name))  			this.AcceptIssue (new Issues.Issue ("Missing attribute 'name' in native dependency manifest for " + assemblyName' Issues.IssueSeverity.Warning));  		if (filesVerified.Contains (name))  			continue;  		//What is the expected size? If none listed' any size will work.   		int fileBytes = 0;  		if (c.Attrs ["fileBytes"] != null && !int.TryParse (c.Attrs ["fileBytes"]' System.Globalization.NumberStyles.Number' NumberFormatInfo.InvariantInfo' out fileBytes))  			this.AcceptIssue (new Issues.Issue ("Failed to parse fileBytes value " + c.Attrs ["fileBytes"] + " in native dependency manifest for " + assemblyName' Issues.IssueSeverity.Warning));  		//Download URL?  		string url = c.Attrs ["url"];  		string destPath = Path.Combine (TargetFolder' name);  		long existingLength = 0;  		//Does it already exist?  		if (File.Exists (destPath)) {  			if (fileBytes < 1) {  				filesVerified.Add (name);  				continue;  			} else {  				existingLength = new FileInfo (destPath).Length;  				if (existingLength == fileBytes) {  					filesVerified.Add (name);  					continue;  				}  			}  		}  		var d = new Dependency () {  			Exists = existingLength > 0'  			Name = name'  			Url = url'  			DestPath = destPath'  			ExistingLength = existingLength'  			ExpectedLength = fileBytes'  			Client = new WebClient ()'  			RequestingAssembly = assemblyName  		};  		q.Enqueue (d);  	}  	sw.Stop ();  	if (sw.ElapsedMilliseconds > 100 && q.Count < 1)  		this.AcceptIssue (new Issues.Issue ("Verifying native dependencies for " + assemblyName + " took " + sw.ElapsedMilliseconds + "ms."' Issues.IssueSeverity.Warning));  	ServicePointManager.DefaultConnectionLimit = 1000;  	//Allow more than 2 simultaneous HTTP requests.  	StringBuilder message = new StringBuilder ();  	if (q.Count > 0) {  		Stopwatch dsw = new Stopwatch ();  		dsw.Start ();  		using (var cd = new Countdown (q.Count)) {  			foreach (var current in q.ToArray ()) {  				var d = current;  				ThreadPool.QueueUserWorkItem (x => {  					DownloadFile (d' message);  					cd.Signal ();  				});  			}  			cd.Wait ();  		}  		dsw.Stop ();  		this.AcceptIssue (new Issues.Issue ("Some native dependencies for " + assemblyName + " were missing' but were downloaded successfully. This delayed startup time by " + (sw.ElapsedMilliseconds + dsw.ElapsedMilliseconds).ToString () + "ms."' message.ToString ()' Issues.IssueSeverity.Warning));  	}  } finally {  	foreach (Dependency d in q.ToArray ()) {  		d.Client.Dispose ();  	}  }  
Magic Number,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The following statement contains a magic number: try {  	foreach (Node c in manifest.childrenByName ("file")) {  		string bitness = c.Attrs ["bitness"];  		//Skip files with the wrong bitness  		if (bitness != null && !bitness.Equals (platform' StringComparison.OrdinalIgnoreCase))  			continue;  		string name = c.Attrs ["name"];  		//Skip duplicate names  		if (string.IsNullOrEmpty (name))  			this.AcceptIssue (new Issues.Issue ("Missing attribute 'name' in native dependency manifest for " + assemblyName' Issues.IssueSeverity.Warning));  		if (filesVerified.Contains (name))  			continue;  		//What is the expected size? If none listed' any size will work.   		int fileBytes = 0;  		if (c.Attrs ["fileBytes"] != null && !int.TryParse (c.Attrs ["fileBytes"]' System.Globalization.NumberStyles.Number' NumberFormatInfo.InvariantInfo' out fileBytes))  			this.AcceptIssue (new Issues.Issue ("Failed to parse fileBytes value " + c.Attrs ["fileBytes"] + " in native dependency manifest for " + assemblyName' Issues.IssueSeverity.Warning));  		//Download URL?  		string url = c.Attrs ["url"];  		string destPath = Path.Combine (TargetFolder' name);  		long existingLength = 0;  		//Does it already exist?  		if (File.Exists (destPath)) {  			if (fileBytes < 1) {  				filesVerified.Add (name);  				continue;  			} else {  				existingLength = new FileInfo (destPath).Length;  				if (existingLength == fileBytes) {  					filesVerified.Add (name);  					continue;  				}  			}  		}  		var d = new Dependency () {  			Exists = existingLength > 0'  			Name = name'  			Url = url'  			DestPath = destPath'  			ExistingLength = existingLength'  			ExpectedLength = fileBytes'  			Client = new WebClient ()'  			RequestingAssembly = assemblyName  		};  		q.Enqueue (d);  	}  	sw.Stop ();  	if (sw.ElapsedMilliseconds > 100 && q.Count < 1)  		this.AcceptIssue (new Issues.Issue ("Verifying native dependencies for " + assemblyName + " took " + sw.ElapsedMilliseconds + "ms."' Issues.IssueSeverity.Warning));  	ServicePointManager.DefaultConnectionLimit = 1000;  	//Allow more than 2 simultaneous HTTP requests.  	StringBuilder message = new StringBuilder ();  	if (q.Count > 0) {  		Stopwatch dsw = new Stopwatch ();  		dsw.Start ();  		using (var cd = new Countdown (q.Count)) {  			foreach (var current in q.ToArray ()) {  				var d = current;  				ThreadPool.QueueUserWorkItem (x => {  					DownloadFile (d' message);  					cd.Signal ();  				});  			}  			cd.Wait ();  		}  		dsw.Stop ();  		this.AcceptIssue (new Issues.Issue ("Some native dependencies for " + assemblyName + " were missing' but were downloaded successfully. This delayed startup time by " + (sw.ElapsedMilliseconds + dsw.ElapsedMilliseconds).ToString () + "ms."' message.ToString ()' Issues.IssueSeverity.Warning));  	}  } finally {  	foreach (Dependency d in q.ToArray ()) {  		d.Client.Dispose ();  	}  }  
Magic Number,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The following statement contains a magic number: if (sw.ElapsedMilliseconds > 100 && q.Count < 1)  	this.AcceptIssue (new Issues.Issue ("Verifying native dependencies for " + assemblyName + " took " + sw.ElapsedMilliseconds + "ms."' Issues.IssueSeverity.Warning));  
Magic Number,ImageResizer.Configuration.Plugins,NativeDependencyManager,F:\newReposMay17\imazen_resizer\Core\Configuration\NativeDependencyManager.cs,EnsureLoaded,The following statement contains a magic number: ServicePointManager.DefaultConnectionLimit = 1000;  
Magic Number,ImageResizer.Configuration.Xml,Selector,F:\newReposMay17\imazen_resizer\Core\Configuration\Xml\Selector.cs,GetRemainder,The following statement contains a magic number: if (this.Count < 2)  	return null;  
Magic Number,ImageResizer.Configuration.Xml,Selector,F:\newReposMay17\imazen_resizer\Core\Configuration\Xml\Selector.cs,GetAllExceptLast,The following statement contains a magic number: if (this.Count < 2)  	return null;  
Magic Number,ImageResizer.Resizing,BoxPadding,F:\newReposMay17\imazen_resizer\Core\Resizing\BoxPadding.cs,Parse,The following statement contains a magic number: if (coords.Length == 4)  	return new BoxPadding (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer.Resizing,BoxPadding,F:\newReposMay17\imazen_resizer\Core\Resizing\BoxPadding.cs,Parse,The following statement contains a magic number: if (coords.Length == 4)  	return new BoxPadding (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer.Resizing,BoxPadding,F:\newReposMay17\imazen_resizer\Core\Resizing\BoxPadding.cs,Parse,The following statement contains a magic number: if (coords.Length == 4)  	return new BoxPadding (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer.Resizing,BoxPadding,F:\newReposMay17\imazen_resizer\Core\Resizing\BoxPadding.cs,Parse,The following statement contains a magic number: return new BoxPadding (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer.Resizing,BoxPadding,F:\newReposMay17\imazen_resizer\Core\Resizing\BoxPadding.cs,Parse,The following statement contains a magic number: return new BoxPadding (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer.Resizing,BoxPadding,F:\newReposMay17\imazen_resizer\Core\Resizing\BoxPadding.cs,GetEdgeOffsets,The following statement contains a magic number: return new float[4] {  	(float)top'  	(float)right'  	(float)bottom'  	(float)left  };  
Magic Number,ImageResizer.Resizing,ImageLayoutEngine,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageLayoutEngine.cs,determineManualCropWindow,The following statement contains a magic number: if (cropWindow.IsEmpty) {  	//Use the crop size if present.  	cropWindow = new RectangleF (new PointF (0' 0)' originalSize);  	if (settings.GetList<double> ("crop"' 0' 4) != null) {  		cropWindow = PolygonMath.ToRectangle (settings.getCustomCropSourceRect (originalSize));  		//Round the custom crop rectangle coordinates  		//Ensure right/bottom bounded after rounding completes  		cropWindow.Width = Math.Min (originalSize.Width - cropWindow.Left' cropWindow.Width);  		cropWindow.Height = Math.Min (originalSize.Height - cropWindow.Top' cropWindow.Height);  		if (cropWindow.Size.IsEmpty)  			throw new Exception ("You must specify a custom crop rectangle if crop=custom");  	}  }  
Magic Number,ImageResizer.Resizing,ImageLayoutEngine,F:\newReposMay17\imazen_resizer\Core\Resizing\ImageLayoutEngine.cs,determineManualCropWindow,The following statement contains a magic number: if (settings.GetList<double> ("crop"' 0' 4) != null) {  	cropWindow = PolygonMath.ToRectangle (settings.getCustomCropSourceRect (originalSize));  	//Round the custom crop rectangle coordinates  	//Ensure right/bottom bounded after rounding completes  	cropWindow.Width = Math.Min (originalSize.Width - cropWindow.Left' cropWindow.Width);  	cropWindow.Height = Math.Min (originalSize.Height - cropWindow.Top' cropWindow.Height);  	if (cropWindow.Size.IsEmpty)  		throw new Exception ("You must specify a custom crop rectangle if crop=custom");  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (int.TryParse (value' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture' out val)) {  	int alpha = 255;  	if (value.Length == 4 || value.Length == 8) {  		int regLength = value.Length - (value.Length / 4);  		alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  		if (regLength == 3)  			alpha *= 16;  		value = value.Substring (0' regLength);  	}  	return Color.FromArgb (alpha' System.Drawing.ColorTranslator.FromHtml ("#" + value));  } else {  	try {  		Color c = System.Drawing.ColorTranslator.FromHtml (value);  		//Throws an 'Exception' instance if invalid  		return (c.IsEmpty) ? null : (Nullable<Color>)c;  	} catch {  		return null;  	}  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (int.TryParse (value' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture' out val)) {  	int alpha = 255;  	if (value.Length == 4 || value.Length == 8) {  		int regLength = value.Length - (value.Length / 4);  		alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  		if (regLength == 3)  			alpha *= 16;  		value = value.Substring (0' regLength);  	}  	return Color.FromArgb (alpha' System.Drawing.ColorTranslator.FromHtml ("#" + value));  } else {  	try {  		Color c = System.Drawing.ColorTranslator.FromHtml (value);  		//Throws an 'Exception' instance if invalid  		return (c.IsEmpty) ? null : (Nullable<Color>)c;  	} catch {  		return null;  	}  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (int.TryParse (value' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture' out val)) {  	int alpha = 255;  	if (value.Length == 4 || value.Length == 8) {  		int regLength = value.Length - (value.Length / 4);  		alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  		if (regLength == 3)  			alpha *= 16;  		value = value.Substring (0' regLength);  	}  	return Color.FromArgb (alpha' System.Drawing.ColorTranslator.FromHtml ("#" + value));  } else {  	try {  		Color c = System.Drawing.ColorTranslator.FromHtml (value);  		//Throws an 'Exception' instance if invalid  		return (c.IsEmpty) ? null : (Nullable<Color>)c;  	} catch {  		return null;  	}  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (int.TryParse (value' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture' out val)) {  	int alpha = 255;  	if (value.Length == 4 || value.Length == 8) {  		int regLength = value.Length - (value.Length / 4);  		alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  		if (regLength == 3)  			alpha *= 16;  		value = value.Substring (0' regLength);  	}  	return Color.FromArgb (alpha' System.Drawing.ColorTranslator.FromHtml ("#" + value));  } else {  	try {  		Color c = System.Drawing.ColorTranslator.FromHtml (value);  		//Throws an 'Exception' instance if invalid  		return (c.IsEmpty) ? null : (Nullable<Color>)c;  	} catch {  		return null;  	}  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (int.TryParse (value' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture' out val)) {  	int alpha = 255;  	if (value.Length == 4 || value.Length == 8) {  		int regLength = value.Length - (value.Length / 4);  		alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  		if (regLength == 3)  			alpha *= 16;  		value = value.Substring (0' regLength);  	}  	return Color.FromArgb (alpha' System.Drawing.ColorTranslator.FromHtml ("#" + value));  } else {  	try {  		Color c = System.Drawing.ColorTranslator.FromHtml (value);  		//Throws an 'Exception' instance if invalid  		return (c.IsEmpty) ? null : (Nullable<Color>)c;  	} catch {  		return null;  	}  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (int.TryParse (value' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture' out val)) {  	int alpha = 255;  	if (value.Length == 4 || value.Length == 8) {  		int regLength = value.Length - (value.Length / 4);  		alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  		if (regLength == 3)  			alpha *= 16;  		value = value.Substring (0' regLength);  	}  	return Color.FromArgb (alpha' System.Drawing.ColorTranslator.FromHtml ("#" + value));  } else {  	try {  		Color c = System.Drawing.ColorTranslator.FromHtml (value);  		//Throws an 'Exception' instance if invalid  		return (c.IsEmpty) ? null : (Nullable<Color>)c;  	} catch {  		return null;  	}  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (value.Length == 4 || value.Length == 8) {  	int regLength = value.Length - (value.Length / 4);  	alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  	if (regLength == 3)  		alpha *= 16;  	value = value.Substring (0' regLength);  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (value.Length == 4 || value.Length == 8) {  	int regLength = value.Length - (value.Length / 4);  	alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  	if (regLength == 3)  		alpha *= 16;  	value = value.Substring (0' regLength);  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (value.Length == 4 || value.Length == 8) {  	int regLength = value.Length - (value.Length / 4);  	alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  	if (regLength == 3)  		alpha *= 16;  	value = value.Substring (0' regLength);  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (value.Length == 4 || value.Length == 8) {  	int regLength = value.Length - (value.Length / 4);  	alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  	if (regLength == 3)  		alpha *= 16;  	value = value.Substring (0' regLength);  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (value.Length == 4 || value.Length == 8) {  	int regLength = value.Length - (value.Length / 4);  	alpha = int.Parse (value.Substring (regLength)' System.Globalization.NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);  	if (regLength == 3)  		alpha *= 16;  	value = value.Substring (0' regLength);  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (regLength == 3)  	alpha *= 16;  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: if (regLength == 3)  	alpha *= 16;  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,ParseColor,The following statement contains a magic number: alpha *= 16;  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,SerializeColor,The following statement contains a magic number: if (text.StartsWith ("#")) {  	text = text.TrimStart ('#');  	if (value.A != 255)  		text += value.A.ToString ("X2"' NumberFormatInfo.InvariantInfo);  }  
Magic Number,ImageResizer.Util,ParseUtils,F:\newReposMay17\imazen_resizer\Core\Util\ParseUtils.cs,SerializeColor,The following statement contains a magic number: if (value.A != 255)  	text += value.A.ToString ("X2"' NumberFormatInfo.InvariantInfo);  
Magic Number,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ParseQueryOnly,The following statement contains a magic number: foreach (string s in pairs) {  	string[] namevalue = s.Split (new char[] {  		'='  	}' StringSplitOptions.RemoveEmptyEntries);  	if (namevalue.Length > 2) {  		//Handle &key=value=value and &key===value=value -> key : "value=value"  		string value = s.Substring (s.IndexOf ('=')).TrimStart ('=');  		c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (value) : value;  	} else if (namevalue.Length == 2) {  		//Handle key=value (normal)  		c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (namevalue [1]) : namevalue [1];  	} else if (namevalue.Length == 1) {  		//Handle &key=&key2= or &key&key2 -> key: ""' key2: ""  		//Setting a null value would be confusing' as that is how we determine  		//whether a certain parameter exists  		c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = "";  	}  }  
Magic Number,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ParseQueryOnly,The following statement contains a magic number: foreach (string s in pairs) {  	string[] namevalue = s.Split (new char[] {  		'='  	}' StringSplitOptions.RemoveEmptyEntries);  	if (namevalue.Length > 2) {  		//Handle &key=value=value and &key===value=value -> key : "value=value"  		string value = s.Substring (s.IndexOf ('=')).TrimStart ('=');  		c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (value) : value;  	} else if (namevalue.Length == 2) {  		//Handle key=value (normal)  		c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (namevalue [1]) : namevalue [1];  	} else if (namevalue.Length == 1) {  		//Handle &key=&key2= or &key&key2 -> key: ""' key2: ""  		//Setting a null value would be confusing' as that is how we determine  		//whether a certain parameter exists  		c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = "";  	}  }  
Magic Number,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ParseQueryOnly,The following statement contains a magic number: if (namevalue.Length > 2) {  	//Handle &key=value=value and &key===value=value -> key : "value=value"  	string value = s.Substring (s.IndexOf ('=')).TrimStart ('=');  	c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (value) : value;  } else if (namevalue.Length == 2) {  	//Handle key=value (normal)  	c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (namevalue [1]) : namevalue [1];  } else if (namevalue.Length == 1) {  	//Handle &key=&key2= or &key&key2 -> key: ""' key2: ""  	//Setting a null value would be confusing' as that is how we determine  	//whether a certain parameter exists  	c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = "";  }  
Magic Number,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ParseQueryOnly,The following statement contains a magic number: if (namevalue.Length > 2) {  	//Handle &key=value=value and &key===value=value -> key : "value=value"  	string value = s.Substring (s.IndexOf ('=')).TrimStart ('=');  	c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (value) : value;  } else if (namevalue.Length == 2) {  	//Handle key=value (normal)  	c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (namevalue [1]) : namevalue [1];  } else if (namevalue.Length == 1) {  	//Handle &key=&key2= or &key&key2 -> key: ""' key2: ""  	//Setting a null value would be confusing' as that is how we determine  	//whether a certain parameter exists  	c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = "";  }  
Magic Number,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,ParseQueryOnly,The following statement contains a magic number: if (namevalue.Length == 2) {  	//Handle key=value (normal)  	c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = urlDecode ? HttpUtility.UrlDecode (namevalue [1]) : namevalue [1];  } else if (namevalue.Length == 1) {  	//Handle &key=&key2= or &key&key2 -> key: ""' key2: ""  	//Setting a null value would be confusing' as that is how we determine  	//whether a certain parameter exists  	c [urlDecode ? HttpUtility.UrlDecode (namevalue [0]) : namevalue [0]] = "";  }  
Magic Number,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,FromBase64UToBytes,The following statement contains a magic number: data = data.PadRight (data.Length + ((4 - data.Length % 4) % 4)' '=');  
Magic Number,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,FromBase64UToBytes,The following statement contains a magic number: data = data.PadRight (data.Length + ((4 - data.Length % 4) % 4)' '=');  
Magic Number,ImageResizer.Util,PathUtils,F:\newReposMay17\imazen_resizer\Core\Util\PathUtils.cs,FromBase64UToBytes,The following statement contains a magic number: data = data.PadRight (data.Length + ((4 - data.Length % 4) % 4)' '=');  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,RotatePoly,The following statement contains a magic number: for (int i = 0; i < poly.Length; i++)  	pts [i] = RotateVector (poly [i]' degrees * Math.PI / 180);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,RotatePoly,The following statement contains a magic number: pts [i] = RotateVector (poly [i]' degrees * Math.PI / 180);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,RotatePoly,The following statement contains a magic number: for (int i = 0; i < poly.Length; i++)  	pts [i] = RotateVector (poly [i]' degrees * Math.PI / 180' origin);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,RotatePoly,The following statement contains a magic number: pts [i] = RotateVector (poly [i]' degrees * Math.PI / 180' origin);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ToPoly,The following statement contains a magic number: r [2] = new PointF (rect.Right' rect.Bottom);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ToPoly,The following statement contains a magic number: r [3] = new PointF (rect.Left' rect.Bottom);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetBoundingBox,The following statement contains a magic number: for (var i = 0; i < flattenedPoints.Length; i++) {  	var v = flattenedPoints [i];  	if (i % 2 == 0) {  		if (minx == null || v < minx.Value)  			minx = v;  		if (maxx == null || v > maxx.Value)  			maxx = v;  	} else {  		if (miny == null || v < miny.Value)  			miny = v;  		if (maxy == null || v > maxy.Value)  			maxy = v;  	}  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetBoundingBox,The following statement contains a magic number: if (i % 2 == 0) {  	if (minx == null || v < minx.Value)  		minx = v;  	if (maxx == null || v > maxx.Value)  		maxx = v;  } else {  	if (miny == null || v < miny.Value)  		miny = v;  	if (maxy == null || v > maxy.Value)  		maxy = v;  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,getParallelogram,The following statement contains a magic number: p [2] = quad [3];  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,getParallelogram,The following statement contains a magic number: p [2] = quad [3];  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCorners,The following statement contains a magic number: for (int i = 0; i < poly.Length; i++) {  	//Get next an prev points. Wrap around. Clockwise.  	PointF next = (i < end) ? poly [i + 1] : poly [i - end];  	PointF prev = (i > 0) ? poly [i - 1] : poly [i + end];  	PointF current = poly [i];  	float prevWidth = (i > 0) ? widths [i - 1] : widths [i + end];  	float width = widths [i];  	//Radians = pi/(180*degrees)  	//Degrees = radians*180/pi  	//Get vectors perpendicular to next and prev' with lengths of 'offset'.  	PointF pP = ChangeMagnitude (RotateVector (new PointF (prev.X - current.X' prev.Y - current.Y)' Math.PI / 2)//rotate 90 clockwise.  	' prevWidth);  	//scale to offset length.  	PointF pN = ChangeMagnitude (RotateVector (new PointF (next.X - current.X' next.Y - current.Y)' Math.PI / -2)//rotate 90 counter-clockwise.  	' width);  	//scale to offset length.  	//Add to get points 2 and 4 of the parallelogram.  	//Add both to get point 3  	corners [i' 0] = current;  	corners [i' 1] = new PointF (current.X + pP.X' current.Y + pP.Y);  	corners [i' 2] = new PointF (current.X + pP.X + pN.X' current.Y + pP.Y + pN.Y);  	corners [i' 3] = new PointF (current.X + pN.X' current.Y + pN.Y);  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCorners,The following statement contains a magic number: for (int i = 0; i < poly.Length; i++) {  	//Get next an prev points. Wrap around. Clockwise.  	PointF next = (i < end) ? poly [i + 1] : poly [i - end];  	PointF prev = (i > 0) ? poly [i - 1] : poly [i + end];  	PointF current = poly [i];  	float prevWidth = (i > 0) ? widths [i - 1] : widths [i + end];  	float width = widths [i];  	//Radians = pi/(180*degrees)  	//Degrees = radians*180/pi  	//Get vectors perpendicular to next and prev' with lengths of 'offset'.  	PointF pP = ChangeMagnitude (RotateVector (new PointF (prev.X - current.X' prev.Y - current.Y)' Math.PI / 2)//rotate 90 clockwise.  	' prevWidth);  	//scale to offset length.  	PointF pN = ChangeMagnitude (RotateVector (new PointF (next.X - current.X' next.Y - current.Y)' Math.PI / -2)//rotate 90 counter-clockwise.  	' width);  	//scale to offset length.  	//Add to get points 2 and 4 of the parallelogram.  	//Add both to get point 3  	corners [i' 0] = current;  	corners [i' 1] = new PointF (current.X + pP.X' current.Y + pP.Y);  	corners [i' 2] = new PointF (current.X + pP.X + pN.X' current.Y + pP.Y + pN.Y);  	corners [i' 3] = new PointF (current.X + pN.X' current.Y + pN.Y);  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCorners,The following statement contains a magic number: for (int i = 0; i < poly.Length; i++) {  	//Get next an prev points. Wrap around. Clockwise.  	PointF next = (i < end) ? poly [i + 1] : poly [i - end];  	PointF prev = (i > 0) ? poly [i - 1] : poly [i + end];  	PointF current = poly [i];  	float prevWidth = (i > 0) ? widths [i - 1] : widths [i + end];  	float width = widths [i];  	//Radians = pi/(180*degrees)  	//Degrees = radians*180/pi  	//Get vectors perpendicular to next and prev' with lengths of 'offset'.  	PointF pP = ChangeMagnitude (RotateVector (new PointF (prev.X - current.X' prev.Y - current.Y)' Math.PI / 2)//rotate 90 clockwise.  	' prevWidth);  	//scale to offset length.  	PointF pN = ChangeMagnitude (RotateVector (new PointF (next.X - current.X' next.Y - current.Y)' Math.PI / -2)//rotate 90 counter-clockwise.  	' width);  	//scale to offset length.  	//Add to get points 2 and 4 of the parallelogram.  	//Add both to get point 3  	corners [i' 0] = current;  	corners [i' 1] = new PointF (current.X + pP.X' current.Y + pP.Y);  	corners [i' 2] = new PointF (current.X + pP.X + pN.X' current.Y + pP.Y + pN.Y);  	corners [i' 3] = new PointF (current.X + pN.X' current.Y + pN.Y);  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCorners,The following statement contains a magic number: for (int i = 0; i < poly.Length; i++) {  	//Get next an prev points. Wrap around. Clockwise.  	PointF next = (i < end) ? poly [i + 1] : poly [i - end];  	PointF prev = (i > 0) ? poly [i - 1] : poly [i + end];  	PointF current = poly [i];  	float prevWidth = (i > 0) ? widths [i - 1] : widths [i + end];  	float width = widths [i];  	//Radians = pi/(180*degrees)  	//Degrees = radians*180/pi  	//Get vectors perpendicular to next and prev' with lengths of 'offset'.  	PointF pP = ChangeMagnitude (RotateVector (new PointF (prev.X - current.X' prev.Y - current.Y)' Math.PI / 2)//rotate 90 clockwise.  	' prevWidth);  	//scale to offset length.  	PointF pN = ChangeMagnitude (RotateVector (new PointF (next.X - current.X' next.Y - current.Y)' Math.PI / -2)//rotate 90 counter-clockwise.  	' width);  	//scale to offset length.  	//Add to get points 2 and 4 of the parallelogram.  	//Add both to get point 3  	corners [i' 0] = current;  	corners [i' 1] = new PointF (current.X + pP.X' current.Y + pP.Y);  	corners [i' 2] = new PointF (current.X + pP.X + pN.X' current.Y + pP.Y + pN.Y);  	corners [i' 3] = new PointF (current.X + pN.X' current.Y + pN.Y);  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCorners,The following statement contains a magic number: corners [i' 2] = new PointF (current.X + pP.X + pN.X' current.Y + pP.Y + pN.Y);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCorners,The following statement contains a magic number: corners [i' 3] = new PointF (current.X + pN.X' current.Y + pN.Y);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetSides,The following statement contains a magic number: for (int i = 0; i <= corners.GetUpperBound (0); i++) {  	int next = (i < corners.GetUpperBound (0)) ? i + 1 : i - corners.GetUpperBound (0);  	sides [i' 0] = corners [i' 3];  	sides [i' 3] = corners [i' 0];  	sides [i' 1] = corners [next' 1];  	sides [i' 2] = corners [next' 0];  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetSides,The following statement contains a magic number: for (int i = 0; i <= corners.GetUpperBound (0); i++) {  	int next = (i < corners.GetUpperBound (0)) ? i + 1 : i - corners.GetUpperBound (0);  	sides [i' 0] = corners [i' 3];  	sides [i' 3] = corners [i' 0];  	sides [i' 1] = corners [next' 1];  	sides [i' 2] = corners [next' 0];  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetSides,The following statement contains a magic number: for (int i = 0; i <= corners.GetUpperBound (0); i++) {  	int next = (i < corners.GetUpperBound (0)) ? i + 1 : i - corners.GetUpperBound (0);  	sides [i' 0] = corners [i' 3];  	sides [i' 3] = corners [i' 0];  	sides [i' 1] = corners [next' 1];  	sides [i' 2] = corners [next' 0];  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetSides,The following statement contains a magic number: sides [i' 0] = corners [i' 3];  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetSides,The following statement contains a magic number: sides [i' 3] = corners [i' 0];  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetSides,The following statement contains a magic number: sides [i' 2] = corners [next' 0];  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,InflatePoly,The following statement contains a magic number: for (int i = 0; i <= corners.GetUpperBound (0); i++)  	newPoly [i] = corners [i' 2];  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,InflatePoly,The following statement contains a magic number: newPoly [i] = corners [i' 2];  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,InflatePoly,The following statement contains a magic number: for (int i = 0; i <= corners.GetUpperBound (0); i++)  	newPoly [i] = corners [i' 2];  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,InflatePoly,The following statement contains a magic number: newPoly [i] = corners [i' 2];  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CenterInside,The following statement contains a magic number: return MovePoly (NormalizePoly (inner)' new PointF ((outBox.Width - inBox.Width) / 2 + outBox.X' (outBox.Height - inBox.Height) / 2 + outBox.Y));  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CenterInside,The following statement contains a magic number: return MovePoly (NormalizePoly (inner)' new PointF ((outBox.Width - inBox.Width) / 2 + outBox.X' (outBox.Height - inBox.Height) / 2 + outBox.Y));  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CenterInside,The following statement contains a magic number: return new RectangleF (bounds.Width / 2 + bounds.X - (size.Width / 2)' bounds.Height / 2 + bounds.Y - (size.Height / 2)' size.Width' size.Height);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CenterInside,The following statement contains a magic number: return new RectangleF (bounds.Width / 2 + bounds.X - (size.Width / 2)' bounds.Height / 2 + bounds.Y - (size.Height / 2)' size.Width' size.Height);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CenterInside,The following statement contains a magic number: return new RectangleF (bounds.Width / 2 + bounds.X - (size.Width / 2)' bounds.Height / 2 + bounds.Y - (size.Height / 2)' size.Width' size.Height);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CenterInside,The following statement contains a magic number: return new RectangleF (bounds.Width / 2 + bounds.X - (size.Width / 2)' bounds.Height / 2 + bounds.Y - (size.Height / 2)' size.Width' size.Height);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,AlignWith,The following statement contains a magic number: if (align == ContentAlignment.BottomCenter || align == ContentAlignment.MiddleCenter || align == ContentAlignment.TopCenter)  	obj.X = container.X + (container.Width - obj.Width) / 2;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,AlignWith,The following statement contains a magic number: obj.X = container.X + (container.Width - obj.Width) / 2;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,AlignWith,The following statement contains a magic number: if (align == ContentAlignment.MiddleLeft || align == ContentAlignment.MiddleCenter || align == ContentAlignment.MiddleRight)  	obj.Y = container.Y + (container.Height - obj.Height) / 2;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,AlignWith,The following statement contains a magic number: obj.Y = container.Y + (container.Height - obj.Height) / 2;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,Average,The following statement contains a magic number: return new PointF ((a.X + b.X) / 2' (a.Y + b.Y) / 2);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,Average,The following statement contains a magic number: return new PointF ((a.X + b.X) / 2' (a.Y + b.Y) / 2);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: d = d % 360;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d < 0)  	d += 360;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: d += 360;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 315 && d < 360)  	return 0;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 315 && d < 360)  	return 0;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 0 && d < 45)  	return 0;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 45 && d < 135)  	return 90;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 45 && d < 135)  	return 90;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 45 && d < 135)  	return 90;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: return 90;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 135 && d < 225)  	return 180;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 135 && d < 225)  	return 180;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 135 && d < 225)  	return 180;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: return 180;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 225 && d < 315)  	return 270;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 225 && d < 315)  	return 270;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: if (d >= 225 && d < 315)  	return 270;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,NormalizeTo90Intervals,The following statement contains a magic number: return 270;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.None) {  	return (RotateFlipType)(int)(angle / 90);  } else if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: return (RotateFlipType)(int)(angle / 90);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.X) {  	return (RotateFlipType)(int)(4 + (angle / 90));  } else if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: return (RotateFlipType)(int)(4 + (angle / 90));  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: return (RotateFlipType)(int)(4 + (angle / 90));  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.Y) {  	if (angle == 0)  		return (RotateFlipType)6;  	if (angle == 90)  		return (RotateFlipType)7;  	if (angle == 180)  		return (RotateFlipType)4;  	if (angle == 270)  		return (RotateFlipType)5;  } else if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 0)  	return (RotateFlipType)6;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: return (RotateFlipType)6;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 90)  	return (RotateFlipType)7;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 90)  	return (RotateFlipType)7;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: return (RotateFlipType)7;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 180)  	return (RotateFlipType)4;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 180)  	return (RotateFlipType)4;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: return (RotateFlipType)4;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 270)  	return (RotateFlipType)5;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 270)  	return (RotateFlipType)5;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: return (RotateFlipType)5;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (flip == FlipMode.XY) {  	if (angle == 0)  		return (RotateFlipType)2;  	if (angle == 90)  		return (RotateFlipType)3;  	if (angle == 180)  		return (RotateFlipType)0;  	if (angle == 270)  		return (RotateFlipType)1;  } else {  	throw new ArgumentException ("Invalid FlipMode value " + flip.ToString ());  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 0)  	return (RotateFlipType)2;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: return (RotateFlipType)2;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 90)  	return (RotateFlipType)3;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 90)  	return (RotateFlipType)3;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: return (RotateFlipType)3;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 180)  	return (RotateFlipType)0;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,CombineFlipAndRotate,The following statement contains a magic number: if (angle == 270)  	return (RotateFlipType)1;  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCroppingRectangle,The following statement contains a magic number: for (int i = 0; i < c.Length; i++) {  	bool xvalue = i % 2 == 0;  	if (xvalue && xunits != 0)  		c [i] *= (imageSize.Width / xunits);  	if (!xvalue && yunits != 0)  		c [i] *= (imageSize.Height / yunits);  	//Prohibit values larger than imageSize  	if (xvalue && c [i] > imageSize.Width)  		c [i] = imageSize.Width;  	if (!xvalue && c [i] > imageSize.Height)  		c [i] = imageSize.Height;  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCroppingRectangle,The following statement contains a magic number: if (c.Length == 2) {  	if (c [0] < 1 || c [1] < 1)  		return defValue;  	//We can't do anything with negative values here  	//Center horizontally and vertically.  	double x = (imageSize.Width - c [0]) / 2;  	double y = (imageSize.Height - c [1]) / 2;  	c = new double[] {  		x'  		y'  		x + c [0]'  		y + c [1]  	};  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCroppingRectangle,The following statement contains a magic number: if (c.Length == 2) {  	if (c [0] < 1 || c [1] < 1)  		return defValue;  	//We can't do anything with negative values here  	//Center horizontally and vertically.  	double x = (imageSize.Width - c [0]) / 2;  	double y = (imageSize.Height - c [1]) / 2;  	c = new double[] {  		x'  		y'  		x + c [0]'  		y + c [1]  	};  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,GetCroppingRectangle,The following statement contains a magic number: if (c.Length == 2) {  	if (c [0] < 1 || c [1] < 1)  		return defValue;  	//We can't do anything with negative values here  	//Center horizontally and vertically.  	double x = (imageSize.Width - c [0]) / 2;  	double y = (imageSize.Height - c [1]) / 2;  	c = new double[] {  		x'  		y'  		x + c [0]'  		y + c [1]  	};  }  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ExpandTo,The following statement contains a magic number: return new RectangleF (box.X - (dx / 2)' box.Y - (dy / 2)' copySize.Width' copySize.Height);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ExpandTo,The following statement contains a magic number: return new RectangleF (box.X - (dx / 2)' box.Y - (dy / 2)' copySize.Width' copySize.Height);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ScaleRect,The following statement contains a magic number: return new RectangleF (rect.X - (dx / 2)' rect.Y - (dy / 2)' rect.Width + dx' rect.Height + dy);  
Magic Number,ImageResizer.Util,PolygonMath,F:\newReposMay17\imazen_resizer\Core\Util\PolygonMath.cs,ScaleRect,The following statement contains a magic number: return new RectangleF (rect.X - (dx / 2)' rect.Y - (dy / 2)' rect.Width + dx' rect.Height + dy);  
Magic Number,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,parseCrop,The following statement contains a magic number: if (coords.Length == 4)  	return new KeyValuePair<CropMode' double[]> (CropMode.Custom' coords);  
Magic Number,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,parsePadding,The following statement contains a magic number: if (coords.Length == 4)  	return new BoxPadding (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,parsePadding,The following statement contains a magic number: if (coords.Length == 4)  	return new BoxPadding (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,parsePadding,The following statement contains a magic number: if (coords.Length == 4)  	return new BoxPadding (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,parsePadding,The following statement contains a magic number: return new BoxPadding (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,parsePadding,The following statement contains a magic number: return new BoxPadding (coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ImageResizer.Util,Utils,F:\newReposMay17\imazen_resizer\Core\Util\Utils.cs,parsePointF,The following statement contains a magic number: if (coords.Length == 2)  	return new PointF ((float)coords [0]' (float)coords [1]);  
Missing Default,ImageResizer.Plugins.Basic,Image404,F:\newReposMay17\imazen_resizer\Core\Plugins\Basic\Image404.cs,CreateRemovalMatcher,The following switch statement is missing a default case: switch (filterMode) {  case FilterMode.IncludeUnknownCommands:  	// To include unknown commands' we remove blacklisted  	// and 'except' commands.  	shouldRemove = delegate (string name' string value) {  		return DefaultBlacklist.IsMatch (name' value) || except.IsMatch (name' value);  	};  	break;  case FilterMode.ExcludeUnknownCommands:  	// To exclude unknown commands' we *keep* whitelisted  	// and 'except' commands.  	shouldRemove = delegate (string name' string value) {  		return !(DefaultWhitelist.IsMatch (name' value) || except.IsMatch (name' value));  	};  	break;  case FilterMode.IncludeAllCommands:  	// To include all commands' we remove any of the 'except'  	// commands.  	shouldRemove = delegate (string name' string value) {  		return except.IsMatch (name' value);  	};  	break;  case FilterMode.ExcludeAllCommands:  	// To exclude all commands' we only keep the 'except'  	// commands.  	shouldRemove = delegate (string name' string value) {  		return !except.IsMatch (name' value);  	};  	break;  }  
