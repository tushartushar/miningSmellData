Implementation smell,Namespace,Class,File,Method,Description
Long Method,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The method has 194 lines of code.
Complex Method,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,Cyclomatic complexity of the method is 23
Complex Method,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,Cyclomatic complexity of the method is 24
Complex Method,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,Cyclomatic complexity of the method is 10
Complex Method,PhotoshopFile,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,Save,Cyclomatic complexity of the method is 8
Complex Method,PhotoshopFile,WaitableCounter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PrivateThreadPool.cs,Dispose,Cyclomatic complexity of the method is 8
Complex Method,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImageResources,Cyclomatic complexity of the method is 11
Complex Method,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,SaveLayers,Cyclomatic complexity of the method is 9
Complex Method,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,Cyclomatic complexity of the method is 19
Complex Method,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,parseTypeString,Cyclomatic complexity of the method is 14
Complex Method,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,ReadValue,Cyclomatic complexity of the method is 38
Complex Method,PhotoshopFile.Text,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,Cyclomatic complexity of the method is 17
Complex Method,PhotoshopFile.Text,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,Cyclomatic complexity of the method is 25
Complex Method,PhotoshopFile.Text,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,Cyclomatic complexity of the method is 23
Complex Method,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,Cyclomatic complexity of the method is 43
Complex Method,PhotoshopFile.Text,Token,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,Cyclomatic complexity of the method is 18
Complex Method,PhotoshopFile.Text,TypeTool,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TypeTool.cs,TypeTool,Cyclomatic complexity of the method is 8
Long Statement,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The length of the statement  "		c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]); " is 131.
Long Statement,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The length of the statement  "			c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]); " is 134.
Long Statement,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The length of the statement  "			c = Color.FromArgb ((int)layer.colorModeData [index]' layer.colorModeData [index + 256]' layer.colorModeData [index + 2 * 256]); " is 128.
Long Statement,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,SaveImageRLE,The length of the statement  "			rleRowLengths [row + startIdx] = RleHelper.EncodedRow (writer.BaseStream' m_imageData [ch]' row * m_columns' m_columns); " is 120.
Long Statement,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,getString,The length of the statement  "	string s = lineprefix + "(" + this.Type.ToString () + ") " + this.Name + ":" + ((this.Value == null) ? "null" : this.Value.ToString ()); " is 136.
Long Statement,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The length of the statement  "	return Color.FromArgb ((int)((double)values [0] * 255)' (int)((double)values [1] * 255)' (int)((double)values [2] * 255)' (int)((double)values [3] * 255)); " is 155.
Long Statement,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The length of the statement  "		throw new Exception ("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString (b)); " is 126.
Long Statement,PhotoshopFile.Text,TdTaStylesheetReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaStylesheetReader.cs,BuildRunItem,The length of the statement  "	return TdTaParser.MergeObjects (TdTaParser.getDict (tree' baseSelector + ".DefaultRunData")' TdTaParser.getList (tree' baseSelector + ".RunArray") [index]); " is 156.
Long Statement,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The length of the statement  "		throw new Exception ("Old style tySh font syntax not implemented' found on layer " + l.Name + ". Use a newer version of Photoshop"); " is 132.
Long Statement,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The length of the statement  "		throw new Exception ("Txt2 text layer info not supported' found on layer " + l.Name + ". Where did you find this file? What version of photoshop?"); " is 148.
Long Statement,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The length of the statement  "			fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' ""); " is 128.
Long Statement,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The length of the statement  "				using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) { " is 148.
Complex Conditional,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetMaskValue,The conditional expression  "y >= 0 && y < mask.Rect.Height && x >= 0 && x < mask.Rect.Width"  is complex.
Complex Conditional,PhotoshopFile,ReadableBinary,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The conditional expression  "((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26)"  is complex.
Complex Conditional,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,copy,The conditional expression  "o is double || o is string || o is int || o is bool"  is complex.
Complex Conditional,PhotoshopFile.Text,Token,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The conditional expression  "Char.IsWhiteSpace (pc) || pc == '\n' || pc == '[' || pc == ']' || pc == '<' || pc == '>'"  is complex.
Complex Conditional,PhotoshopFile.Text,Token,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The conditional expression  "Char.IsWhiteSpace (pc) || pc == '\n' || pc == ']' || pc == '>'"  is complex.
Complex Conditional,PhotoshopFile.Text,Token,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The conditional expression  "c == 't' || c == 'T' || c == 'f' || c == 'F'"  is complex.
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadInt16,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 2);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadInt16,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 2);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadDouble,The following statement contains a magic number: unsafe {  	SwapBytes ((byte*)&val' 8);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadDouble,The following statement contains a magic number: SwapBytes ((byte*)&val' 8);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadInt32,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 4);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadInt32,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 4);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadInt64,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 8);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadInt64,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 8);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadUInt16,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 2);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadUInt16,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 2);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadUInt32,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 4);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadUInt32,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 4);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadUInt64,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 8);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadUInt64,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 8);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPascalString,The following statement contains a magic number: if ((stringLength % 2) == 0)  	base.ReadByte ();  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDUnicodeString,The following statement contains a magic number: for (int i = 0; i < nLength * 2; i++) {  	char c = base.ReadChar ();  	if (i % 2 == 1 && c != 0)  		s += c;  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDUnicodeString,The following statement contains a magic number: for (int i = 0; i < nLength * 2; i++) {  	char c = base.ReadChar ();  	if (i % 2 == 1 && c != 0)  		s += c;  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDUnicodeString,The following statement contains a magic number: if (i % 2 == 1 && c != 0)  	s += c;  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadTdTaString,The following statement contains a magic number: while (BytesToEnd > 0) {  	c = base.ReadChar ();  	if (c != 0x0)  		sb.Append (c);  	if (c == '>' && sb [sb.Length - 2] == '>' && sb [sb.Length - 3] == '\n') {  		//we hit the end.  		break;  	}  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadTdTaString,The following statement contains a magic number: while (BytesToEnd > 0) {  	c = base.ReadChar ();  	if (c != 0x0)  		sb.Append (c);  	if (c == '>' && sb [sb.Length - 2] == '>' && sb [sb.Length - 3] == '\n') {  		//we hit the end.  		break;  	}  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadTdTaString,The following statement contains a magic number: if (c == '>' && sb [sb.Length - 2] == '>' && sb [sb.Length - 3] == '\n') {  	//we hit the end.  	break;  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadTdTaString,The following statement contains a magic number: if (c == '>' && sb [sb.Length - 2] == '>' && sb [sb.Length - 3] == '\n') {  	//we hit the end.  	break;  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (!alpha)  	a = 255;  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: a = 255;  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: this.BaseStream.Position += 2;  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  
Magic Number,PhotoshopFile,BinaryReverseReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,SwapBytes,The following statement contains a magic number: for (long i = 0; i < nLength / 2; ++i) {  	byte t = *(ptr + i);  	*(ptr + i) = *(ptr + nLength - i - 1);  	*(ptr + nLength - i - 1) = t;  }  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: if (s.Length > 255)  	c = s.Substring (0' 255).ToCharArray ();  else  	c = s.ToCharArray ();  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: if (s.Length > 255)  	c = s.Substring (0' 255).ToCharArray ();  else  	c = s.ToCharArray ();  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: c = s.Substring (0' 255).ToCharArray ();  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: if ((realLength % 2) == 0)  	return;  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: for (int i = 0; i < (2 - (realLength % 2)); i++)  	base.Write ((byte)0);  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: for (int i = 0; i < (2 - (realLength % 2)); i++)  	base.Write ((byte)0);  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 2);  }  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 2);  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 4);  }  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 4);  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 8);  }  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 8);  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 2);  }  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 2);  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 4);  }  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 4);  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe {  	this.SwapBytes ((byte*)&val' 8);  }  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: this.SwapBytes ((byte*)&val' 8);  
Magic Number,PhotoshopFile,BinaryReverseWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,SwapBytes,The following statement contains a magic number: for (long i = 0; i < nLength / 2; ++i) {  	byte t = *(ptr + i);  	*(ptr + i) = *(ptr + nLength - i - 1);  	*(ptr + nLength - i - 1) = t;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,BytesFromBits,The following statement contains a magic number: return (bits + 7) / 8;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,BytesFromBits,The following statement contains a magic number: return (bits + 7) / 8;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetBitmapValue,The following statement contains a magic number: bwValue = (bwValue == 0) ? (byte)255 : (byte)0;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: unsafe {  	byte* pCurrRowPixel = (byte*)bd.Scan0.ToPointer ();  	for (int y = 0; y < psdFile.Rows; y++) {  		int rowIndex = y * psdFile.Columns;  		PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;  		for (int x = 0; x < psdFile.Columns; x++) {  			int pos = rowIndex + x;  			Color pixelColor = GetColor (psdFile' pos);  			pCurrPixel->Alpha = 255;  			pCurrPixel->Red = pixelColor.R;  			pCurrPixel->Green = pixelColor.G;  			pCurrPixel->Blue = pixelColor.B;  			pCurrPixel += 1;  		}  		pCurrRowPixel += bd.Stride;  	}  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: for (int y = 0; y < psdFile.Rows; y++) {  	int rowIndex = y * psdFile.Columns;  	PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;  	for (int x = 0; x < psdFile.Columns; x++) {  		int pos = rowIndex + x;  		Color pixelColor = GetColor (psdFile' pos);  		pCurrPixel->Alpha = 255;  		pCurrPixel->Red = pixelColor.R;  		pCurrPixel->Green = pixelColor.G;  		pCurrPixel->Blue = pixelColor.B;  		pCurrPixel += 1;  	}  	pCurrRowPixel += bd.Stride;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: for (int x = 0; x < psdFile.Columns; x++) {  	int pos = rowIndex + x;  	Color pixelColor = GetColor (psdFile' pos);  	pCurrPixel->Alpha = 255;  	pCurrPixel->Red = pixelColor.R;  	pCurrPixel->Green = pixelColor.G;  	pCurrPixel->Blue = pixelColor.B;  	pCurrPixel += 1;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: pCurrPixel->Alpha = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (psdFile.ImageData [0]' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)psdFile.ImageData [0] [pos];  		c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (psdFile.ImageData [0]' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)psdFile.ImageData [0] [pos];  		c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (psdFile.ImageData [0]' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)psdFile.ImageData [0] [pos];  		c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (psdFile.ImageData [0]' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)psdFile.ImageData [0] [pos];  		c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (psdFile.ImageData [0]' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)psdFile.ImageData [0] [pos];  		c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (psdFile.ImageData [0]' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)psdFile.ImageData [0] [pos];  		c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (psdFile.ImageData [0]' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)psdFile.ImageData [0] [pos];  		c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (psdFile.ImageData [0]' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)psdFile.ImageData [0] [pos];  		c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' 0);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = LabToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: unsafe {  	byte* pCurrRowPixel = (byte*)bd.Scan0.ToPointer ();  	for (int y = 0; y < height; y++) {  		int rowIndex = y * width;  		PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;  		for (int x = 0; x < width; x++) {  			int pos = rowIndex + x;  			//Fast path for RGB mode' somewhat inlined.  			if (l.colorMode == PsdFile.ColorModes.RGB) {  				//Add alpha channel if it exists.  				if (l.hasalpha)  					pCurrPixel->Alpha = l.alphabytes [pos];  				else  					pCurrPixel->Alpha = 255;  				//Apply mask if present.  				if (l.hasmask)  					pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  				pCurrPixel->Red = l.ch0bytes [pos];  				pCurrPixel->Green = l.ch1bytes [pos];  				pCurrPixel->Blue = l.ch2bytes [pos];  			} else {  				Color pixelColor = GetColor (l' pos);  				if (l.hasmask) {  					int maskAlpha = GetMaskValue (layer.MaskData' x' y);  					int oldAlpha = pixelColor.A;  					int newAlpha = (oldAlpha * maskAlpha) / 255;  					pixelColor = Color.FromArgb (newAlpha' pixelColor);  				}  				pCurrPixel->Alpha = pixelColor.A;  				pCurrPixel->Red = pixelColor.R;  				pCurrPixel->Green = pixelColor.G;  				pCurrPixel->Blue = pixelColor.B;  			}  			pCurrPixel += 1;  		}  		pCurrRowPixel += bd.Stride;  	}  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: unsafe {  	byte* pCurrRowPixel = (byte*)bd.Scan0.ToPointer ();  	for (int y = 0; y < height; y++) {  		int rowIndex = y * width;  		PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;  		for (int x = 0; x < width; x++) {  			int pos = rowIndex + x;  			//Fast path for RGB mode' somewhat inlined.  			if (l.colorMode == PsdFile.ColorModes.RGB) {  				//Add alpha channel if it exists.  				if (l.hasalpha)  					pCurrPixel->Alpha = l.alphabytes [pos];  				else  					pCurrPixel->Alpha = 255;  				//Apply mask if present.  				if (l.hasmask)  					pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  				pCurrPixel->Red = l.ch0bytes [pos];  				pCurrPixel->Green = l.ch1bytes [pos];  				pCurrPixel->Blue = l.ch2bytes [pos];  			} else {  				Color pixelColor = GetColor (l' pos);  				if (l.hasmask) {  					int maskAlpha = GetMaskValue (layer.MaskData' x' y);  					int oldAlpha = pixelColor.A;  					int newAlpha = (oldAlpha * maskAlpha) / 255;  					pixelColor = Color.FromArgb (newAlpha' pixelColor);  				}  				pCurrPixel->Alpha = pixelColor.A;  				pCurrPixel->Red = pixelColor.R;  				pCurrPixel->Green = pixelColor.G;  				pCurrPixel->Blue = pixelColor.B;  			}  			pCurrPixel += 1;  		}  		pCurrRowPixel += bd.Stride;  	}  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: unsafe {  	byte* pCurrRowPixel = (byte*)bd.Scan0.ToPointer ();  	for (int y = 0; y < height; y++) {  		int rowIndex = y * width;  		PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;  		for (int x = 0; x < width; x++) {  			int pos = rowIndex + x;  			//Fast path for RGB mode' somewhat inlined.  			if (l.colorMode == PsdFile.ColorModes.RGB) {  				//Add alpha channel if it exists.  				if (l.hasalpha)  					pCurrPixel->Alpha = l.alphabytes [pos];  				else  					pCurrPixel->Alpha = 255;  				//Apply mask if present.  				if (l.hasmask)  					pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  				pCurrPixel->Red = l.ch0bytes [pos];  				pCurrPixel->Green = l.ch1bytes [pos];  				pCurrPixel->Blue = l.ch2bytes [pos];  			} else {  				Color pixelColor = GetColor (l' pos);  				if (l.hasmask) {  					int maskAlpha = GetMaskValue (layer.MaskData' x' y);  					int oldAlpha = pixelColor.A;  					int newAlpha = (oldAlpha * maskAlpha) / 255;  					pixelColor = Color.FromArgb (newAlpha' pixelColor);  				}  				pCurrPixel->Alpha = pixelColor.A;  				pCurrPixel->Red = pixelColor.R;  				pCurrPixel->Green = pixelColor.G;  				pCurrPixel->Blue = pixelColor.B;  			}  			pCurrPixel += 1;  		}  		pCurrRowPixel += bd.Stride;  	}  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	int rowIndex = y * width;  	PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;  	for (int x = 0; x < width; x++) {  		int pos = rowIndex + x;  		//Fast path for RGB mode' somewhat inlined.  		if (l.colorMode == PsdFile.ColorModes.RGB) {  			//Add alpha channel if it exists.  			if (l.hasalpha)  				pCurrPixel->Alpha = l.alphabytes [pos];  			else  				pCurrPixel->Alpha = 255;  			//Apply mask if present.  			if (l.hasmask)  				pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  			pCurrPixel->Red = l.ch0bytes [pos];  			pCurrPixel->Green = l.ch1bytes [pos];  			pCurrPixel->Blue = l.ch2bytes [pos];  		} else {  			Color pixelColor = GetColor (l' pos);  			if (l.hasmask) {  				int maskAlpha = GetMaskValue (layer.MaskData' x' y);  				int oldAlpha = pixelColor.A;  				int newAlpha = (oldAlpha * maskAlpha) / 255;  				pixelColor = Color.FromArgb (newAlpha' pixelColor);  			}  			pCurrPixel->Alpha = pixelColor.A;  			pCurrPixel->Red = pixelColor.R;  			pCurrPixel->Green = pixelColor.G;  			pCurrPixel->Blue = pixelColor.B;  		}  		pCurrPixel += 1;  	}  	pCurrRowPixel += bd.Stride;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	int rowIndex = y * width;  	PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;  	for (int x = 0; x < width; x++) {  		int pos = rowIndex + x;  		//Fast path for RGB mode' somewhat inlined.  		if (l.colorMode == PsdFile.ColorModes.RGB) {  			//Add alpha channel if it exists.  			if (l.hasalpha)  				pCurrPixel->Alpha = l.alphabytes [pos];  			else  				pCurrPixel->Alpha = 255;  			//Apply mask if present.  			if (l.hasmask)  				pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  			pCurrPixel->Red = l.ch0bytes [pos];  			pCurrPixel->Green = l.ch1bytes [pos];  			pCurrPixel->Blue = l.ch2bytes [pos];  		} else {  			Color pixelColor = GetColor (l' pos);  			if (l.hasmask) {  				int maskAlpha = GetMaskValue (layer.MaskData' x' y);  				int oldAlpha = pixelColor.A;  				int newAlpha = (oldAlpha * maskAlpha) / 255;  				pixelColor = Color.FromArgb (newAlpha' pixelColor);  			}  			pCurrPixel->Alpha = pixelColor.A;  			pCurrPixel->Red = pixelColor.R;  			pCurrPixel->Green = pixelColor.G;  			pCurrPixel->Blue = pixelColor.B;  		}  		pCurrPixel += 1;  	}  	pCurrRowPixel += bd.Stride;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	int rowIndex = y * width;  	PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;  	for (int x = 0; x < width; x++) {  		int pos = rowIndex + x;  		//Fast path for RGB mode' somewhat inlined.  		if (l.colorMode == PsdFile.ColorModes.RGB) {  			//Add alpha channel if it exists.  			if (l.hasalpha)  				pCurrPixel->Alpha = l.alphabytes [pos];  			else  				pCurrPixel->Alpha = 255;  			//Apply mask if present.  			if (l.hasmask)  				pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  			pCurrPixel->Red = l.ch0bytes [pos];  			pCurrPixel->Green = l.ch1bytes [pos];  			pCurrPixel->Blue = l.ch2bytes [pos];  		} else {  			Color pixelColor = GetColor (l' pos);  			if (l.hasmask) {  				int maskAlpha = GetMaskValue (layer.MaskData' x' y);  				int oldAlpha = pixelColor.A;  				int newAlpha = (oldAlpha * maskAlpha) / 255;  				pixelColor = Color.FromArgb (newAlpha' pixelColor);  			}  			pCurrPixel->Alpha = pixelColor.A;  			pCurrPixel->Red = pixelColor.R;  			pCurrPixel->Green = pixelColor.G;  			pCurrPixel->Blue = pixelColor.B;  		}  		pCurrPixel += 1;  	}  	pCurrRowPixel += bd.Stride;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	int pos = rowIndex + x;  	//Fast path for RGB mode' somewhat inlined.  	if (l.colorMode == PsdFile.ColorModes.RGB) {  		//Add alpha channel if it exists.  		if (l.hasalpha)  			pCurrPixel->Alpha = l.alphabytes [pos];  		else  			pCurrPixel->Alpha = 255;  		//Apply mask if present.  		if (l.hasmask)  			pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  		pCurrPixel->Red = l.ch0bytes [pos];  		pCurrPixel->Green = l.ch1bytes [pos];  		pCurrPixel->Blue = l.ch2bytes [pos];  	} else {  		Color pixelColor = GetColor (l' pos);  		if (l.hasmask) {  			int maskAlpha = GetMaskValue (layer.MaskData' x' y);  			int oldAlpha = pixelColor.A;  			int newAlpha = (oldAlpha * maskAlpha) / 255;  			pixelColor = Color.FromArgb (newAlpha' pixelColor);  		}  		pCurrPixel->Alpha = pixelColor.A;  		pCurrPixel->Red = pixelColor.R;  		pCurrPixel->Green = pixelColor.G;  		pCurrPixel->Blue = pixelColor.B;  	}  	pCurrPixel += 1;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	int pos = rowIndex + x;  	//Fast path for RGB mode' somewhat inlined.  	if (l.colorMode == PsdFile.ColorModes.RGB) {  		//Add alpha channel if it exists.  		if (l.hasalpha)  			pCurrPixel->Alpha = l.alphabytes [pos];  		else  			pCurrPixel->Alpha = 255;  		//Apply mask if present.  		if (l.hasmask)  			pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  		pCurrPixel->Red = l.ch0bytes [pos];  		pCurrPixel->Green = l.ch1bytes [pos];  		pCurrPixel->Blue = l.ch2bytes [pos];  	} else {  		Color pixelColor = GetColor (l' pos);  		if (l.hasmask) {  			int maskAlpha = GetMaskValue (layer.MaskData' x' y);  			int oldAlpha = pixelColor.A;  			int newAlpha = (oldAlpha * maskAlpha) / 255;  			pixelColor = Color.FromArgb (newAlpha' pixelColor);  		}  		pCurrPixel->Alpha = pixelColor.A;  		pCurrPixel->Red = pixelColor.R;  		pCurrPixel->Green = pixelColor.G;  		pCurrPixel->Blue = pixelColor.B;  	}  	pCurrPixel += 1;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	int pos = rowIndex + x;  	//Fast path for RGB mode' somewhat inlined.  	if (l.colorMode == PsdFile.ColorModes.RGB) {  		//Add alpha channel if it exists.  		if (l.hasalpha)  			pCurrPixel->Alpha = l.alphabytes [pos];  		else  			pCurrPixel->Alpha = 255;  		//Apply mask if present.  		if (l.hasmask)  			pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  		pCurrPixel->Red = l.ch0bytes [pos];  		pCurrPixel->Green = l.ch1bytes [pos];  		pCurrPixel->Blue = l.ch2bytes [pos];  	} else {  		Color pixelColor = GetColor (l' pos);  		if (l.hasmask) {  			int maskAlpha = GetMaskValue (layer.MaskData' x' y);  			int oldAlpha = pixelColor.A;  			int newAlpha = (oldAlpha * maskAlpha) / 255;  			pixelColor = Color.FromArgb (newAlpha' pixelColor);  		}  		pCurrPixel->Alpha = pixelColor.A;  		pCurrPixel->Red = pixelColor.R;  		pCurrPixel->Green = pixelColor.G;  		pCurrPixel->Blue = pixelColor.B;  	}  	pCurrPixel += 1;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: if (l.colorMode == PsdFile.ColorModes.RGB) {  	//Add alpha channel if it exists.  	if (l.hasalpha)  		pCurrPixel->Alpha = l.alphabytes [pos];  	else  		pCurrPixel->Alpha = 255;  	//Apply mask if present.  	if (l.hasmask)  		pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  	pCurrPixel->Red = l.ch0bytes [pos];  	pCurrPixel->Green = l.ch1bytes [pos];  	pCurrPixel->Blue = l.ch2bytes [pos];  } else {  	Color pixelColor = GetColor (l' pos);  	if (l.hasmask) {  		int maskAlpha = GetMaskValue (layer.MaskData' x' y);  		int oldAlpha = pixelColor.A;  		int newAlpha = (oldAlpha * maskAlpha) / 255;  		pixelColor = Color.FromArgb (newAlpha' pixelColor);  	}  	pCurrPixel->Alpha = pixelColor.A;  	pCurrPixel->Red = pixelColor.R;  	pCurrPixel->Green = pixelColor.G;  	pCurrPixel->Blue = pixelColor.B;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: if (l.colorMode == PsdFile.ColorModes.RGB) {  	//Add alpha channel if it exists.  	if (l.hasalpha)  		pCurrPixel->Alpha = l.alphabytes [pos];  	else  		pCurrPixel->Alpha = 255;  	//Apply mask if present.  	if (l.hasmask)  		pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  	pCurrPixel->Red = l.ch0bytes [pos];  	pCurrPixel->Green = l.ch1bytes [pos];  	pCurrPixel->Blue = l.ch2bytes [pos];  } else {  	Color pixelColor = GetColor (l' pos);  	if (l.hasmask) {  		int maskAlpha = GetMaskValue (layer.MaskData' x' y);  		int oldAlpha = pixelColor.A;  		int newAlpha = (oldAlpha * maskAlpha) / 255;  		pixelColor = Color.FromArgb (newAlpha' pixelColor);  	}  	pCurrPixel->Alpha = pixelColor.A;  	pCurrPixel->Red = pixelColor.R;  	pCurrPixel->Green = pixelColor.G;  	pCurrPixel->Blue = pixelColor.B;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: if (l.colorMode == PsdFile.ColorModes.RGB) {  	//Add alpha channel if it exists.  	if (l.hasalpha)  		pCurrPixel->Alpha = l.alphabytes [pos];  	else  		pCurrPixel->Alpha = 255;  	//Apply mask if present.  	if (l.hasmask)  		pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  	pCurrPixel->Red = l.ch0bytes [pos];  	pCurrPixel->Green = l.ch1bytes [pos];  	pCurrPixel->Blue = l.ch2bytes [pos];  } else {  	Color pixelColor = GetColor (l' pos);  	if (l.hasmask) {  		int maskAlpha = GetMaskValue (layer.MaskData' x' y);  		int oldAlpha = pixelColor.A;  		int newAlpha = (oldAlpha * maskAlpha) / 255;  		pixelColor = Color.FromArgb (newAlpha' pixelColor);  	}  	pCurrPixel->Alpha = pixelColor.A;  	pCurrPixel->Red = pixelColor.R;  	pCurrPixel->Green = pixelColor.G;  	pCurrPixel->Blue = pixelColor.B;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: if (l.hasalpha)  	pCurrPixel->Alpha = l.alphabytes [pos];  else  	pCurrPixel->Alpha = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: pCurrPixel->Alpha = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: if (l.hasmask)  	pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue (layer.MaskData' x' y)) / 255);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: if (l.hasmask) {  	int maskAlpha = GetMaskValue (layer.MaskData' x' y);  	int oldAlpha = pixelColor.A;  	int newAlpha = (oldAlpha * maskAlpha) / 255;  	pixelColor = Color.FromArgb (newAlpha' pixelColor);  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (layer.colorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]' layer.ch3bytes [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (layer.ch0bytes' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (layer.ch0bytes [pos]' layer.ch0bytes [pos]' layer.ch0bytes [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)layer.ch0bytes [pos];  		c = Color.FromArgb ((int)layer.colorModeData [index]' layer.colorModeData [index + 256]' layer.colorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (layer.colorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]' layer.ch3bytes [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (layer.ch0bytes' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (layer.ch0bytes [pos]' layer.ch0bytes [pos]' layer.ch0bytes [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)layer.ch0bytes [pos];  		c = Color.FromArgb ((int)layer.colorModeData [index]' layer.colorModeData [index + 256]' layer.colorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (layer.colorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]' layer.ch3bytes [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (layer.ch0bytes' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (layer.ch0bytes [pos]' layer.ch0bytes [pos]' layer.ch0bytes [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)layer.ch0bytes [pos];  		c = Color.FromArgb ((int)layer.colorModeData [index]' layer.colorModeData [index + 256]' layer.colorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]);  	}  	break;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = Color.FromArgb ((int)layer.colorModeData [index]' layer.colorModeData [index + 256]' layer.colorModeData [index + 2 * 256]);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = Color.FromArgb ((int)layer.colorModeData [index]' layer.colorModeData [index + 256]' layer.colorModeData [index + 2 * 256]);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: c = Color.FromArgb ((int)layer.colorModeData [index]' layer.colorModeData [index + 256]' layer.colorModeData [index + 2 * 256]);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetMaskValue,The following statement contains a magic number: if (y >= 0 && y < mask.Rect.Height && x >= 0 && x < mask.Rect.Width) {  	int pos = y * mask.Rect.Width + x;  	if (pos < mask.ImageData.Length)  		c = mask.ImageData [pos];  	else  		c = 255;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetMaskValue,The following statement contains a magic number: if (pos < mask.ImageData.Length)  	c = mask.ImageData [pos];  else  	c = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetMaskValue,The following statement contains a magic number: c = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: unsafe {  	byte* pCurrRowPixel = (byte*)bd.Scan0.ToPointer ();  	for (int y = 0; y < mask.Rect.Height; y++) {  		int rowIndex = y * mask.Rect.Width;  		PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;  		for (int x = 0; x < mask.Rect.Width; x++) {  			int pos = rowIndex + x;  			Color pixelColor = Color.FromArgb (mask.ImageData [pos]' mask.ImageData [pos]' mask.ImageData [pos]);  			pCurrPixel->Alpha = 255;  			pCurrPixel->Red = pixelColor.R;  			pCurrPixel->Green = pixelColor.G;  			pCurrPixel->Blue = pixelColor.B;  			pCurrPixel += 1;  		}  		pCurrRowPixel += bd.Stride;  	}  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: for (int y = 0; y < mask.Rect.Height; y++) {  	int rowIndex = y * mask.Rect.Width;  	PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;  	for (int x = 0; x < mask.Rect.Width; x++) {  		int pos = rowIndex + x;  		Color pixelColor = Color.FromArgb (mask.ImageData [pos]' mask.ImageData [pos]' mask.ImageData [pos]);  		pCurrPixel->Alpha = 255;  		pCurrPixel->Red = pixelColor.R;  		pCurrPixel->Green = pixelColor.G;  		pCurrPixel->Blue = pixelColor.B;  		pCurrPixel += 1;  	}  	pCurrRowPixel += bd.Stride;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: for (int x = 0; x < mask.Rect.Width; x++) {  	int pos = rowIndex + x;  	Color pixelColor = Color.FromArgb (mask.ImageData [pos]' mask.ImageData [pos]' mask.ImageData [pos]);  	pCurrPixel->Alpha = 255;  	pCurrPixel->Red = pixelColor.R;  	pCurrPixel->Green = pixelColor.G;  	pCurrPixel->Blue = pixelColor.B;  	pCurrPixel += 1;  }  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: pCurrPixel->Alpha = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: L_coef = 256.0 / 100.0;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: L_coef = 256.0 / 100.0;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: a_coef = 256.0 / 256.0;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: a_coef = 256.0 / 256.0;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: b_coef = 256.0 / 256.0;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: b_coef = 256.0 / 256.0;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Y' 3) > 0.008856)  	var_Y = Math.Pow (var_Y' 3);  else  	var_Y = (var_Y - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Y' 3) > 0.008856)  	var_Y = Math.Pow (var_Y' 3);  else  	var_Y = (var_Y - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Y' 3) > 0.008856)  	var_Y = Math.Pow (var_Y' 3);  else  	var_Y = (var_Y - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Y' 3) > 0.008856)  	var_Y = Math.Pow (var_Y' 3);  else  	var_Y = (var_Y - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Y' 3) > 0.008856)  	var_Y = Math.Pow (var_Y' 3);  else  	var_Y = (var_Y - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Y' 3) > 0.008856)  	var_Y = Math.Pow (var_Y' 3);  else  	var_Y = (var_Y - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_Y = Math.Pow (var_Y' 3);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_Y = (var_Y - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_Y = (var_Y - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_Y = (var_Y - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_X' 3) > 0.008856)  	var_X = Math.Pow (var_X' 3);  else  	var_X = (var_X - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_X' 3) > 0.008856)  	var_X = Math.Pow (var_X' 3);  else  	var_X = (var_X - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_X' 3) > 0.008856)  	var_X = Math.Pow (var_X' 3);  else  	var_X = (var_X - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_X' 3) > 0.008856)  	var_X = Math.Pow (var_X' 3);  else  	var_X = (var_X - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_X' 3) > 0.008856)  	var_X = Math.Pow (var_X' 3);  else  	var_X = (var_X - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_X' 3) > 0.008856)  	var_X = Math.Pow (var_X' 3);  else  	var_X = (var_X - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_X = Math.Pow (var_X' 3);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_X = (var_X - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_X = (var_X - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_X = (var_X - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Z' 3) > 0.008856)  	var_Z = Math.Pow (var_Z' 3);  else  	var_Z = (var_Z - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Z' 3) > 0.008856)  	var_Z = Math.Pow (var_Z' 3);  else  	var_Z = (var_Z - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Z' 3) > 0.008856)  	var_Z = Math.Pow (var_Z' 3);  else  	var_Z = (var_Z - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Z' 3) > 0.008856)  	var_Z = Math.Pow (var_Z' 3);  else  	var_Z = (var_Z - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Z' 3) > 0.008856)  	var_Z = Math.Pow (var_Z' 3);  else  	var_Z = (var_Z - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow (var_Z' 3) > 0.008856)  	var_Z = Math.Pow (var_Z' 3);  else  	var_Z = (var_Z - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_Z = Math.Pow (var_Z' 3);  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_Z = (var_Z - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_Z = (var_Z - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: var_Z = (var_Z - 16 / 116) / 7.787;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_R > 0.0031308)  	var_R = 1.055 * (Math.Pow (var_R' 1 / 2.4)) - 0.055;  else  	var_R = 12.92 * var_R;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_R > 0.0031308)  	var_R = 1.055 * (Math.Pow (var_R' 1 / 2.4)) - 0.055;  else  	var_R = 12.92 * var_R;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_R > 0.0031308)  	var_R = 1.055 * (Math.Pow (var_R' 1 / 2.4)) - 0.055;  else  	var_R = 12.92 * var_R;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_R > 0.0031308)  	var_R = 1.055 * (Math.Pow (var_R' 1 / 2.4)) - 0.055;  else  	var_R = 12.92 * var_R;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_R > 0.0031308)  	var_R = 1.055 * (Math.Pow (var_R' 1 / 2.4)) - 0.055;  else  	var_R = 12.92 * var_R;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_R = 1.055 * (Math.Pow (var_R' 1 / 2.4)) - 0.055;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_R = 1.055 * (Math.Pow (var_R' 1 / 2.4)) - 0.055;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_R = 1.055 * (Math.Pow (var_R' 1 / 2.4)) - 0.055;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_R = 12.92 * var_R;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_G > 0.0031308)  	var_G = 1.055 * (Math.Pow (var_G' 1 / 2.4)) - 0.055;  else  	var_G = 12.92 * var_G;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_G > 0.0031308)  	var_G = 1.055 * (Math.Pow (var_G' 1 / 2.4)) - 0.055;  else  	var_G = 12.92 * var_G;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_G > 0.0031308)  	var_G = 1.055 * (Math.Pow (var_G' 1 / 2.4)) - 0.055;  else  	var_G = 12.92 * var_G;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_G > 0.0031308)  	var_G = 1.055 * (Math.Pow (var_G' 1 / 2.4)) - 0.055;  else  	var_G = 12.92 * var_G;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_G > 0.0031308)  	var_G = 1.055 * (Math.Pow (var_G' 1 / 2.4)) - 0.055;  else  	var_G = 12.92 * var_G;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_G = 1.055 * (Math.Pow (var_G' 1 / 2.4)) - 0.055;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_G = 1.055 * (Math.Pow (var_G' 1 / 2.4)) - 0.055;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_G = 1.055 * (Math.Pow (var_G' 1 / 2.4)) - 0.055;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_G = 12.92 * var_G;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_B > 0.0031308)  	var_B = 1.055 * (Math.Pow (var_B' 1 / 2.4)) - 0.055;  else  	var_B = 12.92 * var_B;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_B > 0.0031308)  	var_B = 1.055 * (Math.Pow (var_B' 1 / 2.4)) - 0.055;  else  	var_B = 12.92 * var_B;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_B > 0.0031308)  	var_B = 1.055 * (Math.Pow (var_B' 1 / 2.4)) - 0.055;  else  	var_B = 12.92 * var_B;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_B > 0.0031308)  	var_B = 1.055 * (Math.Pow (var_B' 1 / 2.4)) - 0.055;  else  	var_B = 12.92 * var_B;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_B > 0.0031308)  	var_B = 1.055 * (Math.Pow (var_B' 1 / 2.4)) - 0.055;  else  	var_B = 12.92 * var_B;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_B = 1.055 * (Math.Pow (var_B' 1 / 2.4)) - 0.055;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_B = 1.055 * (Math.Pow (var_B' 1 / 2.4)) - 0.055;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_B = 1.055 * (Math.Pow (var_B' 1 / 2.4)) - 0.055;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: var_B = 12.92 * var_B;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nRed < 0)  	nRed = 0;  else if (nRed > 255)  	nRed = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nRed < 0)  	nRed = 0;  else if (nRed > 255)  	nRed = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nRed > 255)  	nRed = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nRed > 255)  	nRed = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: nRed = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nGreen < 0)  	nGreen = 0;  else if (nGreen > 255)  	nGreen = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nGreen < 0)  	nGreen = 0;  else if (nGreen > 255)  	nGreen = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nGreen > 255)  	nGreen = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nGreen > 255)  	nGreen = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: nGreen = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nBlue < 0)  	nBlue = 0;  else if (nBlue > 255)  	nBlue = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nBlue < 0)  	nBlue = 0;  else if (nBlue > 255)  	nBlue = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nBlue > 255)  	nBlue = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nBlue > 255)  	nBlue = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: nBlue = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nRed < 0)  	nRed = 0;  else if (nRed > 255)  	nRed = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nRed < 0)  	nRed = 0;  else if (nRed > 255)  	nRed = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nRed > 255)  	nRed = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nRed > 255)  	nRed = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: nRed = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nGreen < 0)  	nGreen = 0;  else if (nGreen > 255)  	nGreen = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nGreen < 0)  	nGreen = 0;  else if (nGreen > 255)  	nGreen = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nGreen > 255)  	nGreen = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nGreen > 255)  	nGreen = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: nGreen = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nBlue < 0)  	nBlue = 0;  else if (nBlue > 255)  	nBlue = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nBlue < 0)  	nBlue = 0;  else if (nBlue > 255)  	nBlue = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nBlue > 255)  	nBlue = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nBlue > 255)  	nBlue = 255;  
Magic Number,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: nBlue = 255;  
Magic Number,PhotoshopFile,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageResource.cs,ImageResource,The following statement contains a magic number: m_osType = new string (reader.ReadChars (4));  
Magic Number,PhotoshopFile,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageResource.cs,ImageResource,The following statement contains a magic number: if (reader.BaseStream.Position % 2 == 1)  	reader.ReadByte ();  
Magic Number,PhotoshopFile,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageResource.cs,Save,The following statement contains a magic number: if (writer.BaseStream.Position % 2 == 1)  	writer.Write ((byte)0);  
Magic Number,PhotoshopFile,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: using (BinaryReverseReader reader = DataReader) {  	int format = reader.ReadInt32 ();  	int width = reader.ReadInt32 ();  	int height = reader.ReadInt32 ();  	int widthBytes = reader.ReadInt32 ();  	int size = reader.ReadInt32 ();  	int compressedSize = reader.ReadInt32 ();  	short bitPerPixel = reader.ReadInt16 ();  	short planes = reader.ReadInt16 ();  	if (format == 1) {  		byte[] imgData = reader.ReadBytes ((int)(reader.BaseStream.Length - reader.BaseStream.Position));  		using (MemoryStream strm = new MemoryStream (imgData)) {  			m_thumbnailImage = (Bitmap)(Bitmap.FromStream (strm).Clone ());  		}  		if (this.ID == 1033) {  			//// BGR  			//for(int y=0;y<m_thumbnailImage.Height;y++)  			//  for (int x = 0; x < m_thumbnailImage.Width; x++)  			//  {  			//    Color c=m_thumbnailImage.GetPixel(x'y);  			//    Color c2=Color.FromArgb(c.B' c.G' c.R);  			//    m_thumbnailImage.SetPixel(x' y' c);  			//  }  		}  	} else {  		m_thumbnailImage = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	}  }  
Magic Number,PhotoshopFile,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: if (format == 1) {  	byte[] imgData = reader.ReadBytes ((int)(reader.BaseStream.Length - reader.BaseStream.Position));  	using (MemoryStream strm = new MemoryStream (imgData)) {  		m_thumbnailImage = (Bitmap)(Bitmap.FromStream (strm).Clone ());  	}  	if (this.ID == 1033) {  		//// BGR  		//for(int y=0;y<m_thumbnailImage.Height;y++)  		//  for (int x = 0; x < m_thumbnailImage.Width; x++)  		//  {  		//    Color c=m_thumbnailImage.GetPixel(x'y);  		//    Color c2=Color.FromArgb(c.B' c.G' c.R);  		//    m_thumbnailImage.SetPixel(x' y' c);  		//  }  	}  } else {  	m_thumbnailImage = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  }  
Magic Number,PhotoshopFile,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: if (this.ID == 1033) {  	//// BGR  	//for(int y=0;y<m_thumbnailImage.Height;y++)  	//  for (int x = 0; x < m_thumbnailImage.Width; x++)  	//  {  	//    Color c=m_thumbnailImage.GetPixel(x'y);  	//    Color c2=Color.FromArgb(c.B' c.G' c.R);  	//    m_thumbnailImage.SetPixel(x' y' c);  	//  }  }  
Magic Number,PhotoshopFile,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,Layer,The following statement contains a magic number: m_blendModeKey = new string (reader.ReadChars (4));  
Magic Number,PhotoshopFile,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,Save,The following statement contains a magic number: using (new LengthWriter (writer)) {  	m_maskData.Save (writer);  	m_blendingRangesData.Save (writer);  	long namePosition = writer.BaseStream.Position;  	writer.WritePascalString (m_name);  	int paddingBytes = (int)((writer.BaseStream.Position - namePosition) % 4);  	Debug.Print ("Layer {0} write padding bytes after name"' paddingBytes);  	for (int i = 0; i < paddingBytes; i++)  		writer.Write ((byte)0);  	foreach (AdjustmentLayerInfo info in m_adjustmentInfo) {  		info.Save (writer);  	}  }  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadHeader,The following statement contains a magic number: reader.BaseStream.Position += 6;  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadLayers,The following statement contains a magic number: foreach (Layer layer in m_layers) {  	foreach (Layer.Channel channel in layer.Channels) {  		if (channel.ID != -2) {  			channel.LoadPixelData (reader);  			DecompressChannelContext dcc = new DecompressChannelContext (channel);  			WaitCallback waitCallback = new WaitCallback (dcc.DecompressChannel);  			threadPool.QueueUserWorkItem (waitCallback);  		}  	}  	layer.MaskData.LoadPixelData (reader);  }  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadLayers,The following statement contains a magic number: foreach (Layer.Channel channel in layer.Channels) {  	if (channel.ID != -2) {  		channel.LoadPixelData (reader);  		DecompressChannelContext dcc = new DecompressChannelContext (channel);  		WaitCallback waitCallback = new WaitCallback (dcc.DecompressChannel);  		threadPool.QueueUserWorkItem (waitCallback);  	}  }  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadLayers,The following statement contains a magic number: if (channel.ID != -2) {  	channel.LoadPixelData (reader);  	DecompressChannelContext dcc = new DecompressChannelContext (channel);  	WaitCallback waitCallback = new WaitCallback (dcc.DecompressChannel);  	threadPool.QueueUserWorkItem (waitCallback);  }  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadLayers,The following statement contains a magic number: if (reader.BaseStream.Position % 2 == 1)  	reader.ReadByte ();  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,SaveLayers,The following statement contains a magic number: using (new LengthWriter (writer)) {  	short numberOfLayers = (short)m_layers.Count;  	if (AbsoluteAlpha)  		numberOfLayers = (short)-numberOfLayers;  	writer.Write (numberOfLayers);  	// Finish compute-bound operations before embarking on the sequential save  	PrivateThreadPool threadPool = new PrivateThreadPool ();  	foreach (Layer layer in m_layers) {  		layer.PrepareSave (threadPool);  	}  	threadPool.Drain ();  	foreach (Layer layer in m_layers) {  		layer.Save (writer);  	}  	foreach (Layer layer in m_layers) {  		foreach (Layer.Channel channel in layer.Channels) {  			channel.SavePixelData (writer);  		}  	}  	if (writer.BaseStream.Position % 2 == 1)  		writer.Write ((byte)0);  }  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,SaveLayers,The following statement contains a magic number: if (writer.BaseStream.Position % 2 == 1)  	writer.Write ((byte)0);  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following statement contains a magic number: if (m_imageCompression == ImageCompression.Rle) {  	// The RLE-compressed data is proceeded by a 2-byte data count for each row in the data'  	// which we're going to just skip.  	reader.BaseStream.Position += m_rows * m_channels * 2;  }  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following statement contains a magic number: reader.BaseStream.Position += m_rows * m_channels * 2;  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following statement contains a magic number: switch (m_depth) {  case 1:  	bytesPerRow = ImageDecoder.BytesFromBits (m_columns);  	break;  case 8:  	bytesPerRow = m_columns;  	break;  case 16:  	bytesPerRow = m_columns * 2;  	break;  }  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following statement contains a magic number: switch (m_depth) {  case 1:  	bytesPerRow = ImageDecoder.BytesFromBits (m_columns);  	break;  case 8:  	bytesPerRow = m_columns;  	break;  case 16:  	bytesPerRow = m_columns * 2;  	break;  }  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following statement contains a magic number: switch (m_depth) {  case 1:  	bytesPerRow = ImageDecoder.BytesFromBits (m_columns);  	break;  case 8:  	bytesPerRow = m_columns;  	break;  case 16:  	bytesPerRow = m_columns * 2;  	break;  }  
Magic Number,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following statement contains a magic number: bytesPerRow = m_columns * 2;  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: while (count < columns) {  	byte byteValue = (byte)stream.ReadByte ();  	int len = (int)byteValue;  	if (len < 128) {  		len++;  		while (len != 0 && (startIdx + count) < imgData.Length) {  			byteValue = (byte)stream.ReadByte ();  			imgData [startIdx + count] = byteValue;  			count++;  			len--;  		}  	} else if (len > 128) {  		// Next -len+1 bytes in the dest are replicated from next source byte.  		// (Interpret len as a negative 8-bit int.)  		len ^= 0x0FF;  		len += 2;  		byteValue = (byte)stream.ReadByte ();  		while (len != 0 && (startIdx + count) < imgData.Length) {  			imgData [startIdx + count] = byteValue;  			count++;  			len--;  		}  	} else if (128 == len) {  		// Do nothing  	}  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: while (count < columns) {  	byte byteValue = (byte)stream.ReadByte ();  	int len = (int)byteValue;  	if (len < 128) {  		len++;  		while (len != 0 && (startIdx + count) < imgData.Length) {  			byteValue = (byte)stream.ReadByte ();  			imgData [startIdx + count] = byteValue;  			count++;  			len--;  		}  	} else if (len > 128) {  		// Next -len+1 bytes in the dest are replicated from next source byte.  		// (Interpret len as a negative 8-bit int.)  		len ^= 0x0FF;  		len += 2;  		byteValue = (byte)stream.ReadByte ();  		while (len != 0 && (startIdx + count) < imgData.Length) {  			imgData [startIdx + count] = byteValue;  			count++;  			len--;  		}  	} else if (128 == len) {  		// Do nothing  	}  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: while (count < columns) {  	byte byteValue = (byte)stream.ReadByte ();  	int len = (int)byteValue;  	if (len < 128) {  		len++;  		while (len != 0 && (startIdx + count) < imgData.Length) {  			byteValue = (byte)stream.ReadByte ();  			imgData [startIdx + count] = byteValue;  			count++;  			len--;  		}  	} else if (len > 128) {  		// Next -len+1 bytes in the dest are replicated from next source byte.  		// (Interpret len as a negative 8-bit int.)  		len ^= 0x0FF;  		len += 2;  		byteValue = (byte)stream.ReadByte ();  		while (len != 0 && (startIdx + count) < imgData.Length) {  			imgData [startIdx + count] = byteValue;  			count++;  			len--;  		}  	} else if (128 == len) {  		// Do nothing  	}  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: while (count < columns) {  	byte byteValue = (byte)stream.ReadByte ();  	int len = (int)byteValue;  	if (len < 128) {  		len++;  		while (len != 0 && (startIdx + count) < imgData.Length) {  			byteValue = (byte)stream.ReadByte ();  			imgData [startIdx + count] = byteValue;  			count++;  			len--;  		}  	} else if (len > 128) {  		// Next -len+1 bytes in the dest are replicated from next source byte.  		// (Interpret len as a negative 8-bit int.)  		len ^= 0x0FF;  		len += 2;  		byteValue = (byte)stream.ReadByte ();  		while (len != 0 && (startIdx + count) < imgData.Length) {  			imgData [startIdx + count] = byteValue;  			count++;  			len--;  		}  	} else if (128 == len) {  		// Do nothing  	}  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: if (len < 128) {  	len++;  	while (len != 0 && (startIdx + count) < imgData.Length) {  		byteValue = (byte)stream.ReadByte ();  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (len > 128) {  	// Next -len+1 bytes in the dest are replicated from next source byte.  	// (Interpret len as a negative 8-bit int.)  	len ^= 0x0FF;  	len += 2;  	byteValue = (byte)stream.ReadByte ();  	while (len != 0 && (startIdx + count) < imgData.Length) {  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (128 == len) {  	// Do nothing  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: if (len < 128) {  	len++;  	while (len != 0 && (startIdx + count) < imgData.Length) {  		byteValue = (byte)stream.ReadByte ();  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (len > 128) {  	// Next -len+1 bytes in the dest are replicated from next source byte.  	// (Interpret len as a negative 8-bit int.)  	len ^= 0x0FF;  	len += 2;  	byteValue = (byte)stream.ReadByte ();  	while (len != 0 && (startIdx + count) < imgData.Length) {  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (128 == len) {  	// Do nothing  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: if (len < 128) {  	len++;  	while (len != 0 && (startIdx + count) < imgData.Length) {  		byteValue = (byte)stream.ReadByte ();  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (len > 128) {  	// Next -len+1 bytes in the dest are replicated from next source byte.  	// (Interpret len as a negative 8-bit int.)  	len ^= 0x0FF;  	len += 2;  	byteValue = (byte)stream.ReadByte ();  	while (len != 0 && (startIdx + count) < imgData.Length) {  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (128 == len) {  	// Do nothing  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: if (len < 128) {  	len++;  	while (len != 0 && (startIdx + count) < imgData.Length) {  		byteValue = (byte)stream.ReadByte ();  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (len > 128) {  	// Next -len+1 bytes in the dest are replicated from next source byte.  	// (Interpret len as a negative 8-bit int.)  	len ^= 0x0FF;  	len += 2;  	byteValue = (byte)stream.ReadByte ();  	while (len != 0 && (startIdx + count) < imgData.Length) {  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (128 == len) {  	// Do nothing  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: if (len > 128) {  	// Next -len+1 bytes in the dest are replicated from next source byte.  	// (Interpret len as a negative 8-bit int.)  	len ^= 0x0FF;  	len += 2;  	byteValue = (byte)stream.ReadByte ();  	while (len != 0 && (startIdx + count) < imgData.Length) {  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (128 == len) {  	// Do nothing  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: if (len > 128) {  	// Next -len+1 bytes in the dest are replicated from next source byte.  	// (Interpret len as a negative 8-bit int.)  	len ^= 0x0FF;  	len += 2;  	byteValue = (byte)stream.ReadByte ();  	while (len != 0 && (startIdx + count) < imgData.Length) {  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (128 == len) {  	// Do nothing  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: if (len > 128) {  	// Next -len+1 bytes in the dest are replicated from next source byte.  	// (Interpret len as a negative 8-bit int.)  	len ^= 0x0FF;  	len += 2;  	byteValue = (byte)stream.ReadByte ();  	while (len != 0 && (startIdx + count) < imgData.Length) {  		imgData [startIdx + count] = byteValue;  		count++;  		len--;  	}  } else if (128 == len) {  	// Do nothing  }  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: len += 2;  
Magic Number,PhotoshopFile,RleHelper,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: if (128 == len) {  	// Do nothing  }  
Magic Number,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,ReadSpecialString,The following statement contains a magic number: if (length == 0)  	length = 4;  
Magic Number,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,ReadSpecialString,The following statement contains a magic number: length = 4;  
Magic Number,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,ReadValue,The following statement contains a magic number: vt.Type = parseTypeString (new string (r.ReadPSDChars (4)));  
Magic Number,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,ReadValue,The following statement contains a magic number: switch (vt.Type) {  case OSType.tdta:  	uint unknown = r.ReadUInt32 ();  	TdTaParser p = new TdTaParser (r);  	object o = p.ParseOneTree ();  	vt.Value = o;  	break;  case OSType.Descriptor:  	vt = DynVal.ReadDescriptor (r);  	break;  case OSType.List:  	vt.Children = ReadValues (r' true);  	break;  case OSType.Double:  	vt.Value = r.ReadDouble ();  	break;  case OSType.UnitFloat:  	//Unif float  	//TODO: need a specific type for this' with a double and a type (percent/pixel)?  	string tst = GetMeaningOfFourCC (new string (r.ReadPSDChars (4)));  	//#Prc #Pxl #Ang = percent / pixels / angle?  	double d = r.ReadDouble ();  	tst += ": " + d;  	vt.Value = tst;  	break;  case OSType.Enumerated:  	string namesp = ReadSpecialString (r);  	string item = ReadSpecialString (r);  	//vt.Value = namesp + "." + item; //TODO: cast to real enum  	vt.Value = GetMeaningOfFourCC (namesp) + "." + GetMeaningOfFourCC (item);  	break;  case OSType.Integer:  	vt.Value = r.ReadInt32 ();  	//4 byte integer  	break;  case OSType.Boolean:  	vt.Value = r.ReadBoolean ();  	break;  case OSType.String:  	vt.Value = r.ReadPSDUnicodeString ();  	break;  default:  	throw new Exception ("Unhandled type: " + vt.Type);  }  
Magic Number,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,GetMeaningOfFourCC,The following statement contains a magic number: if (fourCC.Length != 4)  	return fourCC;  
Magic Number,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,LoadFourCC,The following statement contains a magic number: foreach (string line in lines) {  	string[] items = line.Split ('\t');  	if (items.Length <= 1)  		continue;  	if (items [1].Length == 0)  		continue;  	string name = items [0].Substring (2);  	foreach (string prefix in prefixes) {  		if (name.StartsWith (prefix)) {  			name = name.Substring (prefix.Length);  			break;  		}  	}  	FourCCs.Add (items [1].PadRight (4' ' ')' name);  }  
Magic Number,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,LoadFourCC,The following statement contains a magic number: foreach (string line in lines) {  	string[] items = line.Split ('\t');  	if (items.Length <= 1)  		continue;  	if (items [1].Length == 0)  		continue;  	string name = items [0].Substring (2);  	foreach (string prefix in prefixes) {  		if (name.StartsWith (prefix)) {  			name = name.Substring (prefix.Length);  			break;  		}  	}  	FourCCs.Add (items [1].PadRight (4' ' ')' name);  }  
Magic Number,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,LoadFourCC,The following statement contains a magic number: FourCCs.Add (items [1].PadRight (4' ' ')' name);  
Magic Number,PhotoshopFile,ReadableBinary,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: for (int i = start; i < (start + length); i++) {  	byte num3 = data [i];  	if (((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26)) {  		sbChars.Append ((char)num3);  	} else {  		sbChars.Append (".");  	}  	sbAll.Append (num3.ToString ("X"' NumberFormatInfo.InvariantInfo).PadLeft (2' '0') + " ");  	pos++;  	if ((pos % 8) == 0) {  		sbAll.Append ("  ");  		sbChars.Append ("  ");  	}  	if (((pos % 0x10) == 0) || (pos == 0)) {  		NewLine (sbAll' sbChars' pos);  		sbChars = new StringBuilder ();  	}  }  
Magic Number,PhotoshopFile,ReadableBinary,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: for (int i = start; i < (start + length); i++) {  	byte num3 = data [i];  	if (((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26)) {  		sbChars.Append ((char)num3);  	} else {  		sbChars.Append (".");  	}  	sbAll.Append (num3.ToString ("X"' NumberFormatInfo.InvariantInfo).PadLeft (2' '0') + " ");  	pos++;  	if ((pos % 8) == 0) {  		sbAll.Append ("  ");  		sbChars.Append ("  ");  	}  	if (((pos % 0x10) == 0) || (pos == 0)) {  		NewLine (sbAll' sbChars' pos);  		sbChars = new StringBuilder ();  	}  }  
Magic Number,PhotoshopFile,ReadableBinary,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: for (int i = start; i < (start + length); i++) {  	byte num3 = data [i];  	if (((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26)) {  		sbChars.Append ((char)num3);  	} else {  		sbChars.Append (".");  	}  	sbAll.Append (num3.ToString ("X"' NumberFormatInfo.InvariantInfo).PadLeft (2' '0') + " ");  	pos++;  	if ((pos % 8) == 0) {  		sbAll.Append ("  ");  		sbChars.Append ("  ");  	}  	if (((pos % 0x10) == 0) || (pos == 0)) {  		NewLine (sbAll' sbChars' pos);  		sbChars = new StringBuilder ();  	}  }  
Magic Number,PhotoshopFile,ReadableBinary,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: for (int i = start; i < (start + length); i++) {  	byte num3 = data [i];  	if (((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26)) {  		sbChars.Append ((char)num3);  	} else {  		sbChars.Append (".");  	}  	sbAll.Append (num3.ToString ("X"' NumberFormatInfo.InvariantInfo).PadLeft (2' '0') + " ");  	pos++;  	if ((pos % 8) == 0) {  		sbAll.Append ("  ");  		sbChars.Append ("  ");  	}  	if (((pos % 0x10) == 0) || (pos == 0)) {  		NewLine (sbAll' sbChars' pos);  		sbChars = new StringBuilder ();  	}  }  
Magic Number,PhotoshopFile,ReadableBinary,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: if (((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26)) {  	sbChars.Append ((char)num3);  } else {  	sbChars.Append (".");  }  
Magic Number,PhotoshopFile,ReadableBinary,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: if (((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26)) {  	sbChars.Append ((char)num3);  } else {  	sbChars.Append (".");  }  
Magic Number,PhotoshopFile,ReadableBinary,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: sbAll.Append (num3.ToString ("X"' NumberFormatInfo.InvariantInfo).PadLeft (2' '0') + " ");  
Magic Number,PhotoshopFile,ReadableBinary,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: if ((pos % 8) == 0) {  	sbAll.Append ("  ");  	sbChars.Append ("  ");  }  
Magic Number,PhotoshopFile,ReadableBinary,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,NewLine,The following statement contains a magic number: sbAll.Append ("\r\n" + pos.ToString ("X"' NumberFormatInfo.InvariantInfo).PadLeft (4' '0') + ":");  
Magic Number,PhotoshopFile.Text,EffectBase,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\EffectBase.cs,ReadBlendKey,The following statement contains a magic number: return new string (r.ReadPSDChars (4));  
Magic Number,PhotoshopFile.Text,Effects,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Effects,The following statement contains a magic number: r.BaseStream.Position += 2;  
Magic Number,PhotoshopFile.Text,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	this.Color = r.ReadPSDColor (16' false);  	//Inner color (no alpha)  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO!  	if (this.Inner)  		this.Unknown = r.ReadByte ();  	this.UnknownColor = r.ReadPSDColor (16' false);  	//unknown color(no alpha)  	this.Data = r.ReadBytes ((int)r.BytesToEnd);  	break;  }  
Magic Number,PhotoshopFile.Text,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	this.Color = r.ReadPSDColor (16' false);  	//Inner color (no alpha)  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO!  	if (this.Inner)  		this.Unknown = r.ReadByte ();  	this.UnknownColor = r.ReadPSDColor (16' false);  	//unknown color(no alpha)  	this.Data = r.ReadBytes ((int)r.BytesToEnd);  	break;  }  
Magic Number,PhotoshopFile.Text,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	this.Color = r.ReadPSDColor (16' false);  	//Inner color (no alpha)  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO!  	if (this.Inner)  		this.Unknown = r.ReadByte ();  	this.UnknownColor = r.ReadPSDColor (16' false);  	//unknown color(no alpha)  	this.Data = r.ReadBytes ((int)r.BytesToEnd);  	break;  }  
Magic Number,PhotoshopFile.Text,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,The following statement contains a magic number: this.Color = r.ReadPSDColor (16' false);  
Magic Number,PhotoshopFile.Text,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,The following statement contains a magic number: this.UnknownColor = r.ReadPSDColor (16' false);  
Magic Number,PhotoshopFile.Text,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Magic Number,PhotoshopFile.Text,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Magic Number,PhotoshopFile.Text,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Magic Number,PhotoshopFile.Text,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Magic Number,PhotoshopFile.Text,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Magic Number,PhotoshopFile.Text,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: this.Color = r.ReadPSDColor (16' true);  
Magic Number,PhotoshopFile.Text,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: this.ShadowColor = r.ReadPSDColor (16' true);  
Magic Number,PhotoshopFile.Text,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	//this.BlendModeSignature = r.ReadUInt32();  	//this.BlendModeKey = r.ReadUInt32();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	//TODO:?  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO: 10 unknown bytes!  	break;  }  
Magic Number,PhotoshopFile.Text,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	//this.BlendModeSignature = r.ReadUInt32();  	//this.BlendModeKey = r.ReadUInt32();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	//TODO:?  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO: 10 unknown bytes!  	break;  }  
Magic Number,PhotoshopFile.Text,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	//this.BlendModeSignature = r.ReadUInt32();  	//this.BlendModeKey = r.ReadUInt32();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	//TODO:?  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO: 10 unknown bytes!  	break;  }  
Magic Number,PhotoshopFile.Text,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,The following statement contains a magic number: this.Color = r.ReadPSDColor (16' true);  
Magic Number,PhotoshopFile.Text,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,The following statement contains a magic number: this.Color = r.ReadPSDColor (16' true);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb ((int)((double)values [0] * 255)' (int)((double)values [1] * 255)' (int)((double)values [2] * 255)' (int)((double)values [3] * 255));  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb ((int)((double)values [0] * 255)' (int)((double)values [1] * 255)' (int)((double)values [2] * 255)' (int)((double)values [3] * 255));  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb ((int)((double)values [0] * 255)' (int)((double)values [1] * 255)' (int)((double)values [2] * 255)' (int)((double)values [3] * 255));  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb ((int)((double)values [0] * 255)' (int)((double)values [1] * 255)' (int)((double)values [2] * 255)' (int)((double)values [3] * 255));  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb ((int)((double)values [0] * 255)' (int)((double)values [1] * 255)' (int)((double)values [2] * 255)' (int)((double)values [3] * 255));  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb ((int)((double)values [0] * 255)' (int)((double)values [1] * 255)' (int)((double)values [2] * 255)' (int)((double)values [3] * 255));  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals ("$")) {  	byte[] b = (byte[])tree;  	//FEFF - big endian  	if (b [0] == 254 && b [1] == 255)  		return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  	//FFEF - little endian  	if (b [0] == 255 && b [1] == 254)  		return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  	throw new Exception ("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString (b));  }  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals ("$")) {  	byte[] b = (byte[])tree;  	//FEFF - big endian  	if (b [0] == 254 && b [1] == 255)  		return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  	//FFEF - little endian  	if (b [0] == 255 && b [1] == 254)  		return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  	throw new Exception ("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString (b));  }  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals ("$")) {  	byte[] b = (byte[])tree;  	//FEFF - big endian  	if (b [0] == 254 && b [1] == 255)  		return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  	//FFEF - little endian  	if (b [0] == 255 && b [1] == 254)  		return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  	throw new Exception ("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString (b));  }  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals ("$")) {  	byte[] b = (byte[])tree;  	//FEFF - big endian  	if (b [0] == 254 && b [1] == 255)  		return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  	//FFEF - little endian  	if (b [0] == 255 && b [1] == 254)  		return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  	throw new Exception ("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString (b));  }  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals ("$")) {  	byte[] b = (byte[])tree;  	//FEFF - big endian  	if (b [0] == 254 && b [1] == 255)  		return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  	//FFEF - little endian  	if (b [0] == 255 && b [1] == 254)  		return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  	throw new Exception ("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString (b));  }  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals ("$")) {  	byte[] b = (byte[])tree;  	//FEFF - big endian  	if (b [0] == 254 && b [1] == 255)  		return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  	//FFEF - little endian  	if (b [0] == 255 && b [1] == 254)  		return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  	throw new Exception ("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString (b));  }  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals ("$")) {  	byte[] b = (byte[])tree;  	//FEFF - big endian  	if (b [0] == 254 && b [1] == 255)  		return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  	//FFEF - little endian  	if (b [0] == 255 && b [1] == 254)  		return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  	throw new Exception ("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString (b));  }  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals ("$")) {  	byte[] b = (byte[])tree;  	//FEFF - big endian  	if (b [0] == 254 && b [1] == 255)  		return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  	//FFEF - little endian  	if (b [0] == 255 && b [1] == 254)  		return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  	throw new Exception ("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString (b));  }  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (b [0] == 254 && b [1] == 255)  	return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (b [0] == 254 && b [1] == 255)  	return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (b [0] == 254 && b [1] == 255)  	return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (b [0] == 254 && b [1] == 255)  	return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: return System.Text.UTF8Encoding.BigEndianUnicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (b [0] == 255 && b [1] == 254)  	return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (b [0] == 255 && b [1] == 254)  	return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (b [0] == 255 && b [1] == 254)  	return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (b [0] == 255 && b [1] == 254)  	return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TdTaParser,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: return System.Text.UTF8Encoding.Unicode.GetString (b' 2' b.Length - 2);  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (outerGlow != null) {  	glowColor = outerGlow.Color;  	glowFlag = outerGlow.Enabled;  	glowWidth = (int)outerGlow.Blur;  	glowOpacity = (double)outerGlow.Opacity / 255.0;  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: glowOpacity = (double)outerGlow.Opacity / 255.0;  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	FontFamily fontFamily = null;  	StringFormat strformat = null;  	try {  		FontStyle style = FontStyle.Regular;  		//Remove MT  		if (fontName.EndsWith ("MT"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Remove -Bold' -Italic' -BoldItalic  		if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold;  		if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Italic;  		if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold | FontStyle.Italic;  		//Remove from fontName  		fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  		//Remove PS  		if (fontName.EndsWith ("PS"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Find font family  		try {  			fontFamily = new FontFamily (fontName);  		} catch (ArgumentException ae) {  			if (IgnoreMissingFonts) {  				fontFamily = FontFamily.GenericSansSerif;  			} else  				throw ae;  		}  		if (fauxBold)  			style |= FontStyle.Bold;  		if (fauxItalic)  			style |= FontStyle.Italic;  		if (underline)  			style |= FontStyle.Underline;  		if (strikethrough)  			style |= FontStyle.Strikeout;  		strformat = new StringFormat ();  		strformat.LineAlignment = hAlign;  		strformat.Alignment = vAlign;  		strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  		if (!horizontal)  			strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  		strformat.Trimming = StringTrimming.None;  		path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  	} finally {  		fontFamily.Dispose ();  		strformat.Dispose ();  	}  	if (glowFlag) {  		if (glowWidth == 3)  			glowWidth = 2;  		//To replicate photoshop rounding bug  		double finalOpacity = (glowOpacity + 1.5) / 2.5;  		//Because Photoshop doesn't actually use the opacity as the final opacity...   		//Add a 30% fade inside the glow width  		int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  		double totalOpacity = 0;  		//Start at transparent  		//start with outermost ring' work inwards  		for (int i = fadeWidth; i >= 0; i--) {  			//How much opacity do we lack to complete the desired opacity?  			//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  			//a=b *(1-c) + c  			//>>> where b!=1' c=(b-a/b-1)  			double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  			int remainingRings = fadeWidth;  			double currentOpacity = missingOpacity / (fadeWidth + 1);  			//Update total opacity  			totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  			//Draw it  			using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  				pen.LineJoin = LineJoin.Round;  				g.DrawPath (pen' path);  			}  		}  	}  	if (fillFirst) {  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  	} else {  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	FontFamily fontFamily = null;  	StringFormat strformat = null;  	try {  		FontStyle style = FontStyle.Regular;  		//Remove MT  		if (fontName.EndsWith ("MT"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Remove -Bold' -Italic' -BoldItalic  		if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold;  		if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Italic;  		if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold | FontStyle.Italic;  		//Remove from fontName  		fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  		//Remove PS  		if (fontName.EndsWith ("PS"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Find font family  		try {  			fontFamily = new FontFamily (fontName);  		} catch (ArgumentException ae) {  			if (IgnoreMissingFonts) {  				fontFamily = FontFamily.GenericSansSerif;  			} else  				throw ae;  		}  		if (fauxBold)  			style |= FontStyle.Bold;  		if (fauxItalic)  			style |= FontStyle.Italic;  		if (underline)  			style |= FontStyle.Underline;  		if (strikethrough)  			style |= FontStyle.Strikeout;  		strformat = new StringFormat ();  		strformat.LineAlignment = hAlign;  		strformat.Alignment = vAlign;  		strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  		if (!horizontal)  			strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  		strformat.Trimming = StringTrimming.None;  		path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  	} finally {  		fontFamily.Dispose ();  		strformat.Dispose ();  	}  	if (glowFlag) {  		if (glowWidth == 3)  			glowWidth = 2;  		//To replicate photoshop rounding bug  		double finalOpacity = (glowOpacity + 1.5) / 2.5;  		//Because Photoshop doesn't actually use the opacity as the final opacity...   		//Add a 30% fade inside the glow width  		int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  		double totalOpacity = 0;  		//Start at transparent  		//start with outermost ring' work inwards  		for (int i = fadeWidth; i >= 0; i--) {  			//How much opacity do we lack to complete the desired opacity?  			//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  			//a=b *(1-c) + c  			//>>> where b!=1' c=(b-a/b-1)  			double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  			int remainingRings = fadeWidth;  			double currentOpacity = missingOpacity / (fadeWidth + 1);  			//Update total opacity  			totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  			//Draw it  			using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  				pen.LineJoin = LineJoin.Round;  				g.DrawPath (pen' path);  			}  		}  	}  	if (fillFirst) {  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  	} else {  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	FontFamily fontFamily = null;  	StringFormat strformat = null;  	try {  		FontStyle style = FontStyle.Regular;  		//Remove MT  		if (fontName.EndsWith ("MT"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Remove -Bold' -Italic' -BoldItalic  		if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold;  		if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Italic;  		if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold | FontStyle.Italic;  		//Remove from fontName  		fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  		//Remove PS  		if (fontName.EndsWith ("PS"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Find font family  		try {  			fontFamily = new FontFamily (fontName);  		} catch (ArgumentException ae) {  			if (IgnoreMissingFonts) {  				fontFamily = FontFamily.GenericSansSerif;  			} else  				throw ae;  		}  		if (fauxBold)  			style |= FontStyle.Bold;  		if (fauxItalic)  			style |= FontStyle.Italic;  		if (underline)  			style |= FontStyle.Underline;  		if (strikethrough)  			style |= FontStyle.Strikeout;  		strformat = new StringFormat ();  		strformat.LineAlignment = hAlign;  		strformat.Alignment = vAlign;  		strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  		if (!horizontal)  			strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  		strformat.Trimming = StringTrimming.None;  		path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  	} finally {  		fontFamily.Dispose ();  		strformat.Dispose ();  	}  	if (glowFlag) {  		if (glowWidth == 3)  			glowWidth = 2;  		//To replicate photoshop rounding bug  		double finalOpacity = (glowOpacity + 1.5) / 2.5;  		//Because Photoshop doesn't actually use the opacity as the final opacity...   		//Add a 30% fade inside the glow width  		int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  		double totalOpacity = 0;  		//Start at transparent  		//start with outermost ring' work inwards  		for (int i = fadeWidth; i >= 0; i--) {  			//How much opacity do we lack to complete the desired opacity?  			//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  			//a=b *(1-c) + c  			//>>> where b!=1' c=(b-a/b-1)  			double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  			int remainingRings = fadeWidth;  			double currentOpacity = missingOpacity / (fadeWidth + 1);  			//Update total opacity  			totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  			//Draw it  			using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  				pen.LineJoin = LineJoin.Round;  				g.DrawPath (pen' path);  			}  		}  	}  	if (fillFirst) {  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  	} else {  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	FontFamily fontFamily = null;  	StringFormat strformat = null;  	try {  		FontStyle style = FontStyle.Regular;  		//Remove MT  		if (fontName.EndsWith ("MT"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Remove -Bold' -Italic' -BoldItalic  		if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold;  		if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Italic;  		if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold | FontStyle.Italic;  		//Remove from fontName  		fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  		//Remove PS  		if (fontName.EndsWith ("PS"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Find font family  		try {  			fontFamily = new FontFamily (fontName);  		} catch (ArgumentException ae) {  			if (IgnoreMissingFonts) {  				fontFamily = FontFamily.GenericSansSerif;  			} else  				throw ae;  		}  		if (fauxBold)  			style |= FontStyle.Bold;  		if (fauxItalic)  			style |= FontStyle.Italic;  		if (underline)  			style |= FontStyle.Underline;  		if (strikethrough)  			style |= FontStyle.Strikeout;  		strformat = new StringFormat ();  		strformat.LineAlignment = hAlign;  		strformat.Alignment = vAlign;  		strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  		if (!horizontal)  			strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  		strformat.Trimming = StringTrimming.None;  		path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  	} finally {  		fontFamily.Dispose ();  		strformat.Dispose ();  	}  	if (glowFlag) {  		if (glowWidth == 3)  			glowWidth = 2;  		//To replicate photoshop rounding bug  		double finalOpacity = (glowOpacity + 1.5) / 2.5;  		//Because Photoshop doesn't actually use the opacity as the final opacity...   		//Add a 30% fade inside the glow width  		int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  		double totalOpacity = 0;  		//Start at transparent  		//start with outermost ring' work inwards  		for (int i = fadeWidth; i >= 0; i--) {  			//How much opacity do we lack to complete the desired opacity?  			//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  			//a=b *(1-c) + c  			//>>> where b!=1' c=(b-a/b-1)  			double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  			int remainingRings = fadeWidth;  			double currentOpacity = missingOpacity / (fadeWidth + 1);  			//Update total opacity  			totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  			//Draw it  			using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  				pen.LineJoin = LineJoin.Round;  				g.DrawPath (pen' path);  			}  		}  	}  	if (fillFirst) {  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  	} else {  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	FontFamily fontFamily = null;  	StringFormat strformat = null;  	try {  		FontStyle style = FontStyle.Regular;  		//Remove MT  		if (fontName.EndsWith ("MT"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Remove -Bold' -Italic' -BoldItalic  		if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold;  		if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Italic;  		if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold | FontStyle.Italic;  		//Remove from fontName  		fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  		//Remove PS  		if (fontName.EndsWith ("PS"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Find font family  		try {  			fontFamily = new FontFamily (fontName);  		} catch (ArgumentException ae) {  			if (IgnoreMissingFonts) {  				fontFamily = FontFamily.GenericSansSerif;  			} else  				throw ae;  		}  		if (fauxBold)  			style |= FontStyle.Bold;  		if (fauxItalic)  			style |= FontStyle.Italic;  		if (underline)  			style |= FontStyle.Underline;  		if (strikethrough)  			style |= FontStyle.Strikeout;  		strformat = new StringFormat ();  		strformat.LineAlignment = hAlign;  		strformat.Alignment = vAlign;  		strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  		if (!horizontal)  			strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  		strformat.Trimming = StringTrimming.None;  		path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  	} finally {  		fontFamily.Dispose ();  		strformat.Dispose ();  	}  	if (glowFlag) {  		if (glowWidth == 3)  			glowWidth = 2;  		//To replicate photoshop rounding bug  		double finalOpacity = (glowOpacity + 1.5) / 2.5;  		//Because Photoshop doesn't actually use the opacity as the final opacity...   		//Add a 30% fade inside the glow width  		int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  		double totalOpacity = 0;  		//Start at transparent  		//start with outermost ring' work inwards  		for (int i = fadeWidth; i >= 0; i--) {  			//How much opacity do we lack to complete the desired opacity?  			//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  			//a=b *(1-c) + c  			//>>> where b!=1' c=(b-a/b-1)  			double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  			int remainingRings = fadeWidth;  			double currentOpacity = missingOpacity / (fadeWidth + 1);  			//Update total opacity  			totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  			//Draw it  			using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  				pen.LineJoin = LineJoin.Round;  				g.DrawPath (pen' path);  			}  		}  	}  	if (fillFirst) {  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  	} else {  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	FontFamily fontFamily = null;  	StringFormat strformat = null;  	try {  		FontStyle style = FontStyle.Regular;  		//Remove MT  		if (fontName.EndsWith ("MT"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Remove -Bold' -Italic' -BoldItalic  		if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold;  		if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Italic;  		if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold | FontStyle.Italic;  		//Remove from fontName  		fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  		//Remove PS  		if (fontName.EndsWith ("PS"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Find font family  		try {  			fontFamily = new FontFamily (fontName);  		} catch (ArgumentException ae) {  			if (IgnoreMissingFonts) {  				fontFamily = FontFamily.GenericSansSerif;  			} else  				throw ae;  		}  		if (fauxBold)  			style |= FontStyle.Bold;  		if (fauxItalic)  			style |= FontStyle.Italic;  		if (underline)  			style |= FontStyle.Underline;  		if (strikethrough)  			style |= FontStyle.Strikeout;  		strformat = new StringFormat ();  		strformat.LineAlignment = hAlign;  		strformat.Alignment = vAlign;  		strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  		if (!horizontal)  			strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  		strformat.Trimming = StringTrimming.None;  		path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  	} finally {  		fontFamily.Dispose ();  		strformat.Dispose ();  	}  	if (glowFlag) {  		if (glowWidth == 3)  			glowWidth = 2;  		//To replicate photoshop rounding bug  		double finalOpacity = (glowOpacity + 1.5) / 2.5;  		//Because Photoshop doesn't actually use the opacity as the final opacity...   		//Add a 30% fade inside the glow width  		int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  		double totalOpacity = 0;  		//Start at transparent  		//start with outermost ring' work inwards  		for (int i = fadeWidth; i >= 0; i--) {  			//How much opacity do we lack to complete the desired opacity?  			//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  			//a=b *(1-c) + c  			//>>> where b!=1' c=(b-a/b-1)  			double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  			int remainingRings = fadeWidth;  			double currentOpacity = missingOpacity / (fadeWidth + 1);  			//Update total opacity  			totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  			//Draw it  			using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  				pen.LineJoin = LineJoin.Round;  				g.DrawPath (pen' path);  			}  		}  	}  	if (fillFirst) {  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  	} else {  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	FontFamily fontFamily = null;  	StringFormat strformat = null;  	try {  		FontStyle style = FontStyle.Regular;  		//Remove MT  		if (fontName.EndsWith ("MT"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Remove -Bold' -Italic' -BoldItalic  		if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold;  		if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Italic;  		if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold | FontStyle.Italic;  		//Remove from fontName  		fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  		//Remove PS  		if (fontName.EndsWith ("PS"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Find font family  		try {  			fontFamily = new FontFamily (fontName);  		} catch (ArgumentException ae) {  			if (IgnoreMissingFonts) {  				fontFamily = FontFamily.GenericSansSerif;  			} else  				throw ae;  		}  		if (fauxBold)  			style |= FontStyle.Bold;  		if (fauxItalic)  			style |= FontStyle.Italic;  		if (underline)  			style |= FontStyle.Underline;  		if (strikethrough)  			style |= FontStyle.Strikeout;  		strformat = new StringFormat ();  		strformat.LineAlignment = hAlign;  		strformat.Alignment = vAlign;  		strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  		if (!horizontal)  			strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  		strformat.Trimming = StringTrimming.None;  		path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  	} finally {  		fontFamily.Dispose ();  		strformat.Dispose ();  	}  	if (glowFlag) {  		if (glowWidth == 3)  			glowWidth = 2;  		//To replicate photoshop rounding bug  		double finalOpacity = (glowOpacity + 1.5) / 2.5;  		//Because Photoshop doesn't actually use the opacity as the final opacity...   		//Add a 30% fade inside the glow width  		int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  		double totalOpacity = 0;  		//Start at transparent  		//start with outermost ring' work inwards  		for (int i = fadeWidth; i >= 0; i--) {  			//How much opacity do we lack to complete the desired opacity?  			//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  			//a=b *(1-c) + c  			//>>> where b!=1' c=(b-a/b-1)  			double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  			int remainingRings = fadeWidth;  			double currentOpacity = missingOpacity / (fadeWidth + 1);  			//Update total opacity  			totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  			//Draw it  			using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  				pen.LineJoin = LineJoin.Round;  				g.DrawPath (pen' path);  			}  		}  	}  	if (fillFirst) {  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  	} else {  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	FontFamily fontFamily = null;  	StringFormat strformat = null;  	try {  		FontStyle style = FontStyle.Regular;  		//Remove MT  		if (fontName.EndsWith ("MT"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Remove -Bold' -Italic' -BoldItalic  		if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold;  		if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Italic;  		if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold | FontStyle.Italic;  		//Remove from fontName  		fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  		//Remove PS  		if (fontName.EndsWith ("PS"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Find font family  		try {  			fontFamily = new FontFamily (fontName);  		} catch (ArgumentException ae) {  			if (IgnoreMissingFonts) {  				fontFamily = FontFamily.GenericSansSerif;  			} else  				throw ae;  		}  		if (fauxBold)  			style |= FontStyle.Bold;  		if (fauxItalic)  			style |= FontStyle.Italic;  		if (underline)  			style |= FontStyle.Underline;  		if (strikethrough)  			style |= FontStyle.Strikeout;  		strformat = new StringFormat ();  		strformat.LineAlignment = hAlign;  		strformat.Alignment = vAlign;  		strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  		if (!horizontal)  			strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  		strformat.Trimming = StringTrimming.None;  		path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  	} finally {  		fontFamily.Dispose ();  		strformat.Dispose ();  	}  	if (glowFlag) {  		if (glowWidth == 3)  			glowWidth = 2;  		//To replicate photoshop rounding bug  		double finalOpacity = (glowOpacity + 1.5) / 2.5;  		//Because Photoshop doesn't actually use the opacity as the final opacity...   		//Add a 30% fade inside the glow width  		int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  		double totalOpacity = 0;  		//Start at transparent  		//start with outermost ring' work inwards  		for (int i = fadeWidth; i >= 0; i--) {  			//How much opacity do we lack to complete the desired opacity?  			//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  			//a=b *(1-c) + c  			//>>> where b!=1' c=(b-a/b-1)  			double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  			int remainingRings = fadeWidth;  			double currentOpacity = missingOpacity / (fadeWidth + 1);  			//Update total opacity  			totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  			//Draw it  			using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  				pen.LineJoin = LineJoin.Round;  				g.DrawPath (pen' path);  			}  		}  	}  	if (fillFirst) {  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  	} else {  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	FontFamily fontFamily = null;  	StringFormat strformat = null;  	try {  		FontStyle style = FontStyle.Regular;  		//Remove MT  		if (fontName.EndsWith ("MT"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Remove -Bold' -Italic' -BoldItalic  		if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold;  		if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Italic;  		if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  			style |= FontStyle.Bold | FontStyle.Italic;  		//Remove from fontName  		fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  		//Remove PS  		if (fontName.EndsWith ("PS"))  			fontName = fontName.Substring (0' fontName.Length - 2);  		//Find font family  		try {  			fontFamily = new FontFamily (fontName);  		} catch (ArgumentException ae) {  			if (IgnoreMissingFonts) {  				fontFamily = FontFamily.GenericSansSerif;  			} else  				throw ae;  		}  		if (fauxBold)  			style |= FontStyle.Bold;  		if (fauxItalic)  			style |= FontStyle.Italic;  		if (underline)  			style |= FontStyle.Underline;  		if (strikethrough)  			style |= FontStyle.Strikeout;  		strformat = new StringFormat ();  		strformat.LineAlignment = hAlign;  		strformat.Alignment = vAlign;  		strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  		if (!horizontal)  			strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  		strformat.Trimming = StringTrimming.None;  		path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  	} finally {  		fontFamily.Dispose ();  		strformat.Dispose ();  	}  	if (glowFlag) {  		if (glowWidth == 3)  			glowWidth = 2;  		//To replicate photoshop rounding bug  		double finalOpacity = (glowOpacity + 1.5) / 2.5;  		//Because Photoshop doesn't actually use the opacity as the final opacity...   		//Add a 30% fade inside the glow width  		int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  		double totalOpacity = 0;  		//Start at transparent  		//start with outermost ring' work inwards  		for (int i = fadeWidth; i >= 0; i--) {  			//How much opacity do we lack to complete the desired opacity?  			//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  			//a=b *(1-c) + c  			//>>> where b!=1' c=(b-a/b-1)  			double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  			int remainingRings = fadeWidth;  			double currentOpacity = missingOpacity / (fadeWidth + 1);  			//Update total opacity  			totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  			//Draw it  			using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  				pen.LineJoin = LineJoin.Round;  				g.DrawPath (pen' path);  			}  		}  	}  	if (fillFirst) {  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  	} else {  		//Draw stroke  		if (strokeFlag) {  			using (Pen p = new Pen (strokeColor' (float)outlineWidth)) {  				p.LineJoin = LineJoin.Round;  				g.DrawPath (p' path);  			}  		}  		//Draw fill  		if (fillFlag) {  			using (SolidBrush brush = new SolidBrush (fillColor)) {  				g.FillPath (brush' path);  			}  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: try {  	FontStyle style = FontStyle.Regular;  	//Remove MT  	if (fontName.EndsWith ("MT"))  		fontName = fontName.Substring (0' fontName.Length - 2);  	//Remove -Bold' -Italic' -BoldItalic  	if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  		style |= FontStyle.Bold;  	if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  		style |= FontStyle.Italic;  	if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  		style |= FontStyle.Bold | FontStyle.Italic;  	//Remove from fontName  	fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  	//Remove PS  	if (fontName.EndsWith ("PS"))  		fontName = fontName.Substring (0' fontName.Length - 2);  	//Find font family  	try {  		fontFamily = new FontFamily (fontName);  	} catch (ArgumentException ae) {  		if (IgnoreMissingFonts) {  			fontFamily = FontFamily.GenericSansSerif;  		} else  			throw ae;  	}  	if (fauxBold)  		style |= FontStyle.Bold;  	if (fauxItalic)  		style |= FontStyle.Italic;  	if (underline)  		style |= FontStyle.Underline;  	if (strikethrough)  		style |= FontStyle.Strikeout;  	strformat = new StringFormat ();  	strformat.LineAlignment = hAlign;  	strformat.Alignment = vAlign;  	strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  	if (!horizontal)  		strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  	strformat.Trimming = StringTrimming.None;  	path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  } finally {  	fontFamily.Dispose ();  	strformat.Dispose ();  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: try {  	FontStyle style = FontStyle.Regular;  	//Remove MT  	if (fontName.EndsWith ("MT"))  		fontName = fontName.Substring (0' fontName.Length - 2);  	//Remove -Bold' -Italic' -BoldItalic  	if (fontName.EndsWith ("-Bold"' StringComparison.OrdinalIgnoreCase))  		style |= FontStyle.Bold;  	if (fontName.EndsWith ("-Italic"' StringComparison.OrdinalIgnoreCase))  		style |= FontStyle.Italic;  	if (fontName.EndsWith ("-BoldItalic"' StringComparison.OrdinalIgnoreCase))  		style |= FontStyle.Bold | FontStyle.Italic;  	//Remove from fontName  	fontName = new Regex ("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace (fontName' "");  	//Remove PS  	if (fontName.EndsWith ("PS"))  		fontName = fontName.Substring (0' fontName.Length - 2);  	//Find font family  	try {  		fontFamily = new FontFamily (fontName);  	} catch (ArgumentException ae) {  		if (IgnoreMissingFonts) {  			fontFamily = FontFamily.GenericSansSerif;  		} else  			throw ae;  	}  	if (fauxBold)  		style |= FontStyle.Bold;  	if (fauxItalic)  		style |= FontStyle.Italic;  	if (underline)  		style |= FontStyle.Underline;  	if (strikethrough)  		style |= FontStyle.Strikeout;  	strformat = new StringFormat ();  	strformat.LineAlignment = hAlign;  	strformat.Alignment = vAlign;  	strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;  	if (!horizontal)  		strformat.FormatFlags |= StringFormatFlags.DirectionVertical;  	strformat.Trimming = StringTrimming.None;  	path.AddString (text' fontFamily' (int)style' (float)(fontSize)' rect' strformat);  } finally {  	fontFamily.Dispose ();  	strformat.Dispose ();  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (fontName.EndsWith ("MT"))  	fontName = fontName.Substring (0' fontName.Length - 2);  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: fontName = fontName.Substring (0' fontName.Length - 2);  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (fontName.EndsWith ("PS"))  	fontName = fontName.Substring (0' fontName.Length - 2);  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: fontName = fontName.Substring (0' fontName.Length - 2);  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (glowFlag) {  	if (glowWidth == 3)  		glowWidth = 2;  	//To replicate photoshop rounding bug  	double finalOpacity = (glowOpacity + 1.5) / 2.5;  	//Because Photoshop doesn't actually use the opacity as the final opacity...   	//Add a 30% fade inside the glow width  	int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  	double totalOpacity = 0;  	//Start at transparent  	//start with outermost ring' work inwards  	for (int i = fadeWidth; i >= 0; i--) {  		//How much opacity do we lack to complete the desired opacity?  		//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  		//a=b *(1-c) + c  		//>>> where b!=1' c=(b-a/b-1)  		double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  		int remainingRings = fadeWidth;  		double currentOpacity = missingOpacity / (fadeWidth + 1);  		//Update total opacity  		totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  		//Draw it  		using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  			pen.LineJoin = LineJoin.Round;  			g.DrawPath (pen' path);  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (glowFlag) {  	if (glowWidth == 3)  		glowWidth = 2;  	//To replicate photoshop rounding bug  	double finalOpacity = (glowOpacity + 1.5) / 2.5;  	//Because Photoshop doesn't actually use the opacity as the final opacity...   	//Add a 30% fade inside the glow width  	int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  	double totalOpacity = 0;  	//Start at transparent  	//start with outermost ring' work inwards  	for (int i = fadeWidth; i >= 0; i--) {  		//How much opacity do we lack to complete the desired opacity?  		//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  		//a=b *(1-c) + c  		//>>> where b!=1' c=(b-a/b-1)  		double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  		int remainingRings = fadeWidth;  		double currentOpacity = missingOpacity / (fadeWidth + 1);  		//Update total opacity  		totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  		//Draw it  		using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  			pen.LineJoin = LineJoin.Round;  			g.DrawPath (pen' path);  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (glowFlag) {  	if (glowWidth == 3)  		glowWidth = 2;  	//To replicate photoshop rounding bug  	double finalOpacity = (glowOpacity + 1.5) / 2.5;  	//Because Photoshop doesn't actually use the opacity as the final opacity...   	//Add a 30% fade inside the glow width  	int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  	double totalOpacity = 0;  	//Start at transparent  	//start with outermost ring' work inwards  	for (int i = fadeWidth; i >= 0; i--) {  		//How much opacity do we lack to complete the desired opacity?  		//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  		//a=b *(1-c) + c  		//>>> where b!=1' c=(b-a/b-1)  		double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  		int remainingRings = fadeWidth;  		double currentOpacity = missingOpacity / (fadeWidth + 1);  		//Update total opacity  		totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  		//Draw it  		using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  			pen.LineJoin = LineJoin.Round;  			g.DrawPath (pen' path);  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (glowFlag) {  	if (glowWidth == 3)  		glowWidth = 2;  	//To replicate photoshop rounding bug  	double finalOpacity = (glowOpacity + 1.5) / 2.5;  	//Because Photoshop doesn't actually use the opacity as the final opacity...   	//Add a 30% fade inside the glow width  	int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  	double totalOpacity = 0;  	//Start at transparent  	//start with outermost ring' work inwards  	for (int i = fadeWidth; i >= 0; i--) {  		//How much opacity do we lack to complete the desired opacity?  		//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  		//a=b *(1-c) + c  		//>>> where b!=1' c=(b-a/b-1)  		double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  		int remainingRings = fadeWidth;  		double currentOpacity = missingOpacity / (fadeWidth + 1);  		//Update total opacity  		totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  		//Draw it  		using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  			pen.LineJoin = LineJoin.Round;  			g.DrawPath (pen' path);  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (glowFlag) {  	if (glowWidth == 3)  		glowWidth = 2;  	//To replicate photoshop rounding bug  	double finalOpacity = (glowOpacity + 1.5) / 2.5;  	//Because Photoshop doesn't actually use the opacity as the final opacity...   	//Add a 30% fade inside the glow width  	int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  	double totalOpacity = 0;  	//Start at transparent  	//start with outermost ring' work inwards  	for (int i = fadeWidth; i >= 0; i--) {  		//How much opacity do we lack to complete the desired opacity?  		//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  		//a=b *(1-c) + c  		//>>> where b!=1' c=(b-a/b-1)  		double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  		int remainingRings = fadeWidth;  		double currentOpacity = missingOpacity / (fadeWidth + 1);  		//Update total opacity  		totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  		//Draw it  		using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  			pen.LineJoin = LineJoin.Round;  			g.DrawPath (pen' path);  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (glowFlag) {  	if (glowWidth == 3)  		glowWidth = 2;  	//To replicate photoshop rounding bug  	double finalOpacity = (glowOpacity + 1.5) / 2.5;  	//Because Photoshop doesn't actually use the opacity as the final opacity...   	//Add a 30% fade inside the glow width  	int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  	double totalOpacity = 0;  	//Start at transparent  	//start with outermost ring' work inwards  	for (int i = fadeWidth; i >= 0; i--) {  		//How much opacity do we lack to complete the desired opacity?  		//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  		//a=b *(1-c) + c  		//>>> where b!=1' c=(b-a/b-1)  		double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  		int remainingRings = fadeWidth;  		double currentOpacity = missingOpacity / (fadeWidth + 1);  		//Update total opacity  		totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  		//Draw it  		using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  			pen.LineJoin = LineJoin.Round;  			g.DrawPath (pen' path);  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (glowFlag) {  	if (glowWidth == 3)  		glowWidth = 2;  	//To replicate photoshop rounding bug  	double finalOpacity = (glowOpacity + 1.5) / 2.5;  	//Because Photoshop doesn't actually use the opacity as the final opacity...   	//Add a 30% fade inside the glow width  	int fadeWidth = (int)Math.Floor (glowWidth * 0.33);  	double totalOpacity = 0;  	//Start at transparent  	//start with outermost ring' work inwards  	for (int i = fadeWidth; i >= 0; i--) {  		//How much opacity do we lack to complete the desired opacity?  		//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  		//a=b *(1-c) + c  		//>>> where b!=1' c=(b-a/b-1)  		double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  		int remainingRings = fadeWidth;  		double currentOpacity = missingOpacity / (fadeWidth + 1);  		//Update total opacity  		totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  		//Draw it  		using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  			pen.LineJoin = LineJoin.Round;  			g.DrawPath (pen' path);  		}  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (glowWidth == 3)  	glowWidth = 2;  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (glowWidth == 3)  	glowWidth = 2;  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: glowWidth = 2;  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: for (int i = fadeWidth; i >= 0; i--) {  	//How much opacity do we lack to complete the desired opacity?  	//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  	//a=b *(1-c) + c  	//>>> where b!=1' c=(b-a/b-1)  	double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  	int remainingRings = fadeWidth;  	double currentOpacity = missingOpacity / (fadeWidth + 1);  	//Update total opacity  	totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  	//Draw it  	using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  		pen.LineJoin = LineJoin.Round;  		g.DrawPath (pen' path);  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: for (int i = fadeWidth; i >= 0; i--) {  	//How much opacity do we lack to complete the desired opacity?  	//totalOpacity = prevOpacity * (1-curOpacity) + curOpacity  	//a=b *(1-c) + c  	//>>> where b!=1' c=(b-a/b-1)  	double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);  	int remainingRings = fadeWidth;  	double currentOpacity = missingOpacity / (fadeWidth + 1);  	//Update total opacity  	totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;  	//Draw it  	using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  		pen.LineJoin = LineJoin.Round;  		g.DrawPath (pen' path);  	}  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  	pen.LineJoin = LineJoin.Round;  	g.DrawPath (pen' path);  }  
Magic Number,PhotoshopFile.Text,TextLayerRenderer,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using (Pen pen = new Pen (Color.FromArgb ((int)Math.Round (currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2))) {  	pen.LineJoin = LineJoin.Round;  	g.DrawPath (pen' path);  }  
Magic Number,PhotoshopFile.Text,Token,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The following statement contains a magic number: if (c == '/') {  	StringBuilder sb = new StringBuilder (40);  	while (r.CanReadByte ()) {  		//Peek at the next char to see if it is whitespace  		char pc = (char)r.PeekChar ();  		if (Char.IsWhiteSpace (pc) || pc == '\n' || pc == '[' || pc == ']' || pc == '<' || pc == '>') {  			//We're done.  			//Strip the leading slash' create token with name  			return new Token (TokenType.MapKey' sb.ToString ());  		} else {  			//A valid char' append it.  			sb.Append (r.ReadChar ());  		}  	}  }  
Magic Number,PhotoshopFile.Text,Token,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The following statement contains a magic number: if (Char.IsDigit (c) || c == '-' || c == '.') {  	StringBuilder sb = new StringBuilder (40);  	sb.Append (c);  	while (r.CanReadByte ()) {  		//Peek at the next char to see if it is whitespace  		char pc = (char)r.PeekChar ();  		if (Char.IsWhiteSpace (pc) || pc == '\n' || pc == ']' || pc == '>') {  			//We're done. Find out what kind of number it is.  			string s = sb.ToString ();  			//If it has a decimal' it's a double  			if (s.Contains ('.')) {  				return new Token (TokenType.Double' double.Parse (s' floatingPointStyle' NumberFormatInfo.InvariantInfo));  			} else {  				return new Token (TokenType.Integer' int.Parse (s' NumberStyles.Integer' NumberFormatInfo.InvariantInfo));  			}  		} else if (Char.IsDigit (c) || c == '-' || c == '.') {  			//A valid char' append it.  			sb.Append (r.ReadChar ());  		} else {  			//Unrecognized char in numeric sq  			throw new TdTaParseException ("Unrecognized character in numeric sequence: " + sb.ToString () + pc' r);  		}  	}  }  
Magic Number,PhotoshopFile.Text,Token,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The following statement contains a magic number: if (Char.IsWhiteSpace (c) || c == '\n') {  	StringBuilder sb = new StringBuilder (40);  	sb.Append (c);  	while (r.CanReadByte ()) {  		//Peek at the next char to see if it is whitespace  		char pc = (char)r.PeekChar ();  		if (Char.IsWhiteSpace (pc) || pc == '\n') {  			sb.Append (r.ReadChar ());  		} else {  			//We done.  			break;  		}  	}  	return new Token (TokenType.Whitespace' sb.ToString ());  }  
Magic Number,PhotoshopFile.Text,TypeTool,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TypeTool.cs,TypeTool,The following statement contains a magic number: for (int i = 0; i < StyleCount; i++) {  	ushort Mark = reader.ReadUInt16 ();  	ushort FaceMark = reader.ReadUInt16 ();  	uint Size = reader.ReadUInt32 ();  	uint Tracking = reader.ReadUInt32 ();  	uint Kerning = reader.ReadUInt32 ();  	uint Leading = reader.ReadUInt32 ();  	uint BaseShift = reader.ReadUInt32 ();  	byte AutoKern = reader.ReadByte ();  	byte Extra = 0;  	if (Version <= 5)  		Extra = reader.ReadByte ();  	byte Rotate = reader.ReadByte ();  }  
Magic Number,PhotoshopFile.Text,TypeTool,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TypeTool.cs,TypeTool,The following statement contains a magic number: if (Version <= 5)  	Extra = reader.ReadByte ();  
Magic Number,PhotoshopFile.Text,TypeTool,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TypeTool.cs,TypeTool,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	reader.ReadUInt16 ();  
Magic Number,PhotoshopFile.Text,TypeToolObject,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TypeToolObject.cs,TypeToolObject,The following statement contains a magic number: if (Data.Length != 17 || !(Array.TrueForAll (Data' b => b == 0))) {  	string s = ReadableBinary.CreateHexEditorString (Data);  	Debug.Write (s);  }  
Missing Default,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following switch statement is missing a default case: switch (psdFile.ColorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' psdFile.ImageData [3] [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (psdFile.ImageData [0]' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]' psdFile.ImageData [0] [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)psdFile.ImageData [0] [pos];  		c = Color.FromArgb ((int)psdFile.ColorModeData [index]' psdFile.ColorModeData [index + 256]' psdFile.ColorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (psdFile.ImageData [0] [pos]' psdFile.ImageData [1] [pos]' psdFile.ImageData [2] [pos]);  	}  	break;  }  
Missing Default,PhotoshopFile,ImageDecoder,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following switch statement is missing a default case: switch (layer.colorMode) {  case PsdFile.ColorModes.RGB:  	c = Color.FromArgb (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]);  	break;  case PsdFile.ColorModes.CMYK:  	c = CMYKToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]' layer.ch3bytes [pos]);  	break;  case PsdFile.ColorModes.Multichannel:  	c = CMYKToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]' 0);  	break;  case PsdFile.ColorModes.Bitmap:  	byte bwValue = ImageDecoder.GetBitmapValue (layer.ch0bytes' pos);  	c = Color.FromArgb (bwValue' bwValue' bwValue);  	break;  case PsdFile.ColorModes.Grayscale:  case PsdFile.ColorModes.Duotone:  	c = Color.FromArgb (layer.ch0bytes [pos]' layer.ch0bytes [pos]' layer.ch0bytes [pos]);  	break;  case PsdFile.ColorModes.Indexed:  	{  		int index = (int)layer.ch0bytes [pos];  		c = Color.FromArgb ((int)layer.colorModeData [index]' layer.colorModeData [index + 256]' layer.colorModeData [index + 2 * 256]);  	}  	break;  case PsdFile.ColorModes.Lab:  	{  		c = LabToRGB (layer.ch0bytes [pos]' layer.ch1bytes [pos]' layer.ch2bytes [pos]);  	}  	break;  }  
Missing Default,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImageResources,The following switch statement is missing a default case: switch (resID) {  case ResourceIDs.ResolutionInfo:  	imgRes = new ResolutionInfo (imgRes);  	break;  case ResourceIDs.Thumbnail1:  case ResourceIDs.Thumbnail2:  	imgRes = new Thumbnail (imgRes);  	break;  case ResourceIDs.AlphaChannelNames:  	imgRes = new AlphaChannels (imgRes);  	break;  }  
Missing Default,PhotoshopFile,PsdFile,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following switch statement is missing a default case: switch (m_depth) {  case 1:  	bytesPerRow = ImageDecoder.BytesFromBits (m_columns);  	break;  case 8:  	bytesPerRow = m_columns;  	break;  case 16:  	bytesPerRow = m_columns * 2;  	break;  }  
Missing Default,PhotoshopFile,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,parseTypeString,The following switch statement is missing a default case: switch (fourCharType) {  case "obj ":  	return OSType.Reference;  case "Objc":  	return OSType.Descriptor;  case "VlLs":  	return OSType.List;  case "doub":  	return OSType.Double;  case "UntF":  	return OSType.UnitFloat;  case "TEXT":  	return OSType.String;  case "enum":  	return OSType.Enumerated;  case "long":  	return OSType.Integer;  case "bool":  	return OSType.Boolean;  case "GlbO":  	return OSType.Descriptor;  case "type":  	return OSType.Class;  case "GlbC":  	return OSType.Class;  case "alis":  	return OSType.Alias;  case "tdta":  	return OSType.tdta;  }  
Missing Default,PhotoshopFile.Text,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,The following switch statement is missing a default case: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	this.Color = r.ReadPSDColor (16' false);  	//Inner color (no alpha)  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO!  	if (this.Inner)  		this.Unknown = r.ReadByte ();  	this.UnknownColor = r.ReadPSDColor (16' false);  	//unknown color(no alpha)  	this.Data = r.ReadBytes ((int)r.BytesToEnd);  	break;  }  
Missing Default,PhotoshopFile.Text,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following switch statement is missing a default case: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Missing Default,PhotoshopFile.Text,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,The following switch statement is missing a default case: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	//this.BlendModeSignature = r.ReadUInt32();  	//this.BlendModeKey = r.ReadUInt32();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	//TODO:?  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO: 10 unknown bytes!  	break;  }  
Missing Default,PhotoshopFile.Text,Token,F:\newReposMay17\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The following switch statement is missing a default case: switch (c) {  case '(':  	return new Token (parseBinary (r));  //Binary data. Leading and trailing parens are stripped' and escaped parens are restored to normal.  case '[':  	return new Token (TokenType.StartList' c.ToString ());  // [ opening list char  case ']':  	return new Token (TokenType.EndList' c.ToString ());  //Closing list char  }  
