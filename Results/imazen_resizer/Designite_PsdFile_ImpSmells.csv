Implementation smell,Namespace,Class,File,Method,Description
Long Method,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The method has 211 lines of code.
Complex Method,PhotoshopFile,WaitableCounter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PrivateThreadPool.cs,Dispose,Cyclomatic complexity of the method is 8
Complex Method,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadLayers,Cyclomatic complexity of the method is 9
Complex Method,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,Cyclomatic complexity of the method is 10
Complex Method,PhotoshopFile.Text,Token,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,Cyclomatic complexity of the method is 18
Long Statement,PhotoshopFile,DynVal,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,getString,The length of the statement  "            string s = lineprefix +  "(" + this.Type.ToString()  + ") "+ this.Name + ":" + ((this.Value == null) ? "null" : this.Value.ToString());" is 135.
Long Statement,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The length of the statement  "            return Color.FromArgb((int)((double)values[0] * 255)'(int)((double)values[1] * 255)'(int)((double)values[2] * 255)'(int)( (double)values[3] * 255));" is 148.
Long Statement,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The length of the statement  "                throw new Exception("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString(b));" is 124.
Long Statement,PhotoshopFile.Text,TdTaStylesheetReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaStylesheetReader.cs,BuildRunItem,The length of the statement  "            return TdTaParser.MergeObjects(TdTaParser.getDict(tree' baseSelector + ".DefaultRunData")' TdTaParser.getList(tree' baseSelector + ".RunArray")[index]);" is 152.
Long Statement,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The length of the statement  "                throw new Exception("Old style tySh font syntax not implemented' found on layer " + l.Name + ". Use a newer version of Photoshop");" is 131.
Long Statement,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The length of the statement  "                throw new Exception("Txt2 text layer info not supported' found on layer " + l.Name + ". Where did you find this file? What version of photoshop?");" is 147.
Long Statement,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The length of the statement  "                    fontName = new Regex("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace(fontName' "");" is 126.
Long Statement,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The length of the statement  "                    double finalOpacity = (glowOpacity + 1.5)/2.5; //Because Photoshop doesn't actually use the opacity as the final opacity... " is 123.
Long Statement,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The length of the statement  "                        using (Pen pen = new Pen(Color.FromArgb((int)Math.Round(currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2)))" is 143.
Long Statement,PhotoshopFile.Text,Token,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The length of the statement  "                case '(': return new Token(parseBinary(r)); //Binary data. Leading and trailing parens are stripped' and escaped parens are restored to normal." is 143.
Complex Conditional,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetMaskValue,The conditional expression  "y >= 0 && y < mask.Rect.Height &&            x >= 0 && x < mask.Rect.Width"  is complex.
Complex Conditional,PhotoshopFile,ReadableBinary,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The conditional expression  "((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26)"  is complex.
Complex Conditional,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,copy,The conditional expression  "o is double || o is string || o is int || o is bool"  is complex.
Complex Conditional,PhotoshopFile.Text,Token,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The conditional expression  "Char.IsWhiteSpace(pc) || pc == '\n' || pc=='[' || pc==']' || pc=='<' || pc=='>'"  is complex.
Complex Conditional,PhotoshopFile.Text,Token,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The conditional expression  "Char.IsWhiteSpace(pc) || pc == '\n' || pc ==']' || pc =='>'"  is complex.
Complex Conditional,PhotoshopFile.Text,Token,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The conditional expression  "c == 't' || c == 'T' || c == 'f' || c == 'F'"  is complex.
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadInt16,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 2);       }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadDouble,The following statement contains a magic number: unsafe         {             SwapBytes((byte*)&val' 8);         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadInt32,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 4);       }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadInt64,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 8);       }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadUInt16,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 2);       }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadUInt32,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 4);       }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadUInt64,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 8);       }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPascalString,The following statement contains a magic number: if ((stringLength % 2) == 0)         base.ReadByte();
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDUnicodeString,The following statement contains a magic number: for (int i = 0; i < nLength * 2; i++)         {                          char c = base.ReadChar();             if (i % 2 == 1 && c != 0)                 s += c;         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDUnicodeString,The following statement contains a magic number: for (int i = 0; i < nLength * 2; i++)         {                          char c = base.ReadChar();             if (i % 2 == 1 && c != 0)                 s += c;         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadTdTaString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(4096);
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadTdTaString,The following statement contains a magic number: while (BytesToEnd > 0)         {             c = base.ReadChar();             if (c != 0x0) sb.Append(c);             if (c == '>' && sb[sb.Length - 2] == '>' && sb[sb.Length - 3] == '\n')             {                 //we hit the end.                 break;             }         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadTdTaString,The following statement contains a magic number: while (BytesToEnd > 0)         {             c = base.ReadChar();             if (c != 0x0) sb.Append(c);             if (c == '>' && sb[sb.Length - 2] == '>' && sb[sb.Length - 3] == '\n')             {                 //we hit the end.                 break;             }         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8)         {             int a = (int)base.ReadByte();             if (!alpha)                 a = 255;             return System.Drawing.Color.FromArgb(a' this.ReadByte()' this.ReadByte()' this.ReadByte());         }         else         {             this.BaseStream.Position += 2; //Always?             ushort a = ushort.MaxValue;             if (alpha)                 a = this.ReadUInt16();             ushort r = this.ReadUInt16();             ushort g = this.ReadUInt16();             ushort b = this.ReadUInt16();             return System.Drawing.Color.FromArgb((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8)         {             int a = (int)base.ReadByte();             if (!alpha)                 a = 255;             return System.Drawing.Color.FromArgb(a' this.ReadByte()' this.ReadByte()' this.ReadByte());         }         else         {             this.BaseStream.Position += 2; //Always?             ushort a = ushort.MaxValue;             if (alpha)                 a = this.ReadUInt16();             ushort r = this.ReadUInt16();             ushort g = this.ReadUInt16();             ushort b = this.ReadUInt16();             return System.Drawing.Color.FromArgb((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8)         {             int a = (int)base.ReadByte();             if (!alpha)                 a = 255;             return System.Drawing.Color.FromArgb(a' this.ReadByte()' this.ReadByte()' this.ReadByte());         }         else         {             this.BaseStream.Position += 2; //Always?             ushort a = ushort.MaxValue;             if (alpha)                 a = this.ReadUInt16();             ushort r = this.ReadUInt16();             ushort g = this.ReadUInt16();             ushort b = this.ReadUInt16();             return System.Drawing.Color.FromArgb((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8)         {             int a = (int)base.ReadByte();             if (!alpha)                 a = 255;             return System.Drawing.Color.FromArgb(a' this.ReadByte()' this.ReadByte()' this.ReadByte());         }         else         {             this.BaseStream.Position += 2; //Always?             ushort a = ushort.MaxValue;             if (alpha)                 a = this.ReadUInt16();             ushort r = this.ReadUInt16();             ushort g = this.ReadUInt16();             ushort b = this.ReadUInt16();             return System.Drawing.Color.FromArgb((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8)         {             int a = (int)base.ReadByte();             if (!alpha)                 a = 255;             return System.Drawing.Color.FromArgb(a' this.ReadByte()' this.ReadByte()' this.ReadByte());         }         else         {             this.BaseStream.Position += 2; //Always?             ushort a = ushort.MaxValue;             if (alpha)                 a = this.ReadUInt16();             ushort r = this.ReadUInt16();             ushort g = this.ReadUInt16();             ushort b = this.ReadUInt16();             return System.Drawing.Color.FromArgb((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8)         {             int a = (int)base.ReadByte();             if (!alpha)                 a = 255;             return System.Drawing.Color.FromArgb(a' this.ReadByte()' this.ReadByte()' this.ReadByte());         }         else         {             this.BaseStream.Position += 2; //Always?             ushort a = ushort.MaxValue;             if (alpha)                 a = this.ReadUInt16();             ushort r = this.ReadUInt16();             ushort g = this.ReadUInt16();             ushort b = this.ReadUInt16();             return System.Drawing.Color.FromArgb((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8)         {             int a = (int)base.ReadByte();             if (!alpha)                 a = 255;             return System.Drawing.Color.FromArgb(a' this.ReadByte()' this.ReadByte()' this.ReadByte());         }         else         {             this.BaseStream.Position += 2; //Always?             ushort a = ushort.MaxValue;             if (alpha)                 a = this.ReadUInt16();             ushort r = this.ReadUInt16();             ushort g = this.ReadUInt16();             ushort b = this.ReadUInt16();             return System.Drawing.Color.FromArgb((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);         }
Magic Number,PhotoshopFile,BinaryReverseReader,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,SwapBytes,The following statement contains a magic number: for (long i = 0; i < nLength / 2; ++i)       {         byte t = *(ptr + i);         *(ptr + i) = *(ptr + nLength - i - 1);         *(ptr + nLength - i - 1) = t;       }
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: if (s.Length > 255)         c = s.Substring(0' 255).ToCharArray();       else         c = s.ToCharArray();
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: if (s.Length > 255)         c = s.Substring(0' 255).ToCharArray();       else         c = s.ToCharArray();
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: if ((realLength % 2) == 0)         return;
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: for (int i = 0; i < (2 - (realLength % 2)); i++)         base.Write((byte)0);
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,WritePascalString,The following statement contains a magic number: for (int i = 0; i < (2 - (realLength % 2)); i++)         base.Write((byte)0);
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 2);       }
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 4);       }
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 8);       }
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 2);       }
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 4);       }
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,Write,The following statement contains a magic number: unsafe       {         this.SwapBytes((byte*)&val' 8);       }
Magic Number,PhotoshopFile,BinaryReverseWriter,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\BinaryReverseReader.cs,SwapBytes,The following statement contains a magic number: for (long i = 0; i < nLength / 2; ++i)       {         byte t = *(ptr + i);         *(ptr + i) = *(ptr + nLength - i - 1);         *(ptr + nLength - i - 1) = t;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,BytesFromBits,The following statement contains a magic number: return (bits + 7) / 8;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,BytesFromBits,The following statement contains a magic number: return (bits + 7) / 8;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetBitmapValue,The following statement contains a magic number: byte mask = (byte)(0x80 >> (pos % 8));
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetBitmapValue,The following statement contains a magic number: byte bwValue = (byte)(bitmap[pos / 8] & mask);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetBitmapValue,The following statement contains a magic number: bwValue = (bwValue == 0) ? (byte)255 : (byte)0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: unsafe       {         byte* pCurrRowPixel = (byte*)bd.Scan0.ToPointer();          for (int y = 0; y < psdFile.Rows; y++)         {           int rowIndex = y * psdFile.Columns;           PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;           for (int x = 0; x < psdFile.Columns; x++)           {             int pos = rowIndex + x;              Color pixelColor = GetColor(psdFile' pos);              pCurrPixel->Alpha = 255;             pCurrPixel->Red = pixelColor.R;             pCurrPixel->Green = pixelColor.G;             pCurrPixel->Blue = pixelColor.B;                           pCurrPixel += 1;           }           pCurrRowPixel += bd.Stride;         }       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[1][pos]'                              psdFile.ImageData[2][pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         psdFile.ImageData[3][pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(psdFile.ImageData[0]' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]);           break;         case PsdFile.ColorModes.Indexed:           {             int index = (int)psdFile.ImageData[0][pos];             c = Color.FromArgb((int)psdFile.ColorModeData[index]'                              psdFile.ColorModeData[index + 256]'                              psdFile.ColorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {             c = LabToRGB(psdFile.ImageData[0][pos]'                          psdFile.ImageData[1][pos]'                          psdFile.ImageData[2][pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[1][pos]'                              psdFile.ImageData[2][pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         psdFile.ImageData[3][pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(psdFile.ImageData[0]' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]);           break;         case PsdFile.ColorModes.Indexed:           {             int index = (int)psdFile.ImageData[0][pos];             c = Color.FromArgb((int)psdFile.ColorModeData[index]'                              psdFile.ColorModeData[index + 256]'                              psdFile.ColorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {             c = LabToRGB(psdFile.ImageData[0][pos]'                          psdFile.ImageData[1][pos]'                          psdFile.ImageData[2][pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[1][pos]'                              psdFile.ImageData[2][pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         psdFile.ImageData[3][pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(psdFile.ImageData[0]' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]);           break;         case PsdFile.ColorModes.Indexed:           {             int index = (int)psdFile.ImageData[0][pos];             c = Color.FromArgb((int)psdFile.ColorModeData[index]'                              psdFile.ColorModeData[index + 256]'                              psdFile.ColorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {             c = LabToRGB(psdFile.ImageData[0][pos]'                          psdFile.ImageData[1][pos]'                          psdFile.ImageData[2][pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[1][pos]'                              psdFile.ImageData[2][pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         psdFile.ImageData[3][pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(psdFile.ImageData[0]' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]);           break;         case PsdFile.ColorModes.Indexed:           {             int index = (int)psdFile.ImageData[0][pos];             c = Color.FromArgb((int)psdFile.ColorModeData[index]'                              psdFile.ColorModeData[index + 256]'                              psdFile.ColorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {             c = LabToRGB(psdFile.ImageData[0][pos]'                          psdFile.ImageData[1][pos]'                          psdFile.ImageData[2][pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[1][pos]'                              psdFile.ImageData[2][pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         psdFile.ImageData[3][pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(psdFile.ImageData[0]' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]);           break;         case PsdFile.ColorModes.Indexed:           {             int index = (int)psdFile.ImageData[0][pos];             c = Color.FromArgb((int)psdFile.ColorModeData[index]'                              psdFile.ColorModeData[index + 256]'                              psdFile.ColorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {             c = LabToRGB(psdFile.ImageData[0][pos]'                          psdFile.ImageData[1][pos]'                          psdFile.ImageData[2][pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[1][pos]'                              psdFile.ImageData[2][pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         psdFile.ImageData[3][pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(psdFile.ImageData[0]' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]);           break;         case PsdFile.ColorModes.Indexed:           {             int index = (int)psdFile.ImageData[0][pos];             c = Color.FromArgb((int)psdFile.ColorModeData[index]'                              psdFile.ColorModeData[index + 256]'                              psdFile.ColorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {             c = LabToRGB(psdFile.ImageData[0][pos]'                          psdFile.ImageData[1][pos]'                          psdFile.ImageData[2][pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[1][pos]'                              psdFile.ImageData[2][pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         psdFile.ImageData[3][pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(psdFile.ImageData[0]' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]);           break;         case PsdFile.ColorModes.Indexed:           {             int index = (int)psdFile.ImageData[0][pos];             c = Color.FromArgb((int)psdFile.ColorModeData[index]'                              psdFile.ColorModeData[index + 256]'                              psdFile.ColorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {             c = LabToRGB(psdFile.ImageData[0][pos]'                          psdFile.ImageData[1][pos]'                          psdFile.ImageData[2][pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (psdFile.ColorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[1][pos]'                              psdFile.ImageData[2][pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         psdFile.ImageData[3][pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(psdFile.ImageData[0]' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]);           break;         case PsdFile.ColorModes.Indexed:           {             int index = (int)psdFile.ImageData[0][pos];             c = Color.FromArgb((int)psdFile.ColorModeData[index]'                              psdFile.ColorModeData[index + 256]'                              psdFile.ColorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {             c = LabToRGB(psdFile.ImageData[0][pos]'                          psdFile.ImageData[1][pos]'                          psdFile.ImageData[2][pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: unsafe       {         byte* pCurrRowPixel = (byte*)bd.Scan0.ToPointer();          for (int y = 0; y < height; y++)         {           int rowIndex = y * width;           PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;           for (int x = 0; x < width; x++)           {             int pos = rowIndex + x;              //Fast path for RGB mode' somewhat inlined.             if (l.colorMode == PsdFile.ColorModes.RGB)             {                 //Add alpha channel if it exists.                 if (l.hasalpha)                      pCurrPixel->Alpha = l.alphabytes[pos];                 else                     pCurrPixel->Alpha = 255;                 //Apply mask if present.                 if (l.hasmask)                     pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue(layer.MaskData' x' y)) / 255);                                   pCurrPixel->Red = l.ch0bytes[pos];                 pCurrPixel->Green = l.ch1bytes[pos];                 pCurrPixel->Blue = l.ch2bytes[pos];              }             else             {                 Color pixelColor = GetColor(l' pos);                  if (l.hasmask)                 {                     int maskAlpha = GetMaskValue(layer.MaskData' x' y);                     int oldAlpha = pixelColor.A;                      int newAlpha = (oldAlpha * maskAlpha) / 255;                     pixelColor = Color.FromArgb(newAlpha' pixelColor);                 }                  pCurrPixel->Alpha = pixelColor.A;                 pCurrPixel->Red = pixelColor.R;                 pCurrPixel->Green = pixelColor.G;                 pCurrPixel->Blue = pixelColor.B;             }              pCurrPixel += 1;           }           pCurrRowPixel += bd.Stride;         }       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: unsafe       {         byte* pCurrRowPixel = (byte*)bd.Scan0.ToPointer();          for (int y = 0; y < height; y++)         {           int rowIndex = y * width;           PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;           for (int x = 0; x < width; x++)           {             int pos = rowIndex + x;              //Fast path for RGB mode' somewhat inlined.             if (l.colorMode == PsdFile.ColorModes.RGB)             {                 //Add alpha channel if it exists.                 if (l.hasalpha)                      pCurrPixel->Alpha = l.alphabytes[pos];                 else                     pCurrPixel->Alpha = 255;                 //Apply mask if present.                 if (l.hasmask)                     pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue(layer.MaskData' x' y)) / 255);                                   pCurrPixel->Red = l.ch0bytes[pos];                 pCurrPixel->Green = l.ch1bytes[pos];                 pCurrPixel->Blue = l.ch2bytes[pos];              }             else             {                 Color pixelColor = GetColor(l' pos);                  if (l.hasmask)                 {                     int maskAlpha = GetMaskValue(layer.MaskData' x' y);                     int oldAlpha = pixelColor.A;                      int newAlpha = (oldAlpha * maskAlpha) / 255;                     pixelColor = Color.FromArgb(newAlpha' pixelColor);                 }                  pCurrPixel->Alpha = pixelColor.A;                 pCurrPixel->Red = pixelColor.R;                 pCurrPixel->Green = pixelColor.G;                 pCurrPixel->Blue = pixelColor.B;             }              pCurrPixel += 1;           }           pCurrRowPixel += bd.Stride;         }       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: unsafe       {         byte* pCurrRowPixel = (byte*)bd.Scan0.ToPointer();          for (int y = 0; y < height; y++)         {           int rowIndex = y * width;           PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;           for (int x = 0; x < width; x++)           {             int pos = rowIndex + x;              //Fast path for RGB mode' somewhat inlined.             if (l.colorMode == PsdFile.ColorModes.RGB)             {                 //Add alpha channel if it exists.                 if (l.hasalpha)                      pCurrPixel->Alpha = l.alphabytes[pos];                 else                     pCurrPixel->Alpha = 255;                 //Apply mask if present.                 if (l.hasmask)                     pCurrPixel->Alpha = (byte)((pCurrPixel->Alpha * GetMaskValue(layer.MaskData' x' y)) / 255);                                   pCurrPixel->Red = l.ch0bytes[pos];                 pCurrPixel->Green = l.ch1bytes[pos];                 pCurrPixel->Blue = l.ch2bytes[pos];              }             else             {                 Color pixelColor = GetColor(l' pos);                  if (l.hasmask)                 {                     int maskAlpha = GetMaskValue(layer.MaskData' x' y);                     int oldAlpha = pixelColor.A;                      int newAlpha = (oldAlpha * maskAlpha) / 255;                     pixelColor = Color.FromArgb(newAlpha' pixelColor);                 }                  pCurrPixel->Alpha = pixelColor.A;                 pCurrPixel->Red = pixelColor.R;                 pCurrPixel->Green = pixelColor.G;                 pCurrPixel->Blue = pixelColor.B;             }              pCurrPixel += 1;           }           pCurrRowPixel += bd.Stride;         }       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (layer.colorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(layer.ch0bytes[pos]'                              layer.ch1bytes[pos]'                              layer.ch2bytes[pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(layer.ch0bytes[pos]'                         layer.ch1bytes[pos]'                         layer.ch2bytes[pos]'                         layer.ch3bytes[pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(layer.ch0bytes[pos]'                         layer.ch1bytes[pos]'                         layer.ch2bytes[pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(layer.ch0bytes' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(layer.ch0bytes[pos]'                              layer.ch0bytes[pos]'                              layer.ch0bytes[pos]);           break;         case PsdFile.ColorModes.Indexed:           {               int index = (int)layer.ch0bytes[pos];             c = Color.FromArgb((int)layer.colorModeData[index]'                              layer.colorModeData[index + 256]'                              layer.colorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {               c = LabToRGB(layer.ch0bytes[pos]'                          layer.ch1bytes[pos]'                          layer.ch2bytes[pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (layer.colorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(layer.ch0bytes[pos]'                              layer.ch1bytes[pos]'                              layer.ch2bytes[pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(layer.ch0bytes[pos]'                         layer.ch1bytes[pos]'                         layer.ch2bytes[pos]'                         layer.ch3bytes[pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(layer.ch0bytes[pos]'                         layer.ch1bytes[pos]'                         layer.ch2bytes[pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(layer.ch0bytes' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(layer.ch0bytes[pos]'                              layer.ch0bytes[pos]'                              layer.ch0bytes[pos]);           break;         case PsdFile.ColorModes.Indexed:           {               int index = (int)layer.ch0bytes[pos];             c = Color.FromArgb((int)layer.colorModeData[index]'                              layer.colorModeData[index + 256]'                              layer.colorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {               c = LabToRGB(layer.ch0bytes[pos]'                          layer.ch1bytes[pos]'                          layer.ch2bytes[pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following statement contains a magic number: switch (layer.colorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(layer.ch0bytes[pos]'                              layer.ch1bytes[pos]'                              layer.ch2bytes[pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(layer.ch0bytes[pos]'                         layer.ch1bytes[pos]'                         layer.ch2bytes[pos]'                         layer.ch3bytes[pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(layer.ch0bytes[pos]'                         layer.ch1bytes[pos]'                         layer.ch2bytes[pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(layer.ch0bytes' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(layer.ch0bytes[pos]'                              layer.ch0bytes[pos]'                              layer.ch0bytes[pos]);           break;         case PsdFile.ColorModes.Indexed:           {               int index = (int)layer.ch0bytes[pos];             c = Color.FromArgb((int)layer.colorModeData[index]'                              layer.colorModeData[index + 256]'                              layer.colorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {               c = LabToRGB(layer.ch0bytes[pos]'                          layer.ch1bytes[pos]'                          layer.ch2bytes[pos]);           }           break;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetMaskValue,The following statement contains a magic number: int c = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetMaskValue,The following statement contains a magic number: if (y >= 0 && y < mask.Rect.Height &&            x >= 0 && x < mask.Rect.Width)       {         int pos = y * mask.Rect.Width + x;         if (pos < mask.ImageData.Length)           c = mask.ImageData[pos];         else           c = 255;       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,DecodeImage,The following statement contains a magic number: unsafe       {         byte* pCurrRowPixel = (byte*)bd.Scan0.ToPointer();          for (int y = 0; y < mask.Rect.Height; y++)         {           int rowIndex = y * mask.Rect.Width;           PixelData* pCurrPixel = (PixelData*)pCurrRowPixel;           for (int x = 0; x < mask.Rect.Width; x++)           {             int pos = rowIndex + x;              Color pixelColor = Color.FromArgb(mask.ImageData[pos]' mask.ImageData[pos]' mask.ImageData[pos]);              pCurrPixel->Alpha = 255;             pCurrPixel->Red = pixelColor.R;             pCurrPixel->Green = pixelColor.G;             pCurrPixel->Blue = pixelColor.B;              pCurrPixel += 1;           }           pCurrRowPixel += bd.Stride;         }       }
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: L_coef = 256.0 / 100.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: L_coef = 256.0 / 100.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: a_coef = 256.0 / 256.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: a_coef = 256.0 / 256.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: b_coef = 256.0 / 256.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: b_coef = 256.0 / 256.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: int a = (int)(exA / a_coef - 128.0);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: int b = (int)(exB / b_coef - 128.0);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: const double ref_X = 95.047;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: const double ref_Y = 100.000;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: const double ref_Z = 108.883;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: double var_Y = ((double)L + 16.0) / 116.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: double var_Y = ((double)L + 16.0) / 116.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: double var_X = (double)a / 500.0 + var_Y;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: double var_Z = var_Y - (double)b / 200.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Y' 3) > 0.008856)         var_Y = Math.Pow(var_Y' 3);       else         var_Y = (var_Y - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Y' 3) > 0.008856)         var_Y = Math.Pow(var_Y' 3);       else         var_Y = (var_Y - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Y' 3) > 0.008856)         var_Y = Math.Pow(var_Y' 3);       else         var_Y = (var_Y - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Y' 3) > 0.008856)         var_Y = Math.Pow(var_Y' 3);       else         var_Y = (var_Y - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Y' 3) > 0.008856)         var_Y = Math.Pow(var_Y' 3);       else         var_Y = (var_Y - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Y' 3) > 0.008856)         var_Y = Math.Pow(var_Y' 3);       else         var_Y = (var_Y - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_X' 3) > 0.008856)         var_X = Math.Pow(var_X' 3);       else         var_X = (var_X - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_X' 3) > 0.008856)         var_X = Math.Pow(var_X' 3);       else         var_X = (var_X - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_X' 3) > 0.008856)         var_X = Math.Pow(var_X' 3);       else         var_X = (var_X - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_X' 3) > 0.008856)         var_X = Math.Pow(var_X' 3);       else         var_X = (var_X - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_X' 3) > 0.008856)         var_X = Math.Pow(var_X' 3);       else         var_X = (var_X - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_X' 3) > 0.008856)         var_X = Math.Pow(var_X' 3);       else         var_X = (var_X - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Z' 3) > 0.008856)         var_Z = Math.Pow(var_Z' 3);       else         var_Z = (var_Z - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Z' 3) > 0.008856)         var_Z = Math.Pow(var_Z' 3);       else         var_Z = (var_Z - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Z' 3) > 0.008856)         var_Z = Math.Pow(var_Z' 3);       else         var_Z = (var_Z - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Z' 3) > 0.008856)         var_Z = Math.Pow(var_Z' 3);       else         var_Z = (var_Z - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Z' 3) > 0.008856)         var_Z = Math.Pow(var_Z' 3);       else         var_Z = (var_Z - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LabToRGB,The following statement contains a magic number: if (Math.Pow(var_Z' 3) > 0.008856)         var_Z = Math.Pow(var_Z' 3);       else         var_Z = (var_Z - 16 / 116) / 7.787;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_X = X / 100.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_Y = Y / 100.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_Z = Z / 100.0;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_R = var_X * 3.2406 + var_Y * (-1.5372) + var_Z * (-0.4986);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_R = var_X * 3.2406 + var_Y * (-1.5372) + var_Z * (-0.4986);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_R = var_X * 3.2406 + var_Y * (-1.5372) + var_Z * (-0.4986);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_G = var_X * (-0.9689) + var_Y * 1.8758 + var_Z * 0.0415;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_G = var_X * (-0.9689) + var_Y * 1.8758 + var_Z * 0.0415;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_G = var_X * (-0.9689) + var_Y * 1.8758 + var_Z * 0.0415;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_B = var_X * 0.0557 + var_Y * (-0.2040) + var_Z * 1.0570;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_B = var_X * 0.0557 + var_Y * (-0.2040) + var_Z * 1.0570;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: double var_B = var_X * 0.0557 + var_Y * (-0.2040) + var_Z * 1.0570;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_R > 0.0031308)         var_R = 1.055 * (Math.Pow(var_R' 1 / 2.4)) - 0.055;       else         var_R = 12.92 * var_R;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_R > 0.0031308)         var_R = 1.055 * (Math.Pow(var_R' 1 / 2.4)) - 0.055;       else         var_R = 12.92 * var_R;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_R > 0.0031308)         var_R = 1.055 * (Math.Pow(var_R' 1 / 2.4)) - 0.055;       else         var_R = 12.92 * var_R;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_R > 0.0031308)         var_R = 1.055 * (Math.Pow(var_R' 1 / 2.4)) - 0.055;       else         var_R = 12.92 * var_R;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_R > 0.0031308)         var_R = 1.055 * (Math.Pow(var_R' 1 / 2.4)) - 0.055;       else         var_R = 12.92 * var_R;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_G > 0.0031308)         var_G = 1.055 * (Math.Pow(var_G' 1 / 2.4)) - 0.055;       else         var_G = 12.92 * var_G;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_G > 0.0031308)         var_G = 1.055 * (Math.Pow(var_G' 1 / 2.4)) - 0.055;       else         var_G = 12.92 * var_G;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_G > 0.0031308)         var_G = 1.055 * (Math.Pow(var_G' 1 / 2.4)) - 0.055;       else         var_G = 12.92 * var_G;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_G > 0.0031308)         var_G = 1.055 * (Math.Pow(var_G' 1 / 2.4)) - 0.055;       else         var_G = 12.92 * var_G;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_G > 0.0031308)         var_G = 1.055 * (Math.Pow(var_G' 1 / 2.4)) - 0.055;       else         var_G = 12.92 * var_G;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_B > 0.0031308)         var_B = 1.055 * (Math.Pow(var_B' 1 / 2.4)) - 0.055;       else         var_B = 12.92 * var_B;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_B > 0.0031308)         var_B = 1.055 * (Math.Pow(var_B' 1 / 2.4)) - 0.055;       else         var_B = 12.92 * var_B;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_B > 0.0031308)         var_B = 1.055 * (Math.Pow(var_B' 1 / 2.4)) - 0.055;       else         var_B = 12.92 * var_B;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_B > 0.0031308)         var_B = 1.055 * (Math.Pow(var_B' 1 / 2.4)) - 0.055;       else         var_B = 12.92 * var_B;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (var_B > 0.0031308)         var_B = 1.055 * (Math.Pow(var_B' 1 / 2.4)) - 0.055;       else         var_B = 12.92 * var_B;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: int nRed = (int)(var_R * 256.0);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: int nGreen = (int)(var_G * 256.0);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: int nBlue = (int)(var_B * 256.0);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nRed < 0) nRed = 0;       else if (nRed > 255) nRed = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nRed < 0) nRed = 0;       else if (nRed > 255) nRed = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nGreen < 0) nGreen = 0;       else if (nGreen > 255) nGreen = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nGreen < 0) nGreen = 0;       else if (nGreen > 255) nGreen = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nBlue < 0) nBlue = 0;       else if (nBlue > 255) nBlue = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,XYZToRGB,The following statement contains a magic number: if (nBlue < 0) nBlue = 0;       else if (nBlue > 255) nBlue = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: double dMaxColours = Math.Pow(2' 8);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: double dMaxColours = Math.Pow(2' 8);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: int nRed = (int)((1.0 - (C * (1 - K) + K)) * 255);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: int nGreen = (int)((1.0 - (M * (1 - K) + K)) * 255);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: int nBlue = (int)((1.0 - (Y * (1 - K) + K)) * 255);
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nRed < 0) nRed = 0;       else if (nRed > 255) nRed = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nRed < 0) nRed = 0;       else if (nRed > 255) nRed = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nGreen < 0) nGreen = 0;       else if (nGreen > 255) nGreen = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nGreen < 0) nGreen = 0;       else if (nGreen > 255) nGreen = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nBlue < 0) nBlue = 0;       else if (nBlue > 255) nBlue = 255;
Magic Number,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,CMYKToRGB,The following statement contains a magic number: if (nBlue < 0) nBlue = 0;       else if (nBlue > 255) nBlue = 255;
Magic Number,PhotoshopFile,LayerWrapper,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LayerWrapper,The following statement contains a magic number: hasmask = l.SortedChannels.ContainsKey(-2);
Magic Number,PhotoshopFile,LayerWrapper,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LayerWrapper,The following statement contains a magic number: hasch2 = l.SortedChannels.ContainsKey(2);
Magic Number,PhotoshopFile,LayerWrapper,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LayerWrapper,The following statement contains a magic number: hasch3 = l.SortedChannels.ContainsKey(3);
Magic Number,PhotoshopFile,LayerWrapper,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LayerWrapper,The following statement contains a magic number: if (hasch2) ch2bytes = l.SortedChannels[2].ImageData;
Magic Number,PhotoshopFile,LayerWrapper,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,LayerWrapper,The following statement contains a magic number: if (hasch3) ch3bytes = l.SortedChannels[3].ImageData;
Magic Number,PhotoshopFile,ImageResource,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageResource.cs,ImageResource,The following statement contains a magic number: m_osType = new string(reader.ReadChars(4));
Magic Number,PhotoshopFile,ImageResource,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageResource.cs,ImageResource,The following statement contains a magic number: if (reader.BaseStream.Position % 2 == 1)         reader.ReadByte();
Magic Number,PhotoshopFile,ImageResource,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageResource.cs,Save,The following statement contains a magic number: if (writer.BaseStream.Position % 2 == 1)         writer.Write((byte)0);
Magic Number,PhotoshopFile,Thumbnail,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: using (BinaryReverseReader reader = DataReader)       {         int format = reader.ReadInt32();         int width = reader.ReadInt32();         int height = reader.ReadInt32();         int widthBytes = reader.ReadInt32();         int size = reader.ReadInt32();         int compressedSize = reader.ReadInt32();         short bitPerPixel = reader.ReadInt16();         short planes = reader.ReadInt16();          if (format == 1)         {            byte[] imgData = reader.ReadBytes((int)(reader.BaseStream.Length - reader.BaseStream.Position));            using (MemoryStream strm = new MemoryStream(imgData))           {             m_thumbnailImage = (Bitmap)(Bitmap.FromStream(strm).Clone());           }            if (this.ID == 1033)           {             //// BGR             //for(int y=0;y<m_thumbnailImage.Height;y++)             //  for (int x = 0; x < m_thumbnailImage.Width; x++)             //  {             //    Color c=m_thumbnailImage.GetPixel(x'y);             //    Color c2=Color.FromArgb(c.B' c.G' c.R);             //    m_thumbnailImage.SetPixel(x' y' c);             //  }           }          }         else         {           m_thumbnailImage = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);         }       }
Magic Number,PhotoshopFile,Layer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,Layer,The following statement contains a magic number: string signature = new string(reader.ReadChars(4));
Magic Number,PhotoshopFile,Layer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,Layer,The following statement contains a magic number: m_blendModeKey = new string(reader.ReadChars(4));
Magic Number,PhotoshopFile,Layer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,Layer,The following statement contains a magic number: int paddingBytes =(int)((reader.BaseStream.Position - namePosition) % 4);
Magic Number,PhotoshopFile,Layer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,Save,The following statement contains a magic number: using (new LengthWriter(writer))       {         m_maskData.Save(writer);         m_blendingRangesData.Save(writer);          long namePosition = writer.BaseStream.Position;          writer.WritePascalString(m_name);          int paddingBytes = (int)((writer.BaseStream.Position - namePosition) % 4);         Debug.Print("Layer {0} write padding bytes after name"' paddingBytes);          for (int i = 0; i < paddingBytes;i++ )           writer.Write((byte)0);          foreach (AdjustmentLayerInfo info in m_adjustmentInfo)         {           info.Save(writer);         }       }
Magic Number,PhotoshopFile,Channel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,Save,The following statement contains a magic number: writer.Write(Data.Length+2);
Magic Number,PhotoshopFile,Channel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,LoadPixelData,The following statement contains a magic number: using (BinaryReverseReader readerImg = DataReader)         {           m_imageCompression = (ImageCompression)readerImg.ReadInt16();            m_bytesPerRow = 0;            switch (m_layer.PsdFile.Depth)           {             case 1:               m_bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               m_bytesPerRow = m_layer.m_rect.Width;               break;             case 16:               m_bytesPerRow = m_layer.m_rect.Width * 2;               break;           }            m_imageData = new byte[m_layer.m_rect.Height * m_bytesPerRow];            switch (m_imageCompression)           {             case ImageCompression.Raw:               readerImg.Read(m_imageData' 0' m_imageData.Length);               break;             case ImageCompression.Rle:               {                 m_rowLengthList = new uint[m_layer.m_rect.Height];                 uint totalRleLength = 0;                 for (int i = 0; i < m_rowLengthList.Length; i++)                 {                   m_rowLengthList[i] = readerImg.ReadUInt16();                   totalRleLength += m_rowLengthList[i];                 }                 m_data = new byte[totalRleLength];                  uint idxData = 0;                 for (int i = 0; i < m_layer.m_rect.Height; i++)                 {                   readerImg.Read(m_data' (int)idxData' (int)m_rowLengthList[i]);                   idxData += m_rowLengthList[i];                    // The PSD specification states that rows are padded to even sizes.                   // However' PSD files generated by Photoshop CS4 do not actually                   // follow this stipulation.                 }               }               break;             default:               break;           }         }
Magic Number,PhotoshopFile,Channel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,LoadPixelData,The following statement contains a magic number: using (BinaryReverseReader readerImg = DataReader)         {           m_imageCompression = (ImageCompression)readerImg.ReadInt16();            m_bytesPerRow = 0;            switch (m_layer.PsdFile.Depth)           {             case 1:               m_bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               m_bytesPerRow = m_layer.m_rect.Width;               break;             case 16:               m_bytesPerRow = m_layer.m_rect.Width * 2;               break;           }            m_imageData = new byte[m_layer.m_rect.Height * m_bytesPerRow];            switch (m_imageCompression)           {             case ImageCompression.Raw:               readerImg.Read(m_imageData' 0' m_imageData.Length);               break;             case ImageCompression.Rle:               {                 m_rowLengthList = new uint[m_layer.m_rect.Height];                 uint totalRleLength = 0;                 for (int i = 0; i < m_rowLengthList.Length; i++)                 {                   m_rowLengthList[i] = readerImg.ReadUInt16();                   totalRleLength += m_rowLengthList[i];                 }                 m_data = new byte[totalRleLength];                  uint idxData = 0;                 for (int i = 0; i < m_layer.m_rect.Height; i++)                 {                   readerImg.Read(m_data' (int)idxData' (int)m_rowLengthList[i]);                   idxData += m_rowLengthList[i];                    // The PSD specification states that rows are padded to even sizes.                   // However' PSD files generated by Photoshop CS4 do not actually                   // follow this stipulation.                 }               }               break;             default:               break;           }         }
Magic Number,PhotoshopFile,Channel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,LoadPixelData,The following statement contains a magic number: using (BinaryReverseReader readerImg = DataReader)         {           m_imageCompression = (ImageCompression)readerImg.ReadInt16();            m_bytesPerRow = 0;            switch (m_layer.PsdFile.Depth)           {             case 1:               m_bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               m_bytesPerRow = m_layer.m_rect.Width;               break;             case 16:               m_bytesPerRow = m_layer.m_rect.Width * 2;               break;           }            m_imageData = new byte[m_layer.m_rect.Height * m_bytesPerRow];            switch (m_imageCompression)           {             case ImageCompression.Raw:               readerImg.Read(m_imageData' 0' m_imageData.Length);               break;             case ImageCompression.Rle:               {                 m_rowLengthList = new uint[m_layer.m_rect.Height];                 uint totalRleLength = 0;                 for (int i = 0; i < m_rowLengthList.Length; i++)                 {                   m_rowLengthList[i] = readerImg.ReadUInt16();                   totalRleLength += m_rowLengthList[i];                 }                 m_data = new byte[totalRleLength];                  uint idxData = 0;                 for (int i = 0; i < m_layer.m_rect.Height; i++)                 {                   readerImg.Read(m_data' (int)idxData' (int)m_rowLengthList[i]);                   idxData += m_rowLengthList[i];                    // The PSD specification states that rows are padded to even sizes.                   // However' PSD files generated by Photoshop CS4 do not actually                   // follow this stipulation.                 }               }               break;             default:               break;           }         }
Magic Number,PhotoshopFile,Channel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,CompressImageData,The following statement contains a magic number: if (m_imageCompression == ImageCompression.Rle)         {           MemoryStream dataStream = new MemoryStream();           BinaryReverseWriter writer = new BinaryReverseWriter(dataStream);            // we will write the correct lengths later' so remember            // the position           long lengthPosition = writer.BaseStream.Position;            int[] rleRowLengths = new int[m_layer.m_rect.Height];           for (int i = 0; i < rleRowLengths.Length; i++)           {             writer.Write((short)0x1234);           }            //---------------------------------------------------------------            int bytesPerRow = 0;            switch (m_layer.PsdFile.Depth)           {             case 1:               bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               bytesPerRow = m_layer.m_rect.Width;               break;             case 16:               bytesPerRow = m_layer.m_rect.Width * 2;               break;           }            //---------------------------------------------------------------            for (int row = 0; row < m_layer.m_rect.Height; row++)           {             int rowIndex = row * m_layer.m_rect.Width;             rleRowLengths[row] = RleHelper.EncodedRow(writer.BaseStream' m_imageData' rowIndex' bytesPerRow);           }            //---------------------------------------------------------------            long endPosition = writer.BaseStream.Position;            writer.BaseStream.Position = lengthPosition;            for (int i = 0; i < rleRowLengths.Length; i++)           {             writer.Write((short)rleRowLengths[i]);           }            writer.BaseStream.Position = endPosition;            dataStream.Close();            m_data = dataStream.ToArray();            dataStream.Dispose();          }         else         {           m_data = (byte[])m_imageData.Clone();         }
Magic Number,PhotoshopFile,Channel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,CompressImageData,The following statement contains a magic number: if (m_imageCompression == ImageCompression.Rle)         {           MemoryStream dataStream = new MemoryStream();           BinaryReverseWriter writer = new BinaryReverseWriter(dataStream);            // we will write the correct lengths later' so remember            // the position           long lengthPosition = writer.BaseStream.Position;            int[] rleRowLengths = new int[m_layer.m_rect.Height];           for (int i = 0; i < rleRowLengths.Length; i++)           {             writer.Write((short)0x1234);           }            //---------------------------------------------------------------            int bytesPerRow = 0;            switch (m_layer.PsdFile.Depth)           {             case 1:               bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               bytesPerRow = m_layer.m_rect.Width;               break;             case 16:               bytesPerRow = m_layer.m_rect.Width * 2;               break;           }            //---------------------------------------------------------------            for (int row = 0; row < m_layer.m_rect.Height; row++)           {             int rowIndex = row * m_layer.m_rect.Width;             rleRowLengths[row] = RleHelper.EncodedRow(writer.BaseStream' m_imageData' rowIndex' bytesPerRow);           }            //---------------------------------------------------------------            long endPosition = writer.BaseStream.Position;            writer.BaseStream.Position = lengthPosition;            for (int i = 0; i < rleRowLengths.Length; i++)           {             writer.Write((short)rleRowLengths[i]);           }            writer.BaseStream.Position = endPosition;            dataStream.Close();            m_data = dataStream.ToArray();            dataStream.Dispose();          }         else         {           m_data = (byte[])m_imageData.Clone();         }
Magic Number,PhotoshopFile,Channel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,CompressImageData,The following statement contains a magic number: if (m_imageCompression == ImageCompression.Rle)         {           MemoryStream dataStream = new MemoryStream();           BinaryReverseWriter writer = new BinaryReverseWriter(dataStream);            // we will write the correct lengths later' so remember            // the position           long lengthPosition = writer.BaseStream.Position;            int[] rleRowLengths = new int[m_layer.m_rect.Height];           for (int i = 0; i < rleRowLengths.Length; i++)           {             writer.Write((short)0x1234);           }            //---------------------------------------------------------------            int bytesPerRow = 0;            switch (m_layer.PsdFile.Depth)           {             case 1:               bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               bytesPerRow = m_layer.m_rect.Width;               break;             case 16:               bytesPerRow = m_layer.m_rect.Width * 2;               break;           }            //---------------------------------------------------------------            for (int row = 0; row < m_layer.m_rect.Height; row++)           {             int rowIndex = row * m_layer.m_rect.Width;             rleRowLengths[row] = RleHelper.EncodedRow(writer.BaseStream' m_imageData' rowIndex' bytesPerRow);           }            //---------------------------------------------------------------            long endPosition = writer.BaseStream.Position;            writer.BaseStream.Position = lengthPosition;            for (int i = 0; i < rleRowLengths.Length; i++)           {             writer.Write((short)rleRowLengths[i]);           }            writer.BaseStream.Position = endPosition;            dataStream.Close();            m_data = dataStream.ToArray();            dataStream.Dispose();          }         else         {           m_data = (byte[])m_imageData.Clone();         }
Magic Number,PhotoshopFile,Mask,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,Mask,The following statement contains a magic number: if (maskLength == 36)         {           BitVector32 realFlags = new BitVector32(reader.ReadByte());            byte realUserMaskBackground = reader.ReadByte();            Rectangle rect = new Rectangle();           rect.Y = reader.ReadInt32();           rect.X = reader.ReadInt32();           rect.Height = reader.ReadInt32() - m_rect.Y;           rect.Width = reader.ReadInt32() - m_rect.X;         }
Magic Number,PhotoshopFile,Mask,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,LoadPixelData,The following statement contains a magic number: if (m_rect.IsEmpty || m_layer.SortedChannels.ContainsKey(-2) == false)           return;
Magic Number,PhotoshopFile,Mask,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,LoadPixelData,The following statement contains a magic number: Channel maskChannel = m_layer.SortedChannels[-2];
Magic Number,PhotoshopFile,Mask,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,LoadPixelData,The following statement contains a magic number: using (BinaryReverseReader readerImg = maskChannel.DataReader)         {           maskChannel.ImageCompression = (ImageCompression)readerImg.ReadInt16();            int bytesPerRow = 0;            switch (m_layer.PsdFile.Depth)           {             case 1:               bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               bytesPerRow = m_rect.Width;               break;             case 16:               bytesPerRow = m_rect.Width * 2;               break;           }            maskChannel.ImageData = new byte[m_rect.Height * bytesPerRow];           // Fill Array           for (int i = 0; i < maskChannel.ImageData.Length; i++)           {             maskChannel.ImageData[i] = 0xAB;           }            m_imageData = (byte[])maskChannel.ImageData.Clone();            switch (maskChannel.ImageCompression)           {             case ImageCompression.Raw:               readerImg.Read(maskChannel.ImageData' 0' maskChannel.ImageData.Length);               break;             case ImageCompression.Rle:               {                 uint[] rowLengthList = new uint[m_rect.Height];                  for (int i = 0; i < rowLengthList.Length; i++)                   rowLengthList[i] = readerImg.ReadUInt16();                  for (int i = 0; i < m_rect.Height; i++)                 {                   int rowIndex = i * m_rect.Width;                   RleHelper.DecodedRow(readerImg.BaseStream' maskChannel.ImageData' rowIndex' bytesPerRow);                 }               }               break;             default:               break;           }            m_imageData = (byte[])maskChannel.ImageData.Clone();          }
Magic Number,PhotoshopFile,Mask,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,LoadPixelData,The following statement contains a magic number: using (BinaryReverseReader readerImg = maskChannel.DataReader)         {           maskChannel.ImageCompression = (ImageCompression)readerImg.ReadInt16();            int bytesPerRow = 0;            switch (m_layer.PsdFile.Depth)           {             case 1:               bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               bytesPerRow = m_rect.Width;               break;             case 16:               bytesPerRow = m_rect.Width * 2;               break;           }            maskChannel.ImageData = new byte[m_rect.Height * bytesPerRow];           // Fill Array           for (int i = 0; i < maskChannel.ImageData.Length; i++)           {             maskChannel.ImageData[i] = 0xAB;           }            m_imageData = (byte[])maskChannel.ImageData.Clone();            switch (maskChannel.ImageCompression)           {             case ImageCompression.Raw:               readerImg.Read(maskChannel.ImageData' 0' maskChannel.ImageData.Length);               break;             case ImageCompression.Rle:               {                 uint[] rowLengthList = new uint[m_rect.Height];                  for (int i = 0; i < rowLengthList.Length; i++)                   rowLengthList[i] = readerImg.ReadUInt16();                  for (int i = 0; i < m_rect.Height; i++)                 {                   int rowIndex = i * m_rect.Width;                   RleHelper.DecodedRow(readerImg.BaseStream' maskChannel.ImageData' rowIndex' bytesPerRow);                 }               }               break;             default:               break;           }            m_imageData = (byte[])maskChannel.ImageData.Clone();          }
Magic Number,PhotoshopFile,Mask,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,LoadPixelData,The following statement contains a magic number: using (BinaryReverseReader readerImg = maskChannel.DataReader)         {           maskChannel.ImageCompression = (ImageCompression)readerImg.ReadInt16();            int bytesPerRow = 0;            switch (m_layer.PsdFile.Depth)           {             case 1:               bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               bytesPerRow = m_rect.Width;               break;             case 16:               bytesPerRow = m_rect.Width * 2;               break;           }            maskChannel.ImageData = new byte[m_rect.Height * bytesPerRow];           // Fill Array           for (int i = 0; i < maskChannel.ImageData.Length; i++)           {             maskChannel.ImageData[i] = 0xAB;           }            m_imageData = (byte[])maskChannel.ImageData.Clone();            switch (maskChannel.ImageCompression)           {             case ImageCompression.Raw:               readerImg.Read(maskChannel.ImageData' 0' maskChannel.ImageData.Length);               break;             case ImageCompression.Rle:               {                 uint[] rowLengthList = new uint[m_rect.Height];                  for (int i = 0; i < rowLengthList.Length; i++)                   rowLengthList[i] = readerImg.ReadUInt16();                  for (int i = 0; i < m_rect.Height; i++)                 {                   int rowIndex = i * m_rect.Width;                   RleHelper.DecodedRow(readerImg.BaseStream' maskChannel.ImageData' rowIndex' bytesPerRow);                 }               }               break;             default:               break;           }            m_imageData = (byte[])maskChannel.ImageData.Clone();          }
Magic Number,PhotoshopFile,AdjustmentLayerInfo,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,AdjustmentLayerInfo,The following statement contains a magic number: string signature = new string(reader.ReadChars(4));
Magic Number,PhotoshopFile,AdjustmentLayerInfo,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,AdjustmentLayerInfo,The following statement contains a magic number: m_key = new string(reader.ReadChars(4));
Magic Number,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadHeader,The following statement contains a magic number: string signature = new string(reader.ReadChars(4));
Magic Number,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadHeader,The following statement contains a magic number: reader.BaseStream.Position += 6;
Magic Number,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadLayers,The following statement contains a magic number: foreach (Layer layer in m_layers)       {         foreach (Layer.Channel channel in layer.Channels)         {           if (channel.ID != -2)           {             channel.LoadPixelData(reader);             DecompressChannelContext dcc = new DecompressChannelContext(channel);             WaitCallback waitCallback = new WaitCallback(dcc.DecompressChannel);             threadPool.QueueUserWorkItem(waitCallback);           }         }          layer.MaskData.LoadPixelData(reader);       }
Magic Number,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadLayers,The following statement contains a magic number: if (reader.BaseStream.Position % 2 == 1)         reader.ReadByte();
Magic Number,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,SaveLayers,The following statement contains a magic number: using (new LengthWriter(writer))       {         short numberOfLayers = (short)m_layers.Count;         if (AbsoluteAlpha)           numberOfLayers = (short)-numberOfLayers;          writer.Write(numberOfLayers);          // Finish compute-bound operations before embarking on the sequential save         PrivateThreadPool threadPool = new PrivateThreadPool();         foreach (Layer layer in m_layers)         {           layer.PrepareSave(threadPool);         }         threadPool.Drain();          foreach (Layer layer in m_layers)         {           layer.Save(writer);         }          foreach (Layer layer in m_layers)         {           foreach (Layer.Channel channel in layer.Channels)           {             channel.SavePixelData(writer);           }         }          if (writer.BaseStream.Position % 2 == 1)           writer.Write((byte)0);       }
Magic Number,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following statement contains a magic number: if (m_imageCompression == ImageCompression.Rle)       {         // The RLE-compressed data is proceeded by a 2-byte data count for each row in the data'         // which we're going to just skip.         reader.BaseStream.Position += m_rows * m_channels * 2;       }
Magic Number,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following statement contains a magic number: switch (m_depth)       {         case 1:           bytesPerRow = ImageDecoder.BytesFromBits(m_columns);           break;         case 8:           bytesPerRow = m_columns;           break;         case 16:           bytesPerRow = m_columns * 2;           break;       }
Magic Number,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following statement contains a magic number: switch (m_depth)       {         case 1:           bytesPerRow = ImageDecoder.BytesFromBits(m_columns);           break;         case 8:           bytesPerRow = m_columns;           break;         case 16:           bytesPerRow = m_columns * 2;           break;       }
Magic Number,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following statement contains a magic number: switch (m_depth)       {         case 1:           bytesPerRow = ImageDecoder.BytesFromBits(m_columns);           break;         case 8:           bytesPerRow = m_columns;           break;         case 16:           bytesPerRow = m_columns * 2;           break;       }
Magic Number,PhotoshopFile,RleHelper,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: while (count < columns)       {         byte byteValue = (byte)stream.ReadByte();          int len = (int)byteValue;         if (len < 128)         {           len++;           while (len != 0 && (startIdx + count) < imgData.Length)           {             byteValue = (byte)stream.ReadByte();              imgData[startIdx + count] = byteValue;             count++;             len--;           }         }         else if (len > 128)         {           // Next -len+1 bytes in the dest are replicated from next source byte.           // (Interpret len as a negative 8-bit int.)           len ^= 0x0FF;           len += 2;           byteValue = (byte)stream.ReadByte();            while (len != 0 && (startIdx + count) < imgData.Length)           {             imgData[startIdx + count] = byteValue;             count++;             len--;           }         }         else if (128 == len)         {           // Do nothing         }       }
Magic Number,PhotoshopFile,RleHelper,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: while (count < columns)       {         byte byteValue = (byte)stream.ReadByte();          int len = (int)byteValue;         if (len < 128)         {           len++;           while (len != 0 && (startIdx + count) < imgData.Length)           {             byteValue = (byte)stream.ReadByte();              imgData[startIdx + count] = byteValue;             count++;             len--;           }         }         else if (len > 128)         {           // Next -len+1 bytes in the dest are replicated from next source byte.           // (Interpret len as a negative 8-bit int.)           len ^= 0x0FF;           len += 2;           byteValue = (byte)stream.ReadByte();            while (len != 0 && (startIdx + count) < imgData.Length)           {             imgData[startIdx + count] = byteValue;             count++;             len--;           }         }         else if (128 == len)         {           // Do nothing         }       }
Magic Number,PhotoshopFile,RleHelper,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: while (count < columns)       {         byte byteValue = (byte)stream.ReadByte();          int len = (int)byteValue;         if (len < 128)         {           len++;           while (len != 0 && (startIdx + count) < imgData.Length)           {             byteValue = (byte)stream.ReadByte();              imgData[startIdx + count] = byteValue;             count++;             len--;           }         }         else if (len > 128)         {           // Next -len+1 bytes in the dest are replicated from next source byte.           // (Interpret len as a negative 8-bit int.)           len ^= 0x0FF;           len += 2;           byteValue = (byte)stream.ReadByte();            while (len != 0 && (startIdx + count) < imgData.Length)           {             imgData[startIdx + count] = byteValue;             count++;             len--;           }         }         else if (128 == len)         {           // Do nothing         }       }
Magic Number,PhotoshopFile,RleHelper,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,DecodedRow,The following statement contains a magic number: while (count < columns)       {         byte byteValue = (byte)stream.ReadByte();          int len = (int)byteValue;         if (len < 128)         {           len++;           while (len != 0 && (startIdx + count) < imgData.Length)           {             byteValue = (byte)stream.ReadByte();              imgData[startIdx + count] = byteValue;             count++;             len--;           }         }         else if (len > 128)         {           // Next -len+1 bytes in the dest are replicated from next source byte.           // (Interpret len as a negative 8-bit int.)           len ^= 0x0FF;           len += 2;           byteValue = (byte)stream.ReadByte();            while (len != 0 && (startIdx + count) < imgData.Length)           {             imgData[startIdx + count] = byteValue;             count++;             len--;           }         }         else if (128 == len)         {           // Do nothing         }       }
Magic Number,PhotoshopFile,RlePacketStateMachine,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,PushRow,The following statement contains a magic number: for (int i = startIdx; i < endIdx; i++)         {           byte color = imgData[i];           if (packetLength == 0)           {             // Starting a fresh packet.             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength == 1)           {             // 2nd byte of this packet... decide RLE or non-RLE.             m_rlePacket = (color == lastValue);             lastValue = color;             packetLength = 2;           }           else if (packetLength == maxPacketLength)           {             // Packet is full. Start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color != lastValue)           {             // We were filling in an RLE packet' and we got a non-repeated color.             // Emit the current packet and start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color == lastValue)           {             // We are filling in an RLE packet' and we got another repeated color.             // Add the new color to the current packet.             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color != lastValue)           {             // We are filling in a raw packet' and we got another random color.             // Add the new color to the current packet.             lastValue = color;             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color == lastValue)           {             // We were filling in a raw packet' but we got a repeated color.             // Emit the current packet without its last color' and start a             // new RLE packet that starts with a length of 2.             --packetLength;             Flush();             m_rlePacket = true;             packetLength = 2;             lastValue = color;           }         }
Magic Number,PhotoshopFile,RlePacketStateMachine,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,PushRow,The following statement contains a magic number: for (int i = startIdx; i < endIdx; i++)         {           byte color = imgData[i];           if (packetLength == 0)           {             // Starting a fresh packet.             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength == 1)           {             // 2nd byte of this packet... decide RLE or non-RLE.             m_rlePacket = (color == lastValue);             lastValue = color;             packetLength = 2;           }           else if (packetLength == maxPacketLength)           {             // Packet is full. Start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color != lastValue)           {             // We were filling in an RLE packet' and we got a non-repeated color.             // Emit the current packet and start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color == lastValue)           {             // We are filling in an RLE packet' and we got another repeated color.             // Add the new color to the current packet.             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color != lastValue)           {             // We are filling in a raw packet' and we got another random color.             // Add the new color to the current packet.             lastValue = color;             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color == lastValue)           {             // We were filling in a raw packet' but we got a repeated color.             // Emit the current packet without its last color' and start a             // new RLE packet that starts with a length of 2.             --packetLength;             Flush();             m_rlePacket = true;             packetLength = 2;             lastValue = color;           }         }
Magic Number,PhotoshopFile,RlePacketStateMachine,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,PushRow,The following statement contains a magic number: for (int i = startIdx; i < endIdx; i++)         {           byte color = imgData[i];           if (packetLength == 0)           {             // Starting a fresh packet.             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength == 1)           {             // 2nd byte of this packet... decide RLE or non-RLE.             m_rlePacket = (color == lastValue);             lastValue = color;             packetLength = 2;           }           else if (packetLength == maxPacketLength)           {             // Packet is full. Start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color != lastValue)           {             // We were filling in an RLE packet' and we got a non-repeated color.             // Emit the current packet and start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color == lastValue)           {             // We are filling in an RLE packet' and we got another repeated color.             // Add the new color to the current packet.             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color != lastValue)           {             // We are filling in a raw packet' and we got another random color.             // Add the new color to the current packet.             lastValue = color;             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color == lastValue)           {             // We were filling in a raw packet' but we got a repeated color.             // Emit the current packet without its last color' and start a             // new RLE packet that starts with a length of 2.             --packetLength;             Flush();             m_rlePacket = true;             packetLength = 2;             lastValue = color;           }         }
Magic Number,PhotoshopFile,RlePacketStateMachine,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,PushRow,The following statement contains a magic number: for (int i = startIdx; i < endIdx; i++)         {           byte color = imgData[i];           if (packetLength == 0)           {             // Starting a fresh packet.             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength == 1)           {             // 2nd byte of this packet... decide RLE or non-RLE.             m_rlePacket = (color == lastValue);             lastValue = color;             packetLength = 2;           }           else if (packetLength == maxPacketLength)           {             // Packet is full. Start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color != lastValue)           {             // We were filling in an RLE packet' and we got a non-repeated color.             // Emit the current packet and start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color == lastValue)           {             // We are filling in an RLE packet' and we got another repeated color.             // Add the new color to the current packet.             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color != lastValue)           {             // We are filling in a raw packet' and we got another random color.             // Add the new color to the current packet.             lastValue = color;             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color == lastValue)           {             // We were filling in a raw packet' but we got a repeated color.             // Emit the current packet without its last color' and start a             // new RLE packet that starts with a length of 2.             --packetLength;             Flush();             m_rlePacket = true;             packetLength = 2;             lastValue = color;           }         }
Magic Number,PhotoshopFile,RlePacketStateMachine,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,PushRow,The following statement contains a magic number: for (int i = startIdx; i < endIdx; i++)         {           byte color = imgData[i];           if (packetLength == 0)           {             // Starting a fresh packet.             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength == 1)           {             // 2nd byte of this packet... decide RLE or non-RLE.             m_rlePacket = (color == lastValue);             lastValue = color;             packetLength = 2;           }           else if (packetLength == maxPacketLength)           {             // Packet is full. Start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color != lastValue)           {             // We were filling in an RLE packet' and we got a non-repeated color.             // Emit the current packet and start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color == lastValue)           {             // We are filling in an RLE packet' and we got another repeated color.             // Add the new color to the current packet.             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color != lastValue)           {             // We are filling in a raw packet' and we got another random color.             // Add the new color to the current packet.             lastValue = color;             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color == lastValue)           {             // We were filling in a raw packet' but we got a repeated color.             // Emit the current packet without its last color' and start a             // new RLE packet that starts with a length of 2.             --packetLength;             Flush();             m_rlePacket = true;             packetLength = 2;             lastValue = color;           }         }
Magic Number,PhotoshopFile,RlePacketStateMachine,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,PushRow,The following statement contains a magic number: for (int i = startIdx; i < endIdx; i++)         {           byte color = imgData[i];           if (packetLength == 0)           {             // Starting a fresh packet.             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength == 1)           {             // 2nd byte of this packet... decide RLE or non-RLE.             m_rlePacket = (color == lastValue);             lastValue = color;             packetLength = 2;           }           else if (packetLength == maxPacketLength)           {             // Packet is full. Start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color != lastValue)           {             // We were filling in an RLE packet' and we got a non-repeated color.             // Emit the current packet and start a new one.             Flush();             m_rlePacket = false;             lastValue = color;             idxPacketData = i;             packetLength = 1;           }           else if (packetLength >= 2 && m_rlePacket && color == lastValue)           {             // We are filling in an RLE packet' and we got another repeated color.             // Add the new color to the current packet.             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color != lastValue)           {             // We are filling in a raw packet' and we got another random color.             // Add the new color to the current packet.             lastValue = color;             ++packetLength;           }           else if (packetLength >= 2 && !m_rlePacket && color == lastValue)           {             // We were filling in a raw packet' but we got a repeated color.             // Emit the current packet without its last color' and start a             // new RLE packet that starts with a length of 2.             --packetLength;             Flush();             m_rlePacket = true;             packetLength = 2;             lastValue = color;           }         }
Magic Number,PhotoshopFile,DynVal,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,ReadSpecialString,The following statement contains a magic number: if (length == 0)                 length = 4;
Magic Number,PhotoshopFile,DynVal,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,ReadValue,The following statement contains a magic number: vt.Type = parseTypeString(new string(r.ReadPSDChars(4)));
Magic Number,PhotoshopFile,DynVal,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,ReadValue,The following statement contains a magic number: switch (vt.Type)             {                 case  OSType.tdta:                                          uint unknown = r.ReadUInt32();                     TdTaParser p = new TdTaParser(r);                     object o = p.ParseOneTree();                     vt.Value = o;                      break;                 case  OSType.Descriptor:                     vt = DynVal.ReadDescriptor(r);                     break;                 case OSType.List:                      vt.Children = ReadValues(r'true);                     break;                 case OSType.Double:                     vt.Value = r.ReadDouble();                     break;                 case OSType.UnitFloat: //Unif float                     //TODO: need a specific type for this' with a double and a type (percent/pixel)?                     string tst = GetMeaningOfFourCC(new string(r.ReadPSDChars(4))); //#Prc #Pxl #Ang = percent / pixels / angle?                     double d = r.ReadDouble();                     tst += ": " + d;                     vt.Value = tst;                     break;                 case OSType.Enumerated:                     string namesp = ReadSpecialString(r);                     string item = ReadSpecialString(r);                     //vt.Value = namesp + "." + item; //TODO: cast to real enum                     vt.Value = GetMeaningOfFourCC(namesp) + "." + GetMeaningOfFourCC(item);                     break;                 case OSType.Integer:                     vt.Value = r.ReadInt32(); //4 byte integer                     break;                 case OSType.Boolean:                     vt.Value = r.ReadBoolean();                     break;                 case  OSType.String:                     vt.Value = r.ReadPSDUnicodeString();                     break;                  default:                     throw new Exception("Unhandled type: " + vt.Type);             }
Magic Number,PhotoshopFile,DynVal,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,GetMeaningOfFourCC,The following statement contains a magic number: if (fourCC.Length != 4)                 return fourCC;
Magic Number,PhotoshopFile,DynVal,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,LoadFourCC,The following statement contains a magic number: foreach (string line in lines)             {                 string[] items = line.Split('\t');                 if (items.Length <= 1)                     continue;                 if (items[1].Length == 0)                     continue;                 string name = items[0].Substring(2);                 foreach (string prefix in prefixes)                 {                     if (name.StartsWith(prefix))                     {                         name = name.Substring(prefix.Length);                         break;                     }                 }                 FourCCs.Add(items[1].PadRight(4' ' ')' name);             }
Magic Number,PhotoshopFile,DynVal,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,LoadFourCC,The following statement contains a magic number: foreach (string line in lines)             {                 string[] items = line.Split('\t');                 if (items.Length <= 1)                     continue;                 if (items[1].Length == 0)                     continue;                 string name = items[0].Substring(2);                 foreach (string prefix in prefixes)                 {                     if (name.StartsWith(prefix))                     {                         name = name.Substring(prefix.Length);                         break;                     }                 }                 FourCCs.Add(items[1].PadRight(4' ' ')' name);             }
Magic Number,PhotoshopFile,ReadableBinary,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: for (int i = start; i < (start + length); i++)             {                 byte num3 = data[i];                 if (((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26))                 {                     sbChars.Append((char)num3);                 }                 else                 {                     sbChars.Append(".");                 }                 sbAll.Append(num3.ToString("X"'NumberFormatInfo.InvariantInfo).PadLeft(2' '0') + " ");                 pos++;                 if ((pos % 8) == 0)                 {                     sbAll.Append("  ");                     sbChars.Append("  ");                 }                 if (((pos % 0x10) == 0) || (pos == 0))                 {                     NewLine(sbAll' sbChars' pos);                     sbChars = new StringBuilder();                 }             }
Magic Number,PhotoshopFile,ReadableBinary,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: for (int i = start; i < (start + length); i++)             {                 byte num3 = data[i];                 if (((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26))                 {                     sbChars.Append((char)num3);                 }                 else                 {                     sbChars.Append(".");                 }                 sbAll.Append(num3.ToString("X"'NumberFormatInfo.InvariantInfo).PadLeft(2' '0') + " ");                 pos++;                 if ((pos % 8) == 0)                 {                     sbAll.Append("  ");                     sbChars.Append("  ");                 }                 if (((pos % 0x10) == 0) || (pos == 0))                 {                     NewLine(sbAll' sbChars' pos);                     sbChars = new StringBuilder();                 }             }
Magic Number,PhotoshopFile,ReadableBinary,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: for (int i = start; i < (start + length); i++)             {                 byte num3 = data[i];                 if (((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26))                 {                     sbChars.Append((char)num3);                 }                 else                 {                     sbChars.Append(".");                 }                 sbAll.Append(num3.ToString("X"'NumberFormatInfo.InvariantInfo).PadLeft(2' '0') + " ");                 pos++;                 if ((pos % 8) == 0)                 {                     sbAll.Append("  ");                     sbChars.Append("  ");                 }                 if (((pos % 0x10) == 0) || (pos == 0))                 {                     NewLine(sbAll' sbChars' pos);                     sbChars = new StringBuilder();                 }             }
Magic Number,PhotoshopFile,ReadableBinary,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,CreateHexEditorString,The following statement contains a magic number: for (int i = start; i < (start + length); i++)             {                 byte num3 = data[i];                 if (((((num3 >= 0x20) && (num3 <= 0x7e)) || (num3 >= 160)) && ((num3 != 60) && (num3 != 0x3e))) && (num3 != 0x26))                 {                     sbChars.Append((char)num3);                 }                 else                 {                     sbChars.Append(".");                 }                 sbAll.Append(num3.ToString("X"'NumberFormatInfo.InvariantInfo).PadLeft(2' '0') + " ");                 pos++;                 if ((pos % 8) == 0)                 {                     sbAll.Append("  ");                     sbChars.Append("  ");                 }                 if (((pos % 0x10) == 0) || (pos == 0))                 {                     NewLine(sbAll' sbChars' pos);                     sbChars = new StringBuilder();                 }             }
Magic Number,PhotoshopFile,ReadableBinary,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\ReadableBinary.cs,NewLine,The following statement contains a magic number: sbAll.Append("\r\n" + pos.ToString("X"' NumberFormatInfo.InvariantInfo).PadLeft(4' '0') + ":");
Magic Number,PhotoshopFile.Text,EffectBase,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\EffectBase.cs,ReadBlendKey,The following statement contains a magic number: string blendModeSignature = new string(r.ReadPSDChars(4));
Magic Number,PhotoshopFile.Text,EffectBase,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\EffectBase.cs,ReadBlendKey,The following statement contains a magic number: return new string(r.ReadPSDChars(4));
Magic Number,PhotoshopFile.Text,Effects,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Effects,The following statement contains a magic number: r.BaseStream.Position += 2;
Magic Number,PhotoshopFile.Text,Glow,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Data = null;                     break;                 case 2:                     this.Blur = (uint)r.ReadUInt16();                     this.Intensity = r.ReadUInt32();                     ushort something = r.ReadUInt16();                     this.Color = r.ReadPSDColor(16' false); //Inner color (no alpha)                      this.BlendModeKey = this.ReadBlendKey(r);                     this.Enabled = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     //TODO!                     if (this.Inner)                         this.Unknown = r.ReadByte();                     this.UnknownColor = r.ReadPSDColor(16' false); //unknown color(no alpha)                     this.Data = r.ReadBytes((int)r.BytesToEnd);                     break;             }
Magic Number,PhotoshopFile.Text,Glow,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Data = null;                     break;                 case 2:                     this.Blur = (uint)r.ReadUInt16();                     this.Intensity = r.ReadUInt32();                     ushort something = r.ReadUInt16();                     this.Color = r.ReadPSDColor(16' false); //Inner color (no alpha)                      this.BlendModeKey = this.ReadBlendKey(r);                     this.Enabled = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     //TODO!                     if (this.Inner)                         this.Unknown = r.ReadByte();                     this.UnknownColor = r.ReadPSDColor(16' false); //unknown color(no alpha)                     this.Data = r.ReadBytes((int)r.BytesToEnd);                     break;             }
Magic Number,PhotoshopFile.Text,Glow,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Data = null;                     break;                 case 2:                     this.Blur = (uint)r.ReadUInt16();                     this.Intensity = r.ReadUInt32();                     ushort something = r.ReadUInt16();                     this.Color = r.ReadPSDColor(16' false); //Inner color (no alpha)                      this.BlendModeKey = this.ReadBlendKey(r);                     this.Enabled = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     //TODO!                     if (this.Inner)                         this.Unknown = r.ReadByte();                     this.UnknownColor = r.ReadPSDColor(16' false); //unknown color(no alpha)                     this.Data = r.ReadBytes((int)r.BytesToEnd);                     break;             }
Magic Number,PhotoshopFile.Text,Bevel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Data = null;                     break;                 case 2:                     this.Angle = (uint)r.ReadUInt16();                     this.Strength = (uint)r.ReadUInt16();                     this.Blur = (uint)r.ReadUInt16();                      this.Unknown1 = r.ReadByte();                     this.Unknown2 = r.ReadByte();                     this.Unknown3 = r.ReadUInt16();                     this.Unknown4 = r.ReadUInt16();                      this.BlendModeKey = this.ReadBlendKey(r);                     this.ShadowBlendModeKey = this.ReadBlendKey(r);                      this.Color = r.ReadPSDColor(16' true);                     this.ShadowColor = r.ReadPSDColor(16' true);                      this.BevelStyle = r.ReadByte();                     this.Opacity = r.ReadByte();                     this.ShadowOpacity = r.ReadByte();                      this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Inverted = r.ReadBoolean();                      System.Drawing.Color someColor = r.ReadPSDColor(16' true);                     System.Drawing.Color someColor2 = r.ReadPSDColor(16' true);                     break;             }
Magic Number,PhotoshopFile.Text,Bevel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Data = null;                     break;                 case 2:                     this.Angle = (uint)r.ReadUInt16();                     this.Strength = (uint)r.ReadUInt16();                     this.Blur = (uint)r.ReadUInt16();                      this.Unknown1 = r.ReadByte();                     this.Unknown2 = r.ReadByte();                     this.Unknown3 = r.ReadUInt16();                     this.Unknown4 = r.ReadUInt16();                      this.BlendModeKey = this.ReadBlendKey(r);                     this.ShadowBlendModeKey = this.ReadBlendKey(r);                      this.Color = r.ReadPSDColor(16' true);                     this.ShadowColor = r.ReadPSDColor(16' true);                      this.BevelStyle = r.ReadByte();                     this.Opacity = r.ReadByte();                     this.ShadowOpacity = r.ReadByte();                      this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Inverted = r.ReadBoolean();                      System.Drawing.Color someColor = r.ReadPSDColor(16' true);                     System.Drawing.Color someColor2 = r.ReadPSDColor(16' true);                     break;             }
Magic Number,PhotoshopFile.Text,Bevel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Data = null;                     break;                 case 2:                     this.Angle = (uint)r.ReadUInt16();                     this.Strength = (uint)r.ReadUInt16();                     this.Blur = (uint)r.ReadUInt16();                      this.Unknown1 = r.ReadByte();                     this.Unknown2 = r.ReadByte();                     this.Unknown3 = r.ReadUInt16();                     this.Unknown4 = r.ReadUInt16();                      this.BlendModeKey = this.ReadBlendKey(r);                     this.ShadowBlendModeKey = this.ReadBlendKey(r);                      this.Color = r.ReadPSDColor(16' true);                     this.ShadowColor = r.ReadPSDColor(16' true);                      this.BevelStyle = r.ReadByte();                     this.Opacity = r.ReadByte();                     this.ShadowOpacity = r.ReadByte();                      this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Inverted = r.ReadBoolean();                      System.Drawing.Color someColor = r.ReadPSDColor(16' true);                     System.Drawing.Color someColor2 = r.ReadPSDColor(16' true);                     break;             }
Magic Number,PhotoshopFile.Text,Bevel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Data = null;                     break;                 case 2:                     this.Angle = (uint)r.ReadUInt16();                     this.Strength = (uint)r.ReadUInt16();                     this.Blur = (uint)r.ReadUInt16();                      this.Unknown1 = r.ReadByte();                     this.Unknown2 = r.ReadByte();                     this.Unknown3 = r.ReadUInt16();                     this.Unknown4 = r.ReadUInt16();                      this.BlendModeKey = this.ReadBlendKey(r);                     this.ShadowBlendModeKey = this.ReadBlendKey(r);                      this.Color = r.ReadPSDColor(16' true);                     this.ShadowColor = r.ReadPSDColor(16' true);                      this.BevelStyle = r.ReadByte();                     this.Opacity = r.ReadByte();                     this.ShadowOpacity = r.ReadByte();                      this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Inverted = r.ReadBoolean();                      System.Drawing.Color someColor = r.ReadPSDColor(16' true);                     System.Drawing.Color someColor2 = r.ReadPSDColor(16' true);                     break;             }
Magic Number,PhotoshopFile.Text,Bevel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Data = null;                     break;                 case 2:                     this.Angle = (uint)r.ReadUInt16();                     this.Strength = (uint)r.ReadUInt16();                     this.Blur = (uint)r.ReadUInt16();                      this.Unknown1 = r.ReadByte();                     this.Unknown2 = r.ReadByte();                     this.Unknown3 = r.ReadUInt16();                     this.Unknown4 = r.ReadUInt16();                      this.BlendModeKey = this.ReadBlendKey(r);                     this.ShadowBlendModeKey = this.ReadBlendKey(r);                      this.Color = r.ReadPSDColor(16' true);                     this.ShadowColor = r.ReadPSDColor(16' true);                      this.BevelStyle = r.ReadByte();                     this.Opacity = r.ReadByte();                     this.ShadowOpacity = r.ReadByte();                      this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Inverted = r.ReadBoolean();                      System.Drawing.Color someColor = r.ReadPSDColor(16' true);                     System.Drawing.Color someColor2 = r.ReadPSDColor(16' true);                     break;             }
Magic Number,PhotoshopFile.Text,Shadow,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Intensity = r.ReadUInt32();                      this.Angle = r.ReadUInt32();                     this.Distance = r.ReadUInt32();                      this.Color = r.ReadPSDColor(16' true);                      this.BlendModeKey = this.ReadBlendKey(r);                     //this.BlendModeSignature = r.ReadUInt32();                     //this.BlendModeKey = r.ReadUInt32();                     this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     break;                  case 2:                     this.Blur = (uint)r.ReadUInt16();                     this.Intensity = r.ReadUInt32();                      this.Angle = r.ReadUInt32();                     this.Distance = r.ReadUInt32();                      ushort something = r.ReadUInt16();//TODO:?                      this.Color = r.ReadPSDColor(16' true);                      this.BlendModeKey = this.ReadBlendKey(r);                     this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     //TODO: 10 unknown bytes!                     break;             }
Magic Number,PhotoshopFile.Text,Shadow,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Intensity = r.ReadUInt32();                      this.Angle = r.ReadUInt32();                     this.Distance = r.ReadUInt32();                      this.Color = r.ReadPSDColor(16' true);                      this.BlendModeKey = this.ReadBlendKey(r);                     //this.BlendModeSignature = r.ReadUInt32();                     //this.BlendModeKey = r.ReadUInt32();                     this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     break;                  case 2:                     this.Blur = (uint)r.ReadUInt16();                     this.Intensity = r.ReadUInt32();                      this.Angle = r.ReadUInt32();                     this.Distance = r.ReadUInt32();                      ushort something = r.ReadUInt16();//TODO:?                      this.Color = r.ReadPSDColor(16' true);                      this.BlendModeKey = this.ReadBlendKey(r);                     this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     //TODO: 10 unknown bytes!                     break;             }
Magic Number,PhotoshopFile.Text,Shadow,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,The following statement contains a magic number: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Intensity = r.ReadUInt32();                      this.Angle = r.ReadUInt32();                     this.Distance = r.ReadUInt32();                      this.Color = r.ReadPSDColor(16' true);                      this.BlendModeKey = this.ReadBlendKey(r);                     //this.BlendModeSignature = r.ReadUInt32();                     //this.BlendModeKey = r.ReadUInt32();                     this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     break;                  case 2:                     this.Blur = (uint)r.ReadUInt16();                     this.Intensity = r.ReadUInt32();                      this.Angle = r.ReadUInt32();                     this.Distance = r.ReadUInt32();                      ushort something = r.ReadUInt16();//TODO:?                      this.Color = r.ReadPSDColor(16' true);                      this.BlendModeKey = this.ReadBlendKey(r);                     this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     //TODO: 10 unknown bytes!                     break;             }
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb((int)((double)values[0] * 255)'(int)((double)values[1] * 255)'(int)((double)values[2] * 255)'(int)( (double)values[3] * 255));
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb((int)((double)values[0] * 255)'(int)((double)values[1] * 255)'(int)((double)values[2] * 255)'(int)( (double)values[3] * 255));
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb((int)((double)values[0] * 255)'(int)((double)values[1] * 255)'(int)((double)values[2] * 255)'(int)( (double)values[3] * 255));
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb((int)((double)values[0] * 255)'(int)((double)values[1] * 255)'(int)((double)values[2] * 255)'(int)( (double)values[3] * 255));
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb((int)((double)values[0] * 255)'(int)((double)values[1] * 255)'(int)((double)values[2] * 255)'(int)( (double)values[3] * 255));
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,getColor,The following statement contains a magic number: return Color.FromArgb((int)((double)values[0] * 255)'(int)((double)values[1] * 255)'(int)((double)values[2] * 255)'(int)( (double)values[3] * 255));
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals("$"))             {                 byte[] b = (byte[])tree;                 //FEFF - big endian                 if (b[0] == 254 && b[1] == 255) return System.Text.UTF8Encoding.BigEndianUnicode.GetString(b'2'b.Length -2);                 //FFEF - little endian                 if (b[0] == 255 && b[1] == 254) return System.Text.UTF8Encoding.Unicode.GetString(b' 2' b.Length - 2);                 throw new Exception("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString(b));             }
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals("$"))             {                 byte[] b = (byte[])tree;                 //FEFF - big endian                 if (b[0] == 254 && b[1] == 255) return System.Text.UTF8Encoding.BigEndianUnicode.GetString(b'2'b.Length -2);                 //FFEF - little endian                 if (b[0] == 255 && b[1] == 254) return System.Text.UTF8Encoding.Unicode.GetString(b' 2' b.Length - 2);                 throw new Exception("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString(b));             }
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals("$"))             {                 byte[] b = (byte[])tree;                 //FEFF - big endian                 if (b[0] == 254 && b[1] == 255) return System.Text.UTF8Encoding.BigEndianUnicode.GetString(b'2'b.Length -2);                 //FFEF - little endian                 if (b[0] == 255 && b[1] == 254) return System.Text.UTF8Encoding.Unicode.GetString(b' 2' b.Length - 2);                 throw new Exception("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString(b));             }
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals("$"))             {                 byte[] b = (byte[])tree;                 //FEFF - big endian                 if (b[0] == 254 && b[1] == 255) return System.Text.UTF8Encoding.BigEndianUnicode.GetString(b'2'b.Length -2);                 //FFEF - little endian                 if (b[0] == 255 && b[1] == 254) return System.Text.UTF8Encoding.Unicode.GetString(b' 2' b.Length - 2);                 throw new Exception("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString(b));             }
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals("$"))             {                 byte[] b = (byte[])tree;                 //FEFF - big endian                 if (b[0] == 254 && b[1] == 255) return System.Text.UTF8Encoding.BigEndianUnicode.GetString(b'2'b.Length -2);                 //FFEF - little endian                 if (b[0] == 255 && b[1] == 254) return System.Text.UTF8Encoding.Unicode.GetString(b' 2' b.Length - 2);                 throw new Exception("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString(b));             }
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals("$"))             {                 byte[] b = (byte[])tree;                 //FEFF - big endian                 if (b[0] == 254 && b[1] == 255) return System.Text.UTF8Encoding.BigEndianUnicode.GetString(b'2'b.Length -2);                 //FFEF - little endian                 if (b[0] == 255 && b[1] == 254) return System.Text.UTF8Encoding.Unicode.GetString(b' 2' b.Length - 2);                 throw new Exception("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString(b));             }
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals("$"))             {                 byte[] b = (byte[])tree;                 //FEFF - big endian                 if (b[0] == 254 && b[1] == 255) return System.Text.UTF8Encoding.BigEndianUnicode.GetString(b'2'b.Length -2);                 //FFEF - little endian                 if (b[0] == 255 && b[1] == 254) return System.Text.UTF8Encoding.Unicode.GetString(b' 2' b.Length - 2);                 throw new Exception("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString(b));             }
Magic Number,PhotoshopFile.Text,TdTaParser,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TdTaParser.cs,query,The following statement contains a magic number: if (selector.Equals("$"))             {                 byte[] b = (byte[])tree;                 //FEFF - big endian                 if (b[0] == 254 && b[1] == 255) return System.Text.UTF8Encoding.BigEndianUnicode.GetString(b'2'b.Length -2);                 //FFEF - little endian                 if (b[0] == 255 && b[1] == 254) return System.Text.UTF8Encoding.Unicode.GetString(b' 2' b.Length - 2);                 throw new Exception("Failed to find Byte Order mark in string! :" + System.Text.UTF8Encoding.BigEndianUnicode.GetString(b));             }
Magic Number,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: if (outerGlow != null){                 glowColor = outerGlow.Color;                 glowFlag = outerGlow.Enabled;                 glowWidth = (int)outerGlow.Blur;                 glowOpacity = (double)outerGlow.Opacity / 255.0;             }
Magic Number,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using(GraphicsPath path = new GraphicsPath()){                 FontFamily fontFamily = null;                 StringFormat strformat = null;                 try{                     FontStyle style = FontStyle.Regular;                     //Remove MT                     if (fontName.EndsWith("MT")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Remove -Bold' -Italic' -BoldItalic                     if (fontName.EndsWith("-Bold"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold;                     if (fontName.EndsWith("-Italic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Italic;                     if (fontName.EndsWith("-BoldItalic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold | FontStyle.Italic;                     //Remove from fontName                     fontName = new Regex("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace(fontName' "");                     //Remove PS                     if (fontName.EndsWith("PS")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Find font family                     try {                         fontFamily = new FontFamily(fontName);                     } catch (ArgumentException ae) {                         if (IgnoreMissingFonts) {                             fontFamily = FontFamily.GenericSansSerif;                         } else throw ae;                      }                     if (fauxBold) style |= FontStyle.Bold;                     if (fauxItalic) style |= FontStyle.Italic;                     if (underline) style |= FontStyle.Underline;                     if (strikethrough) style |= FontStyle.Strikeout;                      strformat = new StringFormat();                     strformat.LineAlignment = hAlign;                     strformat.Alignment = vAlign;                     strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;                     if (!horizontal) strformat.FormatFlags |= StringFormatFlags.DirectionVertical;                     strformat.Trimming = StringTrimming.None;                                          path.AddString(text' fontFamily'                         (int)style' (float)(fontSize)'rect' strformat);                 }finally{                     fontFamily.Dispose();                     strformat.Dispose();                 }                  if (glowFlag)                 {                     if (glowWidth == 3) glowWidth = 2; //To replicate photoshop rounding bug                                        double finalOpacity = (glowOpacity + 1.5)/2.5; //Because Photoshop doesn't actually use the opacity as the final opacity...                      //Add a 30% fade inside the glow width                     int fadeWidth = (int)Math.Floor(glowWidth * 0.33);                      double totalOpacity = 0; //Start at transparent                      //start with outermost ring' work inwards                     for (int i = fadeWidth; i >=0; i--)                     {                         //How much opacity do we lack to complete the desired opacity?                         //totalOpacity = prevOpacity * (1-curOpacity) + curOpacity                         //a=b *(1-c) + c                         //>>> where b!=1' c=(b-a/b-1)                         double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);                          int remainingRings = fadeWidth;                                                 double currentOpacity = missingOpacity / (fadeWidth + 1);                         //Update total opacity                         totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;                         //Draw it                         using (Pen pen = new Pen(Color.FromArgb((int)Math.Round(currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2)))                         {                             pen.LineJoin = LineJoin.Round;                             g.DrawPath(pen' path);                         }                     }                 }                  if (fillFirst){                     //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor'(float)outlineWidth)){                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                 }else{                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor' (float)outlineWidth))                         {                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                                         //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                 }             }
Magic Number,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using(GraphicsPath path = new GraphicsPath()){                 FontFamily fontFamily = null;                 StringFormat strformat = null;                 try{                     FontStyle style = FontStyle.Regular;                     //Remove MT                     if (fontName.EndsWith("MT")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Remove -Bold' -Italic' -BoldItalic                     if (fontName.EndsWith("-Bold"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold;                     if (fontName.EndsWith("-Italic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Italic;                     if (fontName.EndsWith("-BoldItalic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold | FontStyle.Italic;                     //Remove from fontName                     fontName = new Regex("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace(fontName' "");                     //Remove PS                     if (fontName.EndsWith("PS")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Find font family                     try {                         fontFamily = new FontFamily(fontName);                     } catch (ArgumentException ae) {                         if (IgnoreMissingFonts) {                             fontFamily = FontFamily.GenericSansSerif;                         } else throw ae;                      }                     if (fauxBold) style |= FontStyle.Bold;                     if (fauxItalic) style |= FontStyle.Italic;                     if (underline) style |= FontStyle.Underline;                     if (strikethrough) style |= FontStyle.Strikeout;                      strformat = new StringFormat();                     strformat.LineAlignment = hAlign;                     strformat.Alignment = vAlign;                     strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;                     if (!horizontal) strformat.FormatFlags |= StringFormatFlags.DirectionVertical;                     strformat.Trimming = StringTrimming.None;                                          path.AddString(text' fontFamily'                         (int)style' (float)(fontSize)'rect' strformat);                 }finally{                     fontFamily.Dispose();                     strformat.Dispose();                 }                  if (glowFlag)                 {                     if (glowWidth == 3) glowWidth = 2; //To replicate photoshop rounding bug                                        double finalOpacity = (glowOpacity + 1.5)/2.5; //Because Photoshop doesn't actually use the opacity as the final opacity...                      //Add a 30% fade inside the glow width                     int fadeWidth = (int)Math.Floor(glowWidth * 0.33);                      double totalOpacity = 0; //Start at transparent                      //start with outermost ring' work inwards                     for (int i = fadeWidth; i >=0; i--)                     {                         //How much opacity do we lack to complete the desired opacity?                         //totalOpacity = prevOpacity * (1-curOpacity) + curOpacity                         //a=b *(1-c) + c                         //>>> where b!=1' c=(b-a/b-1)                         double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);                          int remainingRings = fadeWidth;                                                 double currentOpacity = missingOpacity / (fadeWidth + 1);                         //Update total opacity                         totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;                         //Draw it                         using (Pen pen = new Pen(Color.FromArgb((int)Math.Round(currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2)))                         {                             pen.LineJoin = LineJoin.Round;                             g.DrawPath(pen' path);                         }                     }                 }                  if (fillFirst){                     //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor'(float)outlineWidth)){                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                 }else{                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor' (float)outlineWidth))                         {                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                                         //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                 }             }
Magic Number,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using(GraphicsPath path = new GraphicsPath()){                 FontFamily fontFamily = null;                 StringFormat strformat = null;                 try{                     FontStyle style = FontStyle.Regular;                     //Remove MT                     if (fontName.EndsWith("MT")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Remove -Bold' -Italic' -BoldItalic                     if (fontName.EndsWith("-Bold"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold;                     if (fontName.EndsWith("-Italic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Italic;                     if (fontName.EndsWith("-BoldItalic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold | FontStyle.Italic;                     //Remove from fontName                     fontName = new Regex("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace(fontName' "");                     //Remove PS                     if (fontName.EndsWith("PS")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Find font family                     try {                         fontFamily = new FontFamily(fontName);                     } catch (ArgumentException ae) {                         if (IgnoreMissingFonts) {                             fontFamily = FontFamily.GenericSansSerif;                         } else throw ae;                      }                     if (fauxBold) style |= FontStyle.Bold;                     if (fauxItalic) style |= FontStyle.Italic;                     if (underline) style |= FontStyle.Underline;                     if (strikethrough) style |= FontStyle.Strikeout;                      strformat = new StringFormat();                     strformat.LineAlignment = hAlign;                     strformat.Alignment = vAlign;                     strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;                     if (!horizontal) strformat.FormatFlags |= StringFormatFlags.DirectionVertical;                     strformat.Trimming = StringTrimming.None;                                          path.AddString(text' fontFamily'                         (int)style' (float)(fontSize)'rect' strformat);                 }finally{                     fontFamily.Dispose();                     strformat.Dispose();                 }                  if (glowFlag)                 {                     if (glowWidth == 3) glowWidth = 2; //To replicate photoshop rounding bug                                        double finalOpacity = (glowOpacity + 1.5)/2.5; //Because Photoshop doesn't actually use the opacity as the final opacity...                      //Add a 30% fade inside the glow width                     int fadeWidth = (int)Math.Floor(glowWidth * 0.33);                      double totalOpacity = 0; //Start at transparent                      //start with outermost ring' work inwards                     for (int i = fadeWidth; i >=0; i--)                     {                         //How much opacity do we lack to complete the desired opacity?                         //totalOpacity = prevOpacity * (1-curOpacity) + curOpacity                         //a=b *(1-c) + c                         //>>> where b!=1' c=(b-a/b-1)                         double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);                          int remainingRings = fadeWidth;                                                 double currentOpacity = missingOpacity / (fadeWidth + 1);                         //Update total opacity                         totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;                         //Draw it                         using (Pen pen = new Pen(Color.FromArgb((int)Math.Round(currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2)))                         {                             pen.LineJoin = LineJoin.Round;                             g.DrawPath(pen' path);                         }                     }                 }                  if (fillFirst){                     //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor'(float)outlineWidth)){                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                 }else{                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor' (float)outlineWidth))                         {                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                                         //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                 }             }
Magic Number,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using(GraphicsPath path = new GraphicsPath()){                 FontFamily fontFamily = null;                 StringFormat strformat = null;                 try{                     FontStyle style = FontStyle.Regular;                     //Remove MT                     if (fontName.EndsWith("MT")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Remove -Bold' -Italic' -BoldItalic                     if (fontName.EndsWith("-Bold"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold;                     if (fontName.EndsWith("-Italic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Italic;                     if (fontName.EndsWith("-BoldItalic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold | FontStyle.Italic;                     //Remove from fontName                     fontName = new Regex("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace(fontName' "");                     //Remove PS                     if (fontName.EndsWith("PS")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Find font family                     try {                         fontFamily = new FontFamily(fontName);                     } catch (ArgumentException ae) {                         if (IgnoreMissingFonts) {                             fontFamily = FontFamily.GenericSansSerif;                         } else throw ae;                      }                     if (fauxBold) style |= FontStyle.Bold;                     if (fauxItalic) style |= FontStyle.Italic;                     if (underline) style |= FontStyle.Underline;                     if (strikethrough) style |= FontStyle.Strikeout;                      strformat = new StringFormat();                     strformat.LineAlignment = hAlign;                     strformat.Alignment = vAlign;                     strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;                     if (!horizontal) strformat.FormatFlags |= StringFormatFlags.DirectionVertical;                     strformat.Trimming = StringTrimming.None;                                          path.AddString(text' fontFamily'                         (int)style' (float)(fontSize)'rect' strformat);                 }finally{                     fontFamily.Dispose();                     strformat.Dispose();                 }                  if (glowFlag)                 {                     if (glowWidth == 3) glowWidth = 2; //To replicate photoshop rounding bug                                        double finalOpacity = (glowOpacity + 1.5)/2.5; //Because Photoshop doesn't actually use the opacity as the final opacity...                      //Add a 30% fade inside the glow width                     int fadeWidth = (int)Math.Floor(glowWidth * 0.33);                      double totalOpacity = 0; //Start at transparent                      //start with outermost ring' work inwards                     for (int i = fadeWidth; i >=0; i--)                     {                         //How much opacity do we lack to complete the desired opacity?                         //totalOpacity = prevOpacity * (1-curOpacity) + curOpacity                         //a=b *(1-c) + c                         //>>> where b!=1' c=(b-a/b-1)                         double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);                          int remainingRings = fadeWidth;                                                 double currentOpacity = missingOpacity / (fadeWidth + 1);                         //Update total opacity                         totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;                         //Draw it                         using (Pen pen = new Pen(Color.FromArgb((int)Math.Round(currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2)))                         {                             pen.LineJoin = LineJoin.Round;                             g.DrawPath(pen' path);                         }                     }                 }                  if (fillFirst){                     //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor'(float)outlineWidth)){                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                 }else{                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor' (float)outlineWidth))                         {                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                                         //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                 }             }
Magic Number,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using(GraphicsPath path = new GraphicsPath()){                 FontFamily fontFamily = null;                 StringFormat strformat = null;                 try{                     FontStyle style = FontStyle.Regular;                     //Remove MT                     if (fontName.EndsWith("MT")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Remove -Bold' -Italic' -BoldItalic                     if (fontName.EndsWith("-Bold"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold;                     if (fontName.EndsWith("-Italic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Italic;                     if (fontName.EndsWith("-BoldItalic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold | FontStyle.Italic;                     //Remove from fontName                     fontName = new Regex("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace(fontName' "");                     //Remove PS                     if (fontName.EndsWith("PS")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Find font family                     try {                         fontFamily = new FontFamily(fontName);                     } catch (ArgumentException ae) {                         if (IgnoreMissingFonts) {                             fontFamily = FontFamily.GenericSansSerif;                         } else throw ae;                      }                     if (fauxBold) style |= FontStyle.Bold;                     if (fauxItalic) style |= FontStyle.Italic;                     if (underline) style |= FontStyle.Underline;                     if (strikethrough) style |= FontStyle.Strikeout;                      strformat = new StringFormat();                     strformat.LineAlignment = hAlign;                     strformat.Alignment = vAlign;                     strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;                     if (!horizontal) strformat.FormatFlags |= StringFormatFlags.DirectionVertical;                     strformat.Trimming = StringTrimming.None;                                          path.AddString(text' fontFamily'                         (int)style' (float)(fontSize)'rect' strformat);                 }finally{                     fontFamily.Dispose();                     strformat.Dispose();                 }                  if (glowFlag)                 {                     if (glowWidth == 3) glowWidth = 2; //To replicate photoshop rounding bug                                        double finalOpacity = (glowOpacity + 1.5)/2.5; //Because Photoshop doesn't actually use the opacity as the final opacity...                      //Add a 30% fade inside the glow width                     int fadeWidth = (int)Math.Floor(glowWidth * 0.33);                      double totalOpacity = 0; //Start at transparent                      //start with outermost ring' work inwards                     for (int i = fadeWidth; i >=0; i--)                     {                         //How much opacity do we lack to complete the desired opacity?                         //totalOpacity = prevOpacity * (1-curOpacity) + curOpacity                         //a=b *(1-c) + c                         //>>> where b!=1' c=(b-a/b-1)                         double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);                          int remainingRings = fadeWidth;                                                 double currentOpacity = missingOpacity / (fadeWidth + 1);                         //Update total opacity                         totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;                         //Draw it                         using (Pen pen = new Pen(Color.FromArgb((int)Math.Round(currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2)))                         {                             pen.LineJoin = LineJoin.Round;                             g.DrawPath(pen' path);                         }                     }                 }                  if (fillFirst){                     //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor'(float)outlineWidth)){                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                 }else{                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor' (float)outlineWidth))                         {                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                                         //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                 }             }
Magic Number,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using(GraphicsPath path = new GraphicsPath()){                 FontFamily fontFamily = null;                 StringFormat strformat = null;                 try{                     FontStyle style = FontStyle.Regular;                     //Remove MT                     if (fontName.EndsWith("MT")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Remove -Bold' -Italic' -BoldItalic                     if (fontName.EndsWith("-Bold"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold;                     if (fontName.EndsWith("-Italic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Italic;                     if (fontName.EndsWith("-BoldItalic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold | FontStyle.Italic;                     //Remove from fontName                     fontName = new Regex("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace(fontName' "");                     //Remove PS                     if (fontName.EndsWith("PS")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Find font family                     try {                         fontFamily = new FontFamily(fontName);                     } catch (ArgumentException ae) {                         if (IgnoreMissingFonts) {                             fontFamily = FontFamily.GenericSansSerif;                         } else throw ae;                      }                     if (fauxBold) style |= FontStyle.Bold;                     if (fauxItalic) style |= FontStyle.Italic;                     if (underline) style |= FontStyle.Underline;                     if (strikethrough) style |= FontStyle.Strikeout;                      strformat = new StringFormat();                     strformat.LineAlignment = hAlign;                     strformat.Alignment = vAlign;                     strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;                     if (!horizontal) strformat.FormatFlags |= StringFormatFlags.DirectionVertical;                     strformat.Trimming = StringTrimming.None;                                          path.AddString(text' fontFamily'                         (int)style' (float)(fontSize)'rect' strformat);                 }finally{                     fontFamily.Dispose();                     strformat.Dispose();                 }                  if (glowFlag)                 {                     if (glowWidth == 3) glowWidth = 2; //To replicate photoshop rounding bug                                        double finalOpacity = (glowOpacity + 1.5)/2.5; //Because Photoshop doesn't actually use the opacity as the final opacity...                      //Add a 30% fade inside the glow width                     int fadeWidth = (int)Math.Floor(glowWidth * 0.33);                      double totalOpacity = 0; //Start at transparent                      //start with outermost ring' work inwards                     for (int i = fadeWidth; i >=0; i--)                     {                         //How much opacity do we lack to complete the desired opacity?                         //totalOpacity = prevOpacity * (1-curOpacity) + curOpacity                         //a=b *(1-c) + c                         //>>> where b!=1' c=(b-a/b-1)                         double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);                          int remainingRings = fadeWidth;                                                 double currentOpacity = missingOpacity / (fadeWidth + 1);                         //Update total opacity                         totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;                         //Draw it                         using (Pen pen = new Pen(Color.FromArgb((int)Math.Round(currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2)))                         {                             pen.LineJoin = LineJoin.Round;                             g.DrawPath(pen' path);                         }                     }                 }                  if (fillFirst){                     //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor'(float)outlineWidth)){                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                 }else{                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor' (float)outlineWidth))                         {                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                                         //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                 }             }
Magic Number,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using(GraphicsPath path = new GraphicsPath()){                 FontFamily fontFamily = null;                 StringFormat strformat = null;                 try{                     FontStyle style = FontStyle.Regular;                     //Remove MT                     if (fontName.EndsWith("MT")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Remove -Bold' -Italic' -BoldItalic                     if (fontName.EndsWith("-Bold"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold;                     if (fontName.EndsWith("-Italic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Italic;                     if (fontName.EndsWith("-BoldItalic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold | FontStyle.Italic;                     //Remove from fontName                     fontName = new Regex("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace(fontName' "");                     //Remove PS                     if (fontName.EndsWith("PS")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Find font family                     try {                         fontFamily = new FontFamily(fontName);                     } catch (ArgumentException ae) {                         if (IgnoreMissingFonts) {                             fontFamily = FontFamily.GenericSansSerif;                         } else throw ae;                      }                     if (fauxBold) style |= FontStyle.Bold;                     if (fauxItalic) style |= FontStyle.Italic;                     if (underline) style |= FontStyle.Underline;                     if (strikethrough) style |= FontStyle.Strikeout;                      strformat = new StringFormat();                     strformat.LineAlignment = hAlign;                     strformat.Alignment = vAlign;                     strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;                     if (!horizontal) strformat.FormatFlags |= StringFormatFlags.DirectionVertical;                     strformat.Trimming = StringTrimming.None;                                          path.AddString(text' fontFamily'                         (int)style' (float)(fontSize)'rect' strformat);                 }finally{                     fontFamily.Dispose();                     strformat.Dispose();                 }                  if (glowFlag)                 {                     if (glowWidth == 3) glowWidth = 2; //To replicate photoshop rounding bug                                        double finalOpacity = (glowOpacity + 1.5)/2.5; //Because Photoshop doesn't actually use the opacity as the final opacity...                      //Add a 30% fade inside the glow width                     int fadeWidth = (int)Math.Floor(glowWidth * 0.33);                      double totalOpacity = 0; //Start at transparent                      //start with outermost ring' work inwards                     for (int i = fadeWidth; i >=0; i--)                     {                         //How much opacity do we lack to complete the desired opacity?                         //totalOpacity = prevOpacity * (1-curOpacity) + curOpacity                         //a=b *(1-c) + c                         //>>> where b!=1' c=(b-a/b-1)                         double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);                          int remainingRings = fadeWidth;                                                 double currentOpacity = missingOpacity / (fadeWidth + 1);                         //Update total opacity                         totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;                         //Draw it                         using (Pen pen = new Pen(Color.FromArgb((int)Math.Round(currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2)))                         {                             pen.LineJoin = LineJoin.Round;                             g.DrawPath(pen' path);                         }                     }                 }                  if (fillFirst){                     //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor'(float)outlineWidth)){                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                 }else{                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor' (float)outlineWidth))                         {                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                                         //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                 }             }
Magic Number,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using(GraphicsPath path = new GraphicsPath()){                 FontFamily fontFamily = null;                 StringFormat strformat = null;                 try{                     FontStyle style = FontStyle.Regular;                     //Remove MT                     if (fontName.EndsWith("MT")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Remove -Bold' -Italic' -BoldItalic                     if (fontName.EndsWith("-Bold"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold;                     if (fontName.EndsWith("-Italic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Italic;                     if (fontName.EndsWith("-BoldItalic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold | FontStyle.Italic;                     //Remove from fontName                     fontName = new Regex("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace(fontName' "");                     //Remove PS                     if (fontName.EndsWith("PS")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Find font family                     try {                         fontFamily = new FontFamily(fontName);                     } catch (ArgumentException ae) {                         if (IgnoreMissingFonts) {                             fontFamily = FontFamily.GenericSansSerif;                         } else throw ae;                      }                     if (fauxBold) style |= FontStyle.Bold;                     if (fauxItalic) style |= FontStyle.Italic;                     if (underline) style |= FontStyle.Underline;                     if (strikethrough) style |= FontStyle.Strikeout;                      strformat = new StringFormat();                     strformat.LineAlignment = hAlign;                     strformat.Alignment = vAlign;                     strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;                     if (!horizontal) strformat.FormatFlags |= StringFormatFlags.DirectionVertical;                     strformat.Trimming = StringTrimming.None;                                          path.AddString(text' fontFamily'                         (int)style' (float)(fontSize)'rect' strformat);                 }finally{                     fontFamily.Dispose();                     strformat.Dispose();                 }                  if (glowFlag)                 {                     if (glowWidth == 3) glowWidth = 2; //To replicate photoshop rounding bug                                        double finalOpacity = (glowOpacity + 1.5)/2.5; //Because Photoshop doesn't actually use the opacity as the final opacity...                      //Add a 30% fade inside the glow width                     int fadeWidth = (int)Math.Floor(glowWidth * 0.33);                      double totalOpacity = 0; //Start at transparent                      //start with outermost ring' work inwards                     for (int i = fadeWidth; i >=0; i--)                     {                         //How much opacity do we lack to complete the desired opacity?                         //totalOpacity = prevOpacity * (1-curOpacity) + curOpacity                         //a=b *(1-c) + c                         //>>> where b!=1' c=(b-a/b-1)                         double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);                          int remainingRings = fadeWidth;                                                 double currentOpacity = missingOpacity / (fadeWidth + 1);                         //Update total opacity                         totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;                         //Draw it                         using (Pen pen = new Pen(Color.FromArgb((int)Math.Round(currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2)))                         {                             pen.LineJoin = LineJoin.Round;                             g.DrawPath(pen' path);                         }                     }                 }                  if (fillFirst){                     //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor'(float)outlineWidth)){                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                 }else{                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor' (float)outlineWidth))                         {                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                                         //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                 }             }
Magic Number,PhotoshopFile.Text,TextLayerRenderer,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TextLayerRenderer.cs,Render,The following statement contains a magic number: using(GraphicsPath path = new GraphicsPath()){                 FontFamily fontFamily = null;                 StringFormat strformat = null;                 try{                     FontStyle style = FontStyle.Regular;                     //Remove MT                     if (fontName.EndsWith("MT")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Remove -Bold' -Italic' -BoldItalic                     if (fontName.EndsWith("-Bold"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold;                     if (fontName.EndsWith("-Italic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Italic;                     if (fontName.EndsWith("-BoldItalic"' StringComparison.OrdinalIgnoreCase)) style |= FontStyle.Bold | FontStyle.Italic;                     //Remove from fontName                     fontName = new Regex("\\-(Bold|Italic|BoldItalic)$"' RegexOptions.IgnoreCase | RegexOptions.IgnoreCase).Replace(fontName' "");                     //Remove PS                     if (fontName.EndsWith("PS")) fontName = fontName.Substring(0' fontName.Length - 2);                     //Find font family                     try {                         fontFamily = new FontFamily(fontName);                     } catch (ArgumentException ae) {                         if (IgnoreMissingFonts) {                             fontFamily = FontFamily.GenericSansSerif;                         } else throw ae;                      }                     if (fauxBold) style |= FontStyle.Bold;                     if (fauxItalic) style |= FontStyle.Italic;                     if (underline) style |= FontStyle.Underline;                     if (strikethrough) style |= FontStyle.Strikeout;                      strformat = new StringFormat();                     strformat.LineAlignment = hAlign;                     strformat.Alignment = vAlign;                     strformat.FormatFlags = StringFormatFlags.NoWrap | StringFormatFlags.NoClip;                     if (!horizontal) strformat.FormatFlags |= StringFormatFlags.DirectionVertical;                     strformat.Trimming = StringTrimming.None;                                          path.AddString(text' fontFamily'                         (int)style' (float)(fontSize)'rect' strformat);                 }finally{                     fontFamily.Dispose();                     strformat.Dispose();                 }                  if (glowFlag)                 {                     if (glowWidth == 3) glowWidth = 2; //To replicate photoshop rounding bug                                        double finalOpacity = (glowOpacity + 1.5)/2.5; //Because Photoshop doesn't actually use the opacity as the final opacity...                      //Add a 30% fade inside the glow width                     int fadeWidth = (int)Math.Floor(glowWidth * 0.33);                      double totalOpacity = 0; //Start at transparent                      //start with outermost ring' work inwards                     for (int i = fadeWidth; i >=0; i--)                     {                         //How much opacity do we lack to complete the desired opacity?                         //totalOpacity = prevOpacity * (1-curOpacity) + curOpacity                         //a=b *(1-c) + c                         //>>> where b!=1' c=(b-a/b-1)                         double missingOpacity = (totalOpacity - finalOpacity) / (totalOpacity - 1);                          int remainingRings = fadeWidth;                                                 double currentOpacity = missingOpacity / (fadeWidth + 1);                         //Update total opacity                         totalOpacity = totalOpacity * (1 - currentOpacity) + currentOpacity;                         //Draw it                         using (Pen pen = new Pen(Color.FromArgb((int)Math.Round(currentOpacity * 255.0)' glowColor)' (float)((glowWidth - fadeWidth + (double)i) * 2)))                         {                             pen.LineJoin = LineJoin.Round;                             g.DrawPath(pen' path);                         }                     }                 }                  if (fillFirst){                     //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor'(float)outlineWidth)){                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                 }else{                     //Draw stroke                     if (strokeFlag){                         using (Pen p = new Pen(strokeColor' (float)outlineWidth))                         {                             p.LineJoin = LineJoin.Round;                             g.DrawPath(p'path);                         }                     }                                         //Draw fill                     if (fillFlag){                         using(SolidBrush brush = new SolidBrush(fillColor)){                             g.FillPath(brush' path);                         }                     }                 }             }
Magic Number,PhotoshopFile.Text,Token,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,parseBinary,The following statement contains a magic number: MemoryStream ms = new MemoryStream(128);
Magic Number,PhotoshopFile.Text,Token,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The following statement contains a magic number: if (c == '/'){                 StringBuilder sb = new StringBuilder(40);                 while (r.CanReadByte()){                     //Peek at the next char to see if it is whitespace                     char pc = (char)r.PeekChar();                     if (Char.IsWhiteSpace(pc) || pc == '\n' || pc=='[' || pc==']' || pc=='<' || pc=='>'){                         //We're done.                         //Strip the leading slash' create token with name                         return new Token(TokenType.MapKey'sb.ToString());                     }else{                         //A valid char' append it.                         sb.Append(r.ReadChar());                     }                 }             }
Magic Number,PhotoshopFile.Text,Token,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The following statement contains a magic number: if (Char.IsDigit(c) || c=='-' || c == '.'){                 StringBuilder sb = new StringBuilder(40);                 sb.Append(c);                 while (r.CanReadByte()){                     //Peek at the next char to see if it is whitespace                     char pc = (char)r.PeekChar();                     if (Char.IsWhiteSpace(pc) || pc == '\n' || pc ==']' || pc =='>'){                         //We're done. Find out what kind of number it is.                         string s = sb.ToString();                         //If it has a decimal' it's a double                         if (s.Contains('.')){                             return new Token(TokenType.Double'double.Parse(s' floatingPointStyle'NumberFormatInfo.InvariantInfo));                         }else{                              return new Token(TokenType.Integer'int.Parse(s'NumberStyles.Integer'NumberFormatInfo.InvariantInfo));                         }                                              }else if (Char.IsDigit(c) || c=='-' || c == '.'){                         //A valid char' append it.                         sb.Append(r.ReadChar());                     }else{                         //Unrecognized char in numeric sq                         throw new TdTaParseException("Unrecognized character in numeric sequence: " + sb.ToString() + pc'r);                     }                 }             }
Magic Number,PhotoshopFile.Text,Token,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The following statement contains a magic number: if (Char.IsWhiteSpace(c) || c == '\n'){                 StringBuilder sb = new StringBuilder(40);                 sb.Append(c);                 while (r.CanReadByte()){                     //Peek at the next char to see if it is whitespace                     char pc = (char)r.PeekChar();                     if (Char.IsWhiteSpace(pc) || pc == '\n'){                         sb.Append(r.ReadChar());                     }else{                         //We done.                         break;                     }                 }                 return new Token(TokenType.Whitespace'sb.ToString());             }
Magic Number,PhotoshopFile.Text,TypeTool,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TypeTool.cs,TypeTool,The following statement contains a magic number: for (int i = 0; i < StyleCount; i++)             {                 ushort Mark = reader.ReadUInt16();                 ushort FaceMark = reader.ReadUInt16();                 uint Size = reader.ReadUInt32();                 uint Tracking = reader.ReadUInt32();                 uint Kerning = reader.ReadUInt32();                 uint Leading = reader.ReadUInt32();                 uint BaseShift = reader.ReadUInt32();                                  byte AutoKern = reader.ReadByte();                 byte Extra = 0;                 if (Version <= 5)                     Extra = reader.ReadByte();                 byte Rotate = reader.ReadByte();             }
Magic Number,PhotoshopFile.Text,TypeTool,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TypeTool.cs,TypeTool,The following statement contains a magic number: for (int i = 0; i < 4; i++)                 reader.ReadUInt16();
Magic Number,PhotoshopFile.Text,TypeToolObject,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\TypeToolObject.cs,TypeToolObject,The following statement contains a magic number: if (Data.Length != 17 || !(Array.TrueForAll(Data' b => b == 0)))             {                 string s = ReadableBinary.CreateHexEditorString(Data);                 Debug.Write(s);             }
Missing Default,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following switch statement is missing a default case: switch (psdFile.ColorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[1][pos]'                              psdFile.ImageData[2][pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         psdFile.ImageData[3][pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(psdFile.ImageData[0][pos]'                         psdFile.ImageData[1][pos]'                         psdFile.ImageData[2][pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(psdFile.ImageData[0]' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]'                              psdFile.ImageData[0][pos]);           break;         case PsdFile.ColorModes.Indexed:           {             int index = (int)psdFile.ImageData[0][pos];             c = Color.FromArgb((int)psdFile.ColorModeData[index]'                              psdFile.ColorModeData[index + 256]'                              psdFile.ColorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {             c = LabToRGB(psdFile.ImageData[0][pos]'                          psdFile.ImageData[1][pos]'                          psdFile.ImageData[2][pos]);           }           break;       }
Missing Default,PhotoshopFile,ImageDecoder,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\ImageDecoderBitmaps.cs,GetColor,The following switch statement is missing a default case: switch (layer.colorMode)       {         case PsdFile.ColorModes.RGB:           c = Color.FromArgb(layer.ch0bytes[pos]'                              layer.ch1bytes[pos]'                              layer.ch2bytes[pos]);           break;         case PsdFile.ColorModes.CMYK:           c = CMYKToRGB(layer.ch0bytes[pos]'                         layer.ch1bytes[pos]'                         layer.ch2bytes[pos]'                         layer.ch3bytes[pos]);           break;         case PsdFile.ColorModes.Multichannel:           c = CMYKToRGB(layer.ch0bytes[pos]'                         layer.ch1bytes[pos]'                         layer.ch2bytes[pos]'                         0);           break;         case PsdFile.ColorModes.Bitmap:           byte bwValue = ImageDecoder.GetBitmapValue(layer.ch0bytes' pos);           c = Color.FromArgb(bwValue' bwValue' bwValue);           break;         case PsdFile.ColorModes.Grayscale:         case PsdFile.ColorModes.Duotone:           c = Color.FromArgb(layer.ch0bytes[pos]'                              layer.ch0bytes[pos]'                              layer.ch0bytes[pos]);           break;         case PsdFile.ColorModes.Indexed:           {               int index = (int)layer.ch0bytes[pos];             c = Color.FromArgb((int)layer.colorModeData[index]'                              layer.colorModeData[index + 256]'                              layer.colorModeData[index + 2 * 256]);           }           break;         case PsdFile.ColorModes.Lab:           {               c = LabToRGB(layer.ch0bytes[pos]'                          layer.ch1bytes[pos]'                          layer.ch2bytes[pos]);           }           break;       }
Missing Default,PhotoshopFile,Channel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,LoadPixelData,The following switch statement is missing a default case: switch (m_layer.PsdFile.Depth)           {             case 1:               m_bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               m_bytesPerRow = m_layer.m_rect.Width;               break;             case 16:               m_bytesPerRow = m_layer.m_rect.Width * 2;               break;           }
Missing Default,PhotoshopFile,Channel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,CompressImageData,The following switch statement is missing a default case: switch (m_layer.PsdFile.Depth)           {             case 1:               bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               bytesPerRow = m_layer.m_rect.Width;               break;             case 16:               bytesPerRow = m_layer.m_rect.Width * 2;               break;           }
Missing Default,PhotoshopFile,Mask,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Layer.cs,LoadPixelData,The following switch statement is missing a default case: switch (m_layer.PsdFile.Depth)           {             case 1:               bytesPerRow = ImageDecoder.BytesFromBits(m_layer.m_rect.Width);               break;             case 8:               bytesPerRow = m_rect.Width;               break;             case 16:               bytesPerRow = m_rect.Width * 2;               break;           }
Missing Default,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImageResources,The following switch statement is missing a default case: switch (resID)         {           case ResourceIDs.ResolutionInfo:             imgRes = new ResolutionInfo(imgRes);             break;           case ResourceIDs.Thumbnail1:           case ResourceIDs.Thumbnail2:             imgRes = new Thumbnail(imgRes);             break;           case ResourceIDs.AlphaChannelNames:             imgRes = new AlphaChannels(imgRes);             break;         }
Missing Default,PhotoshopFile,PsdFile,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\PsdFile.cs,LoadImage,The following switch statement is missing a default case: switch (m_depth)       {         case 1:           bytesPerRow = ImageDecoder.BytesFromBits(m_columns);           break;         case 8:           bytesPerRow = m_columns;           break;         case 16:           bytesPerRow = m_columns * 2;           break;       }
Missing Default,PhotoshopFile,DynVal,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\DynVal.cs,parseTypeString,The following switch statement is missing a default case: switch (fourCharType)             {                 case "obj ": return OSType.Reference;                 case "Objc": return OSType.Descriptor;                 case "VlLs": return OSType.List;                 case "doub": return OSType.Double;                 case "UntF": return OSType.UnitFloat;                 case "TEXT": return OSType.String;                 case "enum": return OSType.Enumerated;                 case "long": return OSType.Integer;                 case "bool": return OSType.Boolean;                 case "GlbO": return OSType.Descriptor;                 case "type": return OSType.Class;                 case "GlbC": return OSType.Class;                 case "alis": return OSType.Alias;                 case "tdta": return OSType.tdta;             }
Missing Default,PhotoshopFile.Text,Glow,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Glow,The following switch statement is missing a default case: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Data = null;                     break;                 case 2:                     this.Blur = (uint)r.ReadUInt16();                     this.Intensity = r.ReadUInt32();                     ushort something = r.ReadUInt16();                     this.Color = r.ReadPSDColor(16' false); //Inner color (no alpha)                      this.BlendModeKey = this.ReadBlendKey(r);                     this.Enabled = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     //TODO!                     if (this.Inner)                         this.Unknown = r.ReadByte();                     this.UnknownColor = r.ReadPSDColor(16' false); //unknown color(no alpha)                     this.Data = r.ReadBytes((int)r.BytesToEnd);                     break;             }
Missing Default,PhotoshopFile.Text,Bevel,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Bevel,The following switch statement is missing a default case: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Data = null;                     break;                 case 2:                     this.Angle = (uint)r.ReadUInt16();                     this.Strength = (uint)r.ReadUInt16();                     this.Blur = (uint)r.ReadUInt16();                      this.Unknown1 = r.ReadByte();                     this.Unknown2 = r.ReadByte();                     this.Unknown3 = r.ReadUInt16();                     this.Unknown4 = r.ReadUInt16();                      this.BlendModeKey = this.ReadBlendKey(r);                     this.ShadowBlendModeKey = this.ReadBlendKey(r);                      this.Color = r.ReadPSDColor(16' true);                     this.ShadowColor = r.ReadPSDColor(16' true);                      this.BevelStyle = r.ReadByte();                     this.Opacity = r.ReadByte();                     this.ShadowOpacity = r.ReadByte();                      this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Inverted = r.ReadBoolean();                      System.Drawing.Color someColor = r.ReadPSDColor(16' true);                     System.Drawing.Color someColor2 = r.ReadPSDColor(16' true);                     break;             }
Missing Default,PhotoshopFile.Text,Shadow,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Effects.cs,Shadow,The following switch statement is missing a default case: switch (version)             {                 case 0:                     this.Blur = r.ReadUInt32();                     this.Intensity = r.ReadUInt32();                      this.Angle = r.ReadUInt32();                     this.Distance = r.ReadUInt32();                      this.Color = r.ReadPSDColor(16' true);                      this.BlendModeKey = this.ReadBlendKey(r);                     //this.BlendModeSignature = r.ReadUInt32();                     //this.BlendModeKey = r.ReadUInt32();                     this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     break;                  case 2:                     this.Blur = (uint)r.ReadUInt16();                     this.Intensity = r.ReadUInt32();                      this.Angle = r.ReadUInt32();                     this.Distance = r.ReadUInt32();                      ushort something = r.ReadUInt16();//TODO:?                      this.Color = r.ReadPSDColor(16' true);                      this.BlendModeKey = this.ReadBlendKey(r);                     this.Enabled = r.ReadBoolean();                     this.UseGlobalAngle = r.ReadBoolean();                     this.Opacity = r.ReadByte();                     //TODO: 10 unknown bytes!                     break;             }
Missing Default,PhotoshopFile.Text,Token,C:\repos\imazen_resizer\Plugins\Libs\PsdPlugin\PsdFile\Text\Token.cs,nextToken,The following switch statement is missing a default case: switch (c)             {                 case '(': return new Token(parseBinary(r)); //Binary data. Leading and trailing parens are stripped' and escaped parens are restored to normal.                 case '[': return new Token(TokenType.StartList' c.ToString()); // [ opening list char                 case ']': return new Token(TokenType.EndList' c.ToString()); //Closing list char             }
