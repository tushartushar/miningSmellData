Implementation smell,Namespace,Class,File,Method,Description
Long Method,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The method has 108 lines of code.
Complex Method,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,MarkEye,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,GetEnclosingRect,Cyclomatic complexity of the method is 9
Complex Method,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,Cyclomatic complexity of the method is 15
Complex Method,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,Cyclomatic complexity of the method is 10
Complex Method,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,Cyclomatic complexity of the method is 12
Long Parameter List,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,Consider,The method has 8 parameters.
Long Statement,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,MarkEye,The length of the statement  "	if (subset.X < 0 || subset.Y < 0 || subset.Width < 0 || subset.Height < 0 || subset.Right >= image.Width || subset.Bottom >= image.Height) " is 138.
Long Statement,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,Consider,The length of the statement  "	////Now' let's do thresholding using (a) massCenter and radiuses' and (b) proximity to click point (using same radiuses).  " is 121.
Long Statement,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,GetBlurredMask,The length of the statement  "	using (UnmanagedImage ui = UnmanagedImage.Create (filledArray.GetLength (1)' filledArray.GetLength (0)' PixelFormat.Format8bppIndexed)) { " is 137.
Long Statement,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeatures,The length of the statement  "	CvAvgComp[] faces = Cv.HaarDetectObjects (img' Cascades ["FaceCascade"]' storage' 1.0850' 2' 0' new CvSize (30' 30)' new CvSize (0' 0)).ToArrayAndDispose (); " is 157.
Long Statement,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeatures,The length of the statement  "		CvAvgComp[] pairs = Cv.HaarDetectObjects (img' Cascades ["EyePair45"]' storage' 1.0850' 2' 0' new CvSize (img.Width / 4' img.Width / 20)' new CvSize (0' 0)).ToArrayAndDispose (); " is 178.
Long Statement,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeatures,The length of the statement  "			//Take the 1st most likely that actually contains eyes. We don't want to evaluate multiple eye pairs when there are no faces. " is 125.
Long Statement,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeaturesInFace,The length of the statement  "	CvAvgComp[] pairs = Cv.HaarDetectObjects (img' Cascades ["EyePair22"]' storage' 1.0850' 2' 0' new CvSize (r.Width < 50 ? 11 : 22' r.Width < 50 ? 3 : 5)' new CvSize (0' 0)).ToArrayAndDispose (); " is 193.
Long Statement,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeaturesInFace,The length of the statement  "		//Drop 1/2.75th off the top' leaving us with a full-width rectangle starting at 1/5.5th and stopping at 1/2th of face height. " is 125.
Long Statement,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The length of the statement  "			CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose (); " is 204.
Long Statement,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The length of the statement  "			CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose (); " is 203.
Long Statement,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The length of the statement  "						g.DrawImage (img.ToManagedImage (false)' new Rectangle (0' 0' width' height)' 0' 0' img.Width' img.Height' GraphicsUnit.Pixel' ia); " is 131.
Long Statement,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The length of the statement  "						//TODO: Not sure if ToManagedImage will stick around after the underlying image is disposed. I know that the bitmap data will be gone' guess that's most of it. " is 159.
Long Statement,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The length of the statement  "		Rectangle tinyArea = new Rectangle ((int)Math.Floor (scale * (double)max.X)' (int)Math.Floor (scale * (double)max.Y)' tinySize' tinySize); " is 138.
Long Statement,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The length of the statement  "					*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R]))); " is 163.
Long Statement,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The length of the statement  "					*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14))); " is 120.
Long Statement,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The length of the statement  "		BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat); " is 163.
Long Statement,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The length of the statement  "				AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius)); " is 143.
Long Statement,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,The length of the statement  "		PointF[] newPoints = c.CurrentImageBuilder.TranslatePoints (points.ToArray ()' s.originalSize' new ResizeSettings (s.settings)); " is 128.
Long Statement,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,The length of the statement  "				g.DrawRectangle (eyes [i / 2].Feature == FeatureType.Eye ? Pens.Green : Pens.Gray' new Rectangle ((int)x1' (int)y1' (int)(x2 - x1)' (int)(y2 - y1))); " is 149.
Complex Conditional,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,MarkEye,The conditional expression  "subset.X < 0 || subset.Y < 0 || subset.Width < 0 || subset.Height < 0 || subset.Right >= image.Width || subset.Bottom >= image.Height"  is complex.
Complex Conditional,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,Consider,The conditional expression  "n.X < 0 || n.X >= red.Width || n.Y < 0 || n.Y >= red.Height"  is complex.
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,AdaptiveCircleFill,The following statement contains a magic number: MinValue = (byte)Math.Round (0.4 * (double)MaxValue);  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,AdaptiveCircleFill,The following statement contains a magic number: MinValue = Math.Max ((byte)50' MinValue);  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,MarkEye,The following statement contains a magic number: try {  	Point startAt = start;  	using (UnmanagedImage c = new Crop (subset).Apply (image)) {  		red = new RedEyeFilter (2).Apply (c);  		if (maxPointSearchDistance > 0)  			startAt = new ManualSearcher ().FindMaxPixel (c' start' maxPointSearchDistance);  	}  	var fill = new AdaptiveCircleFill (red' startAt' start' maxEyeRadius * 2);  	fill.FirstPass ();  	fill.SecondPass ();  	fill.CorrectRedEye (image' subset.X' subset.Y);  	//fill.MarkFilledPixels(image' subset.X' subset.Y' new byte[] { 0' 255' 0' 0 });  	//fill.SetPixel(image' startAt.X + subset.X' startAt.Y + subset.Y' new byte[] { 255' 255' 0' 0 });  } finally {  	if (red != null)  		red.Dispose ();  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,MarkEye,The following statement contains a magic number: try {  	Point startAt = start;  	using (UnmanagedImage c = new Crop (subset).Apply (image)) {  		red = new RedEyeFilter (2).Apply (c);  		if (maxPointSearchDistance > 0)  			startAt = new ManualSearcher ().FindMaxPixel (c' start' maxPointSearchDistance);  	}  	var fill = new AdaptiveCircleFill (red' startAt' start' maxEyeRadius * 2);  	fill.FirstPass ();  	fill.SecondPass ();  	fill.CorrectRedEye (image' subset.X' subset.Y);  	//fill.MarkFilledPixels(image' subset.X' subset.Y' new byte[] { 0' 255' 0' 0 });  	//fill.SetPixel(image' startAt.X + subset.X' startAt.Y + subset.Y' new byte[] { 255' 255' 0' 0 });  } finally {  	if (red != null)  		red.Dispose ();  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,MarkEye,The following statement contains a magic number: using (UnmanagedImage c = new Crop (subset).Apply (image)) {  	red = new RedEyeFilter (2).Apply (c);  	if (maxPointSearchDistance > 0)  		startAt = new ManualSearcher ().FindMaxPixel (c' start' maxPointSearchDistance);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,MarkEye,The following statement contains a magic number: red = new RedEyeFilter (2).Apply (c);  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: while (q.Count > 0) {  	//Dequeue the parent point   	p = q.Dequeue ();  	//Find its value  	pval = red.Collect8bppPixelValues (new List<AForge.IntPoint> (new AForge.IntPoint[] {  		new AForge.IntPoint (p.X' p.Y)  	})) [0];  	//Calculate its distance from the start point  	//pdist = Math.Sqrt((p.X - StartAt.X) * (p.X - StartAt.X) + (p.Y - StartAt.Y) * (p.Y - StartAt.Y));  	//Calculate the current center of balance.   	PointF center;  	//Calculate the min est. radius based on filled pixels  	double minRadius = Math.Sqrt (FilledCount / Math.PI);  	double maxRadius;  	byte avg;  	if (useExistingMass) {  		center = this.WeightedCenter;  		maxRadius = this.FilledRadius * 1.5;  		avg = this.FillAverage;  	} else {  		center = new PointF ((float)SumX / (float)FilledCount' (float)SumY / (float)FilledCount);  		maxRadius = Math.Sqrt (FilledCount * 2.2 / Math.PI);  		maxRadius = Math.Sqrt (FilledCount * (2.2 * Math.Cos (Math.PI / 2 * maxRadius / MaxRadius)) / Math.PI);  		//Adjust maxRadius to use a smaller multiplier as the size approaches the hard outer limit  		maxRadius = Math.Max (maxRadius' minRadius);  		//Make sure it isn't smaller - it is possible.   		//What's the current average value of the filled area?  		avg = (byte)(SumV / FilledCount);  	}  	Consider (p' pval' -1' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 0' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' -1' 0' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' 0' center' minRadius' maxRadius' avg);  	Consider (p' pval' -1' 1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 0' 1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' 1' center' minRadius' maxRadius' avg);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: while (q.Count > 0) {  	//Dequeue the parent point   	p = q.Dequeue ();  	//Find its value  	pval = red.Collect8bppPixelValues (new List<AForge.IntPoint> (new AForge.IntPoint[] {  		new AForge.IntPoint (p.X' p.Y)  	})) [0];  	//Calculate its distance from the start point  	//pdist = Math.Sqrt((p.X - StartAt.X) * (p.X - StartAt.X) + (p.Y - StartAt.Y) * (p.Y - StartAt.Y));  	//Calculate the current center of balance.   	PointF center;  	//Calculate the min est. radius based on filled pixels  	double minRadius = Math.Sqrt (FilledCount / Math.PI);  	double maxRadius;  	byte avg;  	if (useExistingMass) {  		center = this.WeightedCenter;  		maxRadius = this.FilledRadius * 1.5;  		avg = this.FillAverage;  	} else {  		center = new PointF ((float)SumX / (float)FilledCount' (float)SumY / (float)FilledCount);  		maxRadius = Math.Sqrt (FilledCount * 2.2 / Math.PI);  		maxRadius = Math.Sqrt (FilledCount * (2.2 * Math.Cos (Math.PI / 2 * maxRadius / MaxRadius)) / Math.PI);  		//Adjust maxRadius to use a smaller multiplier as the size approaches the hard outer limit  		maxRadius = Math.Max (maxRadius' minRadius);  		//Make sure it isn't smaller - it is possible.   		//What's the current average value of the filled area?  		avg = (byte)(SumV / FilledCount);  	}  	Consider (p' pval' -1' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 0' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' -1' 0' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' 0' center' minRadius' maxRadius' avg);  	Consider (p' pval' -1' 1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 0' 1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' 1' center' minRadius' maxRadius' avg);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: while (q.Count > 0) {  	//Dequeue the parent point   	p = q.Dequeue ();  	//Find its value  	pval = red.Collect8bppPixelValues (new List<AForge.IntPoint> (new AForge.IntPoint[] {  		new AForge.IntPoint (p.X' p.Y)  	})) [0];  	//Calculate its distance from the start point  	//pdist = Math.Sqrt((p.X - StartAt.X) * (p.X - StartAt.X) + (p.Y - StartAt.Y) * (p.Y - StartAt.Y));  	//Calculate the current center of balance.   	PointF center;  	//Calculate the min est. radius based on filled pixels  	double minRadius = Math.Sqrt (FilledCount / Math.PI);  	double maxRadius;  	byte avg;  	if (useExistingMass) {  		center = this.WeightedCenter;  		maxRadius = this.FilledRadius * 1.5;  		avg = this.FillAverage;  	} else {  		center = new PointF ((float)SumX / (float)FilledCount' (float)SumY / (float)FilledCount);  		maxRadius = Math.Sqrt (FilledCount * 2.2 / Math.PI);  		maxRadius = Math.Sqrt (FilledCount * (2.2 * Math.Cos (Math.PI / 2 * maxRadius / MaxRadius)) / Math.PI);  		//Adjust maxRadius to use a smaller multiplier as the size approaches the hard outer limit  		maxRadius = Math.Max (maxRadius' minRadius);  		//Make sure it isn't smaller - it is possible.   		//What's the current average value of the filled area?  		avg = (byte)(SumV / FilledCount);  	}  	Consider (p' pval' -1' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 0' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' -1' 0' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' 0' center' minRadius' maxRadius' avg);  	Consider (p' pval' -1' 1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 0' 1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' 1' center' minRadius' maxRadius' avg);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: while (q.Count > 0) {  	//Dequeue the parent point   	p = q.Dequeue ();  	//Find its value  	pval = red.Collect8bppPixelValues (new List<AForge.IntPoint> (new AForge.IntPoint[] {  		new AForge.IntPoint (p.X' p.Y)  	})) [0];  	//Calculate its distance from the start point  	//pdist = Math.Sqrt((p.X - StartAt.X) * (p.X - StartAt.X) + (p.Y - StartAt.Y) * (p.Y - StartAt.Y));  	//Calculate the current center of balance.   	PointF center;  	//Calculate the min est. radius based on filled pixels  	double minRadius = Math.Sqrt (FilledCount / Math.PI);  	double maxRadius;  	byte avg;  	if (useExistingMass) {  		center = this.WeightedCenter;  		maxRadius = this.FilledRadius * 1.5;  		avg = this.FillAverage;  	} else {  		center = new PointF ((float)SumX / (float)FilledCount' (float)SumY / (float)FilledCount);  		maxRadius = Math.Sqrt (FilledCount * 2.2 / Math.PI);  		maxRadius = Math.Sqrt (FilledCount * (2.2 * Math.Cos (Math.PI / 2 * maxRadius / MaxRadius)) / Math.PI);  		//Adjust maxRadius to use a smaller multiplier as the size approaches the hard outer limit  		maxRadius = Math.Max (maxRadius' minRadius);  		//Make sure it isn't smaller - it is possible.   		//What's the current average value of the filled area?  		avg = (byte)(SumV / FilledCount);  	}  	Consider (p' pval' -1' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 0' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' -1' center' minRadius' maxRadius' avg);  	Consider (p' pval' -1' 0' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' 0' center' minRadius' maxRadius' avg);  	Consider (p' pval' -1' 1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 0' 1' center' minRadius' maxRadius' avg);  	Consider (p' pval' 1' 1' center' minRadius' maxRadius' avg);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: if (useExistingMass) {  	center = this.WeightedCenter;  	maxRadius = this.FilledRadius * 1.5;  	avg = this.FillAverage;  } else {  	center = new PointF ((float)SumX / (float)FilledCount' (float)SumY / (float)FilledCount);  	maxRadius = Math.Sqrt (FilledCount * 2.2 / Math.PI);  	maxRadius = Math.Sqrt (FilledCount * (2.2 * Math.Cos (Math.PI / 2 * maxRadius / MaxRadius)) / Math.PI);  	//Adjust maxRadius to use a smaller multiplier as the size approaches the hard outer limit  	maxRadius = Math.Max (maxRadius' minRadius);  	//Make sure it isn't smaller - it is possible.   	//What's the current average value of the filled area?  	avg = (byte)(SumV / FilledCount);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: if (useExistingMass) {  	center = this.WeightedCenter;  	maxRadius = this.FilledRadius * 1.5;  	avg = this.FillAverage;  } else {  	center = new PointF ((float)SumX / (float)FilledCount' (float)SumY / (float)FilledCount);  	maxRadius = Math.Sqrt (FilledCount * 2.2 / Math.PI);  	maxRadius = Math.Sqrt (FilledCount * (2.2 * Math.Cos (Math.PI / 2 * maxRadius / MaxRadius)) / Math.PI);  	//Adjust maxRadius to use a smaller multiplier as the size approaches the hard outer limit  	maxRadius = Math.Max (maxRadius' minRadius);  	//Make sure it isn't smaller - it is possible.   	//What's the current average value of the filled area?  	avg = (byte)(SumV / FilledCount);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: if (useExistingMass) {  	center = this.WeightedCenter;  	maxRadius = this.FilledRadius * 1.5;  	avg = this.FillAverage;  } else {  	center = new PointF ((float)SumX / (float)FilledCount' (float)SumY / (float)FilledCount);  	maxRadius = Math.Sqrt (FilledCount * 2.2 / Math.PI);  	maxRadius = Math.Sqrt (FilledCount * (2.2 * Math.Cos (Math.PI / 2 * maxRadius / MaxRadius)) / Math.PI);  	//Adjust maxRadius to use a smaller multiplier as the size approaches the hard outer limit  	maxRadius = Math.Max (maxRadius' minRadius);  	//Make sure it isn't smaller - it is possible.   	//What's the current average value of the filled area?  	avg = (byte)(SumV / FilledCount);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: if (useExistingMass) {  	center = this.WeightedCenter;  	maxRadius = this.FilledRadius * 1.5;  	avg = this.FillAverage;  } else {  	center = new PointF ((float)SumX / (float)FilledCount' (float)SumY / (float)FilledCount);  	maxRadius = Math.Sqrt (FilledCount * 2.2 / Math.PI);  	maxRadius = Math.Sqrt (FilledCount * (2.2 * Math.Cos (Math.PI / 2 * maxRadius / MaxRadius)) / Math.PI);  	//Adjust maxRadius to use a smaller multiplier as the size approaches the hard outer limit  	maxRadius = Math.Max (maxRadius' minRadius);  	//Make sure it isn't smaller - it is possible.   	//What's the current average value of the filled area?  	avg = (byte)(SumV / FilledCount);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: maxRadius = this.FilledRadius * 1.5;  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: maxRadius = Math.Sqrt (FilledCount * 2.2 / Math.PI);  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: maxRadius = Math.Sqrt (FilledCount * (2.2 * Math.Cos (Math.PI / 2 * maxRadius / MaxRadius)) / Math.PI);  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,FillPoints,The following statement contains a magic number: maxRadius = Math.Sqrt (FilledCount * (2.2 * Math.Cos (Math.PI / 2 * maxRadius / MaxRadius)) / Math.PI);  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,Consider,The following statement contains a magic number: threshold = Math.Cos (Math.PI / 2 * Math.Min (1' (mdist / Math.Max (3' maxRadius))));  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,Consider,The following statement contains a magic number: threshold = Math.Cos (Math.PI / 2 * Math.Min (1' (mdist / Math.Max (3' maxRadius))));  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,SetPixel,The following statement contains a magic number: if (pixelSize > 4)  	throw new NotSupportedException ();  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,MarkFilledPixels,The following statement contains a magic number: if (pixelSize > 4)  	throw new NotSupportedException ();  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,GetBlurredMask,The following statement contains a magic number: using (UnmanagedImage ui = UnmanagedImage.Create (filledArray.GetLength (1)' filledArray.GetLength (0)' PixelFormat.Format8bppIndexed)) {  	MarkFilledPixels (ui' 0' 0' new byte[] {  		255  	});  	return new GaussianBlur (1.25' 5).Apply (ui);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,GetBlurredMask,The following statement contains a magic number: using (UnmanagedImage ui = UnmanagedImage.Create (filledArray.GetLength (1)' filledArray.GetLength (0)' PixelFormat.Format8bppIndexed)) {  	MarkFilledPixels (ui' 0' 0' new byte[] {  		255  	});  	return new GaussianBlur (1.25' 5).Apply (ui);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,GetBlurredMask,The following statement contains a magic number: using (UnmanagedImage ui = UnmanagedImage.Create (filledArray.GetLength (1)' filledArray.GetLength (0)' PixelFormat.Format8bppIndexed)) {  	MarkFilledPixels (ui' 0' 0' new byte[] {  		255  	});  	return new GaussianBlur (1.25' 5).Apply (ui);  }  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,GetBlurredMask,The following statement contains a magic number: MarkFilledPixels (ui' 0' 0' new byte[] {  	255  });  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,GetBlurredMask,The following statement contains a magic number: return new GaussianBlur (1.25' 5).Apply (ui);  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,GetBlurredMask,The following statement contains a magic number: return new GaussianBlur (1.25' 5).Apply (ui);  
Magic Number,ImageResizer.Plugins.RedEye,AdaptiveCircleFill,F:\newReposMay17\imazen_resizer\Plugins\RedEye\AdaptiveCircleFill.cs,CorrectRedEye,The following statement contains a magic number: if (pixelSize > 4)  	throw new Exception ("Invalid pixel depth");  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeatures,The following statement contains a magic number: if (faces.Length == 0) {  	CvAvgComp[] pairs = Cv.HaarDetectObjects (img' Cascades ["EyePair45"]' storage' 1.0850' 2' 0' new CvSize (img.Width / 4' img.Width / 20)' new CvSize (0' 0)).ToArrayAndDispose ();  	if (pairs.Length > 0) {  		//TODO!!! Uncomment and test now that CompareByNeighbors sorts correctly  		//Array.Sort<CvAvgComp>(pairs' CompareByNeighbors);   		//Take the 1st most likely that actually contains eyes. We don't want to evaluate multiple eye pairs when there are no faces.  		//If there are pairs' evaluate them all. Finding eyes within multiple pairs is unlikely  		foreach (CvAvgComp pair in pairs) {  			var results = DetectFeaturesInPair (img' storage' pair);  			eyes.AddRange (results);  			if (results.Count > 0)  				break;  		}  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeatures,The following statement contains a magic number: if (faces.Length == 0) {  	CvAvgComp[] pairs = Cv.HaarDetectObjects (img' Cascades ["EyePair45"]' storage' 1.0850' 2' 0' new CvSize (img.Width / 4' img.Width / 20)' new CvSize (0' 0)).ToArrayAndDispose ();  	if (pairs.Length > 0) {  		//TODO!!! Uncomment and test now that CompareByNeighbors sorts correctly  		//Array.Sort<CvAvgComp>(pairs' CompareByNeighbors);   		//Take the 1st most likely that actually contains eyes. We don't want to evaluate multiple eye pairs when there are no faces.  		//If there are pairs' evaluate them all. Finding eyes within multiple pairs is unlikely  		foreach (CvAvgComp pair in pairs) {  			var results = DetectFeaturesInPair (img' storage' pair);  			eyes.AddRange (results);  			if (results.Count > 0)  				break;  		}  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeatures,The following statement contains a magic number: if (faces.Length == 0) {  	CvAvgComp[] pairs = Cv.HaarDetectObjects (img' Cascades ["EyePair45"]' storage' 1.0850' 2' 0' new CvSize (img.Width / 4' img.Width / 20)' new CvSize (0' 0)).ToArrayAndDispose ();  	if (pairs.Length > 0) {  		//TODO!!! Uncomment and test now that CompareByNeighbors sorts correctly  		//Array.Sort<CvAvgComp>(pairs' CompareByNeighbors);   		//Take the 1st most likely that actually contains eyes. We don't want to evaluate multiple eye pairs when there are no faces.  		//If there are pairs' evaluate them all. Finding eyes within multiple pairs is unlikely  		foreach (CvAvgComp pair in pairs) {  			var results = DetectFeaturesInPair (img' storage' pair);  			eyes.AddRange (results);  			if (results.Count > 0)  				break;  		}  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeatures,The following statement contains a magic number: if (faces.Length == 0) {  	CvAvgComp[] pairs = Cv.HaarDetectObjects (img' Cascades ["EyePair45"]' storage' 1.0850' 2' 0' new CvSize (img.Width / 4' img.Width / 20)' new CvSize (0' 0)).ToArrayAndDispose ();  	if (pairs.Length > 0) {  		//TODO!!! Uncomment and test now that CompareByNeighbors sorts correctly  		//Array.Sort<CvAvgComp>(pairs' CompareByNeighbors);   		//Take the 1st most likely that actually contains eyes. We don't want to evaluate multiple eye pairs when there are no faces.  		//If there are pairs' evaluate them all. Finding eyes within multiple pairs is unlikely  		foreach (CvAvgComp pair in pairs) {  			var results = DetectFeaturesInPair (img' storage' pair);  			eyes.AddRange (results);  			if (results.Count > 0)  				break;  		}  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeaturesInFace,The following statement contains a magic number: r.Height = Cv.Round ((double)r.Height / 2);  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeaturesInFace,The following statement contains a magic number: if (pairs.Length == 0) {  	//Drop 1/2.75th off the top' leaving us with a full-width rectangle starting at 1/5.5th and stopping at 1/2th of face height.  	int aFifth = Cv.Round ((double)r.Height * 2 / 5.5);  	r.Y += aFifth;  	r.Height -= aFifth;  	eyes.AddRange (DetectEyesInRegion (img' storage' r));  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeaturesInFace,The following statement contains a magic number: if (pairs.Length == 0) {  	//Drop 1/2.75th off the top' leaving us with a full-width rectangle starting at 1/5.5th and stopping at 1/2th of face height.  	int aFifth = Cv.Round ((double)r.Height * 2 / 5.5);  	r.Y += aFifth;  	r.Height -= aFifth;  	eyes.AddRange (DetectEyesInRegion (img' storage' r));  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeaturesInPair,The following statement contains a magic number: pair.Top -= pair.Height / 2;  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeaturesInPair,The following statement contains a magic number: pair.Height *= 2;  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeaturesInPair,The following statement contains a magic number: pair.Left -= pair.Width / 5;  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeaturesInPair,The following statement contains a magic number: pair.Width += pair.Width / 5 * 2;  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectFeaturesInPair,The following statement contains a magic number: pair.Width += pair.Width / 5 * 2;  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: leftEye.Width = (int)(leftEye.Width * 0.6);  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: rightEye.Width = (int)(rightEye.Width * 0.6);  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: rightEye.X += (int)(region.Width * 0.4);  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: vars.Add (new object[] {  	0'  	3'  	0.5f  });  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: vars.Add (new object[] {  	0'  	3'  	0.7f  });  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: vars.Add (new object[] {  	0'  	3'  	1.0f  });  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: vars.Add (new object[] {  	0'  	2'  	0.5f  });  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: vars.Add (new object[] {  	0'  	2'  	0.7f  });  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: vars.Add (new object[] {  	0'  	2'  	1.0f  });  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: foreach (object[] vals in vars) {  	CvRect left = leftEye;  	left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  	left.Height = (int)((float)left.Height * (float)vals [2]);  	CvRect right = rightEye;  	right.Height = left.Height;  	right.Y = left.Y;  	if (!foundLeft) {  		//Search for eyes  		storage.Clear ();  		img.SetROI (left);  		CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  		if (leyes.Length > 0) {  			eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  			foundLeft = true;  		}  	}  	if (!foundRight) {  		storage.Clear ();  		img.SetROI (right);  		CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  		if (reyes.Length > 0) {  			eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  			foundRight = true;  		}  	}  	if (foundLeft && foundRight)  		break;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: foreach (object[] vals in vars) {  	CvRect left = leftEye;  	left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  	left.Height = (int)((float)left.Height * (float)vals [2]);  	CvRect right = rightEye;  	right.Height = left.Height;  	right.Y = left.Y;  	if (!foundLeft) {  		//Search for eyes  		storage.Clear ();  		img.SetROI (left);  		CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  		if (leyes.Length > 0) {  			eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  			foundLeft = true;  		}  	}  	if (!foundRight) {  		storage.Clear ();  		img.SetROI (right);  		CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  		if (reyes.Length > 0) {  			eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  			foundRight = true;  		}  	}  	if (foundLeft && foundRight)  		break;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: foreach (object[] vals in vars) {  	CvRect left = leftEye;  	left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  	left.Height = (int)((float)left.Height * (float)vals [2]);  	CvRect right = rightEye;  	right.Height = left.Height;  	right.Y = left.Y;  	if (!foundLeft) {  		//Search for eyes  		storage.Clear ();  		img.SetROI (left);  		CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  		if (leyes.Length > 0) {  			eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  			foundLeft = true;  		}  	}  	if (!foundRight) {  		storage.Clear ();  		img.SetROI (right);  		CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  		if (reyes.Length > 0) {  			eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  			foundRight = true;  		}  	}  	if (foundLeft && foundRight)  		break;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: foreach (object[] vals in vars) {  	CvRect left = leftEye;  	left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  	left.Height = (int)((float)left.Height * (float)vals [2]);  	CvRect right = rightEye;  	right.Height = left.Height;  	right.Y = left.Y;  	if (!foundLeft) {  		//Search for eyes  		storage.Clear ();  		img.SetROI (left);  		CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  		if (leyes.Length > 0) {  			eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  			foundLeft = true;  		}  	}  	if (!foundRight) {  		storage.Clear ();  		img.SetROI (right);  		CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  		if (reyes.Length > 0) {  			eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  			foundRight = true;  		}  	}  	if (foundLeft && foundRight)  		break;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: foreach (object[] vals in vars) {  	CvRect left = leftEye;  	left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  	left.Height = (int)((float)left.Height * (float)vals [2]);  	CvRect right = rightEye;  	right.Height = left.Height;  	right.Y = left.Y;  	if (!foundLeft) {  		//Search for eyes  		storage.Clear ();  		img.SetROI (left);  		CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  		if (leyes.Length > 0) {  			eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  			foundLeft = true;  		}  	}  	if (!foundRight) {  		storage.Clear ();  		img.SetROI (right);  		CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  		if (reyes.Length > 0) {  			eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  			foundRight = true;  		}  	}  	if (foundLeft && foundRight)  		break;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: foreach (object[] vals in vars) {  	CvRect left = leftEye;  	left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  	left.Height = (int)((float)left.Height * (float)vals [2]);  	CvRect right = rightEye;  	right.Height = left.Height;  	right.Y = left.Y;  	if (!foundLeft) {  		//Search for eyes  		storage.Clear ();  		img.SetROI (left);  		CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  		if (leyes.Length > 0) {  			eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  			foundLeft = true;  		}  	}  	if (!foundRight) {  		storage.Clear ();  		img.SetROI (right);  		CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  		if (reyes.Length > 0) {  			eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  			foundRight = true;  		}  	}  	if (foundLeft && foundRight)  		break;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: foreach (object[] vals in vars) {  	CvRect left = leftEye;  	left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  	left.Height = (int)((float)left.Height * (float)vals [2]);  	CvRect right = rightEye;  	right.Height = left.Height;  	right.Y = left.Y;  	if (!foundLeft) {  		//Search for eyes  		storage.Clear ();  		img.SetROI (left);  		CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  		if (leyes.Length > 0) {  			eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  			foundLeft = true;  		}  	}  	if (!foundRight) {  		storage.Clear ();  		img.SetROI (right);  		CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  		if (reyes.Length > 0) {  			eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  			foundRight = true;  		}  	}  	if (foundLeft && foundRight)  		break;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: foreach (object[] vals in vars) {  	CvRect left = leftEye;  	left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  	left.Height = (int)((float)left.Height * (float)vals [2]);  	CvRect right = rightEye;  	right.Height = left.Height;  	right.Y = left.Y;  	if (!foundLeft) {  		//Search for eyes  		storage.Clear ();  		img.SetROI (left);  		CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  		if (leyes.Length > 0) {  			eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  			foundLeft = true;  		}  	}  	if (!foundRight) {  		storage.Clear ();  		img.SetROI (right);  		CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  		if (reyes.Length > 0) {  			eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  			foundRight = true;  		}  	}  	if (foundLeft && foundRight)  		break;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: foreach (object[] vals in vars) {  	CvRect left = leftEye;  	left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  	left.Height = (int)((float)left.Height * (float)vals [2]);  	CvRect right = rightEye;  	right.Height = left.Height;  	right.Y = left.Y;  	if (!foundLeft) {  		//Search for eyes  		storage.Clear ();  		img.SetROI (left);  		CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  		if (leyes.Length > 0) {  			eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  			foundLeft = true;  		}  	}  	if (!foundRight) {  		storage.Clear ();  		img.SetROI (right);  		CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  		//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  		if (reyes.Length > 0) {  			eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  			minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  			foundRight = true;  		}  	}  	if (foundLeft && foundRight)  		break;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: left.Y += (int)((float)left.Height * (float)vals [2] / 2.0);  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: left.Height = (int)((float)left.Height * (float)vals [2]);  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: if (!foundLeft) {  	//Search for eyes  	storage.Clear ();  	img.SetROI (left);  	CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  	//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  	if (leyes.Length > 0) {  		eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  		minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  		foundLeft = true;  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: if (!foundLeft) {  	//Search for eyes  	storage.Clear ();  	img.SetROI (left);  	CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  	//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  	if (leyes.Length > 0) {  		eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  		minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  		foundLeft = true;  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: if (!foundLeft) {  	//Search for eyes  	storage.Clear ();  	img.SetROI (left);  	CvAvgComp[] leyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["RightEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  	//Array.Sort<CvAvgComp>(leyes' CompareByNeighbors);  	if (leyes.Length > 0) {  		eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  		minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  		foundLeft = true;  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: if (leyes.Length > 0) {  	eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  	minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  	foundLeft = true;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: if (leyes.Length > 0) {  	eyes.Add (new ObjRect (leyes [0].Rect.Offset (left.Location).ToRectangleF ()' FeatureType.Eye));  	minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  	foundLeft = true;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: minEyeSize = new CvSize (leyes [0].Rect.Width / 4' leyes [0].Rect.Width / 4);  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: if (!foundRight) {  	storage.Clear ();  	img.SetROI (right);  	CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  	//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  	if (reyes.Length > 0) {  		eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  		minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  		foundRight = true;  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: if (!foundRight) {  	storage.Clear ();  	img.SetROI (right);  	CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  	//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  	if (reyes.Length > 0) {  		eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  		minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  		foundRight = true;  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: if (!foundRight) {  	storage.Clear ();  	img.SetROI (right);  	CvAvgComp[] reyes = Cv.HaarDetectObjects (img' (int)vals [0] == 0 ? Cascades ["LeftEyeCascade"] : Cascades ["Eye"]' storage' 1.0850' (int)vals [1]' 0' minEyeSize' new CvSize (0' 0)).ToArrayAndDispose ();  	//Array.Sort<CvAvgComp>(reyes' CompareByNeighbors);  	if (reyes.Length > 0) {  		eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  		minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  		foundRight = true;  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: if (reyes.Length > 0) {  	eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  	minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  	foundRight = true;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: if (reyes.Length > 0) {  	eyes.Add (new ObjRect (reyes [0].Rect.Offset (right.Location).ToRectangleF ()' FeatureType.Eye));  	minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  	foundRight = true;  }  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  
Magic Number,ImageResizer.Plugins.RedEye,EyeDetection,F:\newReposMay17\imazen_resizer\Plugins\RedEye\EyeDetection.cs,DetectEyesInRegion,The following statement contains a magic number: minEyeSize = new CvSize (reyes [0].Rect.Width / 4' reyes [0].Rect.Width / 4);  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: try {  	if (width != img.Width && height != img.Height) {  		using (Bitmap reduced = new Bitmap (width' height' PixelFormat.Format24bppRgb))  			using (Graphics g = Graphics.FromImage (reduced))  				using (ImageAttributes ia = new ImageAttributes ()) {  					g.CompositingMode = System.Drawing.Drawing2D.CompositingMode.SourceCopy;  					g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;  					g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;  					g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;  					g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;  					ia.SetWrapMode (System.Drawing.Drawing2D.WrapMode.TileFlipXY);  					g.DrawImage (img.ToManagedImage (false)' new Rectangle (0' 0' width' height)' 0' 0' img.Width' img.Height' GraphicsUnit.Pixel' ia);  					//TODO: Not sure if ToManagedImage will stick around after the underlying image is disposed. I know that the bitmap data will be gone' guess that's most of it.  					using (UnmanagedImage rui = UnmanagedImage.FromManagedImage (reduced)) {  						lowRed = new RedEyeFilter (2).Apply (rui);  						// Make an copy using the red eye filter  					}  				}  	} else {  		//Don't resample unless needed  		lowRed = new RedEyeFilter (2).Apply (img);  	}  	Point max = GetMax (lowRed' new PointF (mouse.X / (float)scale' mouse.Y / (float)scale)' maxDistanceFromMouse / scale);  	//We weren't scaling things? OK' cool...  	if (scale == 0)  		return max;  	//Otherwise' let's get the unscaled pixel.   	//Calculate the rectangle surrounding the selected pixel' but in source coordinates.  	int tinySize = (int)Math.Ceiling (scale) + 1;  	Rectangle tinyArea = new Rectangle ((int)Math.Floor (scale * (double)max.X)' (int)Math.Floor (scale * (double)max.Y)' tinySize' tinySize);  	if (tinyArea.Right >= img.Width)  		tinyArea.Width -= img.Width - tinyArea.Right + 1;  	if (tinyArea.Bottom >= img.Height)  		tinyArea.Height -= img.Height - tinyArea.Bottom + 1;  	//Filter it and look  	using (UnmanagedImage tiny = new Crop (tinyArea).Apply (img)) {  		using (UnmanagedImage tinyRed = new RedEyeFilter (2).Apply (tiny)) {  			max = GetMax (tinyRed);  			max.X += tinyArea.X;  			max.Y += tinyArea.Y;  		}  	}  	return max;  } finally {  	if (lowRed != null)  		lowRed.Dispose ();  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: try {  	if (width != img.Width && height != img.Height) {  		using (Bitmap reduced = new Bitmap (width' height' PixelFormat.Format24bppRgb))  			using (Graphics g = Graphics.FromImage (reduced))  				using (ImageAttributes ia = new ImageAttributes ()) {  					g.CompositingMode = System.Drawing.Drawing2D.CompositingMode.SourceCopy;  					g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;  					g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;  					g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;  					g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;  					ia.SetWrapMode (System.Drawing.Drawing2D.WrapMode.TileFlipXY);  					g.DrawImage (img.ToManagedImage (false)' new Rectangle (0' 0' width' height)' 0' 0' img.Width' img.Height' GraphicsUnit.Pixel' ia);  					//TODO: Not sure if ToManagedImage will stick around after the underlying image is disposed. I know that the bitmap data will be gone' guess that's most of it.  					using (UnmanagedImage rui = UnmanagedImage.FromManagedImage (reduced)) {  						lowRed = new RedEyeFilter (2).Apply (rui);  						// Make an copy using the red eye filter  					}  				}  	} else {  		//Don't resample unless needed  		lowRed = new RedEyeFilter (2).Apply (img);  	}  	Point max = GetMax (lowRed' new PointF (mouse.X / (float)scale' mouse.Y / (float)scale)' maxDistanceFromMouse / scale);  	//We weren't scaling things? OK' cool...  	if (scale == 0)  		return max;  	//Otherwise' let's get the unscaled pixel.   	//Calculate the rectangle surrounding the selected pixel' but in source coordinates.  	int tinySize = (int)Math.Ceiling (scale) + 1;  	Rectangle tinyArea = new Rectangle ((int)Math.Floor (scale * (double)max.X)' (int)Math.Floor (scale * (double)max.Y)' tinySize' tinySize);  	if (tinyArea.Right >= img.Width)  		tinyArea.Width -= img.Width - tinyArea.Right + 1;  	if (tinyArea.Bottom >= img.Height)  		tinyArea.Height -= img.Height - tinyArea.Bottom + 1;  	//Filter it and look  	using (UnmanagedImage tiny = new Crop (tinyArea).Apply (img)) {  		using (UnmanagedImage tinyRed = new RedEyeFilter (2).Apply (tiny)) {  			max = GetMax (tinyRed);  			max.X += tinyArea.X;  			max.Y += tinyArea.Y;  		}  	}  	return max;  } finally {  	if (lowRed != null)  		lowRed.Dispose ();  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: try {  	if (width != img.Width && height != img.Height) {  		using (Bitmap reduced = new Bitmap (width' height' PixelFormat.Format24bppRgb))  			using (Graphics g = Graphics.FromImage (reduced))  				using (ImageAttributes ia = new ImageAttributes ()) {  					g.CompositingMode = System.Drawing.Drawing2D.CompositingMode.SourceCopy;  					g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;  					g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;  					g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;  					g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;  					ia.SetWrapMode (System.Drawing.Drawing2D.WrapMode.TileFlipXY);  					g.DrawImage (img.ToManagedImage (false)' new Rectangle (0' 0' width' height)' 0' 0' img.Width' img.Height' GraphicsUnit.Pixel' ia);  					//TODO: Not sure if ToManagedImage will stick around after the underlying image is disposed. I know that the bitmap data will be gone' guess that's most of it.  					using (UnmanagedImage rui = UnmanagedImage.FromManagedImage (reduced)) {  						lowRed = new RedEyeFilter (2).Apply (rui);  						// Make an copy using the red eye filter  					}  				}  	} else {  		//Don't resample unless needed  		lowRed = new RedEyeFilter (2).Apply (img);  	}  	Point max = GetMax (lowRed' new PointF (mouse.X / (float)scale' mouse.Y / (float)scale)' maxDistanceFromMouse / scale);  	//We weren't scaling things? OK' cool...  	if (scale == 0)  		return max;  	//Otherwise' let's get the unscaled pixel.   	//Calculate the rectangle surrounding the selected pixel' but in source coordinates.  	int tinySize = (int)Math.Ceiling (scale) + 1;  	Rectangle tinyArea = new Rectangle ((int)Math.Floor (scale * (double)max.X)' (int)Math.Floor (scale * (double)max.Y)' tinySize' tinySize);  	if (tinyArea.Right >= img.Width)  		tinyArea.Width -= img.Width - tinyArea.Right + 1;  	if (tinyArea.Bottom >= img.Height)  		tinyArea.Height -= img.Height - tinyArea.Bottom + 1;  	//Filter it and look  	using (UnmanagedImage tiny = new Crop (tinyArea).Apply (img)) {  		using (UnmanagedImage tinyRed = new RedEyeFilter (2).Apply (tiny)) {  			max = GetMax (tinyRed);  			max.X += tinyArea.X;  			max.Y += tinyArea.Y;  		}  	}  	return max;  } finally {  	if (lowRed != null)  		lowRed.Dispose ();  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: if (width != img.Width && height != img.Height) {  	using (Bitmap reduced = new Bitmap (width' height' PixelFormat.Format24bppRgb))  		using (Graphics g = Graphics.FromImage (reduced))  			using (ImageAttributes ia = new ImageAttributes ()) {  				g.CompositingMode = System.Drawing.Drawing2D.CompositingMode.SourceCopy;  				g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;  				g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;  				g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;  				g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;  				ia.SetWrapMode (System.Drawing.Drawing2D.WrapMode.TileFlipXY);  				g.DrawImage (img.ToManagedImage (false)' new Rectangle (0' 0' width' height)' 0' 0' img.Width' img.Height' GraphicsUnit.Pixel' ia);  				//TODO: Not sure if ToManagedImage will stick around after the underlying image is disposed. I know that the bitmap data will be gone' guess that's most of it.  				using (UnmanagedImage rui = UnmanagedImage.FromManagedImage (reduced)) {  					lowRed = new RedEyeFilter (2).Apply (rui);  					// Make an copy using the red eye filter  				}  			}  } else {  	//Don't resample unless needed  	lowRed = new RedEyeFilter (2).Apply (img);  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: if (width != img.Width && height != img.Height) {  	using (Bitmap reduced = new Bitmap (width' height' PixelFormat.Format24bppRgb))  		using (Graphics g = Graphics.FromImage (reduced))  			using (ImageAttributes ia = new ImageAttributes ()) {  				g.CompositingMode = System.Drawing.Drawing2D.CompositingMode.SourceCopy;  				g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;  				g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;  				g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;  				g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;  				ia.SetWrapMode (System.Drawing.Drawing2D.WrapMode.TileFlipXY);  				g.DrawImage (img.ToManagedImage (false)' new Rectangle (0' 0' width' height)' 0' 0' img.Width' img.Height' GraphicsUnit.Pixel' ia);  				//TODO: Not sure if ToManagedImage will stick around after the underlying image is disposed. I know that the bitmap data will be gone' guess that's most of it.  				using (UnmanagedImage rui = UnmanagedImage.FromManagedImage (reduced)) {  					lowRed = new RedEyeFilter (2).Apply (rui);  					// Make an copy using the red eye filter  				}  			}  } else {  	//Don't resample unless needed  	lowRed = new RedEyeFilter (2).Apply (img);  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: using (Bitmap reduced = new Bitmap (width' height' PixelFormat.Format24bppRgb))  	using (Graphics g = Graphics.FromImage (reduced))  		using (ImageAttributes ia = new ImageAttributes ()) {  			g.CompositingMode = System.Drawing.Drawing2D.CompositingMode.SourceCopy;  			g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;  			g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;  			g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;  			g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;  			ia.SetWrapMode (System.Drawing.Drawing2D.WrapMode.TileFlipXY);  			g.DrawImage (img.ToManagedImage (false)' new Rectangle (0' 0' width' height)' 0' 0' img.Width' img.Height' GraphicsUnit.Pixel' ia);  			//TODO: Not sure if ToManagedImage will stick around after the underlying image is disposed. I know that the bitmap data will be gone' guess that's most of it.  			using (UnmanagedImage rui = UnmanagedImage.FromManagedImage (reduced)) {  				lowRed = new RedEyeFilter (2).Apply (rui);  				// Make an copy using the red eye filter  			}  		}  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (reduced))  	using (ImageAttributes ia = new ImageAttributes ()) {  		g.CompositingMode = System.Drawing.Drawing2D.CompositingMode.SourceCopy;  		g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;  		g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;  		g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;  		ia.SetWrapMode (System.Drawing.Drawing2D.WrapMode.TileFlipXY);  		g.DrawImage (img.ToManagedImage (false)' new Rectangle (0' 0' width' height)' 0' 0' img.Width' img.Height' GraphicsUnit.Pixel' ia);  		//TODO: Not sure if ToManagedImage will stick around after the underlying image is disposed. I know that the bitmap data will be gone' guess that's most of it.  		using (UnmanagedImage rui = UnmanagedImage.FromManagedImage (reduced)) {  			lowRed = new RedEyeFilter (2).Apply (rui);  			// Make an copy using the red eye filter  		}  	}  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: using (ImageAttributes ia = new ImageAttributes ()) {  	g.CompositingMode = System.Drawing.Drawing2D.CompositingMode.SourceCopy;  	g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;  	g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;  	g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;  	ia.SetWrapMode (System.Drawing.Drawing2D.WrapMode.TileFlipXY);  	g.DrawImage (img.ToManagedImage (false)' new Rectangle (0' 0' width' height)' 0' 0' img.Width' img.Height' GraphicsUnit.Pixel' ia);  	//TODO: Not sure if ToManagedImage will stick around after the underlying image is disposed. I know that the bitmap data will be gone' guess that's most of it.  	using (UnmanagedImage rui = UnmanagedImage.FromManagedImage (reduced)) {  		lowRed = new RedEyeFilter (2).Apply (rui);  		// Make an copy using the red eye filter  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: using (UnmanagedImage rui = UnmanagedImage.FromManagedImage (reduced)) {  	lowRed = new RedEyeFilter (2).Apply (rui);  	// Make an copy using the red eye filter  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: lowRed = new RedEyeFilter (2).Apply (rui);  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: lowRed = new RedEyeFilter (2).Apply (img);  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: using (UnmanagedImage tiny = new Crop (tinyArea).Apply (img)) {  	using (UnmanagedImage tinyRed = new RedEyeFilter (2).Apply (tiny)) {  		max = GetMax (tinyRed);  		max.X += tinyArea.X;  		max.Y += tinyArea.Y;  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,FindMaxPixel,The following statement contains a magic number: using (UnmanagedImage tinyRed = new RedEyeFilter (2).Apply (tiny)) {  	max = GetMax (tinyRed);  	max.X += tinyArea.X;  	max.Y += tinyArea.Y;  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,GetMax,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	byte* px = (byte*)red.ImageData + y * red.Stride;  	for (int x = 0; x < width; x++) {  		if (maxDistance > 0) {  			dist = Math.Sqrt ((weight.X - x) * (weight.X - x) + (weight.Y - y) * (weight.Y - y));  			if (dist < maxDistance) {  				byte val = (byte)((double)*px * Math.Cos (dist / maxDistance * Math.PI / 2));  				if (val > maxVal) {  					maxVal = val;  					max = new Point (x' y);  				}  			}  		} else {  			if (*px > maxVal) {  				maxVal = *px;  				max = new Point (x' y);  			}  		}  		px++;  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,GetMax,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	if (maxDistance > 0) {  		dist = Math.Sqrt ((weight.X - x) * (weight.X - x) + (weight.Y - y) * (weight.Y - y));  		if (dist < maxDistance) {  			byte val = (byte)((double)*px * Math.Cos (dist / maxDistance * Math.PI / 2));  			if (val > maxVal) {  				maxVal = val;  				max = new Point (x' y);  			}  		}  	} else {  		if (*px > maxVal) {  			maxVal = *px;  			max = new Point (x' y);  		}  	}  	px++;  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,GetMax,The following statement contains a magic number: if (maxDistance > 0) {  	dist = Math.Sqrt ((weight.X - x) * (weight.X - x) + (weight.Y - y) * (weight.Y - y));  	if (dist < maxDistance) {  		byte val = (byte)((double)*px * Math.Cos (dist / maxDistance * Math.PI / 2));  		if (val > maxVal) {  			maxVal = val;  			max = new Point (x' y);  		}  	}  } else {  	if (*px > maxVal) {  		maxVal = *px;  		max = new Point (x' y);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,ManualSearcher,F:\newReposMay17\imazen_resizer\Plugins\RedEye\ManualSearcher.cs,GetMax,The following statement contains a magic number: if (dist < maxDistance) {  	byte val = (byte)((double)*px * Math.Cos (dist / maxDistance * Math.PI / 2));  	if (val > maxVal) {  		maxVal = val;  		max = new Point (x' y);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,RedEyeFilter,The following statement contains a magic number: Algorithm = 2;  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (pixelSize <= 4) {  	int srcOffset = sourceData.Stride - width * pixelSize;  	int dstOffset = destinationData.Stride - width;  	// do the job  	byte* src = (byte*)sourceData.ImageData.ToPointer ();  	byte* dst = (byte*)destinationData.ImageData.ToPointer ();  	for (int y = 0; y < height; y++) {  		for (int x = 0; x < width; x++' src += pixelSize' dst++) {  			if (src [RGB.R] == 0)  				continue;  			if (algorithm == 0) {  				//held  				*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  			} else if (algorithm == 1) {  				//normalized r channel  				sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  				*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  			} else if (algorithm == 2) {  				//Smolka  				*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  			} else if (algorithm == 3) {  				//GS  				*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  			} else if (algorithm == 4) {  				//Gabautz  				*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  			}  		}  		src += srcOffset;  		dst += dstOffset;  	}  } else  	throw new NotImplementedException ();  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (pixelSize <= 4) {  	int srcOffset = sourceData.Stride - width * pixelSize;  	int dstOffset = destinationData.Stride - width;  	// do the job  	byte* src = (byte*)sourceData.ImageData.ToPointer ();  	byte* dst = (byte*)destinationData.ImageData.ToPointer ();  	for (int y = 0; y < height; y++) {  		for (int x = 0; x < width; x++' src += pixelSize' dst++) {  			if (src [RGB.R] == 0)  				continue;  			if (algorithm == 0) {  				//held  				*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  			} else if (algorithm == 1) {  				//normalized r channel  				sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  				*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  			} else if (algorithm == 2) {  				//Smolka  				*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  			} else if (algorithm == 3) {  				//GS  				*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  			} else if (algorithm == 4) {  				//Gabautz  				*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  			}  		}  		src += srcOffset;  		dst += dstOffset;  	}  } else  	throw new NotImplementedException ();  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (pixelSize <= 4) {  	int srcOffset = sourceData.Stride - width * pixelSize;  	int dstOffset = destinationData.Stride - width;  	// do the job  	byte* src = (byte*)sourceData.ImageData.ToPointer ();  	byte* dst = (byte*)destinationData.ImageData.ToPointer ();  	for (int y = 0; y < height; y++) {  		for (int x = 0; x < width; x++' src += pixelSize' dst++) {  			if (src [RGB.R] == 0)  				continue;  			if (algorithm == 0) {  				//held  				*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  			} else if (algorithm == 1) {  				//normalized r channel  				sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  				*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  			} else if (algorithm == 2) {  				//Smolka  				*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  			} else if (algorithm == 3) {  				//GS  				*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  			} else if (algorithm == 4) {  				//Gabautz  				*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  			}  		}  		src += srcOffset;  		dst += dstOffset;  	}  } else  	throw new NotImplementedException ();  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (pixelSize <= 4) {  	int srcOffset = sourceData.Stride - width * pixelSize;  	int dstOffset = destinationData.Stride - width;  	// do the job  	byte* src = (byte*)sourceData.ImageData.ToPointer ();  	byte* dst = (byte*)destinationData.ImageData.ToPointer ();  	for (int y = 0; y < height; y++) {  		for (int x = 0; x < width; x++' src += pixelSize' dst++) {  			if (src [RGB.R] == 0)  				continue;  			if (algorithm == 0) {  				//held  				*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  			} else if (algorithm == 1) {  				//normalized r channel  				sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  				*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  			} else if (algorithm == 2) {  				//Smolka  				*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  			} else if (algorithm == 3) {  				//GS  				*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  			} else if (algorithm == 4) {  				//Gabautz  				*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  			}  		}  		src += srcOffset;  		dst += dstOffset;  	}  } else  	throw new NotImplementedException ();  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (pixelSize <= 4) {  	int srcOffset = sourceData.Stride - width * pixelSize;  	int dstOffset = destinationData.Stride - width;  	// do the job  	byte* src = (byte*)sourceData.ImageData.ToPointer ();  	byte* dst = (byte*)destinationData.ImageData.ToPointer ();  	for (int y = 0; y < height; y++) {  		for (int x = 0; x < width; x++' src += pixelSize' dst++) {  			if (src [RGB.R] == 0)  				continue;  			if (algorithm == 0) {  				//held  				*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  			} else if (algorithm == 1) {  				//normalized r channel  				sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  				*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  			} else if (algorithm == 2) {  				//Smolka  				*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  			} else if (algorithm == 3) {  				//GS  				*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  			} else if (algorithm == 4) {  				//Gabautz  				*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  			}  		}  		src += srcOffset;  		dst += dstOffset;  	}  } else  	throw new NotImplementedException ();  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (pixelSize <= 4) {  	int srcOffset = sourceData.Stride - width * pixelSize;  	int dstOffset = destinationData.Stride - width;  	// do the job  	byte* src = (byte*)sourceData.ImageData.ToPointer ();  	byte* dst = (byte*)destinationData.ImageData.ToPointer ();  	for (int y = 0; y < height; y++) {  		for (int x = 0; x < width; x++' src += pixelSize' dst++) {  			if (src [RGB.R] == 0)  				continue;  			if (algorithm == 0) {  				//held  				*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  			} else if (algorithm == 1) {  				//normalized r channel  				sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  				*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  			} else if (algorithm == 2) {  				//Smolka  				*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  			} else if (algorithm == 3) {  				//GS  				*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  			} else if (algorithm == 4) {  				//Gabautz  				*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  			}  		}  		src += srcOffset;  		dst += dstOffset;  	}  } else  	throw new NotImplementedException ();  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (pixelSize <= 4) {  	int srcOffset = sourceData.Stride - width * pixelSize;  	int dstOffset = destinationData.Stride - width;  	// do the job  	byte* src = (byte*)sourceData.ImageData.ToPointer ();  	byte* dst = (byte*)destinationData.ImageData.ToPointer ();  	for (int y = 0; y < height; y++) {  		for (int x = 0; x < width; x++' src += pixelSize' dst++) {  			if (src [RGB.R] == 0)  				continue;  			if (algorithm == 0) {  				//held  				*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  			} else if (algorithm == 1) {  				//normalized r channel  				sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  				*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  			} else if (algorithm == 2) {  				//Smolka  				*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  			} else if (algorithm == 3) {  				//GS  				*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  			} else if (algorithm == 4) {  				//Gabautz  				*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  			}  		}  		src += srcOffset;  		dst += dstOffset;  	}  } else  	throw new NotImplementedException ();  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (pixelSize <= 4) {  	int srcOffset = sourceData.Stride - width * pixelSize;  	int dstOffset = destinationData.Stride - width;  	// do the job  	byte* src = (byte*)sourceData.ImageData.ToPointer ();  	byte* dst = (byte*)destinationData.ImageData.ToPointer ();  	for (int y = 0; y < height; y++) {  		for (int x = 0; x < width; x++' src += pixelSize' dst++) {  			if (src [RGB.R] == 0)  				continue;  			if (algorithm == 0) {  				//held  				*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  			} else if (algorithm == 1) {  				//normalized r channel  				sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  				*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  			} else if (algorithm == 2) {  				//Smolka  				*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  			} else if (algorithm == 3) {  				//GS  				*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  			} else if (algorithm == 4) {  				//Gabautz  				*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  			}  		}  		src += srcOffset;  		dst += dstOffset;  	}  } else  	throw new NotImplementedException ();  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (pixelSize <= 4) {  	int srcOffset = sourceData.Stride - width * pixelSize;  	int dstOffset = destinationData.Stride - width;  	// do the job  	byte* src = (byte*)sourceData.ImageData.ToPointer ();  	byte* dst = (byte*)destinationData.ImageData.ToPointer ();  	for (int y = 0; y < height; y++) {  		for (int x = 0; x < width; x++' src += pixelSize' dst++) {  			if (src [RGB.R] == 0)  				continue;  			if (algorithm == 0) {  				//held  				*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  			} else if (algorithm == 1) {  				//normalized r channel  				sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  				*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  			} else if (algorithm == 2) {  				//Smolka  				*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  			} else if (algorithm == 3) {  				//GS  				*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  			} else if (algorithm == 4) {  				//Gabautz  				*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  			}  		}  		src += srcOffset;  		dst += dstOffset;  	}  } else  	throw new NotImplementedException ();  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (pixelSize <= 4) {  	int srcOffset = sourceData.Stride - width * pixelSize;  	int dstOffset = destinationData.Stride - width;  	// do the job  	byte* src = (byte*)sourceData.ImageData.ToPointer ();  	byte* dst = (byte*)destinationData.ImageData.ToPointer ();  	for (int y = 0; y < height; y++) {  		for (int x = 0; x < width; x++' src += pixelSize' dst++) {  			if (src [RGB.R] == 0)  				continue;  			if (algorithm == 0) {  				//held  				*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  			} else if (algorithm == 1) {  				//normalized r channel  				sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  				*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  			} else if (algorithm == 2) {  				//Smolka  				*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  			} else if (algorithm == 3) {  				//GS  				*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  			} else if (algorithm == 4) {  				//Gabautz  				*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  			}  		}  		src += srcOffset;  		dst += dstOffset;  	}  } else  	throw new NotImplementedException ();  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	for (int x = 0; x < width; x++' src += pixelSize' dst++) {  		if (src [RGB.R] == 0)  			continue;  		if (algorithm == 0) {  			//held  			*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  		} else if (algorithm == 1) {  			//normalized r channel  			sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  			*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  		} else if (algorithm == 2) {  			//Smolka  			*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  		} else if (algorithm == 3) {  			//GS  			*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  		} else if (algorithm == 4) {  			//Gabautz  			*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  		}  	}  	src += srcOffset;  	dst += dstOffset;  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	for (int x = 0; x < width; x++' src += pixelSize' dst++) {  		if (src [RGB.R] == 0)  			continue;  		if (algorithm == 0) {  			//held  			*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  		} else if (algorithm == 1) {  			//normalized r channel  			sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  			*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  		} else if (algorithm == 2) {  			//Smolka  			*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  		} else if (algorithm == 3) {  			//GS  			*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  		} else if (algorithm == 4) {  			//Gabautz  			*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  		}  	}  	src += srcOffset;  	dst += dstOffset;  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	for (int x = 0; x < width; x++' src += pixelSize' dst++) {  		if (src [RGB.R] == 0)  			continue;  		if (algorithm == 0) {  			//held  			*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  		} else if (algorithm == 1) {  			//normalized r channel  			sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  			*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  		} else if (algorithm == 2) {  			//Smolka  			*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  		} else if (algorithm == 3) {  			//GS  			*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  		} else if (algorithm == 4) {  			//Gabautz  			*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  		}  	}  	src += srcOffset;  	dst += dstOffset;  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	for (int x = 0; x < width; x++' src += pixelSize' dst++) {  		if (src [RGB.R] == 0)  			continue;  		if (algorithm == 0) {  			//held  			*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  		} else if (algorithm == 1) {  			//normalized r channel  			sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  			*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  		} else if (algorithm == 2) {  			//Smolka  			*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  		} else if (algorithm == 3) {  			//GS  			*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  		} else if (algorithm == 4) {  			//Gabautz  			*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  		}  	}  	src += srcOffset;  	dst += dstOffset;  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	for (int x = 0; x < width; x++' src += pixelSize' dst++) {  		if (src [RGB.R] == 0)  			continue;  		if (algorithm == 0) {  			//held  			*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  		} else if (algorithm == 1) {  			//normalized r channel  			sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  			*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  		} else if (algorithm == 2) {  			//Smolka  			*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  		} else if (algorithm == 3) {  			//GS  			*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  		} else if (algorithm == 4) {  			//Gabautz  			*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  		}  	}  	src += srcOffset;  	dst += dstOffset;  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	for (int x = 0; x < width; x++' src += pixelSize' dst++) {  		if (src [RGB.R] == 0)  			continue;  		if (algorithm == 0) {  			//held  			*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  		} else if (algorithm == 1) {  			//normalized r channel  			sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  			*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  		} else if (algorithm == 2) {  			//Smolka  			*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  		} else if (algorithm == 3) {  			//GS  			*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  		} else if (algorithm == 4) {  			//Gabautz  			*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  		}  	}  	src += srcOffset;  	dst += dstOffset;  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	for (int x = 0; x < width; x++' src += pixelSize' dst++) {  		if (src [RGB.R] == 0)  			continue;  		if (algorithm == 0) {  			//held  			*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  		} else if (algorithm == 1) {  			//normalized r channel  			sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  			*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  		} else if (algorithm == 2) {  			//Smolka  			*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  		} else if (algorithm == 3) {  			//GS  			*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  		} else if (algorithm == 4) {  			//Gabautz  			*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  		}  	}  	src += srcOffset;  	dst += dstOffset;  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	for (int x = 0; x < width; x++' src += pixelSize' dst++) {  		if (src [RGB.R] == 0)  			continue;  		if (algorithm == 0) {  			//held  			*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  		} else if (algorithm == 1) {  			//normalized r channel  			sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  			*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  		} else if (algorithm == 2) {  			//Smolka  			*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  		} else if (algorithm == 3) {  			//GS  			*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  		} else if (algorithm == 4) {  			//Gabautz  			*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  		}  	}  	src += srcOffset;  	dst += dstOffset;  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	for (int x = 0; x < width; x++' src += pixelSize' dst++) {  		if (src [RGB.R] == 0)  			continue;  		if (algorithm == 0) {  			//held  			*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  		} else if (algorithm == 1) {  			//normalized r channel  			sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  			*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  		} else if (algorithm == 2) {  			//Smolka  			*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  		} else if (algorithm == 3) {  			//GS  			*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  		} else if (algorithm == 4) {  			//Gabautz  			*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  		}  	}  	src += srcOffset;  	dst += dstOffset;  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int x = 0; x < width; x++' src += pixelSize' dst++) {  	if (src [RGB.R] == 0)  		continue;  	if (algorithm == 0) {  		//held  		*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  	} else if (algorithm == 1) {  		//normalized r channel  		sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  		*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  	} else if (algorithm == 2) {  		//Smolka  		*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  	} else if (algorithm == 3) {  		//GS  		*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  	} else if (algorithm == 4) {  		//Gabautz  		*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int x = 0; x < width; x++' src += pixelSize' dst++) {  	if (src [RGB.R] == 0)  		continue;  	if (algorithm == 0) {  		//held  		*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  	} else if (algorithm == 1) {  		//normalized r channel  		sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  		*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  	} else if (algorithm == 2) {  		//Smolka  		*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  	} else if (algorithm == 3) {  		//GS  		*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  	} else if (algorithm == 4) {  		//Gabautz  		*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int x = 0; x < width; x++' src += pixelSize' dst++) {  	if (src [RGB.R] == 0)  		continue;  	if (algorithm == 0) {  		//held  		*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  	} else if (algorithm == 1) {  		//normalized r channel  		sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  		*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  	} else if (algorithm == 2) {  		//Smolka  		*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  	} else if (algorithm == 3) {  		//GS  		*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  	} else if (algorithm == 4) {  		//Gabautz  		*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int x = 0; x < width; x++' src += pixelSize' dst++) {  	if (src [RGB.R] == 0)  		continue;  	if (algorithm == 0) {  		//held  		*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  	} else if (algorithm == 1) {  		//normalized r channel  		sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  		*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  	} else if (algorithm == 2) {  		//Smolka  		*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  	} else if (algorithm == 3) {  		//GS  		*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  	} else if (algorithm == 4) {  		//Gabautz  		*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int x = 0; x < width; x++' src += pixelSize' dst++) {  	if (src [RGB.R] == 0)  		continue;  	if (algorithm == 0) {  		//held  		*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  	} else if (algorithm == 1) {  		//normalized r channel  		sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  		*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  	} else if (algorithm == 2) {  		//Smolka  		*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  	} else if (algorithm == 3) {  		//GS  		*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  	} else if (algorithm == 4) {  		//Gabautz  		*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int x = 0; x < width; x++' src += pixelSize' dst++) {  	if (src [RGB.R] == 0)  		continue;  	if (algorithm == 0) {  		//held  		*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  	} else if (algorithm == 1) {  		//normalized r channel  		sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  		*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  	} else if (algorithm == 2) {  		//Smolka  		*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  	} else if (algorithm == 3) {  		//GS  		*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  	} else if (algorithm == 4) {  		//Gabautz  		*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int x = 0; x < width; x++' src += pixelSize' dst++) {  	if (src [RGB.R] == 0)  		continue;  	if (algorithm == 0) {  		//held  		*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  	} else if (algorithm == 1) {  		//normalized r channel  		sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  		*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  	} else if (algorithm == 2) {  		//Smolka  		*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  	} else if (algorithm == 3) {  		//GS  		*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  	} else if (algorithm == 4) {  		//Gabautz  		*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int x = 0; x < width; x++' src += pixelSize' dst++) {  	if (src [RGB.R] == 0)  		continue;  	if (algorithm == 0) {  		//held  		*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  	} else if (algorithm == 1) {  		//normalized r channel  		sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  		*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  	} else if (algorithm == 2) {  		//Smolka  		*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  	} else if (algorithm == 3) {  		//GS  		*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  	} else if (algorithm == 4) {  		//Gabautz  		*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: for (int x = 0; x < width; x++' src += pixelSize' dst++) {  	if (src [RGB.R] == 0)  		continue;  	if (algorithm == 0) {  		//held  		*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  	} else if (algorithm == 1) {  		//normalized r channel  		sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  		*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  	} else if (algorithm == 2) {  		//Smolka  		*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  	} else if (algorithm == 3) {  		//GS  		*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  	} else if (algorithm == 4) {  		//Gabautz  		*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 0) {  	//held  	*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  } else if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 0) {  	//held  	*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  } else if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 0) {  	//held  	*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  } else if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 0) {  	//held  	*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  } else if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 0) {  	//held  	*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  } else if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 0) {  	//held  	*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  } else if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 0) {  	//held  	*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  } else if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 0) {  	//held  	*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  } else if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 0) {  	//held  	*dst = (byte)Math.Max (src [RGB.R] - Math.Min (src [RGB.G]' src [RGB.B])' 0);  } else if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 1) {  	//normalized r channel  	sum = (src [RGB.R] + src [RGB.G] + src [RGB.B]);  	*dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  } else if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: *dst = (sum != 0) ? (byte)(255 * src [RGB.R] / sum) : (byte)0;  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 2) {  	//Smolka  	*dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  } else if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: *dst = src [RGB.R] == 0 ? (byte)0 : (byte)Math.Min (255' Math.Max (0' ((float)(src [RGB.R] - Math.Max (src [RGB.G]' src [RGB.B])) * 255.0F / (float)src [RGB.R])));  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 3) {  	//GS  	*dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  } else if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: *dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: *dst = (byte)Math.Pow ((Math.Max (0' (src [RGB.R] * 2 - src [RGB.G] - src [RGB.B]) / src [RGB.R]))' 2);  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: if (algorithm == 4) {  	//Gabautz  	*dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: *dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  
Magic Number,ImageResizer.Plugins.RedEye,RedEyeFilter,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyeFilter.cs,ProcessFilter,The following statement contains a magic number: *dst = (byte)Math.Min (255' (src [RGB.R] * src [RGB.R] / (src [RGB.G] * src [RGB.G] + src [RGB.B] * src [RGB.B] + 14)));  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (s.settings ["r.eyes"])) {  	double[] eyes = s.settings.GetList<double> ("r.eyes"' 0);  	// lock source bitmap data  	BitmapData data = s.sourceBitmap.LockBits (new Rectangle (0' 0' s.sourceBitmap.Width' s.sourceBitmap.Height)' ImageLockMode.ReadWrite' s.sourceBitmap.PixelFormat);  	try {  		UnmanagedImage ui = new UnmanagedImage (data);  		for (var i = 0; i < eyes.Length / 5; i++) {  			var x = eyes [i * 5];  			var y = eyes [i * 5 + 1];  			var w = eyes [i * 5 + 2];  			var h = eyes [i * 5 + 3];  			var a = eyes [i * 5 + 4];  			var cx = x + w / 2;  			var cy = y + h / 2;  			var radius = Math.Sqrt (w * w + h * h) / 2;  			AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  		}  	} finally {  		// unlock image  		s.sourceBitmap.UnlockBits (data);  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: try {  	UnmanagedImage ui = new UnmanagedImage (data);  	for (var i = 0; i < eyes.Length / 5; i++) {  		var x = eyes [i * 5];  		var y = eyes [i * 5 + 1];  		var w = eyes [i * 5 + 2];  		var h = eyes [i * 5 + 3];  		var a = eyes [i * 5 + 4];  		var cx = x + w / 2;  		var cy = y + h / 2;  		var radius = Math.Sqrt (w * w + h * h) / 2;  		AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  	}  } finally {  	// unlock image  	s.sourceBitmap.UnlockBits (data);  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: for (var i = 0; i < eyes.Length / 5; i++) {  	var x = eyes [i * 5];  	var y = eyes [i * 5 + 1];  	var w = eyes [i * 5 + 2];  	var h = eyes [i * 5 + 3];  	var a = eyes [i * 5 + 4];  	var cx = x + w / 2;  	var cy = y + h / 2;  	var radius = Math.Sqrt (w * w + h * h) / 2;  	AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,Render,The following statement contains a magic number: AdaptiveCircleFill.MarkEye (ui' new System.Drawing.Point ((int)cx' (int)cy)' (int)Math.Ceiling (radius)' (float)(a > 6 ? radius / 4 : radius));  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,The following statement contains a magic number: if ("true".Equals (s.settings ["r.autoeyes"]' StringComparison.OrdinalIgnoreCase)) {  	List<ObjRect> eyes;  	using (var ed = new EyeDetection ())  		eyes = ed.DetectFeatures (s.sourceBitmap);  	List<PointF> points = new List<PointF> ();  	foreach (ObjRect r in eyes) {  		points.Add (new PointF (r.X' r.Y));  		points.Add (new PointF (r.X2' r.Y2));  	}  	PointF[] newPoints = c.CurrentImageBuilder.TranslatePoints (points.ToArray ()' s.originalSize' new ResizeSettings (s.settings));  	using (Graphics g = Graphics.FromImage (s.destBitmap)) {  		for (i = 0; i < newPoints.Length - 1; i += 2) {  			float x1 = newPoints [i].X;  			float y1 = newPoints [i].Y;  			float x2 = newPoints [i + 1].X;  			float y2 = newPoints [i + 1].Y;  			float t;  			if (x1 > x2) {  				t = x2;  				x2 = x1;  				x1 = t;  			}  			if (y1 > y2) {  				t = y1;  				y1 = y2;  				y2 = t;  			}  			g.DrawRectangle (eyes [i / 2].Feature == FeatureType.Eye ? Pens.Green : Pens.Gray' new Rectangle ((int)x1' (int)y1' (int)(x2 - x1)' (int)(y2 - y1)));  		}  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,The following statement contains a magic number: if ("true".Equals (s.settings ["r.autoeyes"]' StringComparison.OrdinalIgnoreCase)) {  	List<ObjRect> eyes;  	using (var ed = new EyeDetection ())  		eyes = ed.DetectFeatures (s.sourceBitmap);  	List<PointF> points = new List<PointF> ();  	foreach (ObjRect r in eyes) {  		points.Add (new PointF (r.X' r.Y));  		points.Add (new PointF (r.X2' r.Y2));  	}  	PointF[] newPoints = c.CurrentImageBuilder.TranslatePoints (points.ToArray ()' s.originalSize' new ResizeSettings (s.settings));  	using (Graphics g = Graphics.FromImage (s.destBitmap)) {  		for (i = 0; i < newPoints.Length - 1; i += 2) {  			float x1 = newPoints [i].X;  			float y1 = newPoints [i].Y;  			float x2 = newPoints [i + 1].X;  			float y2 = newPoints [i + 1].Y;  			float t;  			if (x1 > x2) {  				t = x2;  				x2 = x1;  				x1 = t;  			}  			if (y1 > y2) {  				t = y1;  				y1 = y2;  				y2 = t;  			}  			g.DrawRectangle (eyes [i / 2].Feature == FeatureType.Eye ? Pens.Green : Pens.Gray' new Rectangle ((int)x1' (int)y1' (int)(x2 - x1)' (int)(y2 - y1)));  		}  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (s.destBitmap)) {  	for (i = 0; i < newPoints.Length - 1; i += 2) {  		float x1 = newPoints [i].X;  		float y1 = newPoints [i].Y;  		float x2 = newPoints [i + 1].X;  		float y2 = newPoints [i + 1].Y;  		float t;  		if (x1 > x2) {  			t = x2;  			x2 = x1;  			x1 = t;  		}  		if (y1 > y2) {  			t = y1;  			y1 = y2;  			y2 = t;  		}  		g.DrawRectangle (eyes [i / 2].Feature == FeatureType.Eye ? Pens.Green : Pens.Gray' new Rectangle ((int)x1' (int)y1' (int)(x2 - x1)' (int)(y2 - y1)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (s.destBitmap)) {  	for (i = 0; i < newPoints.Length - 1; i += 2) {  		float x1 = newPoints [i].X;  		float y1 = newPoints [i].Y;  		float x2 = newPoints [i + 1].X;  		float y2 = newPoints [i + 1].Y;  		float t;  		if (x1 > x2) {  			t = x2;  			x2 = x1;  			x1 = t;  		}  		if (y1 > y2) {  			t = y1;  			y1 = y2;  			y2 = t;  		}  		g.DrawRectangle (eyes [i / 2].Feature == FeatureType.Eye ? Pens.Green : Pens.Gray' new Rectangle ((int)x1' (int)y1' (int)(x2 - x1)' (int)(y2 - y1)));  	}  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,The following statement contains a magic number: for (i = 0; i < newPoints.Length - 1; i += 2) {  	float x1 = newPoints [i].X;  	float y1 = newPoints [i].Y;  	float x2 = newPoints [i + 1].X;  	float y2 = newPoints [i + 1].Y;  	float t;  	if (x1 > x2) {  		t = x2;  		x2 = x1;  		x1 = t;  	}  	if (y1 > y2) {  		t = y1;  		y1 = y2;  		y2 = t;  	}  	g.DrawRectangle (eyes [i / 2].Feature == FeatureType.Eye ? Pens.Green : Pens.Gray' new Rectangle ((int)x1' (int)y1' (int)(x2 - x1)' (int)(y2 - y1)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,The following statement contains a magic number: for (i = 0; i < newPoints.Length - 1; i += 2) {  	float x1 = newPoints [i].X;  	float y1 = newPoints [i].Y;  	float x2 = newPoints [i + 1].X;  	float y2 = newPoints [i + 1].Y;  	float t;  	if (x1 > x2) {  		t = x2;  		x2 = x1;  		x1 = t;  	}  	if (y1 > y2) {  		t = y1;  		y1 = y2;  		y2 = t;  	}  	g.DrawRectangle (eyes [i / 2].Feature == FeatureType.Eye ? Pens.Green : Pens.Gray' new Rectangle ((int)x1' (int)y1' (int)(x2 - x1)' (int)(y2 - y1)));  }  
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,The following statement contains a magic number: i += 2
Magic Number,ImageResizer.Plugins.RedEye,RedEyePlugin,F:\newReposMay17\imazen_resizer\Plugins\RedEye\RedEyePlugin.cs,PostRenderImage,The following statement contains a magic number: g.DrawRectangle (eyes [i / 2].Feature == FeatureType.Eye ? Pens.Green : Pens.Gray' new Rectangle ((int)x1' (int)y1' (int)(x2 - x1)' (int)(y2 - y1)));  
