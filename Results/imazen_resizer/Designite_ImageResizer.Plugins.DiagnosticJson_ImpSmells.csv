Implementation smell,Namespace,Class,File,Method,Description
Complex Method,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,Cyclomatic complexity of the method is 19
Long Statement,ImageResizer.Plugins.DiagnosticJson,DiagnosticJsonPlugin,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\DiagnosticJsonPlugin.cs,PrepareDestinationBitmap,The length of the statement  "	throw new AlternateResponseException ("Resizing pipeline was canceled as JSON data was requested instead."' "application/json; charset=utf-8"' bytes); " is 150.
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null && (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone || !string.IsNullOrEmpty (state.settings ["sRotate"]))) {  	// We need to calculate the original rect/poly by *reversing* the  	// requested sFlip/sRotate.  We determine what the requested change  	// was' then calculate the reverse.  	var angle = state.settings.Get<double> ("sRotate"' 0);  	var flipRotate = (int)PolygonMath.CombineFlipAndRotate (state.settings.SourceFlip' angle);  	var copyPoly = PolygonMath.ToPoly (state.copyRect);  	var trueOriginalSize = state.originalSize;  	// The RotateFlipType values are ordered such that odd values  	// transpose the size of the rectangle' %4 gives the rotation  	// and /4 (=> 0 or 1) whether there's been an x-flip.  We can  	// use this to streamline our calculations.  	if (flipRotate % 2 == 1) {  		trueOriginalSize = new Size (state.originalSize.Height' state.originalSize.Width);  	}  	this.preAdjustedSourceRect = new SizeOnly (trueOriginalSize);  	// Remember that the sFlip/sRotate change performed the rotation  	// first and then the flip' so we have to do the opposite to go  	// backwards.  	if (flipRotate / 4 == 1) {  		copyPoly = PolygonMath.ScalePoints (copyPoly' -1' 1' PointF.Empty);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	}  	// It's possible to calculate a rotation-origin that will place  	// the original pre-sRotate (0'0) point back at (0'0) again...  	// but since it involves sqrt()' there would be rounding errors  	// that we should be able to avoid.  (We might' in fact' want to  	// avoid using PolygonMath entirely' and hand-map the points  	// backwards for accuracy.)  	switch (flipRotate % 4) {  	case 0:  		// no rotation  		// no-op!  		break;  	case 1:  		// 90 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  		break;  	case 2:  		// 180 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  		break;  	case 3:  		// 270 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  		break;  	}  	this.preAdjustedImageSourcePoly = new PolyRect (copyPoly);  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null && (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone || !string.IsNullOrEmpty (state.settings ["sRotate"]))) {  	// We need to calculate the original rect/poly by *reversing* the  	// requested sFlip/sRotate.  We determine what the requested change  	// was' then calculate the reverse.  	var angle = state.settings.Get<double> ("sRotate"' 0);  	var flipRotate = (int)PolygonMath.CombineFlipAndRotate (state.settings.SourceFlip' angle);  	var copyPoly = PolygonMath.ToPoly (state.copyRect);  	var trueOriginalSize = state.originalSize;  	// The RotateFlipType values are ordered such that odd values  	// transpose the size of the rectangle' %4 gives the rotation  	// and /4 (=> 0 or 1) whether there's been an x-flip.  We can  	// use this to streamline our calculations.  	if (flipRotate % 2 == 1) {  		trueOriginalSize = new Size (state.originalSize.Height' state.originalSize.Width);  	}  	this.preAdjustedSourceRect = new SizeOnly (trueOriginalSize);  	// Remember that the sFlip/sRotate change performed the rotation  	// first and then the flip' so we have to do the opposite to go  	// backwards.  	if (flipRotate / 4 == 1) {  		copyPoly = PolygonMath.ScalePoints (copyPoly' -1' 1' PointF.Empty);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	}  	// It's possible to calculate a rotation-origin that will place  	// the original pre-sRotate (0'0) point back at (0'0) again...  	// but since it involves sqrt()' there would be rounding errors  	// that we should be able to avoid.  (We might' in fact' want to  	// avoid using PolygonMath entirely' and hand-map the points  	// backwards for accuracy.)  	switch (flipRotate % 4) {  	case 0:  		// no rotation  		// no-op!  		break;  	case 1:  		// 90 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  		break;  	case 2:  		// 180 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  		break;  	case 3:  		// 270 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  		break;  	}  	this.preAdjustedImageSourcePoly = new PolyRect (copyPoly);  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null && (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone || !string.IsNullOrEmpty (state.settings ["sRotate"]))) {  	// We need to calculate the original rect/poly by *reversing* the  	// requested sFlip/sRotate.  We determine what the requested change  	// was' then calculate the reverse.  	var angle = state.settings.Get<double> ("sRotate"' 0);  	var flipRotate = (int)PolygonMath.CombineFlipAndRotate (state.settings.SourceFlip' angle);  	var copyPoly = PolygonMath.ToPoly (state.copyRect);  	var trueOriginalSize = state.originalSize;  	// The RotateFlipType values are ordered such that odd values  	// transpose the size of the rectangle' %4 gives the rotation  	// and /4 (=> 0 or 1) whether there's been an x-flip.  We can  	// use this to streamline our calculations.  	if (flipRotate % 2 == 1) {  		trueOriginalSize = new Size (state.originalSize.Height' state.originalSize.Width);  	}  	this.preAdjustedSourceRect = new SizeOnly (trueOriginalSize);  	// Remember that the sFlip/sRotate change performed the rotation  	// first and then the flip' so we have to do the opposite to go  	// backwards.  	if (flipRotate / 4 == 1) {  		copyPoly = PolygonMath.ScalePoints (copyPoly' -1' 1' PointF.Empty);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	}  	// It's possible to calculate a rotation-origin that will place  	// the original pre-sRotate (0'0) point back at (0'0) again...  	// but since it involves sqrt()' there would be rounding errors  	// that we should be able to avoid.  (We might' in fact' want to  	// avoid using PolygonMath entirely' and hand-map the points  	// backwards for accuracy.)  	switch (flipRotate % 4) {  	case 0:  		// no rotation  		// no-op!  		break;  	case 1:  		// 90 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  		break;  	case 2:  		// 180 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  		break;  	case 3:  		// 270 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  		break;  	}  	this.preAdjustedImageSourcePoly = new PolyRect (copyPoly);  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null && (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone || !string.IsNullOrEmpty (state.settings ["sRotate"]))) {  	// We need to calculate the original rect/poly by *reversing* the  	// requested sFlip/sRotate.  We determine what the requested change  	// was' then calculate the reverse.  	var angle = state.settings.Get<double> ("sRotate"' 0);  	var flipRotate = (int)PolygonMath.CombineFlipAndRotate (state.settings.SourceFlip' angle);  	var copyPoly = PolygonMath.ToPoly (state.copyRect);  	var trueOriginalSize = state.originalSize;  	// The RotateFlipType values are ordered such that odd values  	// transpose the size of the rectangle' %4 gives the rotation  	// and /4 (=> 0 or 1) whether there's been an x-flip.  We can  	// use this to streamline our calculations.  	if (flipRotate % 2 == 1) {  		trueOriginalSize = new Size (state.originalSize.Height' state.originalSize.Width);  	}  	this.preAdjustedSourceRect = new SizeOnly (trueOriginalSize);  	// Remember that the sFlip/sRotate change performed the rotation  	// first and then the flip' so we have to do the opposite to go  	// backwards.  	if (flipRotate / 4 == 1) {  		copyPoly = PolygonMath.ScalePoints (copyPoly' -1' 1' PointF.Empty);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	}  	// It's possible to calculate a rotation-origin that will place  	// the original pre-sRotate (0'0) point back at (0'0) again...  	// but since it involves sqrt()' there would be rounding errors  	// that we should be able to avoid.  (We might' in fact' want to  	// avoid using PolygonMath entirely' and hand-map the points  	// backwards for accuracy.)  	switch (flipRotate % 4) {  	case 0:  		// no rotation  		// no-op!  		break;  	case 1:  		// 90 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  		break;  	case 2:  		// 180 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  		break;  	case 3:  		// 270 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  		break;  	}  	this.preAdjustedImageSourcePoly = new PolyRect (copyPoly);  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null && (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone || !string.IsNullOrEmpty (state.settings ["sRotate"]))) {  	// We need to calculate the original rect/poly by *reversing* the  	// requested sFlip/sRotate.  We determine what the requested change  	// was' then calculate the reverse.  	var angle = state.settings.Get<double> ("sRotate"' 0);  	var flipRotate = (int)PolygonMath.CombineFlipAndRotate (state.settings.SourceFlip' angle);  	var copyPoly = PolygonMath.ToPoly (state.copyRect);  	var trueOriginalSize = state.originalSize;  	// The RotateFlipType values are ordered such that odd values  	// transpose the size of the rectangle' %4 gives the rotation  	// and /4 (=> 0 or 1) whether there's been an x-flip.  We can  	// use this to streamline our calculations.  	if (flipRotate % 2 == 1) {  		trueOriginalSize = new Size (state.originalSize.Height' state.originalSize.Width);  	}  	this.preAdjustedSourceRect = new SizeOnly (trueOriginalSize);  	// Remember that the sFlip/sRotate change performed the rotation  	// first and then the flip' so we have to do the opposite to go  	// backwards.  	if (flipRotate / 4 == 1) {  		copyPoly = PolygonMath.ScalePoints (copyPoly' -1' 1' PointF.Empty);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	}  	// It's possible to calculate a rotation-origin that will place  	// the original pre-sRotate (0'0) point back at (0'0) again...  	// but since it involves sqrt()' there would be rounding errors  	// that we should be able to avoid.  (We might' in fact' want to  	// avoid using PolygonMath entirely' and hand-map the points  	// backwards for accuracy.)  	switch (flipRotate % 4) {  	case 0:  		// no rotation  		// no-op!  		break;  	case 1:  		// 90 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  		break;  	case 2:  		// 180 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  		break;  	case 3:  		// 270 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  		break;  	}  	this.preAdjustedImageSourcePoly = new PolyRect (copyPoly);  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null && (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone || !string.IsNullOrEmpty (state.settings ["sRotate"]))) {  	// We need to calculate the original rect/poly by *reversing* the  	// requested sFlip/sRotate.  We determine what the requested change  	// was' then calculate the reverse.  	var angle = state.settings.Get<double> ("sRotate"' 0);  	var flipRotate = (int)PolygonMath.CombineFlipAndRotate (state.settings.SourceFlip' angle);  	var copyPoly = PolygonMath.ToPoly (state.copyRect);  	var trueOriginalSize = state.originalSize;  	// The RotateFlipType values are ordered such that odd values  	// transpose the size of the rectangle' %4 gives the rotation  	// and /4 (=> 0 or 1) whether there's been an x-flip.  We can  	// use this to streamline our calculations.  	if (flipRotate % 2 == 1) {  		trueOriginalSize = new Size (state.originalSize.Height' state.originalSize.Width);  	}  	this.preAdjustedSourceRect = new SizeOnly (trueOriginalSize);  	// Remember that the sFlip/sRotate change performed the rotation  	// first and then the flip' so we have to do the opposite to go  	// backwards.  	if (flipRotate / 4 == 1) {  		copyPoly = PolygonMath.ScalePoints (copyPoly' -1' 1' PointF.Empty);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	}  	// It's possible to calculate a rotation-origin that will place  	// the original pre-sRotate (0'0) point back at (0'0) again...  	// but since it involves sqrt()' there would be rounding errors  	// that we should be able to avoid.  (We might' in fact' want to  	// avoid using PolygonMath entirely' and hand-map the points  	// backwards for accuracy.)  	switch (flipRotate % 4) {  	case 0:  		// no rotation  		// no-op!  		break;  	case 1:  		// 90 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  		break;  	case 2:  		// 180 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  		break;  	case 3:  		// 270 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  		break;  	}  	this.preAdjustedImageSourcePoly = new PolyRect (copyPoly);  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null && (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone || !string.IsNullOrEmpty (state.settings ["sRotate"]))) {  	// We need to calculate the original rect/poly by *reversing* the  	// requested sFlip/sRotate.  We determine what the requested change  	// was' then calculate the reverse.  	var angle = state.settings.Get<double> ("sRotate"' 0);  	var flipRotate = (int)PolygonMath.CombineFlipAndRotate (state.settings.SourceFlip' angle);  	var copyPoly = PolygonMath.ToPoly (state.copyRect);  	var trueOriginalSize = state.originalSize;  	// The RotateFlipType values are ordered such that odd values  	// transpose the size of the rectangle' %4 gives the rotation  	// and /4 (=> 0 or 1) whether there's been an x-flip.  We can  	// use this to streamline our calculations.  	if (flipRotate % 2 == 1) {  		trueOriginalSize = new Size (state.originalSize.Height' state.originalSize.Width);  	}  	this.preAdjustedSourceRect = new SizeOnly (trueOriginalSize);  	// Remember that the sFlip/sRotate change performed the rotation  	// first and then the flip' so we have to do the opposite to go  	// backwards.  	if (flipRotate / 4 == 1) {  		copyPoly = PolygonMath.ScalePoints (copyPoly' -1' 1' PointF.Empty);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	}  	// It's possible to calculate a rotation-origin that will place  	// the original pre-sRotate (0'0) point back at (0'0) again...  	// but since it involves sqrt()' there would be rounding errors  	// that we should be able to avoid.  (We might' in fact' want to  	// avoid using PolygonMath entirely' and hand-map the points  	// backwards for accuracy.)  	switch (flipRotate % 4) {  	case 0:  		// no rotation  		// no-op!  		break;  	case 1:  		// 90 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  		break;  	case 2:  		// 180 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  		break;  	case 3:  		// 270 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  		break;  	}  	this.preAdjustedImageSourcePoly = new PolyRect (copyPoly);  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null && (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone || !string.IsNullOrEmpty (state.settings ["sRotate"]))) {  	// We need to calculate the original rect/poly by *reversing* the  	// requested sFlip/sRotate.  We determine what the requested change  	// was' then calculate the reverse.  	var angle = state.settings.Get<double> ("sRotate"' 0);  	var flipRotate = (int)PolygonMath.CombineFlipAndRotate (state.settings.SourceFlip' angle);  	var copyPoly = PolygonMath.ToPoly (state.copyRect);  	var trueOriginalSize = state.originalSize;  	// The RotateFlipType values are ordered such that odd values  	// transpose the size of the rectangle' %4 gives the rotation  	// and /4 (=> 0 or 1) whether there's been an x-flip.  We can  	// use this to streamline our calculations.  	if (flipRotate % 2 == 1) {  		trueOriginalSize = new Size (state.originalSize.Height' state.originalSize.Width);  	}  	this.preAdjustedSourceRect = new SizeOnly (trueOriginalSize);  	// Remember that the sFlip/sRotate change performed the rotation  	// first and then the flip' so we have to do the opposite to go  	// backwards.  	if (flipRotate / 4 == 1) {  		copyPoly = PolygonMath.ScalePoints (copyPoly' -1' 1' PointF.Empty);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	}  	// It's possible to calculate a rotation-origin that will place  	// the original pre-sRotate (0'0) point back at (0'0) again...  	// but since it involves sqrt()' there would be rounding errors  	// that we should be able to avoid.  (We might' in fact' want to  	// avoid using PolygonMath entirely' and hand-map the points  	// backwards for accuracy.)  	switch (flipRotate % 4) {  	case 0:  		// no rotation  		// no-op!  		break;  	case 1:  		// 90 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  		break;  	case 2:  		// 180 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  		break;  	case 3:  		// 270 degrees' clockwise  		copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  		copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  		break;  	}  	this.preAdjustedImageSourcePoly = new PolyRect (copyPoly);  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (flipRotate % 2 == 1) {  	trueOriginalSize = new Size (state.originalSize.Height' state.originalSize.Width);  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (flipRotate / 4 == 1) {  	copyPoly = PolygonMath.ScalePoints (copyPoly' -1' 1' PointF.Empty);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: switch (flipRotate % 4) {  case 0:  	// no rotation  	// no-op!  	break;  case 1:  	// 90 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  	break;  case 2:  	// 180 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  	break;  case 3:  	// 270 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	break;  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: switch (flipRotate % 4) {  case 0:  	// no rotation  	// no-op!  	break;  case 1:  	// 90 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  	break;  case 2:  	// 180 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  	break;  case 3:  	// 270 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	break;  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: switch (flipRotate % 4) {  case 0:  	// no rotation  	// no-op!  	break;  case 1:  	// 90 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  	break;  case 2:  	// 180 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  	break;  case 3:  	// 270 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	break;  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: switch (flipRotate % 4) {  case 0:  	// no rotation  	// no-op!  	break;  case 1:  	// 90 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  	break;  case 2:  	// 180 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  	break;  case 3:  	// 270 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	break;  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: switch (flipRotate % 4) {  case 0:  	// no rotation  	// no-op!  	break;  case 1:  	// 90 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  	break;  case 2:  	// 180 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  	break;  case 3:  	// 270 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	break;  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: switch (flipRotate % 4) {  case 0:  	// no rotation  	// no-op!  	break;  case 1:  	// 90 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  	break;  case 2:  	// 180 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  	break;  case 3:  	// 270 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	break;  }  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  
Magic Number,ImageResizer.Plugins.DiagnosticJson,PolyRect,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\PolyRect.cs,PolyRect,The following statement contains a magic number: this.rect = points.Length == 4 && points [0].X == this.x && points [0].Y == this.y && points [1].X == right && points [1].Y == this.y && points [2].X == right && points [2].Y == bottom && points [3].X == this.x && points [3].Y == bottom;  
Magic Number,ImageResizer.Plugins.DiagnosticJson,PolyRect,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\PolyRect.cs,PolyRect,The following statement contains a magic number: this.rect = points.Length == 4 && points [0].X == this.x && points [0].Y == this.y && points [1].X == right && points [1].Y == this.y && points [2].X == right && points [2].Y == bottom && points [3].X == this.x && points [3].Y == bottom;  
Magic Number,ImageResizer.Plugins.DiagnosticJson,PolyRect,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\PolyRect.cs,PolyRect,The following statement contains a magic number: this.rect = points.Length == 4 && points [0].X == this.x && points [0].Y == this.y && points [1].X == right && points [1].Y == this.y && points [2].X == right && points [2].Y == bottom && points [3].X == this.x && points [3].Y == bottom;  
Magic Number,ImageResizer.Plugins.DiagnosticJson,PolyRect,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\PolyRect.cs,PolyRect,The following statement contains a magic number: this.rect = points.Length == 4 && points [0].X == this.x && points [0].Y == this.y && points [1].X == right && points [1].Y == this.y && points [2].X == right && points [2].Y == bottom && points [3].X == this.x && points [3].Y == bottom;  
Magic Number,ImageResizer.Plugins.DiagnosticJson,PolyRect,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\PolyRect.cs,PolyRect,The following statement contains a magic number: this.rect = points.Length == 4 && points [0].X == this.x && points [0].Y == this.y && points [1].X == right && points [1].Y == this.y && points [2].X == right && points [2].Y == bottom && points [3].X == this.x && points [3].Y == bottom;  
Missing Default,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,F:\newReposMay17\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following switch statement is missing a default case: switch (flipRotate % 4) {  case 0:  	// no rotation  	// no-op!  	break;  case 1:  	// 90 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -90);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (0' trueOriginalSize.Height));  	break;  case 2:  	// 180 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -180);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' trueOriginalSize.Height));  	break;  case 3:  	// 270 degrees' clockwise  	copyPoly = PolygonMath.RotatePoly (copyPoly' -270);  	copyPoly = PolygonMath.MovePoly (copyPoly' new PointF (trueOriginalSize.Width' 0));  	break;  }  
