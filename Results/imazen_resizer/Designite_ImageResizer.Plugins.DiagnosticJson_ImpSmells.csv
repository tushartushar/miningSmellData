Implementation smell,Namespace,Class,File,Method,Description
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,C:\repos\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null &&                 (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone ||                 !string.IsNullOrEmpty(state.settings["sRotate"])))             {                 // We need to calculate the original rect/poly by *reversing* the                 // requested sFlip/sRotate.  We determine what the requested change                 // was' then calculate the reverse.                 var angle = state.settings.Get<double>("sRotate"' 0);                 var flipRotate = (int)PolygonMath.CombineFlipAndRotate(state.settings.SourceFlip' angle);                 var copyPoly = PolygonMath.ToPoly(state.copyRect);                 var trueOriginalSize = state.originalSize;                  // The RotateFlipType values are ordered such that odd values                 // transpose the size of the rectangle' %4 gives the rotation                 // and /4 (=> 0 or 1) whether there's been an x-flip.  We can                 // use this to streamline our calculations.                 if (flipRotate % 2 == 1)                 {                     trueOriginalSize = new Size(state.originalSize.Height' state.originalSize.Width);                 }                  this.preAdjustedSourceRect = new SizeOnly(trueOriginalSize);                  // Remember that the sFlip/sRotate change performed the rotation                 // first and then the flip' so we have to do the opposite to go                 // backwards.                 if (flipRotate / 4 == 1)                 {                     copyPoly = PolygonMath.ScalePoints(copyPoly' -1' 1' PointF.Empty);                     copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                 }                  // It's possible to calculate a rotation-origin that will place                 // the original pre-sRotate (0'0) point back at (0'0) again...                 // but since it involves sqrt()' there would be rounding errors                 // that we should be able to avoid.  (We might' in fact' want to                 // avoid using PolygonMath entirely' and hand-map the points                 // backwards for accuracy.)                 switch (flipRotate % 4)                 {                     case 0: // no rotation                         // no-op!                         break;                      case 1: // 90 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -90);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(0' trueOriginalSize.Height));                         break;                      case 2: // 180 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -180);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' trueOriginalSize.Height));                         break;                      case 3: // 270 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -270);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                         break;                 }                  this.preAdjustedImageSourcePoly = new PolyRect(copyPoly);             }
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,C:\repos\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null &&                 (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone ||                 !string.IsNullOrEmpty(state.settings["sRotate"])))             {                 // We need to calculate the original rect/poly by *reversing* the                 // requested sFlip/sRotate.  We determine what the requested change                 // was' then calculate the reverse.                 var angle = state.settings.Get<double>("sRotate"' 0);                 var flipRotate = (int)PolygonMath.CombineFlipAndRotate(state.settings.SourceFlip' angle);                 var copyPoly = PolygonMath.ToPoly(state.copyRect);                 var trueOriginalSize = state.originalSize;                  // The RotateFlipType values are ordered such that odd values                 // transpose the size of the rectangle' %4 gives the rotation                 // and /4 (=> 0 or 1) whether there's been an x-flip.  We can                 // use this to streamline our calculations.                 if (flipRotate % 2 == 1)                 {                     trueOriginalSize = new Size(state.originalSize.Height' state.originalSize.Width);                 }                  this.preAdjustedSourceRect = new SizeOnly(trueOriginalSize);                  // Remember that the sFlip/sRotate change performed the rotation                 // first and then the flip' so we have to do the opposite to go                 // backwards.                 if (flipRotate / 4 == 1)                 {                     copyPoly = PolygonMath.ScalePoints(copyPoly' -1' 1' PointF.Empty);                     copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                 }                  // It's possible to calculate a rotation-origin that will place                 // the original pre-sRotate (0'0) point back at (0'0) again...                 // but since it involves sqrt()' there would be rounding errors                 // that we should be able to avoid.  (We might' in fact' want to                 // avoid using PolygonMath entirely' and hand-map the points                 // backwards for accuracy.)                 switch (flipRotate % 4)                 {                     case 0: // no rotation                         // no-op!                         break;                      case 1: // 90 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -90);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(0' trueOriginalSize.Height));                         break;                      case 2: // 180 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -180);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' trueOriginalSize.Height));                         break;                      case 3: // 270 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -270);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                         break;                 }                  this.preAdjustedImageSourcePoly = new PolyRect(copyPoly);             }
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,C:\repos\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null &&                 (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone ||                 !string.IsNullOrEmpty(state.settings["sRotate"])))             {                 // We need to calculate the original rect/poly by *reversing* the                 // requested sFlip/sRotate.  We determine what the requested change                 // was' then calculate the reverse.                 var angle = state.settings.Get<double>("sRotate"' 0);                 var flipRotate = (int)PolygonMath.CombineFlipAndRotate(state.settings.SourceFlip' angle);                 var copyPoly = PolygonMath.ToPoly(state.copyRect);                 var trueOriginalSize = state.originalSize;                  // The RotateFlipType values are ordered such that odd values                 // transpose the size of the rectangle' %4 gives the rotation                 // and /4 (=> 0 or 1) whether there's been an x-flip.  We can                 // use this to streamline our calculations.                 if (flipRotate % 2 == 1)                 {                     trueOriginalSize = new Size(state.originalSize.Height' state.originalSize.Width);                 }                  this.preAdjustedSourceRect = new SizeOnly(trueOriginalSize);                  // Remember that the sFlip/sRotate change performed the rotation                 // first and then the flip' so we have to do the opposite to go                 // backwards.                 if (flipRotate / 4 == 1)                 {                     copyPoly = PolygonMath.ScalePoints(copyPoly' -1' 1' PointF.Empty);                     copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                 }                  // It's possible to calculate a rotation-origin that will place                 // the original pre-sRotate (0'0) point back at (0'0) again...                 // but since it involves sqrt()' there would be rounding errors                 // that we should be able to avoid.  (We might' in fact' want to                 // avoid using PolygonMath entirely' and hand-map the points                 // backwards for accuracy.)                 switch (flipRotate % 4)                 {                     case 0: // no rotation                         // no-op!                         break;                      case 1: // 90 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -90);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(0' trueOriginalSize.Height));                         break;                      case 2: // 180 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -180);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' trueOriginalSize.Height));                         break;                      case 3: // 270 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -270);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                         break;                 }                  this.preAdjustedImageSourcePoly = new PolyRect(copyPoly);             }
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,C:\repos\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null &&                 (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone ||                 !string.IsNullOrEmpty(state.settings["sRotate"])))             {                 // We need to calculate the original rect/poly by *reversing* the                 // requested sFlip/sRotate.  We determine what the requested change                 // was' then calculate the reverse.                 var angle = state.settings.Get<double>("sRotate"' 0);                 var flipRotate = (int)PolygonMath.CombineFlipAndRotate(state.settings.SourceFlip' angle);                 var copyPoly = PolygonMath.ToPoly(state.copyRect);                 var trueOriginalSize = state.originalSize;                  // The RotateFlipType values are ordered such that odd values                 // transpose the size of the rectangle' %4 gives the rotation                 // and /4 (=> 0 or 1) whether there's been an x-flip.  We can                 // use this to streamline our calculations.                 if (flipRotate % 2 == 1)                 {                     trueOriginalSize = new Size(state.originalSize.Height' state.originalSize.Width);                 }                  this.preAdjustedSourceRect = new SizeOnly(trueOriginalSize);                  // Remember that the sFlip/sRotate change performed the rotation                 // first and then the flip' so we have to do the opposite to go                 // backwards.                 if (flipRotate / 4 == 1)                 {                     copyPoly = PolygonMath.ScalePoints(copyPoly' -1' 1' PointF.Empty);                     copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                 }                  // It's possible to calculate a rotation-origin that will place                 // the original pre-sRotate (0'0) point back at (0'0) again...                 // but since it involves sqrt()' there would be rounding errors                 // that we should be able to avoid.  (We might' in fact' want to                 // avoid using PolygonMath entirely' and hand-map the points                 // backwards for accuracy.)                 switch (flipRotate % 4)                 {                     case 0: // no rotation                         // no-op!                         break;                      case 1: // 90 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -90);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(0' trueOriginalSize.Height));                         break;                      case 2: // 180 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -180);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' trueOriginalSize.Height));                         break;                      case 3: // 270 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -270);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                         break;                 }                  this.preAdjustedImageSourcePoly = new PolyRect(copyPoly);             }
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,C:\repos\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null &&                 (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone ||                 !string.IsNullOrEmpty(state.settings["sRotate"])))             {                 // We need to calculate the original rect/poly by *reversing* the                 // requested sFlip/sRotate.  We determine what the requested change                 // was' then calculate the reverse.                 var angle = state.settings.Get<double>("sRotate"' 0);                 var flipRotate = (int)PolygonMath.CombineFlipAndRotate(state.settings.SourceFlip' angle);                 var copyPoly = PolygonMath.ToPoly(state.copyRect);                 var trueOriginalSize = state.originalSize;                  // The RotateFlipType values are ordered such that odd values                 // transpose the size of the rectangle' %4 gives the rotation                 // and /4 (=> 0 or 1) whether there's been an x-flip.  We can                 // use this to streamline our calculations.                 if (flipRotate % 2 == 1)                 {                     trueOriginalSize = new Size(state.originalSize.Height' state.originalSize.Width);                 }                  this.preAdjustedSourceRect = new SizeOnly(trueOriginalSize);                  // Remember that the sFlip/sRotate change performed the rotation                 // first and then the flip' so we have to do the opposite to go                 // backwards.                 if (flipRotate / 4 == 1)                 {                     copyPoly = PolygonMath.ScalePoints(copyPoly' -1' 1' PointF.Empty);                     copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                 }                  // It's possible to calculate a rotation-origin that will place                 // the original pre-sRotate (0'0) point back at (0'0) again...                 // but since it involves sqrt()' there would be rounding errors                 // that we should be able to avoid.  (We might' in fact' want to                 // avoid using PolygonMath entirely' and hand-map the points                 // backwards for accuracy.)                 switch (flipRotate % 4)                 {                     case 0: // no rotation                         // no-op!                         break;                      case 1: // 90 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -90);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(0' trueOriginalSize.Height));                         break;                      case 2: // 180 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -180);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' trueOriginalSize.Height));                         break;                      case 3: // 270 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -270);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                         break;                 }                  this.preAdjustedImageSourcePoly = new PolyRect(copyPoly);             }
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,C:\repos\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null &&                 (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone ||                 !string.IsNullOrEmpty(state.settings["sRotate"])))             {                 // We need to calculate the original rect/poly by *reversing* the                 // requested sFlip/sRotate.  We determine what the requested change                 // was' then calculate the reverse.                 var angle = state.settings.Get<double>("sRotate"' 0);                 var flipRotate = (int)PolygonMath.CombineFlipAndRotate(state.settings.SourceFlip' angle);                 var copyPoly = PolygonMath.ToPoly(state.copyRect);                 var trueOriginalSize = state.originalSize;                  // The RotateFlipType values are ordered such that odd values                 // transpose the size of the rectangle' %4 gives the rotation                 // and /4 (=> 0 or 1) whether there's been an x-flip.  We can                 // use this to streamline our calculations.                 if (flipRotate % 2 == 1)                 {                     trueOriginalSize = new Size(state.originalSize.Height' state.originalSize.Width);                 }                  this.preAdjustedSourceRect = new SizeOnly(trueOriginalSize);                  // Remember that the sFlip/sRotate change performed the rotation                 // first and then the flip' so we have to do the opposite to go                 // backwards.                 if (flipRotate / 4 == 1)                 {                     copyPoly = PolygonMath.ScalePoints(copyPoly' -1' 1' PointF.Empty);                     copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                 }                  // It's possible to calculate a rotation-origin that will place                 // the original pre-sRotate (0'0) point back at (0'0) again...                 // but since it involves sqrt()' there would be rounding errors                 // that we should be able to avoid.  (We might' in fact' want to                 // avoid using PolygonMath entirely' and hand-map the points                 // backwards for accuracy.)                 switch (flipRotate % 4)                 {                     case 0: // no rotation                         // no-op!                         break;                      case 1: // 90 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -90);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(0' trueOriginalSize.Height));                         break;                      case 2: // 180 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -180);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' trueOriginalSize.Height));                         break;                      case 3: // 270 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -270);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                         break;                 }                  this.preAdjustedImageSourcePoly = new PolyRect(copyPoly);             }
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,C:\repos\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null &&                 (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone ||                 !string.IsNullOrEmpty(state.settings["sRotate"])))             {                 // We need to calculate the original rect/poly by *reversing* the                 // requested sFlip/sRotate.  We determine what the requested change                 // was' then calculate the reverse.                 var angle = state.settings.Get<double>("sRotate"' 0);                 var flipRotate = (int)PolygonMath.CombineFlipAndRotate(state.settings.SourceFlip' angle);                 var copyPoly = PolygonMath.ToPoly(state.copyRect);                 var trueOriginalSize = state.originalSize;                  // The RotateFlipType values are ordered such that odd values                 // transpose the size of the rectangle' %4 gives the rotation                 // and /4 (=> 0 or 1) whether there's been an x-flip.  We can                 // use this to streamline our calculations.                 if (flipRotate % 2 == 1)                 {                     trueOriginalSize = new Size(state.originalSize.Height' state.originalSize.Width);                 }                  this.preAdjustedSourceRect = new SizeOnly(trueOriginalSize);                  // Remember that the sFlip/sRotate change performed the rotation                 // first and then the flip' so we have to do the opposite to go                 // backwards.                 if (flipRotate / 4 == 1)                 {                     copyPoly = PolygonMath.ScalePoints(copyPoly' -1' 1' PointF.Empty);                     copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                 }                  // It's possible to calculate a rotation-origin that will place                 // the original pre-sRotate (0'0) point back at (0'0) again...                 // but since it involves sqrt()' there would be rounding errors                 // that we should be able to avoid.  (We might' in fact' want to                 // avoid using PolygonMath entirely' and hand-map the points                 // backwards for accuracy.)                 switch (flipRotate % 4)                 {                     case 0: // no rotation                         // no-op!                         break;                      case 1: // 90 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -90);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(0' trueOriginalSize.Height));                         break;                      case 2: // 180 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -180);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' trueOriginalSize.Height));                         break;                      case 3: // 270 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -270);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                         break;                 }                  this.preAdjustedImageSourcePoly = new PolyRect(copyPoly);             }
Magic Number,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,C:\repos\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following statement contains a magic number: if (state.sourceBitmap != null &&                 (state.settings.SourceFlip != RotateFlipType.RotateNoneFlipNone ||                 !string.IsNullOrEmpty(state.settings["sRotate"])))             {                 // We need to calculate the original rect/poly by *reversing* the                 // requested sFlip/sRotate.  We determine what the requested change                 // was' then calculate the reverse.                 var angle = state.settings.Get<double>("sRotate"' 0);                 var flipRotate = (int)PolygonMath.CombineFlipAndRotate(state.settings.SourceFlip' angle);                 var copyPoly = PolygonMath.ToPoly(state.copyRect);                 var trueOriginalSize = state.originalSize;                  // The RotateFlipType values are ordered such that odd values                 // transpose the size of the rectangle' %4 gives the rotation                 // and /4 (=> 0 or 1) whether there's been an x-flip.  We can                 // use this to streamline our calculations.                 if (flipRotate % 2 == 1)                 {                     trueOriginalSize = new Size(state.originalSize.Height' state.originalSize.Width);                 }                  this.preAdjustedSourceRect = new SizeOnly(trueOriginalSize);                  // Remember that the sFlip/sRotate change performed the rotation                 // first and then the flip' so we have to do the opposite to go                 // backwards.                 if (flipRotate / 4 == 1)                 {                     copyPoly = PolygonMath.ScalePoints(copyPoly' -1' 1' PointF.Empty);                     copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                 }                  // It's possible to calculate a rotation-origin that will place                 // the original pre-sRotate (0'0) point back at (0'0) again...                 // but since it involves sqrt()' there would be rounding errors                 // that we should be able to avoid.  (We might' in fact' want to                 // avoid using PolygonMath entirely' and hand-map the points                 // backwards for accuracy.)                 switch (flipRotate % 4)                 {                     case 0: // no rotation                         // no-op!                         break;                      case 1: // 90 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -90);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(0' trueOriginalSize.Height));                         break;                      case 2: // 180 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -180);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' trueOriginalSize.Height));                         break;                      case 3: // 270 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -270);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                         break;                 }                  this.preAdjustedImageSourcePoly = new PolyRect(copyPoly);             }
Magic Number,ImageResizer.Plugins.DiagnosticJson,PolyRect,C:\repos\imazen_resizer\Plugins\DiagnosticJson\PolyRect.cs,PolyRect,The following statement contains a magic number: this.rect = points.Length == 4 &&                         points[0].X == this.x && points[0].Y == this.y &&                         points[1].X == right && points[1].Y == this.y &&                         points[2].X == right && points[2].Y == bottom &&                         points[3].X == this.x && points[3].Y == bottom;
Magic Number,ImageResizer.Plugins.DiagnosticJson,PolyRect,C:\repos\imazen_resizer\Plugins\DiagnosticJson\PolyRect.cs,PolyRect,The following statement contains a magic number: this.rect = points.Length == 4 &&                         points[0].X == this.x && points[0].Y == this.y &&                         points[1].X == right && points[1].Y == this.y &&                         points[2].X == right && points[2].Y == bottom &&                         points[3].X == this.x && points[3].Y == bottom;
Magic Number,ImageResizer.Plugins.DiagnosticJson,PolyRect,C:\repos\imazen_resizer\Plugins\DiagnosticJson\PolyRect.cs,PolyRect,The following statement contains a magic number: this.rect = points.Length == 4 &&                         points[0].X == this.x && points[0].Y == this.y &&                         points[1].X == right && points[1].Y == this.y &&                         points[2].X == right && points[2].Y == bottom &&                         points[3].X == this.x && points[3].Y == bottom;
Magic Number,ImageResizer.Plugins.DiagnosticJson,PolyRect,C:\repos\imazen_resizer\Plugins\DiagnosticJson\PolyRect.cs,PolyRect,The following statement contains a magic number: this.rect = points.Length == 4 &&                         points[0].X == this.x && points[0].Y == this.y &&                         points[1].X == right && points[1].Y == this.y &&                         points[2].X == right && points[2].Y == bottom &&                         points[3].X == this.x && points[3].Y == bottom;
Magic Number,ImageResizer.Plugins.DiagnosticJson,PolyRect,C:\repos\imazen_resizer\Plugins\DiagnosticJson\PolyRect.cs,PolyRect,The following statement contains a magic number: this.rect = points.Length == 4 &&                         points[0].X == this.x && points[0].Y == this.y &&                         points[1].X == right && points[1].Y == this.y &&                         points[2].X == right && points[2].Y == bottom &&                         points[3].X == this.x && points[3].Y == bottom;
Missing Default,ImageResizer.Plugins.DiagnosticJson,LayoutInformation,C:\repos\imazen_resizer\Plugins\DiagnosticJson\LayoutInformation.cs,LayoutInformation,The following switch statement is missing a default case: switch (flipRotate % 4)                 {                     case 0: // no rotation                         // no-op!                         break;                      case 1: // 90 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -90);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(0' trueOriginalSize.Height));                         break;                      case 2: // 180 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -180);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' trueOriginalSize.Height));                         break;                      case 3: // 270 degrees' clockwise                         copyPoly = PolygonMath.RotatePoly(copyPoly' -270);                         copyPoly = PolygonMath.MovePoly(copyPoly' new PointF(trueOriginalSize.Width' 0));                         break;                 }
