Implementation smell,Namespace,Class,File,Method,Description
Long Method,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Document,The method has 113 lines of code.
Complex Method,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Save,Cyclomatic complexity of the method is 10
Complex Method,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Document,Cyclomatic complexity of the method is 14
Complex Method,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadValue,Cyclomatic complexity of the method is 45
Complex Method,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,Cyclomatic complexity of the method is 19
Complex Method,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,Cyclomatic complexity of the method is 12
Complex Method,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,Endogine.Codecs.Photoshop,PixelData,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\PixelData.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,Endogine.Codecs.Photoshop,PixelData,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\PixelData.cs,ReadPixels,Cyclomatic complexity of the method is 15
Complex Method,Endogine.Codecs.Photoshop,PixelData,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\PixelData.cs,WritePixels,Cyclomatic complexity of the method is 15
Complex Method,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,Cyclomatic complexity of the method is 47
Complex Method,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,Cyclomatic complexity of the method is 11
Complex Method,Endogine.Codecs.Photoshop.LayerResources,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Glow,Cyclomatic complexity of the method is 17
Complex Method,Endogine.Codecs.Photoshop.LayerResources,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Bevel,Cyclomatic complexity of the method is 25
Complex Method,Endogine.Codecs.Photoshop.LayerResources,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Shadow,Cyclomatic complexity of the method is 23
Complex Method,Endogine.Codecs.Photoshop.LayerResources,TypeTool,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\TypeTool.cs,TypeTool,Cyclomatic complexity of the method is 10
Long Parameter List,Endogine.Codecs.Photoshop,PixelData,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\PixelData.cs,PixelData,The method has 5 parameters.
Long Statement,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The length of the statement  "		return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535; " is 126.
Long Statement,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,AddResource,The length of the statement  "	//TODO: check if we already have one of same type! Except for f*cking paths (stupid Adobe)' gotta get special treatment... " is 122.
Long Statement,Endogine.Codecs.Photoshop,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResource.cs,Prepare,The length of the statement  "			// type.ReflectedType; //Because strangely' when type has internal classes' it wraps both of them somehow? e.g. GridGuidesInfo+GridGuide " is 136.
Long Statement,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Write,The length of the statement  "	if (this._mask != null || (this._blendRanges != null && this._blendRanges.Count > 0) || !string.IsNullOrEmpty (this.Name)) { " is 124.
Long Statement,Endogine.Codecs.Photoshop,PixelData,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\PixelData.cs,WritePixels,The length of the statement  "			rleRowLenghs [row] = Endogine.Serialization.RleCodec.EncodeChunk (writer.BaseStream' data' (long)row * this._width' (long)this._width); " is 135.
Long Statement,Endogine.Codecs.Photoshop,Tools,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Tools.cs,SplitImage,The length of the statement  "	ImageResources.GridGuidesInfo guidesInfo = (ImageResources.GridGuidesInfo)psd.GetResource (typeof(ImageResources.GridGuidesInfo)); " is 130.
Complex Conditional,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Write,The conditional expression  "this._mask != null || (this._blendRanges != null && this._blendRanges.Count > 0) || !string.IsNullOrEmpty (this.Name)"  is complex.
Empty Catch Block,Endogine.Codecs.Photoshop.LayerResources,Txt2,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\DivResources.cs,Txt2,The method has an empty catch block.
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: if (bits == 8) {  	int a = (int)base.ReadByte ();  	if (!alpha)  		a = 255;  	return System.Drawing.Color.FromArgb (a' this.ReadByte ()' this.ReadByte ()' this.ReadByte ());  } else {  	this.BaseStream.Position += 2;  	//Always?  	ushort a = ushort.MaxValue;  	if (alpha)  		a = this.ReadUInt16 ();  	ushort r = this.ReadUInt16 ();  	ushort g = this.ReadUInt16 ();  	ushort b = this.ReadUInt16 ();  	return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: if (!alpha)  	a = 255;  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: a = 255;  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: this.BaseStream.Position += 2;  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDColor,The following statement contains a magic number: return System.Drawing.Color.FromArgb ((int)a >> 8' (int)r >> 8' (int)g >> 8' (int)b >> 8);  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDDouble,The following statement contains a magic number: unsafe {  	SwapBytes ((byte*)&val' 8);  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDDouble,The following statement contains a magic number: SwapBytes ((byte*)&val' 8);  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDSingle,The following statement contains a magic number: unsafe {  	SwapBytes ((byte*)&val' 4);  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDSingle,The following statement contains a magic number: SwapBytes ((byte*)&val' 4);  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDUnicodeString,The following statement contains a magic number: for (int i = 0; i < nLength * 2; i++) {  	char c = base.ReadChar ();  	if (i % 2 == 1 && c != 0)  		s += c;  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDUnicodeString,The following statement contains a magic number: for (int i = 0; i < nLength * 2; i++) {  	char c = base.ReadChar ();  	if (i % 2 == 1 && c != 0)  		s += c;  }  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDReader,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDReader.cs,ReadPSDUnicodeString,The following statement contains a magic number: if (i % 2 == 1 && c != 0)  	s += c;  
Magic Number,Endogine.Codecs.Photoshop,BinaryPSDWriter,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\BinaryPSDWriter.cs,WritePSDDouble,The following statement contains a magic number: BinaryReverseReader.SwapBytes ((byte*)&value' 2);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16)  	return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  else if (true || this.Layer.BitsPerPixel == 8)  	return (float)this._data [x + y * this.Layer.Width] / 255;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16)  	return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  else if (true || this.Layer.BitsPerPixel == 8)  	return (float)this._data [x + y * this.Layer.Width] / 255;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16)  	return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  else if (true || this.Layer.BitsPerPixel == 8)  	return (float)this._data [x + y * this.Layer.Width] / 255;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16)  	return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  else if (true || this.Layer.BitsPerPixel == 8)  	return (float)this._data [x + y * this.Layer.Width] / 255;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16)  	return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  else if (true || this.Layer.BitsPerPixel == 8)  	return (float)this._data [x + y * this.Layer.Width] / 255;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16)  	return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  else if (true || this.Layer.BitsPerPixel == 8)  	return (float)this._data [x + y * this.Layer.Width] / 255;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16)  	return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  else if (true || this.Layer.BitsPerPixel == 8)  	return (float)this._data [x + y * this.Layer.Width] / 255;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: return (float)(((int)this._data [x + y * this.Layer.Width * 2]) << 8 + this._data [x + y * this.Layer.Width * 2 + 1]) / 65535;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: if (true || this.Layer.BitsPerPixel == 8)  	return (float)this._data [x + y * this.Layer.Width] / 255;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: if (true || this.Layer.BitsPerPixel == 8)  	return (float)this._data [x + y * this.Layer.Width] / 255;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,GetPixel,The following statement contains a magic number: return (float)this._data [x + y * this.Layer.Width] / 255;  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16) {  	ushort val = (ushort)(value * 65535);  	this._data [x + y * this.Layer.Width * 2] = (byte)(val >> 8);  	this._data [x + y * this.Layer.Width * 2 + 1] = (byte)(val & 255);  } else if (true || this.Layer.BitsPerPixel == 8)  	this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16) {  	ushort val = (ushort)(value * 65535);  	this._data [x + y * this.Layer.Width * 2] = (byte)(val >> 8);  	this._data [x + y * this.Layer.Width * 2 + 1] = (byte)(val & 255);  } else if (true || this.Layer.BitsPerPixel == 8)  	this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16) {  	ushort val = (ushort)(value * 65535);  	this._data [x + y * this.Layer.Width * 2] = (byte)(val >> 8);  	this._data [x + y * this.Layer.Width * 2 + 1] = (byte)(val & 255);  } else if (true || this.Layer.BitsPerPixel == 8)  	this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16) {  	ushort val = (ushort)(value * 65535);  	this._data [x + y * this.Layer.Width * 2] = (byte)(val >> 8);  	this._data [x + y * this.Layer.Width * 2 + 1] = (byte)(val & 255);  } else if (true || this.Layer.BitsPerPixel == 8)  	this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16) {  	ushort val = (ushort)(value * 65535);  	this._data [x + y * this.Layer.Width * 2] = (byte)(val >> 8);  	this._data [x + y * this.Layer.Width * 2 + 1] = (byte)(val & 255);  } else if (true || this.Layer.BitsPerPixel == 8)  	this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16) {  	ushort val = (ushort)(value * 65535);  	this._data [x + y * this.Layer.Width * 2] = (byte)(val >> 8);  	this._data [x + y * this.Layer.Width * 2 + 1] = (byte)(val & 255);  } else if (true || this.Layer.BitsPerPixel == 8)  	this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16) {  	ushort val = (ushort)(value * 65535);  	this._data [x + y * this.Layer.Width * 2] = (byte)(val >> 8);  	this._data [x + y * this.Layer.Width * 2 + 1] = (byte)(val & 255);  } else if (true || this.Layer.BitsPerPixel == 8)  	this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: if (this.Layer.BitsPerPixel == 16) {  	ushort val = (ushort)(value * 65535);  	this._data [x + y * this.Layer.Width * 2] = (byte)(val >> 8);  	this._data [x + y * this.Layer.Width * 2 + 1] = (byte)(val & 255);  } else if (true || this.Layer.BitsPerPixel == 8)  	this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: this._data [x + y * this.Layer.Width * 2] = (byte)(val >> 8);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: this._data [x + y * this.Layer.Width * 2] = (byte)(val >> 8);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: this._data [x + y * this.Layer.Width * 2 + 1] = (byte)(val & 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: this._data [x + y * this.Layer.Width * 2 + 1] = (byte)(val & 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: if (true || this.Layer.BitsPerPixel == 8)  	this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: if (true || this.Layer.BitsPerPixel == 8)  	this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Channel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Channel.cs,SetPixel,The following statement contains a magic number: this._data [x + y * this.Layer.Width] = (byte)(value * 255);  
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,SaveXml,The following statement contains a magic number: if (saveChannels) {  	bool useRgbPng = (this._header.ColorMode == ColorModes.RGB && this._header.BitsPerPixel == 8);  	//useRgbPng = false;  	FileInfo fi = new FileInfo (filename);  	string path = fi.Directory.FullName + "\\" + fi.Name + "_Bitmaps\\";  	Directory.CreateDirectory (path);  	foreach (Layer layer in this._layers) {  		if (useRgbPng) {  			Bitmap bmp = layer.Bitmap;  			if (bmp == null)  				continue;  			BitmapHelpers.BitmapHelper.Save (bmp' path + layer.Name + ".png");  		} else {  			foreach (KeyValuePair<int' Channel> kv in layer.Channels) {  				Bitmap bmp = kv.Value.Bitmap;  				BitmapHelpers.BitmapHelper.Save (bmp' path + layer.Name + "_Channel_" + kv.Key + ".png");  			}  		}  	}  }  
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Save,The following statement contains a magic number: writer.StartLengthBlock (typeof(uint)' 4);  
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Save,The following statement contains a magic number: writer.PadToNextMultiple (4);  
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Document,The following statement contains a magic number: if (nPaletteLength > 0) {  	this.ColorTable = new List<Color> ();  	for (int i = 0; i < nPaletteLength; i += 3) {  		this.ColorTable.Add (Color.FromArgb ((int)reader.ReadByte ()' (int)reader.ReadByte ()' (int)reader.ReadByte ()));  	}  	//this.ColorTable.Add(Color.FromArgb(255' 10' 20));  	if (this.ColorMode == ColorModes.Duotone) {  	} else {  	}  }  
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Document,The following statement contains a magic number: for (int i = 0; i < nPaletteLength; i += 3) {  	this.ColorTable.Add (Color.FromArgb ((int)reader.ReadByte ()' (int)reader.ReadByte ()' (int)reader.ReadByte ()));  }  
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Document,The following statement contains a magic number: i += 3
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Document,The following statement contains a magic number: if (nTotalLayersBytes == 8) {  	stream.Position += nTotalLayersBytes;  	//this.Unknown = Endogine.Serialization.ReadableBinary.CreateHexEditorString(reader.ReadBytes((int)reader.BytesToEnd));  } else {  	uint nSize = reader.ReadUInt32 ();  	//What's the difference between nTotalLayersBytes and nSize really?  	long nLayersEndPos = reader.BaseStream.Position + nSize;  	short nNumLayers = reader.ReadInt16 ();  	bool bSkipFirstAlpha = false;  	if (nNumLayers < 0) {  		bSkipFirstAlpha = true;  		nNumLayers = (short)-nNumLayers;  	}  	List<Layer> loadOrderLayers = new List<Layer> ();  	this._layers = new List<Layer> ();  	// new Dictionary<int' Layer>();  	for (int nLayerNum = 0; nLayerNum < nNumLayers; nLayerNum++) {  		Layer layerInfo = new Layer (reader' this);  		layerInfo.DebugLayerLoadOrdinal = nLayerNum;  		//if (layerInfo.LayerID < 0)  		//    layerInfo.LayerID = nLayerNum;  		//if (this._layers.ContainsKey(layerInfo.LayerID))  		//    throw(new Exception("Duplicate layer IDs! " + layerInfo.LayerID.ToString()));  		//else  		//    this._layers.Add(layerInfo.LayerID' layerInfo);  		this._layers.Add (layerInfo);  		loadOrderLayers.Add (layerInfo);  	}  	for (int layerNum = 0; layerNum < nNumLayers; layerNum++) {  		Layer layer = (Layer)loadOrderLayers [layerNum];  		layer.ReadPixels (reader);  	}  	reader.JumpToEvenNthByte (4);  	if (reader.BaseStream.Position != nLayersEndPos)  		reader.BaseStream.Position = nLayersEndPos;  	// nAfterLayersDefinitions;  	//Global layer mask  	uint maskLength = reader.ReadUInt32 ();  	this._tempGlobalLayerMask = null;  	if (maskLength > 0) {  		this._tempGlobalLayerMask = reader.ReadBytes ((int)maskLength);  		//TODO: the docs are obviously wrong here...  		//ushort overlayColorSpace = reader.ReadUInt16(); //undefined in docs  		//for (int i = 0; i < 4; i++)   		//    reader.ReadUInt16(); //TODO: UInt16 if 16-bit color? Color components - says *both* 4*2 bytes' and 8 bytes in the docs?  		//reader.ReadUInt16(); //opacity (0-100)  		//reader.ReadByte(); //Kind: 0=Color selectedi.e. inverted; 1=Color protected;128=use value stored per layer.  		//reader.ReadByte(); //padding  	}  	//hmm... another section of "global" layer resources..?  	while (true) {  		long cpPos = reader.BaseStream.Position;  		string sHeader = new string (reader.ReadPSDChars (4));  		reader.BaseStream.Position = cpPos;  		//TODO: -= 4 should work' but sometimes ReadPSDChars advances 5?!?!  		if (sHeader != "8BIM") {  			break;  		}  		LayerResource res = LayerResource.ReadLayerResource (reader' null);  		this._globalLayerResources.Add (res);  	}  }  
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Document,The following statement contains a magic number: if (nTotalLayersBytes == 8) {  	stream.Position += nTotalLayersBytes;  	//this.Unknown = Endogine.Serialization.ReadableBinary.CreateHexEditorString(reader.ReadBytes((int)reader.BytesToEnd));  } else {  	uint nSize = reader.ReadUInt32 ();  	//What's the difference between nTotalLayersBytes and nSize really?  	long nLayersEndPos = reader.BaseStream.Position + nSize;  	short nNumLayers = reader.ReadInt16 ();  	bool bSkipFirstAlpha = false;  	if (nNumLayers < 0) {  		bSkipFirstAlpha = true;  		nNumLayers = (short)-nNumLayers;  	}  	List<Layer> loadOrderLayers = new List<Layer> ();  	this._layers = new List<Layer> ();  	// new Dictionary<int' Layer>();  	for (int nLayerNum = 0; nLayerNum < nNumLayers; nLayerNum++) {  		Layer layerInfo = new Layer (reader' this);  		layerInfo.DebugLayerLoadOrdinal = nLayerNum;  		//if (layerInfo.LayerID < 0)  		//    layerInfo.LayerID = nLayerNum;  		//if (this._layers.ContainsKey(layerInfo.LayerID))  		//    throw(new Exception("Duplicate layer IDs! " + layerInfo.LayerID.ToString()));  		//else  		//    this._layers.Add(layerInfo.LayerID' layerInfo);  		this._layers.Add (layerInfo);  		loadOrderLayers.Add (layerInfo);  	}  	for (int layerNum = 0; layerNum < nNumLayers; layerNum++) {  		Layer layer = (Layer)loadOrderLayers [layerNum];  		layer.ReadPixels (reader);  	}  	reader.JumpToEvenNthByte (4);  	if (reader.BaseStream.Position != nLayersEndPos)  		reader.BaseStream.Position = nLayersEndPos;  	// nAfterLayersDefinitions;  	//Global layer mask  	uint maskLength = reader.ReadUInt32 ();  	this._tempGlobalLayerMask = null;  	if (maskLength > 0) {  		this._tempGlobalLayerMask = reader.ReadBytes ((int)maskLength);  		//TODO: the docs are obviously wrong here...  		//ushort overlayColorSpace = reader.ReadUInt16(); //undefined in docs  		//for (int i = 0; i < 4; i++)   		//    reader.ReadUInt16(); //TODO: UInt16 if 16-bit color? Color components - says *both* 4*2 bytes' and 8 bytes in the docs?  		//reader.ReadUInt16(); //opacity (0-100)  		//reader.ReadByte(); //Kind: 0=Color selectedi.e. inverted; 1=Color protected;128=use value stored per layer.  		//reader.ReadByte(); //padding  	}  	//hmm... another section of "global" layer resources..?  	while (true) {  		long cpPos = reader.BaseStream.Position;  		string sHeader = new string (reader.ReadPSDChars (4));  		reader.BaseStream.Position = cpPos;  		//TODO: -= 4 should work' but sometimes ReadPSDChars advances 5?!?!  		if (sHeader != "8BIM") {  			break;  		}  		LayerResource res = LayerResource.ReadLayerResource (reader' null);  		this._globalLayerResources.Add (res);  	}  }  
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Document,The following statement contains a magic number: if (nTotalLayersBytes == 8) {  	stream.Position += nTotalLayersBytes;  	//this.Unknown = Endogine.Serialization.ReadableBinary.CreateHexEditorString(reader.ReadBytes((int)reader.BytesToEnd));  } else {  	uint nSize = reader.ReadUInt32 ();  	//What's the difference between nTotalLayersBytes and nSize really?  	long nLayersEndPos = reader.BaseStream.Position + nSize;  	short nNumLayers = reader.ReadInt16 ();  	bool bSkipFirstAlpha = false;  	if (nNumLayers < 0) {  		bSkipFirstAlpha = true;  		nNumLayers = (short)-nNumLayers;  	}  	List<Layer> loadOrderLayers = new List<Layer> ();  	this._layers = new List<Layer> ();  	// new Dictionary<int' Layer>();  	for (int nLayerNum = 0; nLayerNum < nNumLayers; nLayerNum++) {  		Layer layerInfo = new Layer (reader' this);  		layerInfo.DebugLayerLoadOrdinal = nLayerNum;  		//if (layerInfo.LayerID < 0)  		//    layerInfo.LayerID = nLayerNum;  		//if (this._layers.ContainsKey(layerInfo.LayerID))  		//    throw(new Exception("Duplicate layer IDs! " + layerInfo.LayerID.ToString()));  		//else  		//    this._layers.Add(layerInfo.LayerID' layerInfo);  		this._layers.Add (layerInfo);  		loadOrderLayers.Add (layerInfo);  	}  	for (int layerNum = 0; layerNum < nNumLayers; layerNum++) {  		Layer layer = (Layer)loadOrderLayers [layerNum];  		layer.ReadPixels (reader);  	}  	reader.JumpToEvenNthByte (4);  	if (reader.BaseStream.Position != nLayersEndPos)  		reader.BaseStream.Position = nLayersEndPos;  	// nAfterLayersDefinitions;  	//Global layer mask  	uint maskLength = reader.ReadUInt32 ();  	this._tempGlobalLayerMask = null;  	if (maskLength > 0) {  		this._tempGlobalLayerMask = reader.ReadBytes ((int)maskLength);  		//TODO: the docs are obviously wrong here...  		//ushort overlayColorSpace = reader.ReadUInt16(); //undefined in docs  		//for (int i = 0; i < 4; i++)   		//    reader.ReadUInt16(); //TODO: UInt16 if 16-bit color? Color components - says *both* 4*2 bytes' and 8 bytes in the docs?  		//reader.ReadUInt16(); //opacity (0-100)  		//reader.ReadByte(); //Kind: 0=Color selectedi.e. inverted; 1=Color protected;128=use value stored per layer.  		//reader.ReadByte(); //padding  	}  	//hmm... another section of "global" layer resources..?  	while (true) {  		long cpPos = reader.BaseStream.Position;  		string sHeader = new string (reader.ReadPSDChars (4));  		reader.BaseStream.Position = cpPos;  		//TODO: -= 4 should work' but sometimes ReadPSDChars advances 5?!?!  		if (sHeader != "8BIM") {  			break;  		}  		LayerResource res = LayerResource.ReadLayerResource (reader' null);  		this._globalLayerResources.Add (res);  	}  }  
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Document,The following statement contains a magic number: reader.JumpToEvenNthByte (4);  
Magic Number,Endogine.Codecs.Photoshop,Document,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Document.cs,Document,The following statement contains a magic number: while (true) {  	long cpPos = reader.BaseStream.Position;  	string sHeader = new string (reader.ReadPSDChars (4));  	reader.BaseStream.Position = cpPos;  	//TODO: -= 4 should work' but sometimes ReadPSDChars advances 5?!?!  	if (sHeader != "8BIM") {  		break;  	}  	LayerResource res = LayerResource.ReadLayerResource (reader' null);  	this._globalLayerResources.Add (res);  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,DynVal,The following statement contains a magic number: if (asDescriptor) {  	uint version = r.ReadUInt32 ();  	string unknown = Endogine.Serialization.ReadableBinary.CreateHexEditorString (r.ReadBytes (6));  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadSpecialString,The following statement contains a magic number: if (length == 0)  	length = 4;  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadSpecialString,The following statement contains a magic number: length = 4;  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadValue,The following statement contains a magic number: switch (type) {  case "tdta":  	vt.Value = Endogine.Serialization.ReadableBinary.CreateHexEditorString (r.ReadBytes (9));  	vt.Children = new List<DynVal> ();  	while (true) {  		DynVal child = new DynVal ();  		vt.Children.Add (child);  		if (child.ReadTdtaItem (r) == false)  			break;  	}  	//r.BaseStream.Position += 9;  	break;  case "Objc":  //Decriptor  case "GlbO":  	//GlobalObject (same)  	string uniName = r.ReadPSDUnicodeString ();  	//uint numSub = r.ReadUInt32();  	//if (numSub > 1)  	//{  	//    //A unicode text here!? What does this have to do with numSub??  	//    r.BaseStream.Position -= 4;  	//    r.ReadPSDUnicodeString();  	//    r.BaseStream.Position -= 2; //Ehh... What?!  	//}  	////TODO: ah: 1 = 1 short = unknown...  	//ushort unknown = r.ReadUInt16();  	//vt.Children = ReadValues(r);  	vt = new DynVal (r' false);  	if (uniName.Length > 0)  		vt.UnicodeName = uniName;  	break;  case "VlLs":  	//List  	vt.Children = new List<DynVal> ();  	int numValues = (int)r.ReadUInt32 ();  	for (int i = 0; i < numValues; i++) {  		DynVal ob = ReadValue (r' true);  		if (ob != null)  			vt.Children.Add (ob);  	}  	break;  case "doub":  	vt.Value = r.ReadPSDDouble ();  	break;  case "UntF":  	//Unif float  	//TODO: need a specific type for this' with a double and a type (percent/pixel)?  	string tst = GetMeaningOfFourCC (new string (r.ReadPSDChars (4)));  	//#Prc #Pxl #Ang = percent / pixels / angle?  	double d = r.ReadPSDDouble ();  	tst += ": " + d;  	vt.Value = tst;  	break;  case "enum":  	string namesp = ReadSpecialString (r);  	string item = ReadSpecialString (r);  	//vt.Value = namesp + "." + item; //TODO: cast to real enum  	vt.Value = GetMeaningOfFourCC (namesp) + "." + GetMeaningOfFourCC (item);  	break;  case "long":  	vt.Value = r.ReadInt32 ();  	//64?  	break;  case "bool":  	vt.Value = r.ReadBoolean ();  	break;  //case "obj ": //reference  //    break;  case "TEXT":  	vt.Value = r.ReadPSDUnicodeString ();  	break;  //case "Enmr": //Enumerated  //    break;  //case "Clss": //Class  //    break;  //case "GlbC": //GlobalClass  //    break;  //case "alis": //Alias  //    break;  default:  	throw new Exception ("Unknown type: " + type);  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadValue,The following statement contains a magic number: switch (type) {  case "tdta":  	vt.Value = Endogine.Serialization.ReadableBinary.CreateHexEditorString (r.ReadBytes (9));  	vt.Children = new List<DynVal> ();  	while (true) {  		DynVal child = new DynVal ();  		vt.Children.Add (child);  		if (child.ReadTdtaItem (r) == false)  			break;  	}  	//r.BaseStream.Position += 9;  	break;  case "Objc":  //Decriptor  case "GlbO":  	//GlobalObject (same)  	string uniName = r.ReadPSDUnicodeString ();  	//uint numSub = r.ReadUInt32();  	//if (numSub > 1)  	//{  	//    //A unicode text here!? What does this have to do with numSub??  	//    r.BaseStream.Position -= 4;  	//    r.ReadPSDUnicodeString();  	//    r.BaseStream.Position -= 2; //Ehh... What?!  	//}  	////TODO: ah: 1 = 1 short = unknown...  	//ushort unknown = r.ReadUInt16();  	//vt.Children = ReadValues(r);  	vt = new DynVal (r' false);  	if (uniName.Length > 0)  		vt.UnicodeName = uniName;  	break;  case "VlLs":  	//List  	vt.Children = new List<DynVal> ();  	int numValues = (int)r.ReadUInt32 ();  	for (int i = 0; i < numValues; i++) {  		DynVal ob = ReadValue (r' true);  		if (ob != null)  			vt.Children.Add (ob);  	}  	break;  case "doub":  	vt.Value = r.ReadPSDDouble ();  	break;  case "UntF":  	//Unif float  	//TODO: need a specific type for this' with a double and a type (percent/pixel)?  	string tst = GetMeaningOfFourCC (new string (r.ReadPSDChars (4)));  	//#Prc #Pxl #Ang = percent / pixels / angle?  	double d = r.ReadPSDDouble ();  	tst += ": " + d;  	vt.Value = tst;  	break;  case "enum":  	string namesp = ReadSpecialString (r);  	string item = ReadSpecialString (r);  	//vt.Value = namesp + "." + item; //TODO: cast to real enum  	vt.Value = GetMeaningOfFourCC (namesp) + "." + GetMeaningOfFourCC (item);  	break;  case "long":  	vt.Value = r.ReadInt32 ();  	//64?  	break;  case "bool":  	vt.Value = r.ReadBoolean ();  	break;  //case "obj ": //reference  //    break;  case "TEXT":  	vt.Value = r.ReadPSDUnicodeString ();  	break;  //case "Enmr": //Enumerated  //    break;  //case "Clss": //Class  //    break;  //case "GlbC": //GlobalClass  //    break;  //case "alis": //Alias  //    break;  default:  	throw new Exception ("Unknown type: " + type);  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadValue,The following statement contains a magic number: vt.Value = Endogine.Serialization.ReadableBinary.CreateHexEditorString (r.ReadBytes (9));  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: while (r.BytesToEnd > 0) {  	byte b = r.ReadByte ();  	buffer [bufPos++] = b;  	if (b == 0x2f)  		// slash "/" seems to be the field delimiter  		break;  	if (b <= 0x00) {  		nearEndCnt++;  		if (nearEndCnt == 12)  			break;  	} else  		nearEndCnt = 0;  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (b <= 0x00) {  	nearEndCnt++;  	if (nearEndCnt == 12)  		break;  } else  	nearEndCnt = 0;  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (nearEndCnt == 12)  	break;  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (this.Name.Contains (" ")) {  	int index = this.Name.IndexOf (" ");  	string val = this.Name.Substring (index + 1);  	//Sometimes it's a unicode string (how do I know..? seems to always have parenthesis) Ugly shortcut:  	if (val [0] == '(' && val [val.Length - 1] == ')') {  		bool unicode = true;  		for (int i = 0; i < val.Length; i++)  			if (val [i] != 0 && val [i] <= 31) {  				unicode = false;  				break;  			}  		if (unicode) {  			string uniVal = "";  			for (int i = 2; i < val.Length; i += 2)  				uniVal += val [i];  			val = uniVal;  		} else {  			byte[] tmp = new byte[val.Length];  			int i = 0;  			foreach (char ch in val)  				tmp [i++] = (byte)ch;  			val = Endogine.Serialization.ReadableBinary.CreateHexEditorString (tmp).Replace ("\r\n"' " ");  		}  	}  	this.Value = val;  	this.Name = this.Name.Remove (index);  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (this.Name.Contains (" ")) {  	int index = this.Name.IndexOf (" ");  	string val = this.Name.Substring (index + 1);  	//Sometimes it's a unicode string (how do I know..? seems to always have parenthesis) Ugly shortcut:  	if (val [0] == '(' && val [val.Length - 1] == ')') {  		bool unicode = true;  		for (int i = 0; i < val.Length; i++)  			if (val [i] != 0 && val [i] <= 31) {  				unicode = false;  				break;  			}  		if (unicode) {  			string uniVal = "";  			for (int i = 2; i < val.Length; i += 2)  				uniVal += val [i];  			val = uniVal;  		} else {  			byte[] tmp = new byte[val.Length];  			int i = 0;  			foreach (char ch in val)  				tmp [i++] = (byte)ch;  			val = Endogine.Serialization.ReadableBinary.CreateHexEditorString (tmp).Replace ("\r\n"' " ");  		}  	}  	this.Value = val;  	this.Name = this.Name.Remove (index);  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (this.Name.Contains (" ")) {  	int index = this.Name.IndexOf (" ");  	string val = this.Name.Substring (index + 1);  	//Sometimes it's a unicode string (how do I know..? seems to always have parenthesis) Ugly shortcut:  	if (val [0] == '(' && val [val.Length - 1] == ')') {  		bool unicode = true;  		for (int i = 0; i < val.Length; i++)  			if (val [i] != 0 && val [i] <= 31) {  				unicode = false;  				break;  			}  		if (unicode) {  			string uniVal = "";  			for (int i = 2; i < val.Length; i += 2)  				uniVal += val [i];  			val = uniVal;  		} else {  			byte[] tmp = new byte[val.Length];  			int i = 0;  			foreach (char ch in val)  				tmp [i++] = (byte)ch;  			val = Endogine.Serialization.ReadableBinary.CreateHexEditorString (tmp).Replace ("\r\n"' " ");  		}  	}  	this.Value = val;  	this.Name = this.Name.Remove (index);  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (val [0] == '(' && val [val.Length - 1] == ')') {  	bool unicode = true;  	for (int i = 0; i < val.Length; i++)  		if (val [i] != 0 && val [i] <= 31) {  			unicode = false;  			break;  		}  	if (unicode) {  		string uniVal = "";  		for (int i = 2; i < val.Length; i += 2)  			uniVal += val [i];  		val = uniVal;  	} else {  		byte[] tmp = new byte[val.Length];  		int i = 0;  		foreach (char ch in val)  			tmp [i++] = (byte)ch;  		val = Endogine.Serialization.ReadableBinary.CreateHexEditorString (tmp).Replace ("\r\n"' " ");  	}  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (val [0] == '(' && val [val.Length - 1] == ')') {  	bool unicode = true;  	for (int i = 0; i < val.Length; i++)  		if (val [i] != 0 && val [i] <= 31) {  			unicode = false;  			break;  		}  	if (unicode) {  		string uniVal = "";  		for (int i = 2; i < val.Length; i += 2)  			uniVal += val [i];  		val = uniVal;  	} else {  		byte[] tmp = new byte[val.Length];  		int i = 0;  		foreach (char ch in val)  			tmp [i++] = (byte)ch;  		val = Endogine.Serialization.ReadableBinary.CreateHexEditorString (tmp).Replace ("\r\n"' " ");  	}  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (val [0] == '(' && val [val.Length - 1] == ')') {  	bool unicode = true;  	for (int i = 0; i < val.Length; i++)  		if (val [i] != 0 && val [i] <= 31) {  			unicode = false;  			break;  		}  	if (unicode) {  		string uniVal = "";  		for (int i = 2; i < val.Length; i += 2)  			uniVal += val [i];  		val = uniVal;  	} else {  		byte[] tmp = new byte[val.Length];  		int i = 0;  		foreach (char ch in val)  			tmp [i++] = (byte)ch;  		val = Endogine.Serialization.ReadableBinary.CreateHexEditorString (tmp).Replace ("\r\n"' " ");  	}  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: for (int i = 0; i < val.Length; i++)  	if (val [i] != 0 && val [i] <= 31) {  		unicode = false;  		break;  	}  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (val [i] != 0 && val [i] <= 31) {  	unicode = false;  	break;  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (unicode) {  	string uniVal = "";  	for (int i = 2; i < val.Length; i += 2)  		uniVal += val [i];  	val = uniVal;  } else {  	byte[] tmp = new byte[val.Length];  	int i = 0;  	foreach (char ch in val)  		tmp [i++] = (byte)ch;  	val = Endogine.Serialization.ReadableBinary.CreateHexEditorString (tmp).Replace ("\r\n"' " ");  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: if (unicode) {  	string uniVal = "";  	for (int i = 2; i < val.Length; i += 2)  		uniVal += val [i];  	val = uniVal;  } else {  	byte[] tmp = new byte[val.Length];  	int i = 0;  	foreach (char ch in val)  		tmp [i++] = (byte)ch;  	val = Endogine.Serialization.ReadableBinary.CreateHexEditorString (tmp).Replace ("\r\n"' " ");  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: for (int i = 2; i < val.Length; i += 2)  	uniVal += val [i];  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: for (int i = 2; i < val.Length; i += 2)  	uniVal += val [i];  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,ReadTdtaItem,The following statement contains a magic number: i += 2
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,GetMeaningOfFourCC,The following statement contains a magic number: if (fourCC.Length != 4)  	return fourCC;  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,LoadFourCC,The following statement contains a magic number: foreach (string line in lines) {  	string[] items = line.Split ('\t');  	if (items.Length <= 1)  		continue;  	if (items [1].Length == 0)  		continue;  	string name = items [0].Substring (2);  	foreach (string prefix in prefixes) {  		if (name.StartsWith (prefix)) {  			name = name.Substring (prefix.Length);  			break;  		}  	}  	FourCCs.Add (items [1].PadRight (4' ' ')' name);  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,LoadFourCC,The following statement contains a magic number: foreach (string line in lines) {  	string[] items = line.Split ('\t');  	if (items.Length <= 1)  		continue;  	if (items [1].Length == 0)  		continue;  	string name = items [0].Substring (2);  	foreach (string prefix in prefixes) {  		if (name.StartsWith (prefix)) {  			name = name.Substring (prefix.Length);  			break;  		}  	}  	FourCCs.Add (items [1].PadRight (4' ' ')' name);  }  
Magic Number,Endogine.Codecs.Photoshop,DynVal,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\DynVal.cs,LoadFourCC,The following statement contains a magic number: FourCCs.Add (items [1].PadRight (4' ' ')' name);  
Magic Number,Endogine.Codecs.Photoshop,EffectBase,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\EffectBase.cs,ReadBlendKey,The following statement contains a magic number: return new string (r.ReadPSDChars (4));  
Magic Number,Endogine.Codecs.Photoshop,Header,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Header.cs,Header,The following statement contains a magic number: reader.Read (buf' (int)reader.BaseStream.Position' 6);  
Magic Number,Endogine.Codecs.Photoshop,Header,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Header.cs,Write,The following statement contains a magic number: for (int i = 0; i < 6; i++)  	writer.Write ((byte)0);  
Magic Number,Endogine.Codecs.Photoshop,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResource.cs,ImageResource,The following statement contains a magic number: if (reader.BaseStream.Position % 2 == 1)  	reader.ReadByte ();  
Magic Number,Endogine.Codecs.Photoshop,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResource.cs,Write,The following statement contains a magic number: writer.PadToNextMultiple (2);  
Magic Number,Endogine.Codecs.Photoshop,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResource.cs,ReadImageResources,The following statement contains a magic number: while (true) {  	long nBefore = reader.BaseStream.Position;  	string settingSignature = new string (reader.ReadPSDChars (4));  	if (settingSignature != "8BIM") {  		reader.BaseStream.Position = nBefore;  		//reader.BaseStream.Position-=4;  		break;  	}  	ImageResource imgRes = new ImageResource (reader);  	ResourceIDs resID = (ResourceIDs)imgRes.ID;  	if (!Enum.IsDefined (typeof(ResourceIDs)' (int)imgRes.ID)) {  		if (imgRes.ID > 2000 && imgRes.ID <= 2999) {  			//Stupid Adobe engineers... This is SO not using the same pattern as everything else!!!  			resID = ResourceIDs.PathInfo;  		}  	}  	if (ResourceTypes.ContainsKey (resID)) {  		Type type = ResourceTypes [resID];  		System.Reflection.ConstructorInfo ci = type.GetConstructor (new Type[] {  			typeof(ImageResource)  		});  		imgRes = (ImageResource)ci.Invoke (new object[] {  			imgRes  		});  	}  	//if (resID != ResourceIDs.Undefined)  	result.Add (imgRes);  }  
Magic Number,Endogine.Codecs.Photoshop,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResource.cs,ReadImageResources,The following statement contains a magic number: while (true) {  	long nBefore = reader.BaseStream.Position;  	string settingSignature = new string (reader.ReadPSDChars (4));  	if (settingSignature != "8BIM") {  		reader.BaseStream.Position = nBefore;  		//reader.BaseStream.Position-=4;  		break;  	}  	ImageResource imgRes = new ImageResource (reader);  	ResourceIDs resID = (ResourceIDs)imgRes.ID;  	if (!Enum.IsDefined (typeof(ResourceIDs)' (int)imgRes.ID)) {  		if (imgRes.ID > 2000 && imgRes.ID <= 2999) {  			//Stupid Adobe engineers... This is SO not using the same pattern as everything else!!!  			resID = ResourceIDs.PathInfo;  		}  	}  	if (ResourceTypes.ContainsKey (resID)) {  		Type type = ResourceTypes [resID];  		System.Reflection.ConstructorInfo ci = type.GetConstructor (new Type[] {  			typeof(ImageResource)  		});  		imgRes = (ImageResource)ci.Invoke (new object[] {  			imgRes  		});  	}  	//if (resID != ResourceIDs.Undefined)  	result.Add (imgRes);  }  
Magic Number,Endogine.Codecs.Photoshop,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResource.cs,ReadImageResources,The following statement contains a magic number: while (true) {  	long nBefore = reader.BaseStream.Position;  	string settingSignature = new string (reader.ReadPSDChars (4));  	if (settingSignature != "8BIM") {  		reader.BaseStream.Position = nBefore;  		//reader.BaseStream.Position-=4;  		break;  	}  	ImageResource imgRes = new ImageResource (reader);  	ResourceIDs resID = (ResourceIDs)imgRes.ID;  	if (!Enum.IsDefined (typeof(ResourceIDs)' (int)imgRes.ID)) {  		if (imgRes.ID > 2000 && imgRes.ID <= 2999) {  			//Stupid Adobe engineers... This is SO not using the same pattern as everything else!!!  			resID = ResourceIDs.PathInfo;  		}  	}  	if (ResourceTypes.ContainsKey (resID)) {  		Type type = ResourceTypes [resID];  		System.Reflection.ConstructorInfo ci = type.GetConstructor (new Type[] {  			typeof(ImageResource)  		});  		imgRes = (ImageResource)ci.Invoke (new object[] {  			imgRes  		});  	}  	//if (resID != ResourceIDs.Undefined)  	result.Add (imgRes);  }  
Magic Number,Endogine.Codecs.Photoshop,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResource.cs,ReadImageResources,The following statement contains a magic number: if (!Enum.IsDefined (typeof(ResourceIDs)' (int)imgRes.ID)) {  	if (imgRes.ID > 2000 && imgRes.ID <= 2999) {  		//Stupid Adobe engineers... This is SO not using the same pattern as everything else!!!  		resID = ResourceIDs.PathInfo;  	}  }  
Magic Number,Endogine.Codecs.Photoshop,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResource.cs,ReadImageResources,The following statement contains a magic number: if (!Enum.IsDefined (typeof(ResourceIDs)' (int)imgRes.ID)) {  	if (imgRes.ID > 2000 && imgRes.ID <= 2999) {  		//Stupid Adobe engineers... This is SO not using the same pattern as everything else!!!  		resID = ResourceIDs.PathInfo;  	}  }  
Magic Number,Endogine.Codecs.Photoshop,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResource.cs,ReadImageResources,The following statement contains a magic number: if (imgRes.ID > 2000 && imgRes.ID <= 2999) {  	//Stupid Adobe engineers... This is SO not using the same pattern as everything else!!!  	resID = ResourceIDs.PathInfo;  }  
Magic Number,Endogine.Codecs.Photoshop,ImageResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResource.cs,ReadImageResources,The following statement contains a magic number: if (imgRes.ID > 2000 && imgRes.ID <= 2999) {  	//Stupid Adobe engineers... This is SO not using the same pattern as everything else!!!  	resID = ResourceIDs.PathInfo;  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: this.BlendKey = new string (reader.ReadPSDChars (4));  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: if (extraDataSize > 0) {  	uint nLength;  	this._mask = new Mask (reader' this);  	if (this._mask.Rectangle == null)  		this._mask = null;  	//blending ranges  	this._blendRanges = new List<System.Drawing.Color> ();  	nLength = reader.ReadUInt32 ();  	//First come Composite gray blend source / destination; Contains 2 black values followed by 2 white values. Present but irrelevant for Lab & Grayscale.  	//Then 4+4 for each channel (source + destination colors)  	for (uint i = 0; i < nLength / 8; i++) {  		this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  		this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  	}  	//Name  	//nLength = (uint)reader.ReadByte();  	//reader.BaseStream.Position -= 1; //TODO: wtf did I do here?  	this.Name = reader.ReadPascalString ();  	//TODO: sometimes there's a 2-byte padding here' but it's not 4-aligned... What is it?  	long posBefore = reader.BaseStream.Position;  	sHeader = new string (reader.ReadPSDChars (4));  	if (sHeader != "8BIM") {  		reader.BaseStream.Position -= 2;  		sHeader = new string (reader.ReadPSDChars (4));  	}  	if (sHeader != "8BIM")  		reader.BaseStream.Position = posBefore;  	else {  		reader.BaseStream.Position -= 4;  		this._resources = LayerResource.ReadLayerResources (reader' null);  	}  	if (reader.BaseStream.Position != nChannelEndPos)  		reader.BaseStream.Position = nChannelEndPos;  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: if (extraDataSize > 0) {  	uint nLength;  	this._mask = new Mask (reader' this);  	if (this._mask.Rectangle == null)  		this._mask = null;  	//blending ranges  	this._blendRanges = new List<System.Drawing.Color> ();  	nLength = reader.ReadUInt32 ();  	//First come Composite gray blend source / destination; Contains 2 black values followed by 2 white values. Present but irrelevant for Lab & Grayscale.  	//Then 4+4 for each channel (source + destination colors)  	for (uint i = 0; i < nLength / 8; i++) {  		this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  		this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  	}  	//Name  	//nLength = (uint)reader.ReadByte();  	//reader.BaseStream.Position -= 1; //TODO: wtf did I do here?  	this.Name = reader.ReadPascalString ();  	//TODO: sometimes there's a 2-byte padding here' but it's not 4-aligned... What is it?  	long posBefore = reader.BaseStream.Position;  	sHeader = new string (reader.ReadPSDChars (4));  	if (sHeader != "8BIM") {  		reader.BaseStream.Position -= 2;  		sHeader = new string (reader.ReadPSDChars (4));  	}  	if (sHeader != "8BIM")  		reader.BaseStream.Position = posBefore;  	else {  		reader.BaseStream.Position -= 4;  		this._resources = LayerResource.ReadLayerResources (reader' null);  	}  	if (reader.BaseStream.Position != nChannelEndPos)  		reader.BaseStream.Position = nChannelEndPos;  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: if (extraDataSize > 0) {  	uint nLength;  	this._mask = new Mask (reader' this);  	if (this._mask.Rectangle == null)  		this._mask = null;  	//blending ranges  	this._blendRanges = new List<System.Drawing.Color> ();  	nLength = reader.ReadUInt32 ();  	//First come Composite gray blend source / destination; Contains 2 black values followed by 2 white values. Present but irrelevant for Lab & Grayscale.  	//Then 4+4 for each channel (source + destination colors)  	for (uint i = 0; i < nLength / 8; i++) {  		this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  		this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  	}  	//Name  	//nLength = (uint)reader.ReadByte();  	//reader.BaseStream.Position -= 1; //TODO: wtf did I do here?  	this.Name = reader.ReadPascalString ();  	//TODO: sometimes there's a 2-byte padding here' but it's not 4-aligned... What is it?  	long posBefore = reader.BaseStream.Position;  	sHeader = new string (reader.ReadPSDChars (4));  	if (sHeader != "8BIM") {  		reader.BaseStream.Position -= 2;  		sHeader = new string (reader.ReadPSDChars (4));  	}  	if (sHeader != "8BIM")  		reader.BaseStream.Position = posBefore;  	else {  		reader.BaseStream.Position -= 4;  		this._resources = LayerResource.ReadLayerResources (reader' null);  	}  	if (reader.BaseStream.Position != nChannelEndPos)  		reader.BaseStream.Position = nChannelEndPos;  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: if (extraDataSize > 0) {  	uint nLength;  	this._mask = new Mask (reader' this);  	if (this._mask.Rectangle == null)  		this._mask = null;  	//blending ranges  	this._blendRanges = new List<System.Drawing.Color> ();  	nLength = reader.ReadUInt32 ();  	//First come Composite gray blend source / destination; Contains 2 black values followed by 2 white values. Present but irrelevant for Lab & Grayscale.  	//Then 4+4 for each channel (source + destination colors)  	for (uint i = 0; i < nLength / 8; i++) {  		this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  		this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  	}  	//Name  	//nLength = (uint)reader.ReadByte();  	//reader.BaseStream.Position -= 1; //TODO: wtf did I do here?  	this.Name = reader.ReadPascalString ();  	//TODO: sometimes there's a 2-byte padding here' but it's not 4-aligned... What is it?  	long posBefore = reader.BaseStream.Position;  	sHeader = new string (reader.ReadPSDChars (4));  	if (sHeader != "8BIM") {  		reader.BaseStream.Position -= 2;  		sHeader = new string (reader.ReadPSDChars (4));  	}  	if (sHeader != "8BIM")  		reader.BaseStream.Position = posBefore;  	else {  		reader.BaseStream.Position -= 4;  		this._resources = LayerResource.ReadLayerResources (reader' null);  	}  	if (reader.BaseStream.Position != nChannelEndPos)  		reader.BaseStream.Position = nChannelEndPos;  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: if (extraDataSize > 0) {  	uint nLength;  	this._mask = new Mask (reader' this);  	if (this._mask.Rectangle == null)  		this._mask = null;  	//blending ranges  	this._blendRanges = new List<System.Drawing.Color> ();  	nLength = reader.ReadUInt32 ();  	//First come Composite gray blend source / destination; Contains 2 black values followed by 2 white values. Present but irrelevant for Lab & Grayscale.  	//Then 4+4 for each channel (source + destination colors)  	for (uint i = 0; i < nLength / 8; i++) {  		this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  		this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  	}  	//Name  	//nLength = (uint)reader.ReadByte();  	//reader.BaseStream.Position -= 1; //TODO: wtf did I do here?  	this.Name = reader.ReadPascalString ();  	//TODO: sometimes there's a 2-byte padding here' but it's not 4-aligned... What is it?  	long posBefore = reader.BaseStream.Position;  	sHeader = new string (reader.ReadPSDChars (4));  	if (sHeader != "8BIM") {  		reader.BaseStream.Position -= 2;  		sHeader = new string (reader.ReadPSDChars (4));  	}  	if (sHeader != "8BIM")  		reader.BaseStream.Position = posBefore;  	else {  		reader.BaseStream.Position -= 4;  		this._resources = LayerResource.ReadLayerResources (reader' null);  	}  	if (reader.BaseStream.Position != nChannelEndPos)  		reader.BaseStream.Position = nChannelEndPos;  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: for (uint i = 0; i < nLength / 8; i++) {  	this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  	this._blendRanges.Add (System.Drawing.Color.FromArgb ((int)reader.ReadUInt32 ()));  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: sHeader = new string (reader.ReadPSDChars (4));  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: if (sHeader != "8BIM") {  	reader.BaseStream.Position -= 2;  	sHeader = new string (reader.ReadPSDChars (4));  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: if (sHeader != "8BIM") {  	reader.BaseStream.Position -= 2;  	sHeader = new string (reader.ReadPSDChars (4));  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: reader.BaseStream.Position -= 2;  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: sHeader = new string (reader.ReadPSDChars (4));  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: if (sHeader != "8BIM")  	reader.BaseStream.Position = posBefore;  else {  	reader.BaseStream.Position -= 4;  	this._resources = LayerResource.ReadLayerResources (reader' null);  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Layer,The following statement contains a magic number: reader.BaseStream.Position -= 4;  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,ReadPixels,The following statement contains a magic number: if (this._channels.ContainsKey (-2))  	numChannelsToRead--;  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,ReadPixels,The following statement contains a magic number: foreach (Channel ch in this._channels.Values) {  	if (ch.Usage != -2)  		ch.Data = px.GetChannelData (i++);  	//ch.ReadPixels(reader);  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,ReadPixels,The following statement contains a magic number: if (ch.Usage != -2)  	ch.Data = px.GetChannelData (i++);  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Write,The following statement contains a magic number: if (this._mask != null || (this._blendRanges != null && this._blendRanges.Count > 0) || !string.IsNullOrEmpty (this.Name)) {  	if (this._mask != null)  		this._mask.Write (writer);  	else  		writer.Write ((uint)0);  	//TODO: should be a static of Mask..?  	//blending ranges  	writer.Write ((uint)this._blendRanges.Count * 4);  	foreach (System.Drawing.Color clr in this._blendRanges)  		writer.Write ((uint)clr.ToArgb ());  	//why is there padding here? Seems unnecessary.  	long namePosition = writer.BaseStream.Position;  	writer.WritePascalString (this.Name);  	int paddingBytes = (int)((writer.BaseStream.Position - namePosition) % 4);  	for (int i = 0; i < paddingBytes; i++)  		writer.Write ((byte)0);  	foreach (LayerResource res in this._resources.Values) {  		res.Write (writer);  	}  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Write,The following statement contains a magic number: if (this._mask != null || (this._blendRanges != null && this._blendRanges.Count > 0) || !string.IsNullOrEmpty (this.Name)) {  	if (this._mask != null)  		this._mask.Write (writer);  	else  		writer.Write ((uint)0);  	//TODO: should be a static of Mask..?  	//blending ranges  	writer.Write ((uint)this._blendRanges.Count * 4);  	foreach (System.Drawing.Color clr in this._blendRanges)  		writer.Write ((uint)clr.ToArgb ());  	//why is there padding here? Seems unnecessary.  	long namePosition = writer.BaseStream.Position;  	writer.WritePascalString (this.Name);  	int paddingBytes = (int)((writer.BaseStream.Position - namePosition) % 4);  	for (int i = 0; i < paddingBytes; i++)  		writer.Write ((byte)0);  	foreach (LayerResource res in this._resources.Values) {  		res.Write (writer);  	}  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,Write,The following statement contains a magic number: writer.Write ((uint)this._blendRanges.Count * 4);  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,WritePixels,The following statement contains a magic number: if (this._isMerged) {  	PixelData px = new PixelData (this.Width' this.Height' this.BitsPerPixel' this._channels.Count' this._isMerged);  	List<byte[]> chs = new List<byte[]> ();  	foreach (Channel ch in this._channels.Values) {  		if (ch.Usage != -2)  			chs.Add (ch.Data);  	}  	px.Write (writer' chs' PixelData.Compression.Rle);  	//System.IO.MemoryStream stream = new System.IO.MemoryStream();  	//System.IO.BinaryWriter wr = new System.IO.BinaryWriter(stream);  } else {  	foreach (Channel ch in this._channels.Values) {  		if (ch.Usage != -2)  			ch.WritePixels (writer);  	}  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,WritePixels,The following statement contains a magic number: if (this._isMerged) {  	PixelData px = new PixelData (this.Width' this.Height' this.BitsPerPixel' this._channels.Count' this._isMerged);  	List<byte[]> chs = new List<byte[]> ();  	foreach (Channel ch in this._channels.Values) {  		if (ch.Usage != -2)  			chs.Add (ch.Data);  	}  	px.Write (writer' chs' PixelData.Compression.Rle);  	//System.IO.MemoryStream stream = new System.IO.MemoryStream();  	//System.IO.BinaryWriter wr = new System.IO.BinaryWriter(stream);  } else {  	foreach (Channel ch in this._channels.Values) {  		if (ch.Usage != -2)  			ch.WritePixels (writer);  	}  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,WritePixels,The following statement contains a magic number: foreach (Channel ch in this._channels.Values) {  	if (ch.Usage != -2)  		chs.Add (ch.Data);  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,WritePixels,The following statement contains a magic number: if (ch.Usage != -2)  	chs.Add (ch.Data);  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,WritePixels,The following statement contains a magic number: foreach (Channel ch in this._channels.Values) {  	if (ch.Usage != -2)  		ch.WritePixels (writer);  }  
Magic Number,Endogine.Codecs.Photoshop,Layer,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Layer.cs,WritePixels,The following statement contains a magic number: if (ch.Usage != -2)  	ch.WritePixels (writer);  
Magic Number,Endogine.Codecs.Photoshop,LayerResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResource.cs,LayerResource,The following statement contains a magic number: if (!(this is EffectBase))  	reader.JumpToEvenNthByte (2);  
Magic Number,Endogine.Codecs.Photoshop,LayerResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResource.cs,LayerResource,The following statement contains a magic number: reader.JumpToEvenNthByte (2);  
Magic Number,Endogine.Codecs.Photoshop,LayerResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResource.cs,Write,The following statement contains a magic number: if (!(this is EffectBase))  	writer.PadToNextMultiple (2);  
Magic Number,Endogine.Codecs.Photoshop,LayerResource,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResource.cs,Write,The following statement contains a magic number: writer.PadToNextMultiple (2);  
Magic Number,Endogine.Codecs.Photoshop,Mask,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Mask.cs,Mask,The following statement contains a magic number: if (nLength == 20)  	reader.ReadUInt16 ();  //padding  else if (nLength == 36) {  	this._flags2 = reader.ReadByte ();  	//same flags as above according to docs!?!?  	this._maskBg = reader.ReadByte ();  	//Real user mask background. Only 0 or 255 - ie bool?!?  	this._otherRectangle = reader.ReadPSDRectangle ();  	//new Rectangle(reader).ToERectangle(); //same as above rectangle according to docs?!?!  }  
Magic Number,Endogine.Codecs.Photoshop,Mask,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Mask.cs,Mask,The following statement contains a magic number: if (nLength == 20)  	reader.ReadUInt16 ();  //padding  else if (nLength == 36) {  	this._flags2 = reader.ReadByte ();  	//same flags as above according to docs!?!?  	this._maskBg = reader.ReadByte ();  	//Real user mask background. Only 0 or 255 - ie bool?!?  	this._otherRectangle = reader.ReadPSDRectangle ();  	//new Rectangle(reader).ToERectangle(); //same as above rectangle according to docs?!?!  }  
Magic Number,Endogine.Codecs.Photoshop,Mask,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\Mask.cs,Mask,The following statement contains a magic number: if (nLength == 36) {  	this._flags2 = reader.ReadByte ();  	//same flags as above according to docs!?!?  	this._maskBg = reader.ReadByte ();  	//Real user mask background. Only 0 or 255 - ie bool?!?  	this._otherRectangle = reader.ReadPSDRectangle ();  	//new Rectangle(reader).ToERectangle(); //same as above rectangle according to docs?!?!  }  
Magic Number,Endogine.Codecs.Photoshop,PixelData,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\PixelData.cs,PreReadPixels,The following statement contains a magic number: switch (compression) {  case Compression.Rle:  	//ignore rle "header" with bytes per row...  	reader.BaseStream.Position += this._height * 2;  	//ushort[] rowLenghtList = new ushort[height];  	//for (int i = 0; i < height; i++)  	//    rowLenghtList[i] = reader.ReadUInt16();  	break;  }  
Magic Number,Endogine.Codecs.Photoshop,PixelData,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\PixelData.cs,PreReadPixels,The following statement contains a magic number: reader.BaseStream.Position += this._height * 2;  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,ColorTransferFunctions,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\ColorTransferFunctions.cs,ColorTransferFunctions,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	this.Functions.Add (new ColorTransferFunction (reader));  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,DisplayInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\DisplayInfo.cs,DisplayInfo,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	this.Color [i] = reader.ReadInt16 ();  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,DisplayInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\DisplayInfo.cs,DisplayInfo,The following statement contains a magic number: this.Opacity = (short)Math.Max (0' Math.Min (100' (int)reader.ReadInt16 ()));  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,DisplayInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\DisplayInfo.cs,SubWrite,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	writer.Write (this.Color [i]);  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,ColorHalftoneInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Halftone.cs,ColorHalftoneInfo,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.Screens.Add (new Screen (reader));  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: this.PathNum = this.ID - 2000;  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: this.ID = 2000;  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: while (reader.BytesToEnd > 0) {  	RecordType rtype = (RecordType)(int)reader.ReadUInt16 ();  	//Should always start with PathFill (0)  	if (cnt == 0 && rtype != RecordType.PathFill)  		throw new Exception ("PathInfo start error!");  	switch (rtype) {  	case RecordType.InitialFill:  		reader.BaseStream.Position += 1;  		bool allPixelStart = reader.ReadBoolean ();  		reader.BaseStream.Position += 22;  		break;  	case RecordType.PathFill:  		if (cnt != 0)  			throw new Exception ("Path fill?!?");  		reader.BaseStream.Position += 24;  		break;  	case RecordType.Clipboard:  		ERectangleF rct = new ERectangleF ();  		rct.Top = reader.ReadPSDSingle ();  		rct.Left = reader.ReadPSDSingle ();  		rct.Bottom = reader.ReadPSDSingle ();  		rct.Right = reader.ReadPSDSingle ();  		Clipboard clp = new Clipboard ();  		clp.Rectangle = rct;  		clp.Scale = reader.ReadPSDSingle ();  		reader.BaseStream.Position += 4;  		this.Commands.Add (clp);  		break;  	case RecordType.ClosedPathLength:  	case RecordType.OpenPathLength:  		numKnots = reader.ReadUInt16 ();  		reader.BaseStream.Position += 22;  		NewPath np = new NewPath ();  		np.Open = (rtype == RecordType.OpenPathLength);  		this.Commands.Add (np);  		break;  	case RecordType.ClosedPathBezierKnotLinked:  	case RecordType.ClosedPathBezierKnotUnlinked:  	case RecordType.OpenPathBezierKnotLinked:  	case RecordType.OpenPathBezierKnotUnlinked:  		BezierKnot bz = new BezierKnot ();  		EPointF[] pts = new EPointF[3];  		for (int i = 0; i < 3; i++) {  			float y = reader.ReadPSDFixedSingle ();  			//y comes first...  			pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  		}  		bz.Control1 = pts [0];  		bz.Anchor = pts [1];  		bz.Control2 = pts [2];  		bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  		//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  		this.Commands.Add (bz);  		numKnots--;  		break;  	}  	cnt++;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: while (reader.BytesToEnd > 0) {  	RecordType rtype = (RecordType)(int)reader.ReadUInt16 ();  	//Should always start with PathFill (0)  	if (cnt == 0 && rtype != RecordType.PathFill)  		throw new Exception ("PathInfo start error!");  	switch (rtype) {  	case RecordType.InitialFill:  		reader.BaseStream.Position += 1;  		bool allPixelStart = reader.ReadBoolean ();  		reader.BaseStream.Position += 22;  		break;  	case RecordType.PathFill:  		if (cnt != 0)  			throw new Exception ("Path fill?!?");  		reader.BaseStream.Position += 24;  		break;  	case RecordType.Clipboard:  		ERectangleF rct = new ERectangleF ();  		rct.Top = reader.ReadPSDSingle ();  		rct.Left = reader.ReadPSDSingle ();  		rct.Bottom = reader.ReadPSDSingle ();  		rct.Right = reader.ReadPSDSingle ();  		Clipboard clp = new Clipboard ();  		clp.Rectangle = rct;  		clp.Scale = reader.ReadPSDSingle ();  		reader.BaseStream.Position += 4;  		this.Commands.Add (clp);  		break;  	case RecordType.ClosedPathLength:  	case RecordType.OpenPathLength:  		numKnots = reader.ReadUInt16 ();  		reader.BaseStream.Position += 22;  		NewPath np = new NewPath ();  		np.Open = (rtype == RecordType.OpenPathLength);  		this.Commands.Add (np);  		break;  	case RecordType.ClosedPathBezierKnotLinked:  	case RecordType.ClosedPathBezierKnotUnlinked:  	case RecordType.OpenPathBezierKnotLinked:  	case RecordType.OpenPathBezierKnotUnlinked:  		BezierKnot bz = new BezierKnot ();  		EPointF[] pts = new EPointF[3];  		for (int i = 0; i < 3; i++) {  			float y = reader.ReadPSDFixedSingle ();  			//y comes first...  			pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  		}  		bz.Control1 = pts [0];  		bz.Anchor = pts [1];  		bz.Control2 = pts [2];  		bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  		//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  		this.Commands.Add (bz);  		numKnots--;  		break;  	}  	cnt++;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: while (reader.BytesToEnd > 0) {  	RecordType rtype = (RecordType)(int)reader.ReadUInt16 ();  	//Should always start with PathFill (0)  	if (cnt == 0 && rtype != RecordType.PathFill)  		throw new Exception ("PathInfo start error!");  	switch (rtype) {  	case RecordType.InitialFill:  		reader.BaseStream.Position += 1;  		bool allPixelStart = reader.ReadBoolean ();  		reader.BaseStream.Position += 22;  		break;  	case RecordType.PathFill:  		if (cnt != 0)  			throw new Exception ("Path fill?!?");  		reader.BaseStream.Position += 24;  		break;  	case RecordType.Clipboard:  		ERectangleF rct = new ERectangleF ();  		rct.Top = reader.ReadPSDSingle ();  		rct.Left = reader.ReadPSDSingle ();  		rct.Bottom = reader.ReadPSDSingle ();  		rct.Right = reader.ReadPSDSingle ();  		Clipboard clp = new Clipboard ();  		clp.Rectangle = rct;  		clp.Scale = reader.ReadPSDSingle ();  		reader.BaseStream.Position += 4;  		this.Commands.Add (clp);  		break;  	case RecordType.ClosedPathLength:  	case RecordType.OpenPathLength:  		numKnots = reader.ReadUInt16 ();  		reader.BaseStream.Position += 22;  		NewPath np = new NewPath ();  		np.Open = (rtype == RecordType.OpenPathLength);  		this.Commands.Add (np);  		break;  	case RecordType.ClosedPathBezierKnotLinked:  	case RecordType.ClosedPathBezierKnotUnlinked:  	case RecordType.OpenPathBezierKnotLinked:  	case RecordType.OpenPathBezierKnotUnlinked:  		BezierKnot bz = new BezierKnot ();  		EPointF[] pts = new EPointF[3];  		for (int i = 0; i < 3; i++) {  			float y = reader.ReadPSDFixedSingle ();  			//y comes first...  			pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  		}  		bz.Control1 = pts [0];  		bz.Anchor = pts [1];  		bz.Control2 = pts [2];  		bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  		//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  		this.Commands.Add (bz);  		numKnots--;  		break;  	}  	cnt++;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: while (reader.BytesToEnd > 0) {  	RecordType rtype = (RecordType)(int)reader.ReadUInt16 ();  	//Should always start with PathFill (0)  	if (cnt == 0 && rtype != RecordType.PathFill)  		throw new Exception ("PathInfo start error!");  	switch (rtype) {  	case RecordType.InitialFill:  		reader.BaseStream.Position += 1;  		bool allPixelStart = reader.ReadBoolean ();  		reader.BaseStream.Position += 22;  		break;  	case RecordType.PathFill:  		if (cnt != 0)  			throw new Exception ("Path fill?!?");  		reader.BaseStream.Position += 24;  		break;  	case RecordType.Clipboard:  		ERectangleF rct = new ERectangleF ();  		rct.Top = reader.ReadPSDSingle ();  		rct.Left = reader.ReadPSDSingle ();  		rct.Bottom = reader.ReadPSDSingle ();  		rct.Right = reader.ReadPSDSingle ();  		Clipboard clp = new Clipboard ();  		clp.Rectangle = rct;  		clp.Scale = reader.ReadPSDSingle ();  		reader.BaseStream.Position += 4;  		this.Commands.Add (clp);  		break;  	case RecordType.ClosedPathLength:  	case RecordType.OpenPathLength:  		numKnots = reader.ReadUInt16 ();  		reader.BaseStream.Position += 22;  		NewPath np = new NewPath ();  		np.Open = (rtype == RecordType.OpenPathLength);  		this.Commands.Add (np);  		break;  	case RecordType.ClosedPathBezierKnotLinked:  	case RecordType.ClosedPathBezierKnotUnlinked:  	case RecordType.OpenPathBezierKnotLinked:  	case RecordType.OpenPathBezierKnotUnlinked:  		BezierKnot bz = new BezierKnot ();  		EPointF[] pts = new EPointF[3];  		for (int i = 0; i < 3; i++) {  			float y = reader.ReadPSDFixedSingle ();  			//y comes first...  			pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  		}  		bz.Control1 = pts [0];  		bz.Anchor = pts [1];  		bz.Control2 = pts [2];  		bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  		//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  		this.Commands.Add (bz);  		numKnots--;  		break;  	}  	cnt++;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: while (reader.BytesToEnd > 0) {  	RecordType rtype = (RecordType)(int)reader.ReadUInt16 ();  	//Should always start with PathFill (0)  	if (cnt == 0 && rtype != RecordType.PathFill)  		throw new Exception ("PathInfo start error!");  	switch (rtype) {  	case RecordType.InitialFill:  		reader.BaseStream.Position += 1;  		bool allPixelStart = reader.ReadBoolean ();  		reader.BaseStream.Position += 22;  		break;  	case RecordType.PathFill:  		if (cnt != 0)  			throw new Exception ("Path fill?!?");  		reader.BaseStream.Position += 24;  		break;  	case RecordType.Clipboard:  		ERectangleF rct = new ERectangleF ();  		rct.Top = reader.ReadPSDSingle ();  		rct.Left = reader.ReadPSDSingle ();  		rct.Bottom = reader.ReadPSDSingle ();  		rct.Right = reader.ReadPSDSingle ();  		Clipboard clp = new Clipboard ();  		clp.Rectangle = rct;  		clp.Scale = reader.ReadPSDSingle ();  		reader.BaseStream.Position += 4;  		this.Commands.Add (clp);  		break;  	case RecordType.ClosedPathLength:  	case RecordType.OpenPathLength:  		numKnots = reader.ReadUInt16 ();  		reader.BaseStream.Position += 22;  		NewPath np = new NewPath ();  		np.Open = (rtype == RecordType.OpenPathLength);  		this.Commands.Add (np);  		break;  	case RecordType.ClosedPathBezierKnotLinked:  	case RecordType.ClosedPathBezierKnotUnlinked:  	case RecordType.OpenPathBezierKnotLinked:  	case RecordType.OpenPathBezierKnotUnlinked:  		BezierKnot bz = new BezierKnot ();  		EPointF[] pts = new EPointF[3];  		for (int i = 0; i < 3; i++) {  			float y = reader.ReadPSDFixedSingle ();  			//y comes first...  			pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  		}  		bz.Control1 = pts [0];  		bz.Anchor = pts [1];  		bz.Control2 = pts [2];  		bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  		//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  		this.Commands.Add (bz);  		numKnots--;  		break;  	}  	cnt++;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: while (reader.BytesToEnd > 0) {  	RecordType rtype = (RecordType)(int)reader.ReadUInt16 ();  	//Should always start with PathFill (0)  	if (cnt == 0 && rtype != RecordType.PathFill)  		throw new Exception ("PathInfo start error!");  	switch (rtype) {  	case RecordType.InitialFill:  		reader.BaseStream.Position += 1;  		bool allPixelStart = reader.ReadBoolean ();  		reader.BaseStream.Position += 22;  		break;  	case RecordType.PathFill:  		if (cnt != 0)  			throw new Exception ("Path fill?!?");  		reader.BaseStream.Position += 24;  		break;  	case RecordType.Clipboard:  		ERectangleF rct = new ERectangleF ();  		rct.Top = reader.ReadPSDSingle ();  		rct.Left = reader.ReadPSDSingle ();  		rct.Bottom = reader.ReadPSDSingle ();  		rct.Right = reader.ReadPSDSingle ();  		Clipboard clp = new Clipboard ();  		clp.Rectangle = rct;  		clp.Scale = reader.ReadPSDSingle ();  		reader.BaseStream.Position += 4;  		this.Commands.Add (clp);  		break;  	case RecordType.ClosedPathLength:  	case RecordType.OpenPathLength:  		numKnots = reader.ReadUInt16 ();  		reader.BaseStream.Position += 22;  		NewPath np = new NewPath ();  		np.Open = (rtype == RecordType.OpenPathLength);  		this.Commands.Add (np);  		break;  	case RecordType.ClosedPathBezierKnotLinked:  	case RecordType.ClosedPathBezierKnotUnlinked:  	case RecordType.OpenPathBezierKnotLinked:  	case RecordType.OpenPathBezierKnotUnlinked:  		BezierKnot bz = new BezierKnot ();  		EPointF[] pts = new EPointF[3];  		for (int i = 0; i < 3; i++) {  			float y = reader.ReadPSDFixedSingle ();  			//y comes first...  			pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  		}  		bz.Control1 = pts [0];  		bz.Anchor = pts [1];  		bz.Control2 = pts [2];  		bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  		//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  		this.Commands.Add (bz);  		numKnots--;  		break;  	}  	cnt++;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: while (reader.BytesToEnd > 0) {  	RecordType rtype = (RecordType)(int)reader.ReadUInt16 ();  	//Should always start with PathFill (0)  	if (cnt == 0 && rtype != RecordType.PathFill)  		throw new Exception ("PathInfo start error!");  	switch (rtype) {  	case RecordType.InitialFill:  		reader.BaseStream.Position += 1;  		bool allPixelStart = reader.ReadBoolean ();  		reader.BaseStream.Position += 22;  		break;  	case RecordType.PathFill:  		if (cnt != 0)  			throw new Exception ("Path fill?!?");  		reader.BaseStream.Position += 24;  		break;  	case RecordType.Clipboard:  		ERectangleF rct = new ERectangleF ();  		rct.Top = reader.ReadPSDSingle ();  		rct.Left = reader.ReadPSDSingle ();  		rct.Bottom = reader.ReadPSDSingle ();  		rct.Right = reader.ReadPSDSingle ();  		Clipboard clp = new Clipboard ();  		clp.Rectangle = rct;  		clp.Scale = reader.ReadPSDSingle ();  		reader.BaseStream.Position += 4;  		this.Commands.Add (clp);  		break;  	case RecordType.ClosedPathLength:  	case RecordType.OpenPathLength:  		numKnots = reader.ReadUInt16 ();  		reader.BaseStream.Position += 22;  		NewPath np = new NewPath ();  		np.Open = (rtype == RecordType.OpenPathLength);  		this.Commands.Add (np);  		break;  	case RecordType.ClosedPathBezierKnotLinked:  	case RecordType.ClosedPathBezierKnotUnlinked:  	case RecordType.OpenPathBezierKnotLinked:  	case RecordType.OpenPathBezierKnotUnlinked:  		BezierKnot bz = new BezierKnot ();  		EPointF[] pts = new EPointF[3];  		for (int i = 0; i < 3; i++) {  			float y = reader.ReadPSDFixedSingle ();  			//y comes first...  			pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  		}  		bz.Control1 = pts [0];  		bz.Anchor = pts [1];  		bz.Control2 = pts [2];  		bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  		//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  		this.Commands.Add (bz);  		numKnots--;  		break;  	}  	cnt++;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: while (reader.BytesToEnd > 0) {  	RecordType rtype = (RecordType)(int)reader.ReadUInt16 ();  	//Should always start with PathFill (0)  	if (cnt == 0 && rtype != RecordType.PathFill)  		throw new Exception ("PathInfo start error!");  	switch (rtype) {  	case RecordType.InitialFill:  		reader.BaseStream.Position += 1;  		bool allPixelStart = reader.ReadBoolean ();  		reader.BaseStream.Position += 22;  		break;  	case RecordType.PathFill:  		if (cnt != 0)  			throw new Exception ("Path fill?!?");  		reader.BaseStream.Position += 24;  		break;  	case RecordType.Clipboard:  		ERectangleF rct = new ERectangleF ();  		rct.Top = reader.ReadPSDSingle ();  		rct.Left = reader.ReadPSDSingle ();  		rct.Bottom = reader.ReadPSDSingle ();  		rct.Right = reader.ReadPSDSingle ();  		Clipboard clp = new Clipboard ();  		clp.Rectangle = rct;  		clp.Scale = reader.ReadPSDSingle ();  		reader.BaseStream.Position += 4;  		this.Commands.Add (clp);  		break;  	case RecordType.ClosedPathLength:  	case RecordType.OpenPathLength:  		numKnots = reader.ReadUInt16 ();  		reader.BaseStream.Position += 22;  		NewPath np = new NewPath ();  		np.Open = (rtype == RecordType.OpenPathLength);  		this.Commands.Add (np);  		break;  	case RecordType.ClosedPathBezierKnotLinked:  	case RecordType.ClosedPathBezierKnotUnlinked:  	case RecordType.OpenPathBezierKnotLinked:  	case RecordType.OpenPathBezierKnotUnlinked:  		BezierKnot bz = new BezierKnot ();  		EPointF[] pts = new EPointF[3];  		for (int i = 0; i < 3; i++) {  			float y = reader.ReadPSDFixedSingle ();  			//y comes first...  			pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  		}  		bz.Control1 = pts [0];  		bz.Anchor = pts [1];  		bz.Control2 = pts [2];  		bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  		//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  		this.Commands.Add (bz);  		numKnots--;  		break;  	}  	cnt++;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: switch (rtype) {  case RecordType.InitialFill:  	reader.BaseStream.Position += 1;  	bool allPixelStart = reader.ReadBoolean ();  	reader.BaseStream.Position += 22;  	break;  case RecordType.PathFill:  	if (cnt != 0)  		throw new Exception ("Path fill?!?");  	reader.BaseStream.Position += 24;  	break;  case RecordType.Clipboard:  	ERectangleF rct = new ERectangleF ();  	rct.Top = reader.ReadPSDSingle ();  	rct.Left = reader.ReadPSDSingle ();  	rct.Bottom = reader.ReadPSDSingle ();  	rct.Right = reader.ReadPSDSingle ();  	Clipboard clp = new Clipboard ();  	clp.Rectangle = rct;  	clp.Scale = reader.ReadPSDSingle ();  	reader.BaseStream.Position += 4;  	this.Commands.Add (clp);  	break;  case RecordType.ClosedPathLength:  case RecordType.OpenPathLength:  	numKnots = reader.ReadUInt16 ();  	reader.BaseStream.Position += 22;  	NewPath np = new NewPath ();  	np.Open = (rtype == RecordType.OpenPathLength);  	this.Commands.Add (np);  	break;  case RecordType.ClosedPathBezierKnotLinked:  case RecordType.ClosedPathBezierKnotUnlinked:  case RecordType.OpenPathBezierKnotLinked:  case RecordType.OpenPathBezierKnotUnlinked:  	BezierKnot bz = new BezierKnot ();  	EPointF[] pts = new EPointF[3];  	for (int i = 0; i < 3; i++) {  		float y = reader.ReadPSDFixedSingle ();  		//y comes first...  		pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  	}  	bz.Control1 = pts [0];  	bz.Anchor = pts [1];  	bz.Control2 = pts [2];  	bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  	//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  	this.Commands.Add (bz);  	numKnots--;  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: switch (rtype) {  case RecordType.InitialFill:  	reader.BaseStream.Position += 1;  	bool allPixelStart = reader.ReadBoolean ();  	reader.BaseStream.Position += 22;  	break;  case RecordType.PathFill:  	if (cnt != 0)  		throw new Exception ("Path fill?!?");  	reader.BaseStream.Position += 24;  	break;  case RecordType.Clipboard:  	ERectangleF rct = new ERectangleF ();  	rct.Top = reader.ReadPSDSingle ();  	rct.Left = reader.ReadPSDSingle ();  	rct.Bottom = reader.ReadPSDSingle ();  	rct.Right = reader.ReadPSDSingle ();  	Clipboard clp = new Clipboard ();  	clp.Rectangle = rct;  	clp.Scale = reader.ReadPSDSingle ();  	reader.BaseStream.Position += 4;  	this.Commands.Add (clp);  	break;  case RecordType.ClosedPathLength:  case RecordType.OpenPathLength:  	numKnots = reader.ReadUInt16 ();  	reader.BaseStream.Position += 22;  	NewPath np = new NewPath ();  	np.Open = (rtype == RecordType.OpenPathLength);  	this.Commands.Add (np);  	break;  case RecordType.ClosedPathBezierKnotLinked:  case RecordType.ClosedPathBezierKnotUnlinked:  case RecordType.OpenPathBezierKnotLinked:  case RecordType.OpenPathBezierKnotUnlinked:  	BezierKnot bz = new BezierKnot ();  	EPointF[] pts = new EPointF[3];  	for (int i = 0; i < 3; i++) {  		float y = reader.ReadPSDFixedSingle ();  		//y comes first...  		pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  	}  	bz.Control1 = pts [0];  	bz.Anchor = pts [1];  	bz.Control2 = pts [2];  	bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  	//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  	this.Commands.Add (bz);  	numKnots--;  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: switch (rtype) {  case RecordType.InitialFill:  	reader.BaseStream.Position += 1;  	bool allPixelStart = reader.ReadBoolean ();  	reader.BaseStream.Position += 22;  	break;  case RecordType.PathFill:  	if (cnt != 0)  		throw new Exception ("Path fill?!?");  	reader.BaseStream.Position += 24;  	break;  case RecordType.Clipboard:  	ERectangleF rct = new ERectangleF ();  	rct.Top = reader.ReadPSDSingle ();  	rct.Left = reader.ReadPSDSingle ();  	rct.Bottom = reader.ReadPSDSingle ();  	rct.Right = reader.ReadPSDSingle ();  	Clipboard clp = new Clipboard ();  	clp.Rectangle = rct;  	clp.Scale = reader.ReadPSDSingle ();  	reader.BaseStream.Position += 4;  	this.Commands.Add (clp);  	break;  case RecordType.ClosedPathLength:  case RecordType.OpenPathLength:  	numKnots = reader.ReadUInt16 ();  	reader.BaseStream.Position += 22;  	NewPath np = new NewPath ();  	np.Open = (rtype == RecordType.OpenPathLength);  	this.Commands.Add (np);  	break;  case RecordType.ClosedPathBezierKnotLinked:  case RecordType.ClosedPathBezierKnotUnlinked:  case RecordType.OpenPathBezierKnotLinked:  case RecordType.OpenPathBezierKnotUnlinked:  	BezierKnot bz = new BezierKnot ();  	EPointF[] pts = new EPointF[3];  	for (int i = 0; i < 3; i++) {  		float y = reader.ReadPSDFixedSingle ();  		//y comes first...  		pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  	}  	bz.Control1 = pts [0];  	bz.Anchor = pts [1];  	bz.Control2 = pts [2];  	bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  	//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  	this.Commands.Add (bz);  	numKnots--;  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: switch (rtype) {  case RecordType.InitialFill:  	reader.BaseStream.Position += 1;  	bool allPixelStart = reader.ReadBoolean ();  	reader.BaseStream.Position += 22;  	break;  case RecordType.PathFill:  	if (cnt != 0)  		throw new Exception ("Path fill?!?");  	reader.BaseStream.Position += 24;  	break;  case RecordType.Clipboard:  	ERectangleF rct = new ERectangleF ();  	rct.Top = reader.ReadPSDSingle ();  	rct.Left = reader.ReadPSDSingle ();  	rct.Bottom = reader.ReadPSDSingle ();  	rct.Right = reader.ReadPSDSingle ();  	Clipboard clp = new Clipboard ();  	clp.Rectangle = rct;  	clp.Scale = reader.ReadPSDSingle ();  	reader.BaseStream.Position += 4;  	this.Commands.Add (clp);  	break;  case RecordType.ClosedPathLength:  case RecordType.OpenPathLength:  	numKnots = reader.ReadUInt16 ();  	reader.BaseStream.Position += 22;  	NewPath np = new NewPath ();  	np.Open = (rtype == RecordType.OpenPathLength);  	this.Commands.Add (np);  	break;  case RecordType.ClosedPathBezierKnotLinked:  case RecordType.ClosedPathBezierKnotUnlinked:  case RecordType.OpenPathBezierKnotLinked:  case RecordType.OpenPathBezierKnotUnlinked:  	BezierKnot bz = new BezierKnot ();  	EPointF[] pts = new EPointF[3];  	for (int i = 0; i < 3; i++) {  		float y = reader.ReadPSDFixedSingle ();  		//y comes first...  		pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  	}  	bz.Control1 = pts [0];  	bz.Anchor = pts [1];  	bz.Control2 = pts [2];  	bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  	//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  	this.Commands.Add (bz);  	numKnots--;  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: switch (rtype) {  case RecordType.InitialFill:  	reader.BaseStream.Position += 1;  	bool allPixelStart = reader.ReadBoolean ();  	reader.BaseStream.Position += 22;  	break;  case RecordType.PathFill:  	if (cnt != 0)  		throw new Exception ("Path fill?!?");  	reader.BaseStream.Position += 24;  	break;  case RecordType.Clipboard:  	ERectangleF rct = new ERectangleF ();  	rct.Top = reader.ReadPSDSingle ();  	rct.Left = reader.ReadPSDSingle ();  	rct.Bottom = reader.ReadPSDSingle ();  	rct.Right = reader.ReadPSDSingle ();  	Clipboard clp = new Clipboard ();  	clp.Rectangle = rct;  	clp.Scale = reader.ReadPSDSingle ();  	reader.BaseStream.Position += 4;  	this.Commands.Add (clp);  	break;  case RecordType.ClosedPathLength:  case RecordType.OpenPathLength:  	numKnots = reader.ReadUInt16 ();  	reader.BaseStream.Position += 22;  	NewPath np = new NewPath ();  	np.Open = (rtype == RecordType.OpenPathLength);  	this.Commands.Add (np);  	break;  case RecordType.ClosedPathBezierKnotLinked:  case RecordType.ClosedPathBezierKnotUnlinked:  case RecordType.OpenPathBezierKnotLinked:  case RecordType.OpenPathBezierKnotUnlinked:  	BezierKnot bz = new BezierKnot ();  	EPointF[] pts = new EPointF[3];  	for (int i = 0; i < 3; i++) {  		float y = reader.ReadPSDFixedSingle ();  		//y comes first...  		pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  	}  	bz.Control1 = pts [0];  	bz.Anchor = pts [1];  	bz.Control2 = pts [2];  	bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  	//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  	this.Commands.Add (bz);  	numKnots--;  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: switch (rtype) {  case RecordType.InitialFill:  	reader.BaseStream.Position += 1;  	bool allPixelStart = reader.ReadBoolean ();  	reader.BaseStream.Position += 22;  	break;  case RecordType.PathFill:  	if (cnt != 0)  		throw new Exception ("Path fill?!?");  	reader.BaseStream.Position += 24;  	break;  case RecordType.Clipboard:  	ERectangleF rct = new ERectangleF ();  	rct.Top = reader.ReadPSDSingle ();  	rct.Left = reader.ReadPSDSingle ();  	rct.Bottom = reader.ReadPSDSingle ();  	rct.Right = reader.ReadPSDSingle ();  	Clipboard clp = new Clipboard ();  	clp.Rectangle = rct;  	clp.Scale = reader.ReadPSDSingle ();  	reader.BaseStream.Position += 4;  	this.Commands.Add (clp);  	break;  case RecordType.ClosedPathLength:  case RecordType.OpenPathLength:  	numKnots = reader.ReadUInt16 ();  	reader.BaseStream.Position += 22;  	NewPath np = new NewPath ();  	np.Open = (rtype == RecordType.OpenPathLength);  	this.Commands.Add (np);  	break;  case RecordType.ClosedPathBezierKnotLinked:  case RecordType.ClosedPathBezierKnotUnlinked:  case RecordType.OpenPathBezierKnotLinked:  case RecordType.OpenPathBezierKnotUnlinked:  	BezierKnot bz = new BezierKnot ();  	EPointF[] pts = new EPointF[3];  	for (int i = 0; i < 3; i++) {  		float y = reader.ReadPSDFixedSingle ();  		//y comes first...  		pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  	}  	bz.Control1 = pts [0];  	bz.Anchor = pts [1];  	bz.Control2 = pts [2];  	bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  	//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  	this.Commands.Add (bz);  	numKnots--;  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: switch (rtype) {  case RecordType.InitialFill:  	reader.BaseStream.Position += 1;  	bool allPixelStart = reader.ReadBoolean ();  	reader.BaseStream.Position += 22;  	break;  case RecordType.PathFill:  	if (cnt != 0)  		throw new Exception ("Path fill?!?");  	reader.BaseStream.Position += 24;  	break;  case RecordType.Clipboard:  	ERectangleF rct = new ERectangleF ();  	rct.Top = reader.ReadPSDSingle ();  	rct.Left = reader.ReadPSDSingle ();  	rct.Bottom = reader.ReadPSDSingle ();  	rct.Right = reader.ReadPSDSingle ();  	Clipboard clp = new Clipboard ();  	clp.Rectangle = rct;  	clp.Scale = reader.ReadPSDSingle ();  	reader.BaseStream.Position += 4;  	this.Commands.Add (clp);  	break;  case RecordType.ClosedPathLength:  case RecordType.OpenPathLength:  	numKnots = reader.ReadUInt16 ();  	reader.BaseStream.Position += 22;  	NewPath np = new NewPath ();  	np.Open = (rtype == RecordType.OpenPathLength);  	this.Commands.Add (np);  	break;  case RecordType.ClosedPathBezierKnotLinked:  case RecordType.ClosedPathBezierKnotUnlinked:  case RecordType.OpenPathBezierKnotLinked:  case RecordType.OpenPathBezierKnotUnlinked:  	BezierKnot bz = new BezierKnot ();  	EPointF[] pts = new EPointF[3];  	for (int i = 0; i < 3; i++) {  		float y = reader.ReadPSDFixedSingle ();  		//y comes first...  		pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  	}  	bz.Control1 = pts [0];  	bz.Anchor = pts [1];  	bz.Control2 = pts [2];  	bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  	//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  	this.Commands.Add (bz);  	numKnots--;  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: switch (rtype) {  case RecordType.InitialFill:  	reader.BaseStream.Position += 1;  	bool allPixelStart = reader.ReadBoolean ();  	reader.BaseStream.Position += 22;  	break;  case RecordType.PathFill:  	if (cnt != 0)  		throw new Exception ("Path fill?!?");  	reader.BaseStream.Position += 24;  	break;  case RecordType.Clipboard:  	ERectangleF rct = new ERectangleF ();  	rct.Top = reader.ReadPSDSingle ();  	rct.Left = reader.ReadPSDSingle ();  	rct.Bottom = reader.ReadPSDSingle ();  	rct.Right = reader.ReadPSDSingle ();  	Clipboard clp = new Clipboard ();  	clp.Rectangle = rct;  	clp.Scale = reader.ReadPSDSingle ();  	reader.BaseStream.Position += 4;  	this.Commands.Add (clp);  	break;  case RecordType.ClosedPathLength:  case RecordType.OpenPathLength:  	numKnots = reader.ReadUInt16 ();  	reader.BaseStream.Position += 22;  	NewPath np = new NewPath ();  	np.Open = (rtype == RecordType.OpenPathLength);  	this.Commands.Add (np);  	break;  case RecordType.ClosedPathBezierKnotLinked:  case RecordType.ClosedPathBezierKnotUnlinked:  case RecordType.OpenPathBezierKnotLinked:  case RecordType.OpenPathBezierKnotUnlinked:  	BezierKnot bz = new BezierKnot ();  	EPointF[] pts = new EPointF[3];  	for (int i = 0; i < 3; i++) {  		float y = reader.ReadPSDFixedSingle ();  		//y comes first...  		pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  	}  	bz.Control1 = pts [0];  	bz.Anchor = pts [1];  	bz.Control2 = pts [2];  	bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  	//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  	this.Commands.Add (bz);  	numKnots--;  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: reader.BaseStream.Position += 22;  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: reader.BaseStream.Position += 24;  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: reader.BaseStream.Position += 4;  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: reader.BaseStream.Position += 22;  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	float y = reader.ReadPSDFixedSingle ();  	//y comes first...  	pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	float y = reader.ReadPSDFixedSingle ();  	//y comes first...  	pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following statement contains a magic number: bz.Control2 = pts [2];  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: if (this.ID == 1033) {  	// BGR  	for (int n = 0; n < numBytes - 2; n += 3) {  		byte tmp = buffer [n + 2];  		buffer [n + 2] = buffer [n];  		buffer [n] = tmp;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: if (this.ID == 1033) {  	// BGR  	for (int n = 0; n < numBytes - 2; n += 3) {  		byte tmp = buffer [n + 2];  		buffer [n + 2] = buffer [n];  		buffer [n] = tmp;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: if (this.ID == 1033) {  	// BGR  	for (int n = 0; n < numBytes - 2; n += 3) {  		byte tmp = buffer [n + 2];  		buffer [n + 2] = buffer [n];  		buffer [n] = tmp;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: if (this.ID == 1033) {  	// BGR  	for (int n = 0; n < numBytes - 2; n += 3) {  		byte tmp = buffer [n + 2];  		buffer [n + 2] = buffer [n];  		buffer [n] = tmp;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: if (this.ID == 1033) {  	// BGR  	for (int n = 0; n < numBytes - 2; n += 3) {  		byte tmp = buffer [n + 2];  		buffer [n + 2] = buffer [n];  		buffer [n] = tmp;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: for (int n = 0; n < numBytes - 2; n += 3) {  	byte tmp = buffer [n + 2];  	buffer [n + 2] = buffer [n];  	buffer [n] = tmp;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: for (int n = 0; n < numBytes - 2; n += 3) {  	byte tmp = buffer [n + 2];  	buffer [n + 2] = buffer [n];  	buffer [n] = tmp;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: for (int n = 0; n < numBytes - 2; n += 3) {  	byte tmp = buffer [n + 2];  	buffer [n + 2] = buffer [n];  	buffer [n] = tmp;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: for (int n = 0; n < numBytes - 2; n += 3) {  	byte tmp = buffer [n + 2];  	buffer [n + 2] = buffer [n];  	buffer [n] = tmp;  }  
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: n += 3
Magic Number,Endogine.Codecs.Photoshop.ImageResources,Thumbnail,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\Thumbnail.cs,Thumbnail,The following statement contains a magic number: buffer [n + 2] = buffer [n];  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,ColorBalance,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,ColorBalance,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	this.Records.Add (new RangeSettings (r));  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 1) {  	this.Colorize = new HSLModifier ();  	this.Colorize.Hue = (short)((int)r.ReadInt16 () * 180 / 100);  	this.Colorize.Saturation = r.ReadInt16 ();  	this.Colorize.Lightness = r.ReadInt16 ();  	for (int i = 0; i < 7; i++) {  		HSLModifier hsl = new HSLModifier ();  		this.Settings.Add (hsl);  		hsl.Hue = r.ReadInt16 ();  	}  	for (int i = 0; i < 7; i++)  		this.Settings [i].Saturation = r.ReadInt16 ();  	for (int i = 0; i < 7; i++)  		this.Settings [i].Lightness = r.ReadInt16 ();  } else if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 1) {  	this.Colorize = new HSLModifier ();  	this.Colorize.Hue = (short)((int)r.ReadInt16 () * 180 / 100);  	this.Colorize.Saturation = r.ReadInt16 ();  	this.Colorize.Lightness = r.ReadInt16 ();  	for (int i = 0; i < 7; i++) {  		HSLModifier hsl = new HSLModifier ();  		this.Settings.Add (hsl);  		hsl.Hue = r.ReadInt16 ();  	}  	for (int i = 0; i < 7; i++)  		this.Settings [i].Saturation = r.ReadInt16 ();  	for (int i = 0; i < 7; i++)  		this.Settings [i].Lightness = r.ReadInt16 ();  } else if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 1) {  	this.Colorize = new HSLModifier ();  	this.Colorize.Hue = (short)((int)r.ReadInt16 () * 180 / 100);  	this.Colorize.Saturation = r.ReadInt16 ();  	this.Colorize.Lightness = r.ReadInt16 ();  	for (int i = 0; i < 7; i++) {  		HSLModifier hsl = new HSLModifier ();  		this.Settings.Add (hsl);  		hsl.Hue = r.ReadInt16 ();  	}  	for (int i = 0; i < 7; i++)  		this.Settings [i].Saturation = r.ReadInt16 ();  	for (int i = 0; i < 7; i++)  		this.Settings [i].Lightness = r.ReadInt16 ();  } else if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 1) {  	this.Colorize = new HSLModifier ();  	this.Colorize.Hue = (short)((int)r.ReadInt16 () * 180 / 100);  	this.Colorize.Saturation = r.ReadInt16 ();  	this.Colorize.Lightness = r.ReadInt16 ();  	for (int i = 0; i < 7; i++) {  		HSLModifier hsl = new HSLModifier ();  		this.Settings.Add (hsl);  		hsl.Hue = r.ReadInt16 ();  	}  	for (int i = 0; i < 7; i++)  		this.Settings [i].Saturation = r.ReadInt16 ();  	for (int i = 0; i < 7; i++)  		this.Settings [i].Lightness = r.ReadInt16 ();  } else if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 1) {  	this.Colorize = new HSLModifier ();  	this.Colorize.Hue = (short)((int)r.ReadInt16 () * 180 / 100);  	this.Colorize.Saturation = r.ReadInt16 ();  	this.Colorize.Lightness = r.ReadInt16 ();  	for (int i = 0; i < 7; i++) {  		HSLModifier hsl = new HSLModifier ();  		this.Settings.Add (hsl);  		hsl.Hue = r.ReadInt16 ();  	}  	for (int i = 0; i < 7; i++)  		this.Settings [i].Saturation = r.ReadInt16 ();  	for (int i = 0; i < 7; i++)  		this.Settings [i].Lightness = r.ReadInt16 ();  } else if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 1) {  	this.Colorize = new HSLModifier ();  	this.Colorize.Hue = (short)((int)r.ReadInt16 () * 180 / 100);  	this.Colorize.Saturation = r.ReadInt16 ();  	this.Colorize.Lightness = r.ReadInt16 ();  	for (int i = 0; i < 7; i++) {  		HSLModifier hsl = new HSLModifier ();  		this.Settings.Add (hsl);  		hsl.Hue = r.ReadInt16 ();  	}  	for (int i = 0; i < 7; i++)  		this.Settings [i].Saturation = r.ReadInt16 ();  	for (int i = 0; i < 7; i++)  		this.Settings [i].Lightness = r.ReadInt16 ();  } else if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 1) {  	this.Colorize = new HSLModifier ();  	this.Colorize.Hue = (short)((int)r.ReadInt16 () * 180 / 100);  	this.Colorize.Saturation = r.ReadInt16 ();  	this.Colorize.Lightness = r.ReadInt16 ();  	for (int i = 0; i < 7; i++) {  		HSLModifier hsl = new HSLModifier ();  		this.Settings.Add (hsl);  		hsl.Hue = r.ReadInt16 ();  	}  	for (int i = 0; i < 7; i++)  		this.Settings [i].Saturation = r.ReadInt16 ();  	for (int i = 0; i < 7; i++)  		this.Settings [i].Lightness = r.ReadInt16 ();  } else if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 1) {  	this.Colorize = new HSLModifier ();  	this.Colorize.Hue = (short)((int)r.ReadInt16 () * 180 / 100);  	this.Colorize.Saturation = r.ReadInt16 ();  	this.Colorize.Lightness = r.ReadInt16 ();  	for (int i = 0; i < 7; i++) {  		HSLModifier hsl = new HSLModifier ();  		this.Settings.Add (hsl);  		hsl.Hue = r.ReadInt16 ();  	}  	for (int i = 0; i < 7; i++)  		this.Settings [i].Saturation = r.ReadInt16 ();  	for (int i = 0; i < 7; i++)  		this.Settings [i].Lightness = r.ReadInt16 ();  } else if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: this.Colorize.Hue = (short)((int)r.ReadInt16 () * 180 / 100);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: this.Colorize.Hue = (short)((int)r.ReadInt16 () * 180 / 100);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: for (int i = 0; i < 7; i++) {  	HSLModifier hsl = new HSLModifier ();  	this.Settings.Add (hsl);  	hsl.Hue = r.ReadInt16 ();  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: for (int i = 0; i < 7; i++)  	this.Settings [i].Saturation = r.ReadInt16 ();  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: for (int i = 0; i < 7; i++)  	this.Settings [i].Lightness = r.ReadInt16 ();  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: if (version == 2) {  	this.Colorize = new HSLModifier (r);  	HSLModifier hsl = new HSLModifier (r);  	//master  	this.Settings.Add (hsl);  	for (int i = 0; i < 6; i++) {  		List<short> ranges = new List<short> ();  		for (int j = 0; j < 4; j++)  			ranges.Add (r.ReadInt16 ());  		hsl = new HSLModifier (r);  		this.Settings.Add (hsl);  		hsl.Ranges = ranges;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: for (int i = 0; i < 6; i++) {  	List<short> ranges = new List<short> ();  	for (int j = 0; j < 4; j++)  		ranges.Add (r.ReadInt16 ());  	hsl = new HSLModifier (r);  	this.Settings.Add (hsl);  	hsl.Ranges = ranges;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: for (int i = 0; i < 6; i++) {  	List<short> ranges = new List<short> ();  	for (int j = 0; j < 4; j++)  		ranges.Add (r.ReadInt16 ());  	hsl = new HSLModifier (r);  	this.Settings.Add (hsl);  	hsl.Ranges = ranges;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,HueSaturation,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,HueSaturation,The following statement contains a magic number: for (int j = 0; j < 4; j++)  	ranges.Add (r.ReadInt16 ());  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,SelectiveColor,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,SelectiveColor,The following statement contains a magic number: for (int i = 0; i < 10; i++)  	this.Records.Add (new CorrectionRecord (r));  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,GradientMap,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,GradientMap,The following statement contains a magic number: r.JumpToEvenNthByte (2);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,GradientMap,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,GradientMap,The following statement contains a magic number: this.MinChannelValues = r.ReadPSDChannelValues (4);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,GradientMap,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,GradientMap,The following statement contains a magic number: this.MaxChannelValues = r.ReadPSDChannelValues (4);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,PhotoFilter,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Adjustments.cs,PhotoFilter,The following statement contains a magic number: r.BaseStream.Position += 16;  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Curves,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Curves.cs,Curves,The following statement contains a magic number: if (r.BytesToEnd > 0) {  	//Same again? Clear Records and begin anew? Brrr... Adobe' argh!  	string head = new string (r.ReadPSDChars (4));  	version = r.ReadUInt16 ();  	//version??  	uint numCurves = r.ReadUInt32 ();  	for (int i = 0; i < numCurves; i++) {  		ushort channelId = r.ReadUInt16 ();  		Curve curve = new Curve (r);  		curve.Channel = (int)channelId - 1;  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,SectionDivider,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\DivResources.cs,SectionDivider,The following statement contains a magic number: if (r.BytesToEnd > 0) {  	string header = new string (r.ReadPSDChars (4));  	this.BlendKey = new string (r.ReadPSDChars (4));  	if (this.BlendKey != "pass") {  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,SectionDivider,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\DivResources.cs,SectionDivider,The following statement contains a magic number: if (r.BytesToEnd > 0) {  	string header = new string (r.ReadPSDChars (4));  	this.BlendKey = new string (r.ReadPSDChars (4));  	if (this.BlendKey != "pass") {  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,SectionDivider,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\DivResources.cs,SectionDivider,The following statement contains a magic number: this.BlendKey = new string (r.ReadPSDChars (4));  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Txt2,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\DivResources.cs,Txt2,The following statement contains a magic number: if (readData) {  	BinaryPSDReader r = this.GetDataReader ();  	r.BaseStream.Position += 2;  	this.Values = new DynVal ();  	this.Values.Children = new List<DynVal> ();  	while (true) {  		DynVal child = new DynVal ();  		this.Values.Children.Add (child);  		try {  			if (child.ReadTdtaItem (r) == false)  				break;  		} catch (Exception ex) {  		}  	}  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Txt2,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\DivResources.cs,Txt2,The following statement contains a magic number: r.BaseStream.Position += 2;  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Effects,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Effects,The following statement contains a magic number: r.BaseStream.Position += 2;  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Glow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO!  	if (this.Inner)  		this.Unknown = r.ReadByte ();  	this.UnknownColor = r.ReadPSDColor (16' true);  	this.Data = r.ReadBytes ((int)r.BytesToEnd);  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Glow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO!  	if (this.Inner)  		this.Unknown = r.ReadByte ();  	this.UnknownColor = r.ReadPSDColor (16' true);  	this.Data = r.ReadBytes ((int)r.BytesToEnd);  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Glow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO!  	if (this.Inner)  		this.Unknown = r.ReadByte ();  	this.UnknownColor = r.ReadPSDColor (16' true);  	this.Data = r.ReadBytes ((int)r.BytesToEnd);  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Glow,The following statement contains a magic number: this.Color = r.ReadPSDColor (16' true);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Glow,The following statement contains a magic number: this.UnknownColor = r.ReadPSDColor (16' true);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Bevel,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Bevel,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Bevel,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Bevel,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Bevel,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Bevel,The following statement contains a magic number: this.Color = r.ReadPSDColor (16' true);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Bevel,The following statement contains a magic number: this.ShadowColor = r.ReadPSDColor (16' true);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Shadow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	//this.BlendModeSignature = r.ReadUInt32();  	//this.BlendModeKey = r.ReadUInt32();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	//TODO:?  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO: 10 unknown bytes!  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Shadow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	//this.BlendModeSignature = r.ReadUInt32();  	//this.BlendModeKey = r.ReadUInt32();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	//TODO:?  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO: 10 unknown bytes!  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Shadow,The following statement contains a magic number: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	//this.BlendModeSignature = r.ReadUInt32();  	//this.BlendModeKey = r.ReadUInt32();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	//TODO:?  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO: 10 unknown bytes!  	break;  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Shadow,The following statement contains a magic number: this.Color = r.ReadPSDColor (16' true);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Shadow,The following statement contains a magic number: this.Color = r.ReadPSDColor (16' true);  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,Levels,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Levels.cs,Levels,The following statement contains a magic number: if (r.BytesToEnd > 0) {  	string head = new string (r.ReadPSDChars (4));  	ushort unknown1 = r.ReadUInt16 ();  	ushort unknown2 = r.ReadUInt16 ();  	while (r.BytesToEnd > 0)  		this.Records.Add (new LevelRecord (r));  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,TypeTool,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\TypeTool.cs,TypeTool,The following statement contains a magic number: for (int i = 0; i < 6; i++)  	//2D transform matrix  	reader.ReadPSDDouble ();  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,TypeTool,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\TypeTool.cs,TypeTool,The following statement contains a magic number: for (int i = 0; i < StyleCount; i++) {  	ushort Mark = reader.ReadUInt16 ();  	ushort FaceMark = reader.ReadUInt16 ();  	uint Size = reader.ReadUInt32 ();  	uint Tracking = reader.ReadUInt32 ();  	uint Kerning = reader.ReadUInt32 ();  	uint Leading = reader.ReadUInt32 ();  	uint BaseShift = reader.ReadUInt32 ();  	byte AutoKern = reader.ReadByte ();  	byte Extra = 0;  	if (Version <= 5)  		Extra = reader.ReadByte ();  	byte Rotate = reader.ReadByte ();  }  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,TypeTool,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\TypeTool.cs,TypeTool,The following statement contains a magic number: if (Version <= 5)  	Extra = reader.ReadByte ();  
Magic Number,Endogine.Codecs.Photoshop.LayerResources,TypeTool,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\TypeTool.cs,TypeTool,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	reader.ReadUInt16 ();  
Missing Default,Endogine.Codecs.Photoshop,PixelData,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\PixelData.cs,PreReadPixels,The following switch statement is missing a default case: switch (compression) {  case Compression.Rle:  	//ignore rle "header" with bytes per row...  	reader.BaseStream.Position += this._height * 2;  	//ushort[] rowLenghtList = new ushort[height];  	//for (int i = 0; i < height; i++)  	//    rowLenghtList[i] = reader.ReadUInt16();  	break;  }  
Missing Default,Endogine.Codecs.Photoshop.ImageResources,PathInfo,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\ImageResources\PathInfo.cs,PathInfo,The following switch statement is missing a default case: switch (rtype) {  case RecordType.InitialFill:  	reader.BaseStream.Position += 1;  	bool allPixelStart = reader.ReadBoolean ();  	reader.BaseStream.Position += 22;  	break;  case RecordType.PathFill:  	if (cnt != 0)  		throw new Exception ("Path fill?!?");  	reader.BaseStream.Position += 24;  	break;  case RecordType.Clipboard:  	ERectangleF rct = new ERectangleF ();  	rct.Top = reader.ReadPSDSingle ();  	rct.Left = reader.ReadPSDSingle ();  	rct.Bottom = reader.ReadPSDSingle ();  	rct.Right = reader.ReadPSDSingle ();  	Clipboard clp = new Clipboard ();  	clp.Rectangle = rct;  	clp.Scale = reader.ReadPSDSingle ();  	reader.BaseStream.Position += 4;  	this.Commands.Add (clp);  	break;  case RecordType.ClosedPathLength:  case RecordType.OpenPathLength:  	numKnots = reader.ReadUInt16 ();  	reader.BaseStream.Position += 22;  	NewPath np = new NewPath ();  	np.Open = (rtype == RecordType.OpenPathLength);  	this.Commands.Add (np);  	break;  case RecordType.ClosedPathBezierKnotLinked:  case RecordType.ClosedPathBezierKnotUnlinked:  case RecordType.OpenPathBezierKnotLinked:  case RecordType.OpenPathBezierKnotUnlinked:  	BezierKnot bz = new BezierKnot ();  	EPointF[] pts = new EPointF[3];  	for (int i = 0; i < 3; i++) {  		float y = reader.ReadPSDFixedSingle ();  		//y comes first...  		pts [i] = new EPointF (reader.ReadPSDFixedSingle ()' y) / 256;  	}  	bz.Control1 = pts [0];  	bz.Anchor = pts [1];  	bz.Control2 = pts [2];  	bz.Linked = (rtype == RecordType.ClosedPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotLinked);  	//bz.Open = (rtype == RecordType.OpenPathBezierKnotLinked || rtype == RecordType.OpenPathBezierKnotUnlinked);  	this.Commands.Add (bz);  	numKnots--;  	break;  }  
Missing Default,Endogine.Codecs.Photoshop.LayerResources,Glow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Glow,The following switch statement is missing a default case: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO!  	if (this.Inner)  		this.Unknown = r.ReadByte ();  	this.UnknownColor = r.ReadPSDColor (16' true);  	this.Data = r.ReadBytes ((int)r.BytesToEnd);  	break;  }  
Missing Default,Endogine.Codecs.Photoshop.LayerResources,Bevel,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Bevel,The following switch statement is missing a default case: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Data = null;  	break;  case 2:  	this.Angle = (uint)r.ReadUInt16 ();  	this.Strength = (uint)r.ReadUInt16 ();  	this.Blur = (uint)r.ReadUInt16 ();  	this.Unknown1 = r.ReadByte ();  	this.Unknown2 = r.ReadByte ();  	this.Unknown3 = r.ReadUInt16 ();  	this.Unknown4 = r.ReadUInt16 ();  	this.BlendModeKey = this.ReadBlendKey (r);  	this.ShadowBlendModeKey = this.ReadBlendKey (r);  	this.Color = r.ReadPSDColor (16' true);  	this.ShadowColor = r.ReadPSDColor (16' true);  	this.BevelStyle = r.ReadByte ();  	this.Opacity = r.ReadByte ();  	this.ShadowOpacity = r.ReadByte ();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Inverted = r.ReadBoolean ();  	System.Drawing.Color someColor = r.ReadPSDColor (16' true);  	System.Drawing.Color someColor2 = r.ReadPSDColor (16' true);  	break;  }  
Missing Default,Endogine.Codecs.Photoshop.LayerResources,Shadow,F:\newReposMay17\imazen_resizer\Plugins\Libs\Endogine\Endogine.Codecs.Photoshop\LayerResources\Effects.cs,Shadow,The following switch statement is missing a default case: switch (version) {  case 0:  	this.Blur = r.ReadUInt32 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	//this.BlendModeSignature = r.ReadUInt32();  	//this.BlendModeKey = r.ReadUInt32();  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	break;  case 2:  	this.Blur = (uint)r.ReadUInt16 ();  	this.Intensity = r.ReadUInt32 ();  	this.Angle = r.ReadUInt32 ();  	this.Distance = r.ReadUInt32 ();  	ushort something = r.ReadUInt16 ();  	//TODO:?  	this.Color = r.ReadPSDColor (16' true);  	this.BlendModeKey = this.ReadBlendKey (r);  	this.Enabled = r.ReadBoolean ();  	this.UseGlobalAngle = r.ReadBoolean ();  	this.Opacity = r.ReadByte ();  	//TODO: 10 unknown bytes!  	break;  }  
