Implementation smell,Namespace,Class,File,Method,Description
Complex Method,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,PrettyGifs,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,Cyclomatic complexity of the method is 11
Complex Method,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,Cyclomatic complexity of the method is 9
Complex Method,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,Cyclomatic complexity of the method is 11
Complex Method,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,QuantizeImage,Cyclomatic complexity of the method is 11
Long Parameter List,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The method has 7 parameters.
Long Parameter List,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,QuantizeImage,The method has 6 parameters.
Long Parameter List,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,AdjustNeighborSource,The method has 6 parameters.
Long Statement,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,CreateIfSuitable,The length of the statement  "	if (!string.IsNullOrEmpty (settings ["encoder"]) && !"prettygifs".Equals (settings ["encoder"]' StringComparison.OrdinalIgnoreCase)) " is 132.
Long Statement,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The length of the statement  "		quantizer.FirstPassPixelCount = (long)Math.Pow (query.Get<int> ("pixelCount"' (int)Math.Sqrt (quantizer.FirstPassPixelCount))' 2); " is 130.
Long Statement,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The length of the statement  "		quantizer.FirstPassPixelThreshold = (long)Math.Pow (query.Get<int> ("pixelThreshold"' (int)Math.Sqrt (quantizer.FirstPassPixelThreshold))' 2); " is 142.
Long Statement,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The length of the statement  "	//Quote: Second' I've found a solution for preserving GIF transparency when invoking Image::Save(...). The .NET (tested on v2.0)  " is 128.
Long Statement,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The length of the statement  "	//GIF encoder considers transparent the first color found in the palette' so I've changed some methods (replace them with the supplied ones): " is 141.
Long Statement,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The length of the statement  "		//To dither' we find the error (difference from real pixel to the palette color)' and subtract it from the next pixel. When that color is paletted'  " is 147.
Long Statement,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The length of the statement  "		//The issue is that error adjustments build up' so you're never working off the original color. Hopefully this doesn't cause issues. " is 132.
Long Statement,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The length of the statement  "						AdjustNeighborSource (x - 1' y - 1' (int)((float)errorR * adjust * -1)' (int)((float)errorG * adjust * -1)' (int)((float)errorB * adjust * -1)' (int)((float)errorA * adjust * -1)); " is 180.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The length of the statement  "			firstPass = new Bitmap ((int)Math.Floor ((double)copy.Width * factor)' (int)Math.Floor ((double)copy.Height * factor)' PixelFormat.Format32bppArgb); " is 148.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The length of the statement  "				//Use the low-quality settings - we want the original colors of the image' nearest neighbor is better than bicubic spline here. " is 127.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The length of the statement  "		tempOutput = new Bitmap (OmitFinalStage ? 2 : src.Width' OmitFinalStage ? 2 : src.Height' PixelFormat.Format8bppIndexed); " is 121.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,QuantizeFullTrust,The length of the statement  "			firstPassData = firstPass.LockBits (new Rectangle (0' 0' firstPass.Width' firstPass.Height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppArgb); " is 147.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,AdjustNeighborSource,The length of the statement  "	IntPtr p = (IntPtr)((long)secondPassIntermediate.Scan0 + ((long)y * (long)secondPassIntermediate.Stride) + (PixelSize * x)); " is 124.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,AdjustNeighborSource,The length of the statement  "	//False to not dispose old block. Since no reference to it exists (I believe PtrToStructure from Color32 copies' not references)' this should be safe " is 149.
Complex Conditional,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The conditional expression  "firstPass != null && firstPass != copy && firstPass != src && firstPass != result"  is complex.
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,Write,The following statement contains a magic number: if (ImageFormat.Png.Equals (OutputFormat)) {  	if (useMax)  		DefaultEncoder.SavePng (i' s);  	else  		SaveIndexed (ImageFormat.Png' i' s' colors' Dither || FourPassDither' FourPassDither' DitherPercent);  } else if (ImageFormat.Gif.Equals (OutputFormat)) {  	if (useMax)  		SaveIndexed (ImageFormat.Gif' i' s' 255' Dither || FourPassDither' FourPassDither' DitherPercent);  	else  		SaveIndexed (ImageFormat.Gif' i' s' colors' Dither || FourPassDither' FourPassDither' DitherPercent);  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,Write,The following statement contains a magic number: if (ImageFormat.Gif.Equals (OutputFormat)) {  	if (useMax)  		SaveIndexed (ImageFormat.Gif' i' s' 255' Dither || FourPassDither' FourPassDither' DitherPercent);  	else  		SaveIndexed (ImageFormat.Gif' i' s' colors' Dither || FourPassDither' FourPassDither' DitherPercent);  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,Write,The following statement contains a magic number: if (useMax)  	SaveIndexed (ImageFormat.Gif' i' s' 255' Dither || FourPassDither' FourPassDither' DitherPercent);  else  	SaveIndexed (ImageFormat.Gif' i' s' colors' Dither || FourPassDither' FourPassDither' DitherPercent);  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,Write,The following statement contains a magic number: SaveIndexed (ImageFormat.Gif' i' s' 255' Dither || FourPassDither' FourPassDither' DitherPercent);  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: if (PreservePalette && originalPalette != null) {  	img.Palette = originalPalette;  	//If we are encoding in PNG' and writing to a non-seekable stream'  	//we have to buffer it all in memory or we'll get an exception  	if (!target.CanSeek && ImageFormat.Png.Equals (format)) {  		using (MemoryStream ms = new MemoryStream (4096)) {  			img.Save (ms' format);  			//Recursive call  			ms.WriteTo (target);  		}  	} else {  		//Everything else  		img.Save (target' format);  	}  	return;  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: if (!target.CanSeek && ImageFormat.Png.Equals (format)) {  	using (MemoryStream ms = new MemoryStream (4096)) {  		img.Save (ms' format);  		//Recursive call  		ms.WriteTo (target);  	}  } else {  	//Everything else  	img.Save (target' format);  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (4096)) {  	img.Save (ms' format);  	//Recursive call  	ms.WriteTo (target);  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: if (query.Get<bool> ("fulltrust"' HasFullTrust)) {  	quantizer.Dither = dither;  	quantizer.FourPass = fourPass;  	quantizer.DitherPercent = (float)ditherPercent / 100;  } else {  	quantizer.FullTrust = false;  	quantizer.OmitFinalStage = true;  	quantizer.ResizeForFirstPass = true;  	quantizer.FirstPassPixelCount = (long)Math.Pow (query.Get<int> ("pixelCount"' (int)Math.Sqrt (quantizer.FirstPassPixelCount))' 2);  	quantizer.FirstPassPixelThreshold = (long)Math.Pow (query.Get<int> ("pixelThreshold"' (int)Math.Sqrt (quantizer.FirstPassPixelThreshold))' 2);  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: if (query.Get<bool> ("fulltrust"' HasFullTrust)) {  	quantizer.Dither = dither;  	quantizer.FourPass = fourPass;  	quantizer.DitherPercent = (float)ditherPercent / 100;  } else {  	quantizer.FullTrust = false;  	quantizer.OmitFinalStage = true;  	quantizer.ResizeForFirstPass = true;  	quantizer.FirstPassPixelCount = (long)Math.Pow (query.Get<int> ("pixelCount"' (int)Math.Sqrt (quantizer.FirstPassPixelCount))' 2);  	quantizer.FirstPassPixelThreshold = (long)Math.Pow (query.Get<int> ("pixelThreshold"' (int)Math.Sqrt (quantizer.FirstPassPixelThreshold))' 2);  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: if (query.Get<bool> ("fulltrust"' HasFullTrust)) {  	quantizer.Dither = dither;  	quantizer.FourPass = fourPass;  	quantizer.DitherPercent = (float)ditherPercent / 100;  } else {  	quantizer.FullTrust = false;  	quantizer.OmitFinalStage = true;  	quantizer.ResizeForFirstPass = true;  	quantizer.FirstPassPixelCount = (long)Math.Pow (query.Get<int> ("pixelCount"' (int)Math.Sqrt (quantizer.FirstPassPixelCount))' 2);  	quantizer.FirstPassPixelThreshold = (long)Math.Pow (query.Get<int> ("pixelThreshold"' (int)Math.Sqrt (quantizer.FirstPassPixelThreshold))' 2);  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: quantizer.DitherPercent = (float)ditherPercent / 100;  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: quantizer.FirstPassPixelCount = (long)Math.Pow (query.Get<int> ("pixelCount"' (int)Math.Sqrt (quantizer.FirstPassPixelCount))' 2);  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: quantizer.FirstPassPixelThreshold = (long)Math.Pow (query.Get<int> ("pixelThreshold"' (int)Math.Sqrt (quantizer.FirstPassPixelThreshold))' 2);  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: using (Bitmap quantized = quantizer.Quantize (img)) {  	//If we are encoding in PNG' and writing to a non-seekable stream'  	//we have to buffer it all in memory or we'll get an exception  	if (!target.CanSeek && ImageFormat.Png.Equals (format)) {  		using (MemoryStream ms = new MemoryStream (4096)) {  			quantized.Save (ms' format);  			//Recursive call  			ms.WriteTo (target);  		}  	} else {  		//Everything else  		quantized.Save (target' format);  	}  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: if (!target.CanSeek && ImageFormat.Png.Equals (format)) {  	using (MemoryStream ms = new MemoryStream (4096)) {  		quantized.Save (ms' format);  		//Recursive call  		ms.WriteTo (target);  	}  } else {  	//Everything else  	quantized.Save (target' format);  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (4096)) {  	quantized.Save (ms' format);  	//Recursive call  	ms.WriteTo (target);  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,GetBitsNeededForColorDepth,The following statement contains a magic number: return (int)Math.Ceiling (Math.Log (colors' 2));  
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,Reset,The following statement contains a magic number: if (maxColors > 255)  	throw new ArgumentOutOfRangeException ("maxColors"' maxColors' "The number of colors should be less than 256");  
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,Reset,The following statement contains a magic number: if ((maxColorBits < 1) | (maxColorBits > 8))  	throw new ArgumentOutOfRangeException ("maxColorBits"' maxColorBits' "This should be between 1 and 8");  
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The following statement contains a magic number: if (pixel.Alpha > 0) {  	paletteIndex = (byte)_octree.GetPaletteIndex (pixel);  	//For dithering we need to track 6 pixels.   	//To dither' we find the error (difference from real pixel to the palette color)' and subtract it from the next pixel. When that color is paletted'   	//The dither occurs.  	//The issue is that error adjustments build up' so you're never working off the original color. Hopefully this doesn't cause issues.  	if (Dither) {  		Color n = _lastPalette.Entries [paletteIndex];  		//The palette version  		//Calculate error for the current pixel  		int errorR = n.R - pixel.Red;  		int errorG = n.G - pixel.Green;  		int errorB = n.B - pixel.Blue;  		int errorA = n.A - pixel.Alpha;  		for (int y = 1; y < 3; y++)  			for (int x = 0; x < 3; x++) {  				float adjust = DitherMatrix [y' x] * DitherPercent;  				//How much of the error should be passed on (in negative form) the this neighbor pixel  				if (adjust != 0) {  					AdjustNeighborSource (x - 1' y - 1' (int)((float)errorR * adjust * -1)' (int)((float)errorG * adjust * -1)' (int)((float)errorB * adjust * -1)' (int)((float)errorA * adjust * -1));  				}  			}  	}  	if (TransparencyAtZero)  		paletteIndex++;  } else {  	if (TransparencyAtZero)  		paletteIndex = 0;  	else  		paletteIndex = (byte)_maxColors;  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The following statement contains a magic number: if (pixel.Alpha > 0) {  	paletteIndex = (byte)_octree.GetPaletteIndex (pixel);  	//For dithering we need to track 6 pixels.   	//To dither' we find the error (difference from real pixel to the palette color)' and subtract it from the next pixel. When that color is paletted'   	//The dither occurs.  	//The issue is that error adjustments build up' so you're never working off the original color. Hopefully this doesn't cause issues.  	if (Dither) {  		Color n = _lastPalette.Entries [paletteIndex];  		//The palette version  		//Calculate error for the current pixel  		int errorR = n.R - pixel.Red;  		int errorG = n.G - pixel.Green;  		int errorB = n.B - pixel.Blue;  		int errorA = n.A - pixel.Alpha;  		for (int y = 1; y < 3; y++)  			for (int x = 0; x < 3; x++) {  				float adjust = DitherMatrix [y' x] * DitherPercent;  				//How much of the error should be passed on (in negative form) the this neighbor pixel  				if (adjust != 0) {  					AdjustNeighborSource (x - 1' y - 1' (int)((float)errorR * adjust * -1)' (int)((float)errorG * adjust * -1)' (int)((float)errorB * adjust * -1)' (int)((float)errorA * adjust * -1));  				}  			}  	}  	if (TransparencyAtZero)  		paletteIndex++;  } else {  	if (TransparencyAtZero)  		paletteIndex = 0;  	else  		paletteIndex = (byte)_maxColors;  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The following statement contains a magic number: if (Dither) {  	Color n = _lastPalette.Entries [paletteIndex];  	//The palette version  	//Calculate error for the current pixel  	int errorR = n.R - pixel.Red;  	int errorG = n.G - pixel.Green;  	int errorB = n.B - pixel.Blue;  	int errorA = n.A - pixel.Alpha;  	for (int y = 1; y < 3; y++)  		for (int x = 0; x < 3; x++) {  			float adjust = DitherMatrix [y' x] * DitherPercent;  			//How much of the error should be passed on (in negative form) the this neighbor pixel  			if (adjust != 0) {  				AdjustNeighborSource (x - 1' y - 1' (int)((float)errorR * adjust * -1)' (int)((float)errorG * adjust * -1)' (int)((float)errorB * adjust * -1)' (int)((float)errorA * adjust * -1));  			}  		}  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The following statement contains a magic number: if (Dither) {  	Color n = _lastPalette.Entries [paletteIndex];  	//The palette version  	//Calculate error for the current pixel  	int errorR = n.R - pixel.Red;  	int errorG = n.G - pixel.Green;  	int errorB = n.B - pixel.Blue;  	int errorA = n.A - pixel.Alpha;  	for (int y = 1; y < 3; y++)  		for (int x = 0; x < 3; x++) {  			float adjust = DitherMatrix [y' x] * DitherPercent;  			//How much of the error should be passed on (in negative form) the this neighbor pixel  			if (adjust != 0) {  				AdjustNeighborSource (x - 1' y - 1' (int)((float)errorR * adjust * -1)' (int)((float)errorG * adjust * -1)' (int)((float)errorB * adjust * -1)' (int)((float)errorA * adjust * -1));  			}  		}  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The following statement contains a magic number: for (int y = 1; y < 3; y++)  	for (int x = 0; x < 3; x++) {  		float adjust = DitherMatrix [y' x] * DitherPercent;  		//How much of the error should be passed on (in negative form) the this neighbor pixel  		if (adjust != 0) {  			AdjustNeighborSource (x - 1' y - 1' (int)((float)errorR * adjust * -1)' (int)((float)errorG * adjust * -1)' (int)((float)errorB * adjust * -1)' (int)((float)errorA * adjust * -1));  		}  	}  
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The following statement contains a magic number: for (int y = 1; y < 3; y++)  	for (int x = 0; x < 3; x++) {  		float adjust = DitherMatrix [y' x] * DitherPercent;  		//How much of the error should be passed on (in negative form) the this neighbor pixel  		if (adjust != 0) {  			AdjustNeighborSource (x - 1' y - 1' (int)((float)errorR * adjust * -1)' (int)((float)errorG * adjust * -1)' (int)((float)errorB * adjust * -1)' (int)((float)errorA * adjust * -1));  		}  	}  
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The following statement contains a magic number: for (int x = 0; x < 3; x++) {  	float adjust = DitherMatrix [y' x] * DitherPercent;  	//How much of the error should be passed on (in negative form) the this neighbor pixel  	if (adjust != 0) {  		AdjustNeighborSource (x - 1' y - 1' (int)((float)errorR * adjust * -1)' (int)((float)errorG * adjust * -1)' (int)((float)errorB * adjust * -1)' (int)((float)errorA * adjust * -1));  	}  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The following statement contains a magic number: try {  	// First off take a 32bpp copy of 'source' if it's not a 32bpp Bitmap instance.  	copy = src as Bitmap;  	if (FourPass || copy == null || !src.PixelFormat.Equals (PixelFormat.Format32bppArgb)) {  		copy = new Bitmap (src.Width' src.Height' PixelFormat.Format32bppArgb);  		// Now lock the bitmap into memory  		using (Graphics g = Graphics.FromImage (copy)) {  			g.PageUnit = GraphicsUnit.Pixel;  			// Draw the source image onto the copy bitmap'  			// which will effect a widening as appropriate.  			g.DrawImage (src' new Point (0' 0));  		}  	}  	firstPass = copy;  	//If we should make a resized version for the first pass' let's do it.  	if (!FixedPalette && ResizeForFirstPass && FirstPassPixelThreshold < copy.Width * copy.Height) {  		double factor = FirstPassPixelCount / ((double)copy.Width * (double)copy.Height);  		firstPass = new Bitmap ((int)Math.Floor ((double)copy.Width * factor)' (int)Math.Floor ((double)copy.Height * factor)' PixelFormat.Format32bppArgb);  		using (Graphics g = Graphics.FromImage (firstPass)) {  			//Use the low-quality settings - we want the original colors of the image' nearest neighbor is better than bicubic spline here.  			g.PageUnit = GraphicsUnit.Pixel;  			g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.NearestNeighbor;  			g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighSpeed;  			g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.None;  			g.DrawImage (copy' 0' 0' firstPass.Width' firstPass.Height);  		}  	}  	copy2 = null;  	if (FourPass) {  		copy2 = new Bitmap (src.Width' src.Height' PixelFormat.Format32bppArgb);  		using (Graphics g = Graphics.FromImage (copy2)) {  			g.PageUnit = GraphicsUnit.Pixel;  			g.DrawImage (src' new Point (0' 0));  		}  	}  	// And make an 8-bit output image  	tempOutput = new Bitmap (OmitFinalStage ? 2 : src.Width' OmitFinalStage ? 2 : src.Height' PixelFormat.Format8bppIndexed);  	//Full trust and low trust are implemented differently.   	if (FullTrust) {  		result = QuantizeFullTrust (firstPass' copy' copy2' tempOutput);  	} else {  		result = QuantizeLowTrust (firstPass' copy' copy2' tempOutput);  	}  	return result;  } finally {  	if (firstPass != null && firstPass != copy && firstPass != src && firstPass != result)  		firstPass.Dispose ();  	if (copy != null && copy != src && copy != result)  		copy.Dispose ();  	if (copy2 != null && copy2 != src && copy2 != result)  		copy2.Dispose ();  	if (tempOutput != null && tempOutput != src && tempOutput != result)  		tempOutput.Dispose ();  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The following statement contains a magic number: try {  	// First off take a 32bpp copy of 'source' if it's not a 32bpp Bitmap instance.  	copy = src as Bitmap;  	if (FourPass || copy == null || !src.PixelFormat.Equals (PixelFormat.Format32bppArgb)) {  		copy = new Bitmap (src.Width' src.Height' PixelFormat.Format32bppArgb);  		// Now lock the bitmap into memory  		using (Graphics g = Graphics.FromImage (copy)) {  			g.PageUnit = GraphicsUnit.Pixel;  			// Draw the source image onto the copy bitmap'  			// which will effect a widening as appropriate.  			g.DrawImage (src' new Point (0' 0));  		}  	}  	firstPass = copy;  	//If we should make a resized version for the first pass' let's do it.  	if (!FixedPalette && ResizeForFirstPass && FirstPassPixelThreshold < copy.Width * copy.Height) {  		double factor = FirstPassPixelCount / ((double)copy.Width * (double)copy.Height);  		firstPass = new Bitmap ((int)Math.Floor ((double)copy.Width * factor)' (int)Math.Floor ((double)copy.Height * factor)' PixelFormat.Format32bppArgb);  		using (Graphics g = Graphics.FromImage (firstPass)) {  			//Use the low-quality settings - we want the original colors of the image' nearest neighbor is better than bicubic spline here.  			g.PageUnit = GraphicsUnit.Pixel;  			g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.NearestNeighbor;  			g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighSpeed;  			g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.None;  			g.DrawImage (copy' 0' 0' firstPass.Width' firstPass.Height);  		}  	}  	copy2 = null;  	if (FourPass) {  		copy2 = new Bitmap (src.Width' src.Height' PixelFormat.Format32bppArgb);  		using (Graphics g = Graphics.FromImage (copy2)) {  			g.PageUnit = GraphicsUnit.Pixel;  			g.DrawImage (src' new Point (0' 0));  		}  	}  	// And make an 8-bit output image  	tempOutput = new Bitmap (OmitFinalStage ? 2 : src.Width' OmitFinalStage ? 2 : src.Height' PixelFormat.Format8bppIndexed);  	//Full trust and low trust are implemented differently.   	if (FullTrust) {  		result = QuantizeFullTrust (firstPass' copy' copy2' tempOutput);  	} else {  		result = QuantizeLowTrust (firstPass' copy' copy2' tempOutput);  	}  	return result;  } finally {  	if (firstPass != null && firstPass != copy && firstPass != src && firstPass != result)  		firstPass.Dispose ();  	if (copy != null && copy != src && copy != result)  		copy.Dispose ();  	if (copy2 != null && copy2 != src && copy2 != result)  		copy2.Dispose ();  	if (tempOutput != null && tempOutput != src && tempOutput != result)  		tempOutput.Dispose ();  }  
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The following statement contains a magic number: tempOutput = new Bitmap (OmitFinalStage ? 2 : src.Width' OmitFinalStage ? 2 : src.Height' PixelFormat.Format8bppIndexed);  
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The following statement contains a magic number: tempOutput = new Bitmap (OmitFinalStage ? 2 : src.Width' OmitFinalStage ? 2 : src.Height' PixelFormat.Format8bppIndexed);  
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,ToByte,The following statement contains a magic number: if (i > 255)  	return 255;  
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,ToByte,The following statement contains a magic number: if (i > 255)  	return 255;  
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,F:\newReposMay17\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,ToByte,The following statement contains a magic number: return 255;  
