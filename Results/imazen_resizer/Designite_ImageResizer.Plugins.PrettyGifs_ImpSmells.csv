Implementation smell,Namespace,Class,File,Method,Description
Complex Method,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,QuantizeImage,Cyclomatic complexity of the method is 11
Long Parameter List,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The method has 7 parameters. Parameters: format' img' target' colors' dither' fourPass' ditherPercent
Long Parameter List,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,QuantizeImage,The method has 6 parameters. Parameters: sourceData' intermediate' output' width' height' bounds
Long Parameter List,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,AdjustNeighborSource,The method has 6 parameters. Parameters: offsetX' offsetY' deltaR' deltaG' deltaB' deltaA
Long Statement,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,CreateIfSuitable,The length of the statement  "            if (!string.IsNullOrEmpty(settings["encoder"]) && !"prettygifs".Equals(settings["encoder"]' StringComparison.OrdinalIgnoreCase)) return null;" is 141.
Long Statement,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,CreateIfSuitable,The length of the statement  "            if (ImageFormat.Gif.Equals(f) || (ImageFormat.Png.Equals(f) && settings["colors"] != null)) return new PrettyGifs(settings' original);" is 134.
Long Statement,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,GetFormatIfSuitable,The length of the statement  "            ImageFormat requestedFormat = DefaultEncoder.GetRequestedFormat(settings.Format' originalFormat); //fallback to originalFormat if not specified." is 144.
Long Statement,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The length of the statement  "                quantizer.FirstPassPixelCount = (long)Math.Pow(query.Get<int>( "pixelCount"' (int)Math.Sqrt(quantizer.FirstPassPixelCount))'2);" is 127.
Long Statement,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The length of the statement  "                quantizer.FirstPassPixelThreshold = (long)Math.Pow(query.Get<int>( "pixelThreshold"' (int)Math.Sqrt(quantizer.FirstPassPixelThreshold))' 2);" is 140.
Long Statement,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The length of the statement  "            //Quote: Second' I've found a solution for preserving GIF transparency when invoking Image::Save(...). The .NET (tested on v2.0) " is 128.
Long Statement,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The length of the statement  "            //GIF encoder considers transparent the first color found in the palette' so I've changed some methods (replace them with the supplied ones):" is 141.
Long Statement,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The length of the statement  "                //To dither' we find the error (difference from real pixel to the palette color)' and subtract it from the next pixel. When that color is paletted' " is 147.
Long Statement,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The length of the statement  "                //The issue is that error adjustments build up' so you're never working off the original color. Hopefully this doesn't cause issues." is 132.
Long Statement,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The length of the statement  "                            float adjust = DitherMatrix[y' x] * DitherPercent;//How much of the error should be passed on (in negative form) the this neighbor pixel" is 136.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,ValidatePropertyValues,The length of the statement  "            if (!FullTrust && !OmitFinalStage) throw new Exception("If FullTrust=False' OmitFinalStage must be set to true. The final stage requires full trust.");" is 151.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,ValidatePropertyValues,The length of the statement  "            if (!FullTrust && FourPass) throw new Exception("If FullTrust=False' FourPass must be false also. Four-pass quantization requires full trust.");" is 144.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The length of the statement  "                    firstPass = new Bitmap((int)Math.Floor((double)copy.Width * factor)' (int)Math.Floor((double)copy.Height * factor)' PixelFormat.Format32bppArgb);" is 145.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The length of the statement  "                        //Use the low-quality settings - we want the original colors of the image' nearest neighbor is better than bicubic spline here." is 127.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The length of the statement  "                tempOutput = new Bitmap(OmitFinalStage ? 2 : src.Width' OmitFinalStage ? 2 : src.Height' PixelFormat.Format8bppIndexed);" is 120.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,QuantizeFullTrust,The length of the statement  "                    firstPassData = firstPass.LockBits(new Rectangle(0' 0' firstPass.Width' firstPass.Height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppArgb);" is 145.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,QuantizeImage,The length of the statement  "            secondPassIntermediate = (intermediate != null) ? intermediate : sourceData;// Not thread safe.... But nothing here is anyways...//For dithering - 5-18-09 ndj" is 158.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,AdjustNeighborSource,The length of the statement  "            IntPtr p = (IntPtr)((long)secondPassIntermediate.Scan0 + ((long)y * (long)secondPassIntermediate.Stride) + (PixelSize * x));" is 124.
Long Statement,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,AdjustNeighborSource,The length of the statement  "            Marshal.StructureToPtr(c' p' true); //False to not dispose old block. Since no reference to it exists (I believe PtrToStructure from Color32 copies' not references)' this should be safe" is 185.
Complex Conditional,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The conditional expression  "firstPass != null && firstPass != copy && firstPass != src && firstPass != result"  is complex.
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,Write,The following statement contains a magic number: byte colors = (byte)Math.Min(Math.Max(this.Colors' 1)' 255);
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,Write,The following statement contains a magic number: if (ImageFormat.Png.Equals(OutputFormat)) {                  if (useMax)                     DefaultEncoder.SavePng(i' s);                 else                     SaveIndexed(ImageFormat.Png' i' s' colors' Dither || FourPassDither' FourPassDither' DitherPercent);             } else if (ImageFormat.Gif.Equals(OutputFormat)) {                  if (useMax)                     SaveIndexed(ImageFormat.Gif' i' s' 255' Dither || FourPassDither' FourPassDither' DitherPercent);                 else                     SaveIndexed(ImageFormat.Gif' i' s' colors' Dither || FourPassDither' FourPassDither' DitherPercent);             }
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: if (PreservePalette && originalPalette != null) {                 img.Palette = originalPalette;                 //If we are encoding in PNG' and writing to a non-seekable stream'                 //we have to buffer it all in memory or we'll get an exception                 if (!target.CanSeek && ImageFormat.Png.Equals(format)) {                     using (MemoryStream ms = new MemoryStream(4096)) {                         img.Save(ms'format); //Recursive call                         ms.WriteTo(target);                     }                 } else {                     //Everything else                     img.Save(target' format);                 }                 return;             }
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: if (query.Get<bool>("fulltrust"'HasFullTrust)) {                 quantizer.Dither = dither;                 quantizer.FourPass = fourPass;                 quantizer.DitherPercent = (float)ditherPercent / 100;             } else {                 quantizer.FullTrust = false;                 quantizer.OmitFinalStage = true;                 quantizer.ResizeForFirstPass = true;                  quantizer.FirstPassPixelCount = (long)Math.Pow(query.Get<int>( "pixelCount"' (int)Math.Sqrt(quantizer.FirstPassPixelCount))'2);                 quantizer.FirstPassPixelThreshold = (long)Math.Pow(query.Get<int>( "pixelThreshold"' (int)Math.Sqrt(quantizer.FirstPassPixelThreshold))' 2);                              }
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: if (query.Get<bool>("fulltrust"'HasFullTrust)) {                 quantizer.Dither = dither;                 quantizer.FourPass = fourPass;                 quantizer.DitherPercent = (float)ditherPercent / 100;             } else {                 quantizer.FullTrust = false;                 quantizer.OmitFinalStage = true;                 quantizer.ResizeForFirstPass = true;                  quantizer.FirstPassPixelCount = (long)Math.Pow(query.Get<int>( "pixelCount"' (int)Math.Sqrt(quantizer.FirstPassPixelCount))'2);                 quantizer.FirstPassPixelThreshold = (long)Math.Pow(query.Get<int>( "pixelThreshold"' (int)Math.Sqrt(quantizer.FirstPassPixelThreshold))' 2);                              }
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: if (query.Get<bool>("fulltrust"'HasFullTrust)) {                 quantizer.Dither = dither;                 quantizer.FourPass = fourPass;                 quantizer.DitherPercent = (float)ditherPercent / 100;             } else {                 quantizer.FullTrust = false;                 quantizer.OmitFinalStage = true;                 quantizer.ResizeForFirstPass = true;                  quantizer.FirstPassPixelCount = (long)Math.Pow(query.Get<int>( "pixelCount"' (int)Math.Sqrt(quantizer.FirstPassPixelCount))'2);                 quantizer.FirstPassPixelThreshold = (long)Math.Pow(query.Get<int>( "pixelThreshold"' (int)Math.Sqrt(quantizer.FirstPassPixelThreshold))' 2);                              }
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,SaveIndexed,The following statement contains a magic number: using (Bitmap quantized = quantizer.Quantize(img)) {                 //If we are encoding in PNG' and writing to a non-seekable stream'                 //we have to buffer it all in memory or we'll get an exception                 if (!target.CanSeek && ImageFormat.Png.Equals(format)) {                     using (MemoryStream ms = new MemoryStream(4096)) {                         quantized.Save(ms'format); //Recursive call                         ms.WriteTo(target);                     }                 } else {                     //Everything else                     quantized.Save(target' format);                 }             }
Magic Number,ImageResizer.Plugins.PrettyGifs,PrettyGifs,C:\repos\imazen_resizer\Plugins\PrettyGifs\PrettyGifs.cs,GetBitsNeededForColorDepth,The following statement contains a magic number: return (int)Math.Ceiling(Math.Log(colors' 2));
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,Reset,The following statement contains a magic number: if (maxColors > 255)                 throw new ArgumentOutOfRangeException("maxColors"' maxColors' "The number of colors should be less than 256");
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,Reset,The following statement contains a magic number: if ((maxColorBits < 1) | (maxColorBits > 8))                 throw new ArgumentOutOfRangeException("maxColorBits"' maxColorBits' "This should be between 1 and 8");
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The following statement contains a magic number: if (pixel.Alpha > 0)             {                 paletteIndex = (byte)_octree.GetPaletteIndex(pixel);                                   //For dithering we need to track 6 pixels.                   //To dither' we find the error (difference from real pixel to the palette color)' and subtract it from the next pixel. When that color is paletted'                  //The dither occurs.                 //The issue is that error adjustments build up' so you're never working off the original color. Hopefully this doesn't cause issues.                 if (Dither)                 {                     Color n = _lastPalette.Entries[paletteIndex]; //The palette version                     //Calculate error for the current pixel                     int errorR = n.R - pixel.Red;                     int errorG = n.G - pixel.Green;                     int errorB = n.B - pixel.Blue;                     int errorA = n.A - pixel.Alpha;                       for (int y = 1; y < 3;y++)                         for (int x = 0; x < 3; x++){                             float adjust = DitherMatrix[y' x] * DitherPercent;//How much of the error should be passed on (in negative form) the this neighbor pixel                             if (adjust != 0)                             {                                                                 AdjustNeighborSource(x - 1' y - 1' (int)((float)errorR * adjust * -1)'                                                                     (int)((float)errorG * adjust * -1)'                                                                     (int)((float)errorB * adjust * -1)'                                                                     (int)((float)errorA * adjust * -1));                                                                 }                         }                                      }                  if (TransparencyAtZero) paletteIndex++;             }             else             {                 if (TransparencyAtZero)                     paletteIndex = 0;                 else                     paletteIndex = (byte)_maxColors;             }
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeQuantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,QuantizePixel,The following statement contains a magic number: if (pixel.Alpha > 0)             {                 paletteIndex = (byte)_octree.GetPaletteIndex(pixel);                                   //For dithering we need to track 6 pixels.                   //To dither' we find the error (difference from real pixel to the palette color)' and subtract it from the next pixel. When that color is paletted'                  //The dither occurs.                 //The issue is that error adjustments build up' so you're never working off the original color. Hopefully this doesn't cause issues.                 if (Dither)                 {                     Color n = _lastPalette.Entries[paletteIndex]; //The palette version                     //Calculate error for the current pixel                     int errorR = n.R - pixel.Red;                     int errorG = n.G - pixel.Green;                     int errorB = n.B - pixel.Blue;                     int errorA = n.A - pixel.Alpha;                       for (int y = 1; y < 3;y++)                         for (int x = 0; x < 3; x++){                             float adjust = DitherMatrix[y' x] * DitherPercent;//How much of the error should be passed on (in negative form) the this neighbor pixel                             if (adjust != 0)                             {                                                                 AdjustNeighborSource(x - 1' y - 1' (int)((float)errorR * adjust * -1)'                                                                     (int)((float)errorG * adjust * -1)'                                                                     (int)((float)errorB * adjust * -1)'                                                                     (int)((float)errorA * adjust * -1));                                                                 }                         }                                      }                  if (TransparencyAtZero) paletteIndex++;             }             else             {                 if (TransparencyAtZero)                     paletteIndex = 0;                 else                     paletteIndex = (byte)_maxColors;             }
Magic Number,ImageResizer.Plugins.PrettyGifs,Octree,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,Octree,The following statement contains a magic number: _reducibleNodes = new OctreeNode[9] ;
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeNode,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,OctreeNode,The following statement contains a magic number: if ( _leaf )                     {                         octree.Leaves++ ;                         _nextReducible = null ;                         _children = null ;                      }                     else                     {                         // Otherwise add this to the reducible nodes                         _nextReducible = octree.ReducibleNodes[level] ;                         octree.ReducibleNodes[level] = this ;                         _children = new OctreeNode[8] ;                     }
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeNode,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,AddColor,The following statement contains a magic number: if ( _leaf )                     {                         Increment ( pixel ) ;                         // Setup the previous node                         octree.TrackPrevious ( this ) ;                     }                     else                     {                         // Go to the next level down in the tree                         int	shift = 7 - level ;                         int index = ( ( pixel.Red & mask[level] ) >> ( shift - 2 ) ) |                             ( ( pixel.Green & mask[level] ) >> ( shift - 1 ) ) |                             ( ( pixel.Blue & mask[level] ) >> ( shift ) ) ;                          OctreeNode	child = _children[index] ;                          if ( null == child )                         {                             // Create a new child node & store in the array                             child = new OctreeNode ( level + 1 ' colorBits ' octree ) ;                              _children[index] = child ;                         }                          // Add the color to the child node                         child.AddColor ( pixel ' colorBits ' level + 1 ' octree ) ;                     }
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeNode,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,AddColor,The following statement contains a magic number: if ( _leaf )                     {                         Increment ( pixel ) ;                         // Setup the previous node                         octree.TrackPrevious ( this ) ;                     }                     else                     {                         // Go to the next level down in the tree                         int	shift = 7 - level ;                         int index = ( ( pixel.Red & mask[level] ) >> ( shift - 2 ) ) |                             ( ( pixel.Green & mask[level] ) >> ( shift - 1 ) ) |                             ( ( pixel.Blue & mask[level] ) >> ( shift ) ) ;                          OctreeNode	child = _children[index] ;                          if ( null == child )                         {                             // Create a new child node & store in the array                             child = new OctreeNode ( level + 1 ' colorBits ' octree ) ;                              _children[index] = child ;                         }                          // Add the color to the child node                         child.AddColor ( pixel ' colorBits ' level + 1 ' octree ) ;                     }
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeNode,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,Reduce,The following statement contains a magic number: for ( int index = 0 ; index < 8 ; index++ )                     {                         if ( null != _children[index] )                         {                             _red += _children[index]._red ;                             _green += _children[index]._green ;                             _blue += _children[index]._blue ;                             _pixelCount += _children[index]._pixelCount ;                             ++children ;                             _children[index] = null ;                         }                     }
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeNode,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,ConstructPalette,The following statement contains a magic number: if ( _leaf )                     {                         // Consume the next palette index                         _paletteIndex = paletteIndex++ ;                          // And set the color of the palette entry                         palette.Add ( Color.FromArgb ( _red / _pixelCount ' _green / _pixelCount ' _blue / _pixelCount ) ) ;                     }                     else                     {                         // Loop through children looking for leaves                         for ( int index = 0 ; index < 8 ; index++ )                         {                             if ( null != _children[index] )                                 _children[index].ConstructPalette ( palette ' ref paletteIndex ) ;                         }                     }
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeNode,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,GetPaletteIndex,The following statement contains a magic number: if ( !_leaf )                     {                         int	shift = 7 - level ;                         int index = ( ( pixel.Red & mask[level] ) >> ( shift - 2 ) ) |                             ( ( pixel.Green & mask[level] ) >> ( shift - 1 ) ) |                             ( ( pixel.Blue & mask[level] ) >> ( shift ) ) ;                          if (null != _children[index])                             paletteIndex = _children[index].GetPaletteIndex(pixel' level + 1);                         else                         {                             //NDJ May-18-09: Occurs when dithering is enabled' since dithering causes new colors to appear in the image                             //throw new Exception("Didn't expect this!");                             //Find closest one nearby                             OctreeNode n = FindClosestMatch(pixel);                             if (n != null)  paletteIndex = n._paletteIndex;                         }                     }
Magic Number,ImageResizer.Plugins.PrettyGifs,OctreeNode,C:\repos\imazen_resizer\Plugins\PrettyGifs\OctreeQuantizer.cs,GetPaletteIndex,The following statement contains a magic number: if ( !_leaf )                     {                         int	shift = 7 - level ;                         int index = ( ( pixel.Red & mask[level] ) >> ( shift - 2 ) ) |                             ( ( pixel.Green & mask[level] ) >> ( shift - 1 ) ) |                             ( ( pixel.Blue & mask[level] ) >> ( shift ) ) ;                          if (null != _children[index])                             paletteIndex = _children[index].GetPaletteIndex(pixel' level + 1);                         else                         {                             //NDJ May-18-09: Occurs when dithering is enabled' since dithering causes new colors to appear in the image                             //throw new Exception("Didn't expect this!");                             //Find closest one nearby                             OctreeNode n = FindClosestMatch(pixel);                             if (n != null)  paletteIndex = n._paletteIndex;                         }                     }
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The following statement contains a magic number: try {                 // First off take a 32bpp copy of 'source' if it's not a 32bpp Bitmap instance.                 copy = src as Bitmap;                 if (FourPass || copy == null || !src.PixelFormat.Equals(PixelFormat.Format32bppArgb)) {                     copy = new Bitmap(src.Width' src.Height' PixelFormat.Format32bppArgb);                      // Now lock the bitmap into memory                     using (Graphics g = Graphics.FromImage(copy)) {                         g.PageUnit = GraphicsUnit.Pixel;                          // Draw the source image onto the copy bitmap'                         // which will effect a widening as appropriate.                         g.DrawImage(src' new Point(0' 0));                      }                 }                  firstPass = copy;                 //If we should make a resized version for the first pass' let's do it.                 if (!FixedPalette && ResizeForFirstPass && FirstPassPixelThreshold < copy.Width * copy.Height) {                     double factor = FirstPassPixelCount / ((double)copy.Width * (double)copy.Height);                     firstPass = new Bitmap((int)Math.Floor((double)copy.Width * factor)' (int)Math.Floor((double)copy.Height * factor)' PixelFormat.Format32bppArgb);                     using (Graphics g = Graphics.FromImage(firstPass)) {                         //Use the low-quality settings - we want the original colors of the image' nearest neighbor is better than bicubic spline here.                         g.PageUnit = GraphicsUnit.Pixel;                         g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.NearestNeighbor;                         g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighSpeed;                         g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.None;                         g.DrawImage(copy' 0' 0' firstPass.Width' firstPass.Height);                     }                 }                 copy2 = null;                 if (FourPass) {                     copy2 = new Bitmap(src.Width' src.Height' PixelFormat.Format32bppArgb);                     using (Graphics g = Graphics.FromImage(copy2)) {                         g.PageUnit = GraphicsUnit.Pixel;                         g.DrawImage(src' new Point(0' 0));                     }                 }                 // And make an 8-bit output image                 tempOutput = new Bitmap(OmitFinalStage ? 2 : src.Width' OmitFinalStage ? 2 : src.Height' PixelFormat.Format8bppIndexed);                  //Full trust and low trust are implemented differently.                  if (FullTrust) {                     result = QuantizeFullTrust(firstPass' copy' copy2' tempOutput);                 } else {                     result = QuantizeLowTrust(firstPass' copy' copy2' tempOutput);                 }                 return result;             } finally {                 if (firstPass != null && firstPass != copy && firstPass != src && firstPass != result) firstPass.Dispose();                 if (copy != null && copy != src && copy != result) copy.Dispose();                 if (copy2 != null && copy2 != src && copy2 != result) copy2.Dispose();                 if (tempOutput != null && tempOutput != src && tempOutput != result) tempOutput.Dispose();             }
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,Quantize,The following statement contains a magic number: try {                 // First off take a 32bpp copy of 'source' if it's not a 32bpp Bitmap instance.                 copy = src as Bitmap;                 if (FourPass || copy == null || !src.PixelFormat.Equals(PixelFormat.Format32bppArgb)) {                     copy = new Bitmap(src.Width' src.Height' PixelFormat.Format32bppArgb);                      // Now lock the bitmap into memory                     using (Graphics g = Graphics.FromImage(copy)) {                         g.PageUnit = GraphicsUnit.Pixel;                          // Draw the source image onto the copy bitmap'                         // which will effect a widening as appropriate.                         g.DrawImage(src' new Point(0' 0));                      }                 }                  firstPass = copy;                 //If we should make a resized version for the first pass' let's do it.                 if (!FixedPalette && ResizeForFirstPass && FirstPassPixelThreshold < copy.Width * copy.Height) {                     double factor = FirstPassPixelCount / ((double)copy.Width * (double)copy.Height);                     firstPass = new Bitmap((int)Math.Floor((double)copy.Width * factor)' (int)Math.Floor((double)copy.Height * factor)' PixelFormat.Format32bppArgb);                     using (Graphics g = Graphics.FromImage(firstPass)) {                         //Use the low-quality settings - we want the original colors of the image' nearest neighbor is better than bicubic spline here.                         g.PageUnit = GraphicsUnit.Pixel;                         g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.NearestNeighbor;                         g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighSpeed;                         g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.None;                         g.DrawImage(copy' 0' 0' firstPass.Width' firstPass.Height);                     }                 }                 copy2 = null;                 if (FourPass) {                     copy2 = new Bitmap(src.Width' src.Height' PixelFormat.Format32bppArgb);                     using (Graphics g = Graphics.FromImage(copy2)) {                         g.PageUnit = GraphicsUnit.Pixel;                         g.DrawImage(src' new Point(0' 0));                     }                 }                 // And make an 8-bit output image                 tempOutput = new Bitmap(OmitFinalStage ? 2 : src.Width' OmitFinalStage ? 2 : src.Height' PixelFormat.Format8bppIndexed);                  //Full trust and low trust are implemented differently.                  if (FullTrust) {                     result = QuantizeFullTrust(firstPass' copy' copy2' tempOutput);                 } else {                     result = QuantizeLowTrust(firstPass' copy' copy2' tempOutput);                 }                 return result;             } finally {                 if (firstPass != null && firstPass != copy && firstPass != src && firstPass != result) firstPass.Dispose();                 if (copy != null && copy != src && copy != result) copy.Dispose();                 if (copy2 != null && copy2 != src && copy2 != result) copy2.Dispose();                 if (tempOutput != null && tempOutput != src && tempOutput != result) tempOutput.Dispose();             }
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,ToByte,The following statement contains a magic number: if (i > 255) return 255;
Magic Number,ImageResizer.Plugins.PrettyGifs,Quantizer,C:\repos\imazen_resizer\Plugins\PrettyGifs\Quantizer.cs,ToByte,The following statement contains a magic number: if (i > 255) return 255;
