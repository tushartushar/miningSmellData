Implementation smell,Namespace,Class,File,Method,Description
Long Method,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The method has 121 lines of code.
Long Method,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The method has 126 lines of code.
Long Method,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The method has 120 lines of code.
Long Method,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The method has 112 lines of code.
Complex Method,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,Cyclomatic complexity of the method is 11
Complex Method,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,CleanFolder,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,Cyclomatic complexity of the method is 8
Long Parameter List,ImageResizer.Plugins.LicenseVerifier,Computation,C:\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,Computation,The method has 6 parameters. Parameters: c' trustedKeys' permanentIssueSink' mgr' clock' enforcementEnabled
Long Parameter List,ImageResizer.Plugins.LicenseVerifier,LicenseFetcher,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseFetcher.cs,LicenseFetcher,The method has 9 parameters. Parameters: clock' getClient' licenseResult' getInfo' sink' licenseId' licenseSecret' baseUrls' licenseFetchIntervalSeconds
Long Parameter List,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The method has 5 parameters. Parameters: keyBasis' extension' writeCallback' timeoutMs' asynchronous
Long Parameter List,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The method has 6 parameters. Parameters: result' physicalPath' relativePath' writeCallback' timeoutMs' recheckFS
Long Parameter List,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The method has 5 parameters. Parameters: keyBasis' extension' writeCallback' timeoutMs' asynchronous
Long Parameter List,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The method has 6 parameters. Parameters: result' physicalPath' relativePath' writeCallback' timeoutMs' recheckFS
Long Parameter List,ImageResizer.Plugins.SourceMemCache,ConstrainedCache<K;V>,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\ConstrainedCache.cs,ConstrainedCache,The method has 5 parameters. Parameters: keyComparer' calculator' maxBytes' usageWindow' minCleanupInterval
Long Identifier,ImageResizer.Plugins.DiskCache,CleanupStrategy,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,,The length of the parameter prohibitRemovalIfCreatedWithin is 30.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,C:\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,AreFeaturesLicensed,The length of the statement  "                    $"License {b.Fields.Id} needs to be upgraded; it does not cover in-use features {notCovered.SelectMany(v => v).Distinct().Delimited("' ")}"' b.ToRedactedString()'" is 162.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,C:\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,IsLicenseValid,The length of the statement  "                    $"License {details.Id} covers ImageResizer versions prior to {details.SubscriptionExpirationDate?.ToString("D")}' but you are using a build dated {GetBuildDate()?.ToString("D")}"'" is 179.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,C:\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,IsLicenseValid,The length of the statement  "                permanentIssues.AcceptIssue(new Issue($"License {details.Id}" + (message != null ? $": {message}" : " is no longer valid")'" is 123.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,C:\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,GetGracePeriodFor,The length of the statement  "                    $"License {chain.Id} was not found in the disk cache and could not be retrieved from the remote server within {graceMinutes} minutes."'" is 135.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,C:\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,SalesMessage,The length of the statement  "                return "Need to change domains? Get a discounted upgrade to a floating license: https://imageresizing.net/licenses/convert";" is 124.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,C:\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,SalesMessage,The length of the statement  "A universal license key would fix that. See if your purchase is eligible for a free key: https://imageresizing.net/licenses/convert";" is 133.
Long Statement,ImageResizer.Plugins.LicenseVerifier,DomainLookup,C:\repos\imazen_resizer\Plugins\LicenseVerifier\DomainLookup.cs,GetDomainMappings,The length of the statement  "                        $"You have mapped {from} to {to}. {to} is not one of the known domains: {string.Join(" "' knownDomains.OrderBy(s => s))}"'" is 122.
Long Statement,ImageResizer.Plugins.LicenseVerifier,LicenseChain,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseChain.cs,ToPublicString,The length of the statement  "                $"License {Id}{(IsRemote ? " (remote)" : "")}\n{string.Join("\n\n"' Licenses().Where(b => b.Fields.IsPublic()).Select(b => freshness(b) + b.ToRedactedString()))}\n");" is 166.
Long Statement,ImageResizer.Plugins.LicenseVerifier,LicenseChain,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseChain.cs,ToString,The length of the statement  "                $"License {Id} (remote={IsRemote})\n    {string.Join("\n\n"' Licenses().Select(b => freshness(b) + b.ToRedactedString())).Replace("\n"' "\n    ")}\n");" is 151.
Long Statement,ImageResizer.Plugins.LicenseVerifier,SignatureTestApp,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Test_Generic,The length of the statement  "                "28178177427582259905122756905913963624440517746414712044433894631438407111916149031583287058323879921298234454158166031934230083094710974550125942791690254427377300877691173542319534371793100994953897137837772694304619234054383162641475011138179669415510521009673718000682851222831185756777382795378538121010194881849505437499638792289283538921706236004391184253166867653735050981736002298838523242717690667046044130539971131293603078008447972889271580670305162199959939004819206804246872436611558871928921860176200657026263241409488257640191893499783065332541392967986495144643652353104461436623253327708136399114561");" is 621.
Long Statement,ImageResizer.Plugins.LicenseVerifier,SignatureTestApp,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Test_Generic,The length of the statement  "                "localhost:RG9tYWluOiBsb2NhbGhvc3QKT3duZXI6IEV2ZXJ5b25lCklzc3VlZDogMjAxNS0wMy0yOFQwOTozNjo1OVoKRmVhdHVyZXM6IFI0RWxpdGUgUjRDcmVhdGl2ZSBSNFBlcmZvcm1hbmNlCg==:h6D+kIXbF3qmvmW2gDpb+b4gdxBjnrkZLvSzXmEnqKAywNJNpTdFekpTOB4SwU14WbTeVyWwvFngHax7WuHBV+0WkQ5lDqKFaRW32vj8CJQeG8Wvnyj9PaNGaS/FpKhNjZbDEmh3qqirBp2NR0bpN4QbhP9NMy7+rOMo0nynAruwWvJKCnuf7mWWdb9a5uTZO9OUcSeS/tY8QaNeIhaCnhPe0Yx9qvOXe5nMnl10CR9ur+EtS54d1qzBGHqN/3oFhiB+xlqNELwz23qR4c8HxbTEyNarkG4CZx8CbbgJfHmPxAYGJTTBTPJ+cdah8MJR16Ta36cRZ2Buy8XYo/nf1g==";" is 502.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "            //2013-apr-25: What happens if the file is still being written to disk - it's present but not complete? To handle that' we use mayBeLocked." is 139.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                //May throw an IOException if the file cannot be opened' and is locked by an external processes for longer than timeoutMs. " is 122.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                //Looks like a miss. Let's enter a lock for the creation of the file. This is a different locking system than for writing to the file - far less contention' as it doesn't include the " is 182.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                //Lock execution using relativePath as the sync basis. Ignore casing differences. This prevents duplicate entries in the write queue and wasted CPU/RAM usage." is 158.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //Now' if the item we seek is in the queue' we have a memcached hit. If not' we should check the index. It's possible the item has been written to disk already." is 160.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did)." is 150.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //When t == null' and we're inside QueueLocks' all work on the file must be finished' so we have no need to consult mayBeLocked." is 128.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                            MemoryStream ms = new MemoryStream(4096);  //4K initial capacity is minimal' but this array will get copied around a lot' better to underestimate." is 146.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                                    if (!TryWriteFile(null' job.PhysicalPath' job.Key' delegate(Stream s) { ((MemoryStream)job.GetReadonlyStream()).CopyToAsync(s); return Task.FromResult(true); }' timeoutMs' true).Result)" is 185.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                                            lp.Logger.Warn("Failed to flush async write' timeout exceeded after {1}ms - {0}"'  result.RelativePath' swio.ElapsedMilliseconds);" is 130.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                                            lp.Logger.Trace("{0}ms: Async write started {1}ms after enqueue for {2}"' swio.ElapsedMilliseconds.ToString().PadLeft(4)' DateTime.UtcNow.Subtract(w.JobCreatedAt).Subtract(swio.Elapsed).TotalMilliseconds' result.RelativePath);" is 226.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                                //This is nested inside a queuelock because if we failed here' the next one will also. Better to force it to wait until the file is written to disk." is 148.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                                if (!await TryWriteFile(result' physicalPath' relativePath' async delegate(Stream s) { await ms.CopyToAsync(s); }' timeoutMs' false)) {" is 135.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                lp.Logger.Trace("{0}ms: {3}{1} for {2}' Key: {4}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' result.Result.ToString()' result.RelativePath' asynchronous ? (asyncFailed ? "AsyncHttpMode' fell back to sync write  " : "AsyncHttpMode+AsyncWrites ") : "AsyncHttpMode"' keyBasis);" is 308.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The length of the statement  "            //Lock execution using relativePath as the sync basis. Ignore casing differences. This locking is process-local' but we also have code to handle file locking." is 158.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The length of the statement  "                    //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did)." is 150.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The length of the statement  "                        // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data." is 203.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The length of the statement  "                            //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else." is 126.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The length of the statement  "                            //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for " is 123.
Long Statement,ImageResizer.Plugins.DiskCache,CachedFolder,C:\repos\imazen_resizer\Plugins\DiskCache\Index\CachedFolder.cs,setCachedFileInfo,The length of the statement  "                    if (info == null && f == null) return; //If the folder doesn't exist' the file definitely doesn't. Already accomplished." is 120.
Long Statement,ImageResizer.Plugins.DiskCache,CachedFolder,C:\repos\imazen_resizer\Plugins\DiskCache\Index\CachedFolder.cs,getSortedSubfiles,The length of the statement  "                Array.Sort<KeyValuePair<string' CachedFileInfo>>(items' delegate(KeyValuePair<string' CachedFileInfo> a' KeyValuePair<string' CachedFileInfo> b) {" is 146.
Long Statement,ImageResizer.Plugins.DiskCache,CachedFolder,C:\repos\imazen_resizer\Plugins\DiskCache\Index\CachedFolder.cs,populateFiles,The length of the statement  "            Dictionary<string' CachedFileInfo> newFiles = new Dictionary<string' CachedFileInfo>(physicalFiles.Length' KeyComparer);" is 120.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,main,The length of the statement  "                if (lp.Logger != null) lp.Logger.Error("Contact support! A critical (and unexpected) exception occurred in the disk cache cleanup worker thread. This needs to be investigated. {0}"' ex.Message + ex.StackTrace);" is 210.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,main,The length of the statement  "                this.AcceptIssue(new Issue("Contact support! A critical (and unexpected) exception occurred in the disk cache cleanup worker thread. This needs to be investigated. "' ex.Message + ex.StackTrace' IssueSeverity.Critical));" is 220.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The length of the statement  "            string mutexKey = "ir.cachedir:" + cache.PhysicalCachePath.ToLowerInvariant().GetHashCode().ToString("x"' NumberFormatInfo.InvariantInfo);" is 138.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The length of the statement  "                        //In this case' another process (running as another user account) has opened the lock. Eventually it may be garbage collected." is 126.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The length of the statement  "                        else Thread.Sleep(10000); //Otherwise just sleep 10s and check again' waiting for the mutex to be garbage collected so we can recreate it." is 138.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The length of the statement  "                        //Don't flood the system even when it's not busy. 50% usage here. Wait for the length of time worked or the optimal work time' whichever is longer." is 147.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,GetIssues,The length of the statement  "                "This process is not currently managing disk cache cleanup. If configured as a web garden' keep in mind that the negligible performance gains are likely to be outweighed by the loss of cache optimization quality."' IssueSeverity.Warning));" is 239.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,GetIssues,The length of the statement  "                    issues.Add(new Issue("Your cache configuration may not be optimal. If this message persists' you should increase the 'subfolders' value in the <diskcache /> element in Web.config"'" is 180.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,GetIssues,The length of the statement  "                        "In the last 5 minutes' a cache folder exceeded both the optimum and maximum limits for file count. This usually indicates that your 'subfolders' setting is too low' and that cached images are being deleted shortly after their creation. \n" +" is 242.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,GetIssues,The length of the statement  "                        "To estimate the appropriate subfolders value' multiply the total number of images on the site times the average number of size variations' and divide by 400. I.e' 6'400 images with 2 variants would be 32. If in doubt' set the value higher' but ensure there is disk space available."' IssueSeverity.Error));" is 307.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,DoTask,The length of the statement  "            if (lp.Logger != null) lp.Logger.Trace("{2}ms: Executing task {0} {1} ({3} tasks remaining)"' item.Task.ToString()' item.RelativePath' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' queue.Count.ToString(NumberFormatInfo.InvariantInfo));" is 265.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,PopulateFolder,The length of the statement  "                    lp.Logger.Trace("{0}ms: Querying file system about {1}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' item.RelativePath);" is 152.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,PopulateFolder,The length of the statement  "                    childWorkItems.Add(new CleanupWorkItem(CleanupWorkItem.Kind.PopulateFolderRecursive' addSlash(item.RelativePath'false) + n' addSlash(item.PhysicalPath'true) + n));" is 163.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,RemoveFile,The length of the statement  "            item.LazyProvider = provider; //So if this item fails' we can queue 'item' again and the next task run will get the next alternative." is 133.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,CleanFolder,The length of the statement  "                //We could actually make this Populate non-recursive' since the recursive Clean would just insert Populates beforehand anyway." is 126.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,CleanFolder,The length of the statement  "                        new CleanupWorkItem(recursive ? CleanupWorkItem.Kind.PopulateFolderRecursive : CleanupWorkItem.Kind.PopulateFolder'item.RelativePath'item.PhysicalPath)'" is 152.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorkItem,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorkItem.cs,Equals,The length of the statement  "            return (other.Task == Task && other.RelativePath == RelativePath && other.PhysicalPath == PhysicalPath && other.LazyProvider == LazyProvider);" is 142.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "            //2013-apr-25: What happens if the file is still being written to disk - it's present but not complete? To handle that' we use mayBeLocked." is 139.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                //May throw an IOException if the file cannot be opened' and is locked by an external processes for longer than timeoutMs. " is 122.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                //Looks like a miss. Let's enter a lock for the creation of the file. This is a different locking system than for writing to the file - far less contention' as it doesn't include the " is 182.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                //Lock execution using relativePath as the sync basis. Ignore casing differences. This prevents duplicate entries in the write queue and wasted CPU/RAM usage." is 158.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //Now' if the item we seek is in the queue' we have a memcached hit. If not' we should check the index. It's possible the item has been written to disk already." is 160.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did)." is 150.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //When t == null' and we're inside QueueLocks' all work on the file must be finished' so we have no need to consult mayBeLocked." is 128.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                            MemoryStream ms = new MemoryStream(4096);  //4K initial capacity is minimal' but this array will get copied around a lot' better to underestimate." is 146.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                                    if (!TryWriteFile(null' job.PhysicalPath' job.Key' delegate(Stream s) { ((MemoryStream)job.GetReadonlyStream()).WriteTo(s); }' timeoutMs' true)) {" is 146.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                                            lp.Logger.Warn("Failed to flush async write' timeout exceeded after {1}ms - {0}"'  result.RelativePath' swio.ElapsedMilliseconds);" is 130.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                                            lp.Logger.Trace("{0}ms: Async write started {1}ms after enqueue for {2}"' swio.ElapsedMilliseconds.ToString().PadLeft(4)' DateTime.UtcNow.Subtract(w.JobCreatedAt).Subtract(swio.Elapsed).TotalMilliseconds' result.RelativePath);" is 226.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                                //This is nested inside a queuelock because if we failed here' the next one will also. Better to force it to wait until the file is written to disk." is 148.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                lp.Logger.Trace("{0}ms: {3}{1} for {2}' Key: {4}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' result.Result.ToString()' result.RelativePath' asynchronous ? (asyncFailed ? "Fallback to sync writes  " : "AsyncWrites ") : ""' keyBasis);" is 266.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The length of the statement  "            //Lock execution using relativePath as the sync basis. Ignore casing differences. This locking is process-local' but we also have code to handle file locking." is 158.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The length of the statement  "                    //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did)." is 150.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The length of the statement  "                        // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data." is 203.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The length of the statement  "                                //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else." is 126.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The length of the statement  "                                //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for " is 123.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Install,The length of the statement  "            if (inAsyncMode == null) throw new InvalidOperationException("You must set Config.Current.Pipeline.UsingAsyncMode before installing DiskCache");" is 144.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Start,The length of the statement  "                if (AutoClean) cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);" is 139.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Start,The length of the statement  "                //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ). " is 132.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Process,The length of the statement  "            if (this.AsyncModuleMode) throw new InvalidOperationException("DiskCache cannot be used in synchronous mode if AsyncModuleMode=true");" is 134.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,ProcessAsync,The length of the statement  "            if (!this.AsyncModuleMode) throw new InvalidOperationException("DiskCache cannot be used in asynchronous mode if AsyncModuleMode=false");" is 137.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,ProcessAsync,The length of the statement  "            CacheResult r = await asyncCache.GetCachedFile(e.RequestCachingKey' e.EstimatedFileExtension' async delegate(Stream outStream){" is 127.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,ProcessAsync,The length of the statement  "                throw new ImageResizer.ImageProcessingException("Failed to acquire a lock on file \"" + r.PhysicalPath + "\" within " + CacheAccessTimeout + "ms. Caching failed.");" is 164.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Process,The length of the statement  "            CacheResult r = cache.GetCachedFile(e.RequestKey' e.SuggestedExtension' e.ResizeImageToStream' CacheAccessTimeout'AsyncWrites);" is 127.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Process,The length of the statement  "                throw new ImageResizer.ImageProcessingException("Failed to acquire a lock on file \"" + r.PhysicalPath + "\" within " + CacheAccessTimeout + "ms. Caching failed.");" is 164.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,HasNTFSPermission,The length of the statement  "                File.WriteAllText(testFile' "You may delete this file - it is written and deleted just to verify permissions are configured correctly");" is 136.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "            if (!c.get("diskcache.hashModifiedDate"' true)) issues.Add(new Issue("DiskCache"' "V4.0 no longer supports hashModifiedDate=false. Please remove this attribute."' IssueSeverity.ConfigurationError));" is 198.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                issues.Add(new Issue("DiskCache"' "Failed to start: Write access to the cache directory is prohibited by your .NET trust level configuration."' " is 143.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                "Please configure your .NET trust level to permit writing to the cache directory. Most medium trust configurations allow this' but yours does not."' IssueSeverity.ConfigurationError));" is 184.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                issues.Add(new Issue("DiskCache"' "Not working: Your NTFS Security permissions are preventing the application from writing to the disk cache"'" is 142.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "    "Please give user " + GetExecutingUser() + " read and write access to directory \"" + PhysicalCacheDir + "\" to correct the problem. You can access NTFS security settings by right-clicking the aforementioned folder and choosing Properties' then Security."' IssueSeverity.ConfigurationError));" is 292.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "            if (!Started && !Enabled) issues.Add(new Issue("DiskCache"' "DiskCache is disabled in Web.config. Set enabled=true on the <diskcache /> element to fix."' null' IssueSeverity.ConfigurationError));" is 195.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                issues.Add(new Issue("DiskCache"' "The asyncBufferSize should not be set below 2 megabytes (2097152). Found in the <diskcache /> element in Web.config."'" is 153.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                    "A buffer that is too small will cause requests to be processed synchronously. Remember to set the value to at least 4x the maximum size of an output image."' IssueSeverity.ConfigurationError));" is 194.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                    "Both IIS and ASP.NET have trouble hosting websites with large numbers of folders over a network drive' such as a SAN. The cache will create " +" is 144.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                    Subfolders.ToString() + " subfolders. If the total number of network-hosted folders exceeds 100' you should contact support@imageresizing.net and consult the documentation for details on configuring IIS and ASP.NET for this situation."' IssueSeverity.Warning));" is 261.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetInfoPairs,The length of the statement  "            list.Add(new KeyValuePair<string' string>("diskcache_drive_avail"' GetCacheDrive()?.AvailableFreeSpace.ToString() ?? ""));" is 122.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,LoadProperty,The length of the statement  "                if (!int.TryParse(value' NumberStyles.Integer' NumberFormatInfo.InvariantInfo' out iValue)) return; //We couldn't parse a value." is 128.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,LoadProperty,The length of the statement  "                if (int.TryParse(value' NumberStyles.Integer' NumberFormatInfo.InvariantInfo' out iValue)) tValue = new TimeSpan(0' 0' iValue);" is 127.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,MeetsCleanupCriteria,The length of the statement  "            return ((now.Subtract(i.AccessedUtc) > AvoidRemovalIfUsedWithin || AvoidRemovalIfUsedWithin <= new TimeSpan(0) || i.AccessedUtc == i.UpdatedUtc) &&" is 147.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,MeetsOverMaxCriteria,The length of the statement  "            return ((now.Subtract(i.AccessedUtc) > ProhibitRemovalIfUsedWithin || ProhibitRemovalIfUsedWithin <= new TimeSpan(0) || i.AccessedUtc == i.UpdatedUtc) &&" is 153.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,GetIssues,The length of the statement  "                    sb.AppendLine(s + " has been changed to " + v.ToString() + " instead of the suggested value' " + defaults[s].ToString());" is 121.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,GetIssues,The length of the statement  "                issues.Add(new Issue( "The cleanup strategy settings have been changed. This is not advised' and may have ill effects. " +" is 122.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,GetIssues,The length of the statement  "                "\nThe default settings for the cleanup strategy were carefully chosen' and should not be changed except at the suggestion of the author.\n" + sb.ToString()' IssueSeverity.Warning));" is 182.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCached,The length of the statement  "            if (this.AsyncModuleMode) throw new InvalidOperationException("SourceDiskCache cannot be used in synchronous mode if AsyncModuleMode=true");" is 140.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCached,The length of the statement  "            string key = original is IVirtualFileSourceCacheKey ? ((IVirtualFileSourceCacheKey)original).GetCacheKey(false) : original.VirtualPath;" is 135.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCachedAsync,The length of the statement  "            if (!this.AsyncModuleMode) throw new InvalidOperationException("SourceDiskCache cannot be used in asynchronous mode if AsyncModuleMode=false");" is 143.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCachedAsync,The length of the statement  "            string key = original is IVirtualFileSourceCacheKey ? ((IVirtualFileSourceCacheKey)original).GetCacheKey(false) : original.VirtualPath;" is 135.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Install,The length of the statement  "            if (inAsyncMode == null) throw new InvalidOperationException("You must set Config.Current.Pipeline.UsingAsyncMode before installing SourceDiskCache");" is 150.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The length of the statement  "                cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);" is 124.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The length of the statement  "                //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ). " is 132.
Long Statement,ImageResizer.Plugins.SourceMemCache,EventCountingDictionary<T>,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,Cleanup,The length of the statement  "            if (mode == CleanupMode.MakeRoom && byteCeiling < 1) return true; //We don't perform minimal cleanups unless a ceiling is specified." is 132.
Long Statement,ImageResizer.Plugins.SourceMemCache,EventCountingDictionary<T>,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,Cleanup,The length of the statement  "            //We have to weak lock method-level' because otherwise a background thread could be cleaning when GetOrAdd is called' and we could have a deadlock" is 146.
Long Statement,ImageResizer.Plugins.SourceMemCache,EventCountingDictionary<T>,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,Cleanup,The length of the statement  "                            if (mode == CleanupMode.Maintenance && c.GetValue() > 0) continue; //Skip counters that incremented while we were working." is 122.
Long Statement,ImageResizer.Plugins.SourceMemCache,SourceMemCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,GetFileIfCached,The length of the statement  "            string key = original is IVirtualFileSourceCacheKey ? ((IVirtualFileSourceCacheKey)original).GetCacheKey(true) : original.VirtualPath;" is 134.
Long Statement,ImageResizer.Plugins.SourceMemCache,SourceMemCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,GetFileIfCachedAsync,The length of the statement  "            string key = original is IVirtualFileSourceCacheKey ? ((IVirtualFileSourceCacheKey)original).GetCacheKey(true) : original.VirtualPath;" is 134.
Long Statement,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,Open,The length of the statement  "                else if (originalHash != CaluclateHash()) throw new AccessViolationException("A read-only memory stream was somehow modified.");" is 128.
Long Statement,ImageResizer.Plugins.DiskCache.Cleanup,CleanupQueue,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupQueue.cs,InsertRange,The length of the statement  "                ReverseEnumerable<CleanupWorkItem> reversed = new ReverseEnumerable<CleanupWorkItem>(new System.Collections.ObjectModel.ReadOnlyCollection<CleanupWorkItem>(items));" is 164.
Empty Catch Block,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The method has an empty catch block.
Empty Catch Block,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The method has an empty catch block.
Empty Catch Block,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,FlushAccessedDate,The method has an empty catch block.
Empty Catch Block,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,FlushAccessedDate,The method has an empty catch block.
Empty Catch Block,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The method has an empty catch block.
Empty Catch Block,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The method has an empty catch block.
Magic Number,ImageResizer.Plugins.LicenseVerifier,Computation,C:\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,GetGracePeriodFor,The following statement contains a magic number: var thirtySeconds = mgr.FirstHeartbeat.Value.AddSeconds(30);
Magic Number,ImageResizer.Plugins.LicenseVerifier,DomainLookup,C:\repos\imazen_resizer\Plugins\LicenseVerifier\DomainLookup.cs,DomainLookup,The following statement contains a magic number: suffixSearchList = knownDomains.Select(known =>                                            {                                                var d = known.TrimStart('.');                                                d = d.StartsWith("www.") ? d.Substring(4) : d;                                                return new KeyValuePair<string' string>("." + d' known);                                            })                                            .ToList();
Magic Number,ImageResizer.Plugins.LicenseVerifier,DomainLookup,C:\repos\imazen_resizer\Plugins\LicenseVerifier\DomainLookup.cs,ExplainNormalizations,The following statement contains a magic number: return LookupTableSize > 0                 ? $"The domain lookup table has {LookupTableSize} elements. Displaying {Math.Min(200' LookupTableSize)}:\n" +                    lookupTable.OrderByDescending(p => p.Value)                                                .Take(200)                                                .Select(pair => pair.Key == pair.Value ? pair.Key : $"{pair.Key} => {pair.Value}").Delimited("' ") +                   "\n"                 : "";
Magic Number,ImageResizer.Plugins.LicenseVerifier,DomainLookup,C:\repos\imazen_resizer\Plugins\LicenseVerifier\DomainLookup.cs,ExplainNormalizations,The following statement contains a magic number: return LookupTableSize > 0                 ? $"The domain lookup table has {LookupTableSize} elements. Displaying {Math.Min(200' LookupTableSize)}:\n" +                    lookupTable.OrderByDescending(p => p.Value)                                                .Take(200)                                                .Select(pair => pair.Key == pair.Value ? pair.Key : $"{pair.Key} => {pair.Value}").Delimited("' ") +                   "\n"                 : "";
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseChain,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseChain.cs,OnFetchResult,The following statement contains a magic number: if (body != null) {                 Last200 = parent.Clock.GetUtcNow();                 var license = parent.TryDeserialize(body' "remote server"' false);                 if (license != null) {                     var newId = license.Fields.Id;                     if (newId == Id) {                         remoteLicense = license;                         // Victory! (we're ignoring failed writes/duplicates)                         parent.Cache.TryPut(fetcher.CacheKey' body);                          LastSuccess = parent.Clock.GetUtcNow();                          lastWorkingUri = results.Last().FullUrl;                     } else {                         parent.AcceptIssue(new Issue(                             "Remote license file does not match. Please contact support@imageresizing.net"'                             "Local: " + Id + "  Remote: " + newId' IssueSeverity.Error));                     }                 }                 // TODO: consider logging a failed deserialization remotely             } else {                 var licenseName = Id;                  if (results.All(r => r.HttpCode == 404 || r.HttpCode == 403)) {                     parent.AcceptIssue(new Issue("No such license (404/403): " + licenseName'                         string.Join("\n"' results.Select(r => "HTTP 404/403 fetching " + RedactSecret(r.ShortUrl)))'                         IssueSeverity.Error));                     // No such subscription key.. but don't downgrade it if exists.                     var cachedString = parent.Cache.Get(fetcher.CacheKey);                     int temp;                     if (cachedString == null || !int.TryParse(cachedString' out temp)) {                         parent.Cache.TryPut(fetcher.CacheKey' results.First().HttpCode.ToString());                     }                     Last404 = parent.Clock.GetUtcNow();                 } else if (results.All(r => r.LikelyNetworkFailure)) {                     // Network failure. Make sure the server can access the remote server                     parent.AcceptIssue(fetcher.FirewallIssue(licenseName));                     LastTimeout = parent.Clock.GetUtcNow();                 } else {                     parent.AcceptIssue(new Issue("Exception(s) occurred fetching license " + licenseName'                         RedactSecret(string.Join("\n"'                             results.Select(r =>                                 $"{r.HttpCode} {r.FullUrl}  LikelyTimeout: {r.LikelyNetworkFailure} Error: {r.FetchError?.ToString()}")))'                         IssueSeverity.Error));                     LastException = parent.Clock.GetUtcNow();                 }             }
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseChain,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseChain.cs,OnFetchResult,The following statement contains a magic number: if (body != null) {                 Last200 = parent.Clock.GetUtcNow();                 var license = parent.TryDeserialize(body' "remote server"' false);                 if (license != null) {                     var newId = license.Fields.Id;                     if (newId == Id) {                         remoteLicense = license;                         // Victory! (we're ignoring failed writes/duplicates)                         parent.Cache.TryPut(fetcher.CacheKey' body);                          LastSuccess = parent.Clock.GetUtcNow();                          lastWorkingUri = results.Last().FullUrl;                     } else {                         parent.AcceptIssue(new Issue(                             "Remote license file does not match. Please contact support@imageresizing.net"'                             "Local: " + Id + "  Remote: " + newId' IssueSeverity.Error));                     }                 }                 // TODO: consider logging a failed deserialization remotely             } else {                 var licenseName = Id;                  if (results.All(r => r.HttpCode == 404 || r.HttpCode == 403)) {                     parent.AcceptIssue(new Issue("No such license (404/403): " + licenseName'                         string.Join("\n"' results.Select(r => "HTTP 404/403 fetching " + RedactSecret(r.ShortUrl)))'                         IssueSeverity.Error));                     // No such subscription key.. but don't downgrade it if exists.                     var cachedString = parent.Cache.Get(fetcher.CacheKey);                     int temp;                     if (cachedString == null || !int.TryParse(cachedString' out temp)) {                         parent.Cache.TryPut(fetcher.CacheKey' results.First().HttpCode.ToString());                     }                     Last404 = parent.Clock.GetUtcNow();                 } else if (results.All(r => r.LikelyNetworkFailure)) {                     // Network failure. Make sure the server can access the remote server                     parent.AcceptIssue(fetcher.FirewallIssue(licenseName));                     LastTimeout = parent.Clock.GetUtcNow();                 } else {                     parent.AcceptIssue(new Issue("Exception(s) occurred fetching license " + licenseName'                         RedactSecret(string.Join("\n"'                             results.Select(r =>                                 $"{r.HttpCode} {r.FullUrl}  LikelyTimeout: {r.LikelyNetworkFailure} Error: {r.FetchError?.ToString()}")))'                         IssueSeverity.Error));                     LastException = parent.Clock.GetUtcNow();                 }             }
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseChain,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseChain.cs,GetLicenseServers,The following statement contains a magic number: return newList.Concat(oldStack.Except(newList)).Take(10).ToArray();
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseChain,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseChain.cs,GetReportPairs,The following statement contains a magic number: var firstHearbeat = (long) (parent.FirstHeartbeat.GetValueOrDefault() -                                         new DateTimeOffset(1970' 1' 1' 0' 0' 0' 0' TimeSpan.Zero)).TotalSeconds;
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseFetcher,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseFetcher.cs,AdjustErrorDebounce,The following statement contains a magic number: if (error.IntervalTicks > 0) {                 error.IntervalTicks *= ErrorMultiplier;                 error.IntervalTicks += (long) Math.Round(new Random().NextDouble() * clock.TicksPerSecond / 2.0);             }
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseFetcher,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseFetcher.cs,ConstructQuerystring,The following statement contains a magic number: try {                 var query = getInfo();                 query.WithPrepend(true).Add("license_id"' id);                 return query.ToQueryString(7000);             } catch (Exception ex) {                 sink.AcceptIssue(new Issue("LicenseManager"' "Failed to collect querystring for license request"'                     ex.ToString()' IssueSeverity.Warning));             }
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseBlob,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Deserialize,The following statement contains a magic number: if (parts.Count < 2) {                 throw new ArgumentException(                     "Not enough ':' delimited segments in license key; failed to deserialize: \"" + license + "\""'                     nameof(license));             }
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseBlob,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Deserialize,The following statement contains a magic number: var dataBytes = Convert.FromBase64String(parts[parts.Count - 2]);
Magic Number,ImageResizer.Plugins.LicenseVerifier,SignatureTestApp,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Main,The following statement contains a magic number: var debug = args.ElementAtOrDefault(2) == "-d";
Magic Number,ImageResizer.Plugins.LicenseVerifier,SignatureTestApp,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Main,The following statement contains a magic number: if (debug) {                 var log = new StringBuilder();                 exitCode = Test_Generic(log) ? 0 : 4;                  if (!Validate(licenseStr' mod' exp' log)) {                     exitCode = 2 ^ exitCode;                 }                 if (exitCode != 0) {                     Console.WriteLine(log.ToString());                 }             } else {                 exitCode = Validate(licenseStr' mod' exp' null) ? 0 : 1;             }
Magic Number,ImageResizer.Plugins.LicenseVerifier,SignatureTestApp,C:\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Main,The following statement contains a magic number: if (debug) {                 var log = new StringBuilder();                 exitCode = Test_Generic(log) ? 0 : 4;                  if (!Validate(licenseStr' mod' exp' log)) {                     exitCode = 2 ^ exitCode;                 }                 if (exitCode != 0) {                     Console.WriteLine(log.ToString());                 }             } else {                 exitCode = Validate(licenseStr' mod' exp' null) ? 0 : 1;             }
Magic Number,ImageResizer.Plugins.DiskCache.Async,AsyncWriteCollection,C:\repos\imazen_resizer\Plugins\DiskCache\Async\AsyncWriteCollection.cs,AsyncWriteCollection,The following statement contains a magic number: MaxQueueBytes = 1024 * 1024 * 10;
Magic Number,ImageResizer.Plugins.DiskCache.Async,AsyncWriteCollection,C:\repos\imazen_resizer\Plugins\DiskCache\Async\AsyncWriteCollection.cs,AsyncWriteCollection,The following statement contains a magic number: MaxQueueBytes = 1024 * 1024 * 10;
Magic Number,ImageResizer.Plugins.DiskCache.Async,AsyncWriteCollection,C:\repos\imazen_resizer\Plugins\DiskCache\Async\AsyncWriteCollection.cs,AsyncWriteCollection,The following statement contains a magic number: MaxQueueBytes = 1024 * 1024 * 10;
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The following statement contains a magic number: if (!asynchronous) {                 //On the first check' verify the file exists using System.IO directly (the last 'true' parameter)                 //May throw an IOException if the file cannot be opened' and is locked by an external processes for longer than timeoutMs.                  //This method may take longer than timeoutMs under absolute worst conditions.                  if (!await TryWriteFile(result' physicalPath' relativePath' writeCallback' timeoutMs' !mayBeLocked)) {                     //On failure                     result.Result = CacheQueryResult.Failed;                 }             }             else if (!Index.existsCertain(relativePath' physicalPath) || mayBeLocked)             {                                  //Looks like a miss. Let's enter a lock for the creation of the file. This is a different locking system than for writing to the file - far less contention' as it doesn't include the                  //This prevents two identical requests from duplicating efforts. Different requests don't lock.                  //Lock execution using relativePath as the sync basis. Ignore casing differences. This prevents duplicate entries in the write queue and wasted CPU/RAM usage.                 if (!await ((AsyncLockProvider)QueueLocks).TryExecuteAsync(relativePath.ToUpperInvariant()' timeoutMs'                     async delegate() {                          //Now' if the item we seek is in the queue' we have a memcached hit. If not' we should check the index. It's possible the item has been written to disk already.                         //If both are a miss' we should see if there is enough room in the write queue. If not' switch to in-thread writing.                           AsyncWrite t = CurrentWrites.Get(relativePath);                          if (t != null) result.Data = t.GetReadonlyStream();                                                    //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                         //When t == null' and we're inside QueueLocks' all work on the file must be finished' so we have no need to consult mayBeLocked.                         if (t == null && !Index.exists(relativePath' physicalPath))                         {                              result.Result = CacheQueryResult.Miss;                             //Still a miss' we even rechecked the file system. Write to memory.                             MemoryStream ms = new MemoryStream(4096);  //4K initial capacity is minimal' but this array will get copied around a lot' better to underestimate.                             //Read' resize' process' and encode the image. Lots of exceptions thrown here.                             await writeCallback(ms);                             ms.Position = 0;                              AsyncWrite w = new AsyncWrite(CurrentWrites'ms' physicalPath' relativePath);                             if (CurrentWrites.Queue(w' delegate(AsyncWrite job) {                                 try {                                     Stopwatch swio = new Stopwatch();                                                                          swio.Start();                                     //We want this to run synchronously' since it's in a background thread already.                                     if (!TryWriteFile(null' job.PhysicalPath' job.Key' delegate(Stream s) { ((MemoryStream)job.GetReadonlyStream()).CopyToAsync(s); return Task.FromResult(true); }' timeoutMs' true).Result)                                     {                                         swio.Stop();                                         //We failed to lock the file.                                         if (lp.Logger != null)                                              lp.Logger.Warn("Failed to flush async write' timeout exceeded after {1}ms - {0}"'  result.RelativePath' swio.ElapsedMilliseconds);                                                                              } else {                                         swio.Stop();                                         if (lp.Logger != null)                                             lp.Logger.Trace("{0}ms: Async write started {1}ms after enqueue for {2}"' swio.ElapsedMilliseconds.ToString().PadLeft(4)' DateTime.UtcNow.Subtract(w.JobCreatedAt).Subtract(swio.Elapsed).TotalMilliseconds' result.RelativePath);                                     }                                  } catch (Exception ex) {                                     if (lp.Logger != null) {                                         lp.Logger.Error("Failed to flush async write' {0} {1}\n{2}"'ex.ToString()' result.RelativePath'ex.StackTrace);                                     }                                 } finally {                                     CurrentWrites.Remove(job); //Remove from the queue' it's done or failed.                                  }                              })) {                                 //We queued it! Send back a read-only memory stream                                 result.Data = w.GetReadonlyStream();                             } else {                                 asyncFailed = false;                                 //We failed to queue it - either the ThreadPool was exhausted or we exceeded the MB limit for the write queue.                                 //Write the MemoryStream to disk using the normal method.                                 //This is nested inside a queuelock because if we failed here' the next one will also. Better to force it to wait until the file is written to disk.                                 if (!await TryWriteFile(result' physicalPath' relativePath' async delegate(Stream s) { await ms.CopyToAsync(s); }' timeoutMs' false)) {                                     if (lp.Logger != null)                                         lp.Logger.Warn("Failed to queue async write' also failed to lock for sync writing: {0}"' result.RelativePath);                                                                          }                             }                          }                      })) {                     //On failure                     result.Result = CacheQueryResult.Failed;                 }              }
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The following statement contains a magic number: if (!asynchronous) {                 //On the first check' verify the file exists using System.IO directly (the last 'true' parameter)                 //May throw an IOException if the file cannot be opened' and is locked by an external processes for longer than timeoutMs.                  //This method may take longer than timeoutMs under absolute worst conditions.                  if (!await TryWriteFile(result' physicalPath' relativePath' writeCallback' timeoutMs' !mayBeLocked)) {                     //On failure                     result.Result = CacheQueryResult.Failed;                 }             }             else if (!Index.existsCertain(relativePath' physicalPath) || mayBeLocked)             {                                  //Looks like a miss. Let's enter a lock for the creation of the file. This is a different locking system than for writing to the file - far less contention' as it doesn't include the                  //This prevents two identical requests from duplicating efforts. Different requests don't lock.                  //Lock execution using relativePath as the sync basis. Ignore casing differences. This prevents duplicate entries in the write queue and wasted CPU/RAM usage.                 if (!await ((AsyncLockProvider)QueueLocks).TryExecuteAsync(relativePath.ToUpperInvariant()' timeoutMs'                     async delegate() {                          //Now' if the item we seek is in the queue' we have a memcached hit. If not' we should check the index. It's possible the item has been written to disk already.                         //If both are a miss' we should see if there is enough room in the write queue. If not' switch to in-thread writing.                           AsyncWrite t = CurrentWrites.Get(relativePath);                          if (t != null) result.Data = t.GetReadonlyStream();                                                    //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                         //When t == null' and we're inside QueueLocks' all work on the file must be finished' so we have no need to consult mayBeLocked.                         if (t == null && !Index.exists(relativePath' physicalPath))                         {                              result.Result = CacheQueryResult.Miss;                             //Still a miss' we even rechecked the file system. Write to memory.                             MemoryStream ms = new MemoryStream(4096);  //4K initial capacity is minimal' but this array will get copied around a lot' better to underestimate.                             //Read' resize' process' and encode the image. Lots of exceptions thrown here.                             await writeCallback(ms);                             ms.Position = 0;                              AsyncWrite w = new AsyncWrite(CurrentWrites'ms' physicalPath' relativePath);                             if (CurrentWrites.Queue(w' delegate(AsyncWrite job) {                                 try {                                     Stopwatch swio = new Stopwatch();                                                                          swio.Start();                                     //We want this to run synchronously' since it's in a background thread already.                                     if (!TryWriteFile(null' job.PhysicalPath' job.Key' delegate(Stream s) { ((MemoryStream)job.GetReadonlyStream()).CopyToAsync(s); return Task.FromResult(true); }' timeoutMs' true).Result)                                     {                                         swio.Stop();                                         //We failed to lock the file.                                         if (lp.Logger != null)                                              lp.Logger.Warn("Failed to flush async write' timeout exceeded after {1}ms - {0}"'  result.RelativePath' swio.ElapsedMilliseconds);                                                                              } else {                                         swio.Stop();                                         if (lp.Logger != null)                                             lp.Logger.Trace("{0}ms: Async write started {1}ms after enqueue for {2}"' swio.ElapsedMilliseconds.ToString().PadLeft(4)' DateTime.UtcNow.Subtract(w.JobCreatedAt).Subtract(swio.Elapsed).TotalMilliseconds' result.RelativePath);                                     }                                  } catch (Exception ex) {                                     if (lp.Logger != null) {                                         lp.Logger.Error("Failed to flush async write' {0} {1}\n{2}"'ex.ToString()' result.RelativePath'ex.StackTrace);                                     }                                 } finally {                                     CurrentWrites.Remove(job); //Remove from the queue' it's done or failed.                                  }                              })) {                                 //We queued it! Send back a read-only memory stream                                 result.Data = w.GetReadonlyStream();                             } else {                                 asyncFailed = false;                                 //We failed to queue it - either the ThreadPool was exhausted or we exceeded the MB limit for the write queue.                                 //Write the MemoryStream to disk using the normal method.                                 //This is nested inside a queuelock because if we failed here' the next one will also. Better to force it to wait until the file is written to disk.                                 if (!await TryWriteFile(result' physicalPath' relativePath' async delegate(Stream s) { await ms.CopyToAsync(s); }' timeoutMs' false)) {                                     if (lp.Logger != null)                                         lp.Logger.Warn("Failed to queue async write' also failed to lock for sync writing: {0}"' result.RelativePath);                                                                          }                             }                          }                      })) {                     //On failure                     result.Result = CacheQueryResult.Failed;                 }              }
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The following statement contains a magic number: if (lp.Logger != null) {                 sw.Stop();                 lp.Logger.Trace("{0}ms: {3}{1} for {2}' Key: {4}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' result.Result.ToString()' result.RelativePath' asynchronous ? (asyncFailed ? "AsyncHttpMode' fell back to sync write  " : "AsyncHttpMode+AsyncWrites ") : "AsyncHttpMode"' keyBasis);             }
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The following statement contains a magic number: return await ((AsyncLockProvider)Locks).TryExecuteAsync(relativePath.ToUpperInvariant()' timeoutMs'                 async delegate() {                      //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                     if (!Index.exists(relativePath' physicalPath)) {                          //Create subdirectory if needed.                         if (!Directory.Exists(Path.GetDirectoryName(physicalPath))) {                             Directory.CreateDirectory(Path.GetDirectoryName(physicalPath));                             if (lp.Logger != null) lp.Logger.Debug("Creating missing parent directory {0}"' Path.GetDirectoryName(physicalPath));                         }                          //Open stream                          //Catch IOException' and if it is a file lock'                         // - (and hashmodified is true)' then it's another process writing to the file' and we can serve the file afterwards                         // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data.                         // I.e' hashmodified=true is the only supported setting for multi-process environments.                         //TODO: Catch UnathorizedAccessException and log issue about file permissions.                         //... If we can wait for a read handle for a specified timeout.                          IOException locked_exception = null;                          try                         {                             string tempFile = physicalPath + ".tmp_" + new Random().Next(int.MaxValue).ToString("x") + ".tmp";                              System.IO.FileStream fs = new FileStream(tempFile' FileMode.Create' FileAccess.Write' FileShare.None);                             bool finished = false;                             try                             {                                 using (fs)                                 {                                     //Run callback to write the cached data                                     await writeCallback(fs); //Can throw any number of exceptions.                                     await fs.FlushAsync();                                     fs.Flush(true);                                     finished = true;                                 }                             }                             finally                             {                                 //Don't leave half-written files around.                                 if (!finished)                                 {                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             bool moved = false;                             if (finished)                             {                                 try                                 {                                     File.Move(tempFile' physicalPath);                                     moved = true;                                 }                                 catch (IOException)                                 {                                     //Will throw IO exception if already exists. Which we consider a hit' so we delete the tempFile                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             if (moved)                             {                                 DateTime createdUtc = DateTime.UtcNow;                                 //Set the created date' so we know the last time we updated the cache.s                                 System.IO.File.SetCreationTimeUtc(physicalPath' createdUtc);                                 //Update index                                 //TODO: what should sourceModifiedUtc be when there is no modified date?                                 Index.setCachedFileInfo(relativePath' new CachedFileInfo(createdUtc' createdUtc' createdUtc));                                 //This was a cache miss                                 if (result != null) result.Result = CacheQueryResult.Miss;                             }                         }                         catch (IOException ex)                         {                              if (IsFileLocked(ex)) locked_exception = ex;                              else throw;                         }                         if (locked_exception != null)                         {                             //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else.                             //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for                              //reading within timeoutMs' simply do nothing and let the file be returned as a hit.                             Stopwatch waitForFile = new Stopwatch();                             bool opened = false;                             while (!opened && waitForFile.ElapsedMilliseconds < timeoutMs)                             {                                 waitForFile.Start();                                 bool waitABitMore = false;                                 try                                 {                                     using (FileStream temp = new FileStream(physicalPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                                         opened = true;                                 }                                 catch (IOException iex)                                 {                                     if (IsFileLocked(iex))                                         waitABitMore = true;                                      else throw iex;                                 }                                 if (waitABitMore) { await Task.Delay((int)Math.Min(30' Math.Round((float)timeoutMs / 3.0))); }                                 waitForFile.Stop();                             }                             if (!opened) throw locked_exception; //By not throwing an exception' it is considered a hit by the rest of the code.                          }                       }                 });
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The following statement contains a magic number: return await ((AsyncLockProvider)Locks).TryExecuteAsync(relativePath.ToUpperInvariant()' timeoutMs'                 async delegate() {                      //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                     if (!Index.exists(relativePath' physicalPath)) {                          //Create subdirectory if needed.                         if (!Directory.Exists(Path.GetDirectoryName(physicalPath))) {                             Directory.CreateDirectory(Path.GetDirectoryName(physicalPath));                             if (lp.Logger != null) lp.Logger.Debug("Creating missing parent directory {0}"' Path.GetDirectoryName(physicalPath));                         }                          //Open stream                          //Catch IOException' and if it is a file lock'                         // - (and hashmodified is true)' then it's another process writing to the file' and we can serve the file afterwards                         // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data.                         // I.e' hashmodified=true is the only supported setting for multi-process environments.                         //TODO: Catch UnathorizedAccessException and log issue about file permissions.                         //... If we can wait for a read handle for a specified timeout.                          IOException locked_exception = null;                          try                         {                             string tempFile = physicalPath + ".tmp_" + new Random().Next(int.MaxValue).ToString("x") + ".tmp";                              System.IO.FileStream fs = new FileStream(tempFile' FileMode.Create' FileAccess.Write' FileShare.None);                             bool finished = false;                             try                             {                                 using (fs)                                 {                                     //Run callback to write the cached data                                     await writeCallback(fs); //Can throw any number of exceptions.                                     await fs.FlushAsync();                                     fs.Flush(true);                                     finished = true;                                 }                             }                             finally                             {                                 //Don't leave half-written files around.                                 if (!finished)                                 {                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             bool moved = false;                             if (finished)                             {                                 try                                 {                                     File.Move(tempFile' physicalPath);                                     moved = true;                                 }                                 catch (IOException)                                 {                                     //Will throw IO exception if already exists. Which we consider a hit' so we delete the tempFile                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             if (moved)                             {                                 DateTime createdUtc = DateTime.UtcNow;                                 //Set the created date' so we know the last time we updated the cache.s                                 System.IO.File.SetCreationTimeUtc(physicalPath' createdUtc);                                 //Update index                                 //TODO: what should sourceModifiedUtc be when there is no modified date?                                 Index.setCachedFileInfo(relativePath' new CachedFileInfo(createdUtc' createdUtc' createdUtc));                                 //This was a cache miss                                 if (result != null) result.Result = CacheQueryResult.Miss;                             }                         }                         catch (IOException ex)                         {                              if (IsFileLocked(ex)) locked_exception = ex;                              else throw;                         }                         if (locked_exception != null)                         {                             //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else.                             //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for                              //reading within timeoutMs' simply do nothing and let the file be returned as a hit.                             Stopwatch waitForFile = new Stopwatch();                             bool opened = false;                             while (!opened && waitForFile.ElapsedMilliseconds < timeoutMs)                             {                                 waitForFile.Start();                                 bool waitABitMore = false;                                 try                                 {                                     using (FileStream temp = new FileStream(physicalPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                                         opened = true;                                 }                                 catch (IOException iex)                                 {                                     if (IsFileLocked(iex))                                         waitABitMore = true;                                      else throw iex;                                 }                                 if (waitABitMore) { await Task.Delay((int)Math.Min(30' Math.Round((float)timeoutMs / 3.0))); }                                 waitForFile.Stop();                             }                             if (!opened) throw locked_exception; //By not throwing an exception' it is considered a hit by the rest of the code.                          }                       }                 });
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: int errorCode = System.Runtime.InteropServices.Marshal.GetHRForException(exception) & ((1 << 16) - 1);
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: return errorCode == 32 || errorCode == 33;
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: return errorCode == 32 || errorCode == 33;
Magic Number,ImageResizer.Plugins.DiskCache,CachedFolder,C:\repos\imazen_resizer\Plugins\DiskCache\Index\CachedFolder.cs,roughCompare,The following statement contains a magic number: return Math.Abs(d1.Ticks - d2.Ticks) < TimeSpan.TicksPerMillisecond * 5;
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The following statement contains a magic number: try {                 //Try to create and lock the mutex' or else open and lock it.                 try{                     cleanupLock = new Mutex(true' mutexKey' out hasLock);                 }catch(UnauthorizedAccessException){                     hasLock = false;                 }                           //Start the work loop                 while (true) {                     //Check for shutdown                     if (shuttingDown) return;                      //Try to acquire a reference to the lock if we didn't have access last time.                     if (cleanupLock == null) {                         //In this case' another process (running as another user account) has opened the lock. Eventually it may be garbage collected.                         try {                             cleanupLock = new Mutex(true' mutexKey' out hasLock);                         } catch (UnauthorizedAccessException) {                             hasLock = false;                         }                     }                      otherProcessManagingCleanup = !hasLock;                     if (!hasLock) {                         //If we have a reference' Wait until the other process calls ReleaseMutex()' or for 30 seconds' whichever is shorter.                         if (cleanupLock != null) hasLock = cleanupLock.WaitOne(30000);                         else Thread.Sleep(10000); //Otherwise just sleep 10s and check again' waiting for the mutex to be garbage collected so we can recreate it.                     }                     otherProcessManagingCleanup = !hasLock;                     if (!hasLock) {                         //Still no luck' someone else is managing things...                         //Clear out the todo-list                         queue.Clear();                         //Get back to doing nothing.                         continue;                     }                                           //Is it time to do some work?                     bool noWorkInTooLong = false; //Has it been too long since we did something?                     lock (_timesLock) noWorkInTooLong = (DateTime.UtcNow.Subtract(new DateTime(lastWorked)) > cs.MaxDelay);                      bool notBusy = false; //Is the server busy recently?                     lock (_timesLock) notBusy = (DateTime.UtcNow.Subtract(new DateTime(lastBusy)) > cs.MinDelay);                     //doSomeWork keeps being true in absence of incoming requests                      //If the server isn't busy' or if this worker has been lazy to long long' do some work and time it.                     Stopwatch workedForTime = null;                     if (noWorkInTooLong || notBusy) {                         workedForTime = new Stopwatch();                         workedForTime.Start();                         DoWorkFor(cs.OptimalWorkSegmentLength);                         lock (_timesLock) lastWorked = DateTime.UtcNow.Ticks;                          workedForTime.Stop();                     }                      //Check for shutdown                     if (shuttingDown) return;                                           //Nothing to do' queue is empty.                     if (queue.IsEmpty)                         //Wait perpetually until notified of more queue items.                         _queueWait.WaitOne();                     else if (notBusy)                         //Don't flood the system even when it's not busy. 50% usage here. Wait for the length of time worked or the optimal work time' whichever is longer.                         //A directory listing can take 30 seconds sometimes and kill the CPU.                         _quitWait.WaitOne((int)Math.Max(cs.OptimalWorkSegmentLength.TotalMilliseconds' workedForTime.ElapsedMilliseconds));                      else {                         //Estimate how long before we can run more code.                         long busyTicks = 0;                         lock (_timesLock) busyTicks = (cs.MinDelay - DateTime.UtcNow.Subtract(new DateTime(lastBusy))).Ticks;                         long maxTicks = 0;                         lock (_timesLock) maxTicks = (cs.MaxDelay - DateTime.UtcNow.Subtract(new DateTime(lastWorked))).Ticks;                         //Use the longer value and add a second to avoid rounding and timing errors.                         _quitWait.WaitOne(new TimeSpan(Math.Max(busyTicks' maxTicks)) + new TimeSpan(0' 0' 1));                     }                       //Check for shutdown                     if (shuttingDown) return;                 }             } finally {                 if (hasLock) cleanupLock.ReleaseMutex();                 otherProcessManagingCleanup = false;             }
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The following statement contains a magic number: try {                 //Try to create and lock the mutex' or else open and lock it.                 try{                     cleanupLock = new Mutex(true' mutexKey' out hasLock);                 }catch(UnauthorizedAccessException){                     hasLock = false;                 }                           //Start the work loop                 while (true) {                     //Check for shutdown                     if (shuttingDown) return;                      //Try to acquire a reference to the lock if we didn't have access last time.                     if (cleanupLock == null) {                         //In this case' another process (running as another user account) has opened the lock. Eventually it may be garbage collected.                         try {                             cleanupLock = new Mutex(true' mutexKey' out hasLock);                         } catch (UnauthorizedAccessException) {                             hasLock = false;                         }                     }                      otherProcessManagingCleanup = !hasLock;                     if (!hasLock) {                         //If we have a reference' Wait until the other process calls ReleaseMutex()' or for 30 seconds' whichever is shorter.                         if (cleanupLock != null) hasLock = cleanupLock.WaitOne(30000);                         else Thread.Sleep(10000); //Otherwise just sleep 10s and check again' waiting for the mutex to be garbage collected so we can recreate it.                     }                     otherProcessManagingCleanup = !hasLock;                     if (!hasLock) {                         //Still no luck' someone else is managing things...                         //Clear out the todo-list                         queue.Clear();                         //Get back to doing nothing.                         continue;                     }                                           //Is it time to do some work?                     bool noWorkInTooLong = false; //Has it been too long since we did something?                     lock (_timesLock) noWorkInTooLong = (DateTime.UtcNow.Subtract(new DateTime(lastWorked)) > cs.MaxDelay);                      bool notBusy = false; //Is the server busy recently?                     lock (_timesLock) notBusy = (DateTime.UtcNow.Subtract(new DateTime(lastBusy)) > cs.MinDelay);                     //doSomeWork keeps being true in absence of incoming requests                      //If the server isn't busy' or if this worker has been lazy to long long' do some work and time it.                     Stopwatch workedForTime = null;                     if (noWorkInTooLong || notBusy) {                         workedForTime = new Stopwatch();                         workedForTime.Start();                         DoWorkFor(cs.OptimalWorkSegmentLength);                         lock (_timesLock) lastWorked = DateTime.UtcNow.Ticks;                          workedForTime.Stop();                     }                      //Check for shutdown                     if (shuttingDown) return;                                           //Nothing to do' queue is empty.                     if (queue.IsEmpty)                         //Wait perpetually until notified of more queue items.                         _queueWait.WaitOne();                     else if (notBusy)                         //Don't flood the system even when it's not busy. 50% usage here. Wait for the length of time worked or the optimal work time' whichever is longer.                         //A directory listing can take 30 seconds sometimes and kill the CPU.                         _quitWait.WaitOne((int)Math.Max(cs.OptimalWorkSegmentLength.TotalMilliseconds' workedForTime.ElapsedMilliseconds));                      else {                         //Estimate how long before we can run more code.                         long busyTicks = 0;                         lock (_timesLock) busyTicks = (cs.MinDelay - DateTime.UtcNow.Subtract(new DateTime(lastBusy))).Ticks;                         long maxTicks = 0;                         lock (_timesLock) maxTicks = (cs.MaxDelay - DateTime.UtcNow.Subtract(new DateTime(lastWorked))).Ticks;                         //Use the longer value and add a second to avoid rounding and timing errors.                         _quitWait.WaitOne(new TimeSpan(Math.Max(busyTicks' maxTicks)) + new TimeSpan(0' 0' 1));                     }                       //Check for shutdown                     if (shuttingDown) return;                 }             } finally {                 if (hasLock) cleanupLock.ReleaseMutex();                 otherProcessManagingCleanup = false;             }
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,GetIssues,The following statement contains a magic number: lock (_timesLock) {                 if (this.lastFoundItemsOverMax > (DateTime.UtcNow.Subtract(new TimeSpan(0' 5' 0)).Ticks))                     issues.Add(new Issue("Your cache configuration may not be optimal. If this message persists' you should increase the 'subfolders' value in the <diskcache /> element in Web.config"'                         "In the last 5 minutes' a cache folder exceeded both the optimum and maximum limits for file count. This usually indicates that your 'subfolders' setting is too low' and that cached images are being deleted shortly after their creation. \n" +                         "To estimate the appropriate subfolders value' multiply the total number of images on the site times the average number of size variations' and divide by 400. I.e' 6'400 images with 2 variants would be 32. If in doubt' set the value higher' but ensure there is disk space available."' IssueSeverity.Error));              }
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,DoTask,The following statement contains a magic number: if (lp.Logger != null) lp.Logger.Trace("{2}ms: Executing task {0} {1} ({3} tasks remaining)"' item.Task.ToString()' item.RelativePath' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' queue.Count.ToString(NumberFormatInfo.InvariantInfo));
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,PopulateFolder,The following statement contains a magic number: if (!cache.Index.GetIsValid(item.RelativePath)) {                 if (lp.Logger != null) {                     Stopwatch sw = new Stopwatch();                     sw.Start();                     cache.Index.populate(item.RelativePath' item.PhysicalPath);                     sw.Stop();                     lp.Logger.Trace("{0}ms: Querying file system about {1}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' item.RelativePath);                 } else                      cache.Index.populate(item.RelativePath' item.PhysicalPath);             }
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,C:\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,RemoveFile,The following statement contains a magic number: cache.Locks.TryExecute(item.RelativePath' 10' delegate() {                  //If the file is already gone' consider the mission a success.                 if (!System.IO.File.Exists(item.PhysicalPath)) {                     cache.Index.setCachedFileInfo(item.RelativePath' null);                     removedFile = true;                     return;                 }                 //Cool' we got a lock on the file.                 //Remove it from the cache. Better a miss than an invalidation.                 cache.Index.setCachedFileInfo(item.RelativePath' null);                 try {                     System.IO.File.Delete(item.PhysicalPath);                 } catch (IOException) {                     return; //The file is in use' or has an open handle. - try the next file.                 } catch (UnauthorizedAccessException) {                     return; //Invalid NTFS permissions or readonly file.  - try the next file                 }                  cache.Index.setCachedFileInfo(item.RelativePath' null); //In case it crossed paths.                 removedFile = true;             });
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The following statement contains a magic number: if (!asynchronous) {                 //On the first check' verify the file exists using System.IO directly (the last 'true' parameter)                 //May throw an IOException if the file cannot be opened' and is locked by an external processes for longer than timeoutMs.                  //This method may take longer than timeoutMs under absolute worst conditions.                  if (!TryWriteFile(result' physicalPath' relativePath' writeCallback' timeoutMs' !mayBeLocked)) {                     //On failure                     result.Result = CacheQueryResult.Failed;                 }             }             else if (!Index.existsCertain(relativePath' physicalPath) || mayBeLocked)             {                                  //Looks like a miss. Let's enter a lock for the creation of the file. This is a different locking system than for writing to the file - far less contention' as it doesn't include the                  //This prevents two identical requests from duplicating efforts. Different requests don't lock.                  //Lock execution using relativePath as the sync basis. Ignore casing differences. This prevents duplicate entries in the write queue and wasted CPU/RAM usage.                 if (!QueueLocks.TryExecute(relativePath.ToUpperInvariant()' timeoutMs'                     delegate() {                          //Now' if the item we seek is in the queue' we have a memcached hit. If not' we should check the index. It's possible the item has been written to disk already.                         //If both are a miss' we should see if there is enough room in the write queue. If not' switch to in-thread writing.                           AsyncWrite t = CurrentWrites.Get(relativePath);                          if (t != null) result.Data = t.GetReadonlyStream();                                                    //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                         //When t == null' and we're inside QueueLocks' all work on the file must be finished' so we have no need to consult mayBeLocked.                         if (t == null && !Index.exists(relativePath' physicalPath))                         {                              result.Result = CacheQueryResult.Miss;                             //Still a miss' we even rechecked the file system. Write to memory.                             MemoryStream ms = new MemoryStream(4096);  //4K initial capacity is minimal' but this array will get copied around a lot' better to underestimate.                             //Read' resize' process' and encode the image. Lots of exceptions thrown here.                             writeCallback(ms);                             ms.Position = 0;                              AsyncWrite w = new AsyncWrite(CurrentWrites'ms' physicalPath' relativePath);                             if (CurrentWrites.Queue(w' delegate(AsyncWrite job) {                                 try {                                     Stopwatch swio = new Stopwatch();                                                                          swio.Start();                                     //TODO: perhaps a different timeout?                                     if (!TryWriteFile(null' job.PhysicalPath' job.Key' delegate(Stream s) { ((MemoryStream)job.GetReadonlyStream()).WriteTo(s); }' timeoutMs' true)) {                                         swio.Stop();                                         //We failed to lock the file.                                         if (lp.Logger != null)                                              lp.Logger.Warn("Failed to flush async write' timeout exceeded after {1}ms - {0}"'  result.RelativePath' swio.ElapsedMilliseconds);                                                                              } else {                                         swio.Stop();                                         if (lp.Logger != null)                                             lp.Logger.Trace("{0}ms: Async write started {1}ms after enqueue for {2}"' swio.ElapsedMilliseconds.ToString().PadLeft(4)' DateTime.UtcNow.Subtract(w.JobCreatedAt).Subtract(swio.Elapsed).TotalMilliseconds' result.RelativePath);                                     }                                  } catch (Exception ex) {                                     if (lp.Logger != null) {                                         lp.Logger.Error("Failed to flush async write' {0} {1}\n{2}"'ex.ToString()' result.RelativePath'ex.StackTrace);                                     }                                 } finally {                                     CurrentWrites.Remove(job); //Remove from the queue' it's done or failed.                                  }                              })) {                                 //We queued it! Send back a read-only memory stream                                 result.Data = w.GetReadonlyStream();                             } else {                                 asyncFailed = false;                                 //We failed to queue it - either the ThreadPool was exhausted or we exceeded the MB limit for the write queue.                                 //Write the MemoryStream to disk using the normal method.                                 //This is nested inside a queuelock because if we failed here' the next one will also. Better to force it to wait until the file is written to disk.                                 if (!TryWriteFile(result' physicalPath' relativePath' delegate(Stream s) { ms.WriteTo(s); }' timeoutMs' false)) {                                     if (lp.Logger != null)                                         lp.Logger.Warn("Failed to queue async write' also failed to lock for sync writing: {0}"' result.RelativePath);                                                                          }                             }                          }                      })) {                     //On failure                     result.Result = CacheQueryResult.Failed;                 }              }
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The following statement contains a magic number: if (!asynchronous) {                 //On the first check' verify the file exists using System.IO directly (the last 'true' parameter)                 //May throw an IOException if the file cannot be opened' and is locked by an external processes for longer than timeoutMs.                  //This method may take longer than timeoutMs under absolute worst conditions.                  if (!TryWriteFile(result' physicalPath' relativePath' writeCallback' timeoutMs' !mayBeLocked)) {                     //On failure                     result.Result = CacheQueryResult.Failed;                 }             }             else if (!Index.existsCertain(relativePath' physicalPath) || mayBeLocked)             {                                  //Looks like a miss. Let's enter a lock for the creation of the file. This is a different locking system than for writing to the file - far less contention' as it doesn't include the                  //This prevents two identical requests from duplicating efforts. Different requests don't lock.                  //Lock execution using relativePath as the sync basis. Ignore casing differences. This prevents duplicate entries in the write queue and wasted CPU/RAM usage.                 if (!QueueLocks.TryExecute(relativePath.ToUpperInvariant()' timeoutMs'                     delegate() {                          //Now' if the item we seek is in the queue' we have a memcached hit. If not' we should check the index. It's possible the item has been written to disk already.                         //If both are a miss' we should see if there is enough room in the write queue. If not' switch to in-thread writing.                           AsyncWrite t = CurrentWrites.Get(relativePath);                          if (t != null) result.Data = t.GetReadonlyStream();                                                    //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                         //When t == null' and we're inside QueueLocks' all work on the file must be finished' so we have no need to consult mayBeLocked.                         if (t == null && !Index.exists(relativePath' physicalPath))                         {                              result.Result = CacheQueryResult.Miss;                             //Still a miss' we even rechecked the file system. Write to memory.                             MemoryStream ms = new MemoryStream(4096);  //4K initial capacity is minimal' but this array will get copied around a lot' better to underestimate.                             //Read' resize' process' and encode the image. Lots of exceptions thrown here.                             writeCallback(ms);                             ms.Position = 0;                              AsyncWrite w = new AsyncWrite(CurrentWrites'ms' physicalPath' relativePath);                             if (CurrentWrites.Queue(w' delegate(AsyncWrite job) {                                 try {                                     Stopwatch swio = new Stopwatch();                                                                          swio.Start();                                     //TODO: perhaps a different timeout?                                     if (!TryWriteFile(null' job.PhysicalPath' job.Key' delegate(Stream s) { ((MemoryStream)job.GetReadonlyStream()).WriteTo(s); }' timeoutMs' true)) {                                         swio.Stop();                                         //We failed to lock the file.                                         if (lp.Logger != null)                                              lp.Logger.Warn("Failed to flush async write' timeout exceeded after {1}ms - {0}"'  result.RelativePath' swio.ElapsedMilliseconds);                                                                              } else {                                         swio.Stop();                                         if (lp.Logger != null)                                             lp.Logger.Trace("{0}ms: Async write started {1}ms after enqueue for {2}"' swio.ElapsedMilliseconds.ToString().PadLeft(4)' DateTime.UtcNow.Subtract(w.JobCreatedAt).Subtract(swio.Elapsed).TotalMilliseconds' result.RelativePath);                                     }                                  } catch (Exception ex) {                                     if (lp.Logger != null) {                                         lp.Logger.Error("Failed to flush async write' {0} {1}\n{2}"'ex.ToString()' result.RelativePath'ex.StackTrace);                                     }                                 } finally {                                     CurrentWrites.Remove(job); //Remove from the queue' it's done or failed.                                  }                              })) {                                 //We queued it! Send back a read-only memory stream                                 result.Data = w.GetReadonlyStream();                             } else {                                 asyncFailed = false;                                 //We failed to queue it - either the ThreadPool was exhausted or we exceeded the MB limit for the write queue.                                 //Write the MemoryStream to disk using the normal method.                                 //This is nested inside a queuelock because if we failed here' the next one will also. Better to force it to wait until the file is written to disk.                                 if (!TryWriteFile(result' physicalPath' relativePath' delegate(Stream s) { ms.WriteTo(s); }' timeoutMs' false)) {                                     if (lp.Logger != null)                                         lp.Logger.Warn("Failed to queue async write' also failed to lock for sync writing: {0}"' result.RelativePath);                                                                          }                             }                          }                      })) {                     //On failure                     result.Result = CacheQueryResult.Failed;                 }              }
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The following statement contains a magic number: if (lp.Logger != null) {                 sw.Stop();                 lp.Logger.Trace("{0}ms: {3}{1} for {2}' Key: {4}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' result.Result.ToString()' result.RelativePath' asynchronous ? (asyncFailed ? "Fallback to sync writes  " : "AsyncWrites ") : ""' keyBasis);             }
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The following statement contains a magic number: return Locks.TryExecute(relativePath.ToUpperInvariant()' timeoutMs'                 delegate() {                      //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                     if (!Index.exists(relativePath' physicalPath)) {                          //Create subdirectory if needed.                         if (!Directory.Exists(Path.GetDirectoryName(physicalPath))) {                             Directory.CreateDirectory(Path.GetDirectoryName(physicalPath));                             if (lp.Logger != null) lp.Logger.Debug("Creating missing parent directory {0}"' Path.GetDirectoryName(physicalPath));                         }                          //Open stream                          //Catch IOException' and if it is a file lock'                         // - (and hashmodified is true)' then it's another process writing to the file' and we can serve the file afterwards                         // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data.                         // I.e' hashmodified=true is the only supported setting for multi-process environments.                         //TODO: Catch UnathorizedAccessException and log issue about file permissions.                         //... If we can wait for a read handle for a specified timeout.                          try                         {                             string tempFile = physicalPath + ".tmp_" + new Random().Next(int.MaxValue).ToString("x") + ".tmp";                              System.IO.FileStream fs = new FileStream(tempFile' FileMode.Create' FileAccess.Write' FileShare.None);                             bool finished = false;                             try                             {                                 using (fs)                                 {                                     //Run callback to write the cached data                                     writeCallback(fs); //Can throw any number of exceptions.                                     fs.Flush(true);                                     finished = true;                                 }                             }                             finally                             {                                 //Don't leave half-written files around.                                 if (!finished)                                 {                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             bool moved = false;                             if (finished)                             {                                 try                                 {                                     File.Move(tempFile' physicalPath);                                     moved = true;                                 }                                 catch (IOException)                                 {                                     //Will throw IO exception if already exists. Which we consider a hit' so we delete the tempFile                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             if (moved)                             {                                 DateTime createdUtc = DateTime.UtcNow;                                 //Set the created date' so we know the last time we updated the cache.s                                 System.IO.File.SetCreationTimeUtc(physicalPath' createdUtc);                                 //Update index                                 //TODO: what should sourceModifiedUtc be when there is no modified date?                                 Index.setCachedFileInfo(relativePath' new CachedFileInfo(createdUtc' createdUtc' createdUtc));                                 //This was a cache miss                                 if (result != null) result.Result = CacheQueryResult.Miss;                             }                         }                         catch (IOException ex)                         {                              if (IsFileLocked(ex)) {                                 //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else.                                 //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for                                  //reading within timeoutMs' simply do nothing and let the file be returned as a hit.                                 Stopwatch waitForFile = new Stopwatch();                                 bool opened = false;                                 while (!opened && waitForFile.ElapsedMilliseconds < timeoutMs) {                                     waitForFile.Start();                                     try {                                         using (FileStream temp = new FileStream(physicalPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                                             opened = true;                                     } catch (IOException iex) {                                         if (IsFileLocked(iex))                                             Thread.Sleep((int)Math.Min(30' Math.Round((float)timeoutMs / 3.0)));                                         else throw iex;                                     }                                     waitForFile.Stop();                                 }                                 if (!opened) throw; //By not throwing an exception' it is considered a hit by the rest of the code.                              } else throw;                         }                      }                 });
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The following statement contains a magic number: return Locks.TryExecute(relativePath.ToUpperInvariant()' timeoutMs'                 delegate() {                      //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                     if (!Index.exists(relativePath' physicalPath)) {                          //Create subdirectory if needed.                         if (!Directory.Exists(Path.GetDirectoryName(physicalPath))) {                             Directory.CreateDirectory(Path.GetDirectoryName(physicalPath));                             if (lp.Logger != null) lp.Logger.Debug("Creating missing parent directory {0}"' Path.GetDirectoryName(physicalPath));                         }                          //Open stream                          //Catch IOException' and if it is a file lock'                         // - (and hashmodified is true)' then it's another process writing to the file' and we can serve the file afterwards                         // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data.                         // I.e' hashmodified=true is the only supported setting for multi-process environments.                         //TODO: Catch UnathorizedAccessException and log issue about file permissions.                         //... If we can wait for a read handle for a specified timeout.                          try                         {                             string tempFile = physicalPath + ".tmp_" + new Random().Next(int.MaxValue).ToString("x") + ".tmp";                              System.IO.FileStream fs = new FileStream(tempFile' FileMode.Create' FileAccess.Write' FileShare.None);                             bool finished = false;                             try                             {                                 using (fs)                                 {                                     //Run callback to write the cached data                                     writeCallback(fs); //Can throw any number of exceptions.                                     fs.Flush(true);                                     finished = true;                                 }                             }                             finally                             {                                 //Don't leave half-written files around.                                 if (!finished)                                 {                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             bool moved = false;                             if (finished)                             {                                 try                                 {                                     File.Move(tempFile' physicalPath);                                     moved = true;                                 }                                 catch (IOException)                                 {                                     //Will throw IO exception if already exists. Which we consider a hit' so we delete the tempFile                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             if (moved)                             {                                 DateTime createdUtc = DateTime.UtcNow;                                 //Set the created date' so we know the last time we updated the cache.s                                 System.IO.File.SetCreationTimeUtc(physicalPath' createdUtc);                                 //Update index                                 //TODO: what should sourceModifiedUtc be when there is no modified date?                                 Index.setCachedFileInfo(relativePath' new CachedFileInfo(createdUtc' createdUtc' createdUtc));                                 //This was a cache miss                                 if (result != null) result.Result = CacheQueryResult.Miss;                             }                         }                         catch (IOException ex)                         {                              if (IsFileLocked(ex)) {                                 //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else.                                 //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for                                  //reading within timeoutMs' simply do nothing and let the file be returned as a hit.                                 Stopwatch waitForFile = new Stopwatch();                                 bool opened = false;                                 while (!opened && waitForFile.ElapsedMilliseconds < timeoutMs) {                                     waitForFile.Start();                                     try {                                         using (FileStream temp = new FileStream(physicalPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                                             opened = true;                                     } catch (IOException iex) {                                         if (IsFileLocked(iex))                                             Thread.Sleep((int)Math.Min(30' Math.Round((float)timeoutMs / 3.0)));                                         else throw iex;                                     }                                     waitForFile.Stop();                                 }                                 if (!opened) throw; //By not throwing an exception' it is considered a hit by the rest of the code.                              } else throw;                         }                      }                 });
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: int errorCode = System.Runtime.InteropServices.Marshal.GetHRForException(exception) & ((1 << 16) - 1);
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: return errorCode == 32 || errorCode == 33;
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: return errorCode == 32 || errorCode == 33;
Magic Number,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The following statement contains a magic number: if (this.AsyncBufferSize < 1024 * 1024 * 2)                 issues.Add(new Issue("DiskCache"' "The asyncBufferSize should not be set below 2 megabytes (2097152). Found in the <diskcache /> element in Web.config."'                     "A buffer that is too small will cause requests to be processed synchronously. Remember to set the value to at least 4x the maximum size of an output image."' IssueSeverity.ConfigurationError));
Magic Number,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The following statement contains a magic number: if (this.AsyncBufferSize < 1024 * 1024 * 2)                 issues.Add(new Issue("DiskCache"' "The asyncBufferSize should not be set below 2 megabytes (2097152). Found in the <diskcache /> element in Web.config."'                     "A buffer that is too small will cause requests to be processed synchronously. Remember to set the value to at least 4x the maximum size of an output image."' IssueSeverity.ConfigurationError));
Magic Number,ImageResizer.Plugins.DiskCache,DiskCache,C:\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The following statement contains a magic number: if (this.AsyncBufferSize < 1024 * 1024 * 2)                 issues.Add(new Issue("DiskCache"' "The asyncBufferSize should not be set below 2 megabytes (2097152). Found in the <diskcache /> element in Web.config."'                     "A buffer that is too small will cause requests to be processed synchronously. Remember to set the value to at least 4x the maximum size of an output image."' IssueSeverity.ConfigurationError));
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,C:\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,getSubfolder,The following statement contains a magic number: int bits = (int)Math.Ceiling(Math.Log(subfolders' 2));
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,C:\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,getSubfolder,The following statement contains a magic number: Debug.Assert(bits <= hash.Length * 8);
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,C:\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,getSubfolder,The following statement contains a magic number: byte[] subfolder = new byte[(int)Math.Ceiling((double)bits / 8.0)];
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,C:\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,getSubfolder,The following statement contains a magic number: subfolder[0] = (byte)((int)subfolder[0] >> ((subfolder.Length * 8) - bits));
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,C:\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,Base16Encode,The following statement contains a magic number: StringBuilder sb = new StringBuilder(bytes.Length * 2);
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,C:\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,Base16Encode,The following statement contains a magic number: foreach (byte b in bytes)                 sb.Append(b.ToString("x"' NumberFormatInfo.InvariantInfo).PadLeft(2' '0'));
Magic Number,ImageResizer.Plugins.DiskCache,WebConfigWriter,C:\repos\imazen_resizer\Plugins\DiskCache\WebConfigWriter.cs,CheckWebConfigEvery5,The following statement contains a magic number: if (_lastCheckedWebConfig < DateTime.UtcNow.Subtract(new TimeSpan(0' 5' 0))) {                 lock (_webConfigSyncObj) {                     if (_lastCheckedWebConfig < DateTime.UtcNow.Subtract(new TimeSpan(0' 5' 0)))                         _checkWebConfig();                 }             }
Magic Number,ImageResizer.Plugins.DiskCache,WebConfigWriter,C:\repos\imazen_resizer\Plugins\DiskCache\WebConfigWriter.cs,CheckWebConfigEvery5,The following statement contains a magic number: if (_lastCheckedWebConfig < DateTime.UtcNow.Subtract(new TimeSpan(0' 5' 0))) {                 lock (_webConfigSyncObj) {                     if (_lastCheckedWebConfig < DateTime.UtcNow.Subtract(new TimeSpan(0' 5' 0)))                         _checkWebConfig();                 }             }
Magic Number,ImageResizer.Plugins.MemCache,MemCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\OutputMemCache\MemCache.cs,MemCachePlugin,The following statement contains a magic number: cache = new ConstrainedCache<string' MemCacheResult>(StringComparer.OrdinalIgnoreCase' delegate(string key' MemCacheResult file) {                 return key.Length * 4 + file.BytesOccupied;             }' maxBytes' usageWindow' new TimeSpan(0' 1' 0));
Magic Number,ImageResizer.Plugins.MemCache,MemCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\OutputMemCache\MemCache.cs,Process,The following statement contains a magic number: locks.TryExecute(key' 3000' delegate() {                 c = cache.Get(key);                 if (c == null) {                     using (var data = new MemoryStream()){                         e.ResizeImageToStream(data);//Very long-running call                         c = new MemCacheResult(data.CopyToBytes(true));                     }                     cache.Set(key' c);//Save to cache (may trigger cleanup)                 }                 Serve(current' e' c);                 return;             });
Magic Number,ImageResizer.Plugins.MemCache,MemCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\OutputMemCache\MemCache.cs,ProcessAsync,The following statement contains a magic number: return asyncLocks.TryExecuteAsync(key' 3000' async delegate()             {                 c = cache.Get(key);                 if (c == null)                 {                     using (var data = new MemoryStream(4096))                     {                         await e.CreateAndWriteResultAsync(data'e);//Very long-running call                         c = new MemCacheResult(data.CopyToBytes(true));                     }                     cache.Set(key' c);//Save to cache (may trigger cleanup)                 }                 Serve(current' e' c);                 return;             });
Magic Number,ImageResizer.Plugins.MemCache,MemCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\OutputMemCache\MemCache.cs,ProcessAsync,The following statement contains a magic number: return asyncLocks.TryExecuteAsync(key' 3000' async delegate()             {                 c = cache.Get(key);                 if (c == null)                 {                     using (var data = new MemoryStream(4096))                     {                         await e.CreateAndWriteResultAsync(data'e);//Very long-running call                         c = new MemCacheResult(data.CopyToBytes(true));                     }                     cache.Set(key' c);//Save to cache (may trigger cleanup)                 }                 Serve(current' e' c);                 return;             });
Magic Number,ImageResizer.Plugins.MemCache,MemCacheHandler,C:\repos\imazen_resizer\Plugins\DiskCache\OutputMemCache\MemCacheHandler.cs,ProcessRequestAsync,The following statement contains a magic number: context.Response.StatusCode = 200;
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCached,The following statement contains a magic number: var r = cache.GetCachedFile(key' ".cache"' delegate(Stream target)              {                  using (Stream data = original.Open())                  {//Very long-running call                      data.CopyToStream(target);                  }              }' 15 * 1000' true);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCached,The following statement contains a magic number: var r = cache.GetCachedFile(key' ".cache"' delegate(Stream target)              {                  using (Stream data = original.Open())                  {//Very long-running call                      data.CopyToStream(target);                  }              }' 15 * 1000' true);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCachedAsync,The following statement contains a magic number: var r = await asyncCache.GetCachedFile(key' ".cache"' async delegate(Stream target)             {                 using (Stream data = await original.OpenAsync())                 {//Very long-running call                     await data.CopyToAsync(target);                 }             }' 15 * 1000' true);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCachedAsync,The following statement contains a magic number: var r = await asyncCache.GetCachedFile(key' ".cache"' async delegate(Stream target)             {                 using (Stream data = await original.OpenAsync())                 {//Very long-running call                     await data.CopyToAsync(target);                 }             }' 15 * 1000' true);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: lock (_startSync)             {                 if (_started) return true;                 if (!IsConfigurationValid()) return false;                  //Init the writer.                 writer = new WebConfigWriter(this' PhysicalCacheDir);                  if (!AsyncModuleMode) cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                 if (AsyncModuleMode) asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                  //Init the cleanup strategy                 var cleanupStrategy = new CleanupStrategy(); //Default settings if null                 cleanupStrategy.TargetItemsPerFolder = 50;                 //Init the cleanup worker                 cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);                 //If we're running with subfolders' enqueue the cache root for cleanup (after the 5 minute delay)                 //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ).                  if (cleaner != null) cleaner.CleanAll();                  //Started successfully                 _started = true;                 return true;             }
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: lock (_startSync)             {                 if (_started) return true;                 if (!IsConfigurationValid()) return false;                  //Init the writer.                 writer = new WebConfigWriter(this' PhysicalCacheDir);                  if (!AsyncModuleMode) cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                 if (AsyncModuleMode) asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                  //Init the cleanup strategy                 var cleanupStrategy = new CleanupStrategy(); //Default settings if null                 cleanupStrategy.TargetItemsPerFolder = 50;                 //Init the cleanup worker                 cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);                 //If we're running with subfolders' enqueue the cache root for cleanup (after the 5 minute delay)                 //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ).                  if (cleaner != null) cleaner.CleanAll();                  //Started successfully                 _started = true;                 return true;             }
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: lock (_startSync)             {                 if (_started) return true;                 if (!IsConfigurationValid()) return false;                  //Init the writer.                 writer = new WebConfigWriter(this' PhysicalCacheDir);                  if (!AsyncModuleMode) cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                 if (AsyncModuleMode) asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                  //Init the cleanup strategy                 var cleanupStrategy = new CleanupStrategy(); //Default settings if null                 cleanupStrategy.TargetItemsPerFolder = 50;                 //Init the cleanup worker                 cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);                 //If we're running with subfolders' enqueue the cache root for cleanup (after the 5 minute delay)                 //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ).                  if (cleaner != null) cleaner.CleanAll();                  //Started successfully                 _started = true;                 return true;             }
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: lock (_startSync)             {                 if (_started) return true;                 if (!IsConfigurationValid()) return false;                  //Init the writer.                 writer = new WebConfigWriter(this' PhysicalCacheDir);                  if (!AsyncModuleMode) cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                 if (AsyncModuleMode) asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                  //Init the cleanup strategy                 var cleanupStrategy = new CleanupStrategy(); //Default settings if null                 cleanupStrategy.TargetItemsPerFolder = 50;                 //Init the cleanup worker                 cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);                 //If we're running with subfolders' enqueue the cache root for cleanup (after the 5 minute delay)                 //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ).                  if (cleaner != null) cleaner.CleanAll();                  //Started successfully                 _started = true;                 return true;             }
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: lock (_startSync)             {                 if (_started) return true;                 if (!IsConfigurationValid()) return false;                  //Init the writer.                 writer = new WebConfigWriter(this' PhysicalCacheDir);                  if (!AsyncModuleMode) cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                 if (AsyncModuleMode) asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                  //Init the cleanup strategy                 var cleanupStrategy = new CleanupStrategy(); //Default settings if null                 cleanupStrategy.TargetItemsPerFolder = 50;                 //Init the cleanup worker                 cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);                 //If we're running with subfolders' enqueue the cache root for cleanup (after the 5 minute delay)                 //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ).                  if (cleaner != null) cleaner.CleanAll();                  //Started successfully                 _started = true;                 return true;             }
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: lock (_startSync)             {                 if (_started) return true;                 if (!IsConfigurationValid()) return false;                  //Init the writer.                 writer = new WebConfigWriter(this' PhysicalCacheDir);                  if (!AsyncModuleMode) cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                 if (AsyncModuleMode) asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                  //Init the cleanup strategy                 var cleanupStrategy = new CleanupStrategy(); //Default settings if null                 cleanupStrategy.TargetItemsPerFolder = 50;                 //Init the cleanup worker                 cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);                 //If we're running with subfolders' enqueue the cache root for cleanup (after the 5 minute delay)                 //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ).                  if (cleaner != null) cleaner.CleanAll();                  //Started successfully                 _started = true;                 return true;             }
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: lock (_startSync)             {                 if (_started) return true;                 if (!IsConfigurationValid()) return false;                  //Init the writer.                 writer = new WebConfigWriter(this' PhysicalCacheDir);                  if (!AsyncModuleMode) cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                 if (AsyncModuleMode) asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                  //Init the cleanup strategy                 var cleanupStrategy = new CleanupStrategy(); //Default settings if null                 cleanupStrategy.TargetItemsPerFolder = 50;                 //Init the cleanup worker                 cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);                 //If we're running with subfolders' enqueue the cache root for cleanup (after the 5 minute delay)                 //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ).                  if (cleaner != null) cleaner.CleanAll();                  //Started successfully                 _started = true;                 return true;             }
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: lock (_startSync)             {                 if (_started) return true;                 if (!IsConfigurationValid()) return false;                  //Init the writer.                 writer = new WebConfigWriter(this' PhysicalCacheDir);                  if (!AsyncModuleMode) cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                 if (AsyncModuleMode) asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                  //Init the cleanup strategy                 var cleanupStrategy = new CleanupStrategy(); //Default settings if null                 cleanupStrategy.TargetItemsPerFolder = 50;                 //Init the cleanup worker                 cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);                 //If we're running with subfolders' enqueue the cache root for cleanup (after the 5 minute delay)                 //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ).                  if (cleaner != null) cleaner.CleanAll();                  //Started successfully                 _started = true;                 return true;             }
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: lock (_startSync)             {                 if (_started) return true;                 if (!IsConfigurationValid()) return false;                  //Init the writer.                 writer = new WebConfigWriter(this' PhysicalCacheDir);                  if (!AsyncModuleMode) cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                 if (AsyncModuleMode) asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);                  //Init the cleanup strategy                 var cleanupStrategy = new CleanupStrategy(); //Default settings if null                 cleanupStrategy.TargetItemsPerFolder = 50;                 //Init the cleanup worker                 cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);                 //If we're running with subfolders' enqueue the cache root for cleanup (after the 5 minute delay)                 //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ).                  if (cleaner != null) cleaner.CleanAll();                  //Started successfully                 _started = true;                 return true;             }
Magic Number,ImageResizer.Plugins.SourceMemCache,ConstrainedCache<K;V>,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\ConstrainedCache.cs,ConstrainedCache,The following statement contains a magic number: s.CounterGranularity = 16;
Magic Number,ImageResizer.Plugins.SourceMemCache,ConstrainedCache<K;V>,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\ConstrainedCache.cs,Set,The following statement contains a magic number: lock (lockSync) {                 data[key] = val;                 usage.Increment(key' calculator(key' val) + 32);             }
Magic Number,ImageResizer.Plugins.SourceMemCache,EventCountingStrategy,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,EventCountingStrategy,The following statement contains a magic number: CounterGranularity = 8;
Magic Number,ImageResizer.Plugins.SourceMemCache,EventCountingStrategy,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,EventCountingStrategy,The following statement contains a magic number: MinimumCleanupInterval = new TimeSpan(0' 0' 20);
Magic Number,ImageResizer.Plugins.SourceMemCache,EventCountingDictionary<T>,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,Cleanup,The following statement contains a magic number: try {                 //In high precision' we lock the entire long-running process                 if (precision == EventCountingStrategy.ThreadingPrecision.Accurate) Monitor.Enter(syncLock);                 try {                     EventCounter[] counters;                     //In fast mode' only lock for the copy and delete. We can sort outside after taking a snapshot.                      //We wont remove newly added ones' but thats ok.                      lock (syncLock) {                         if (mode == CleanupMode.MakeRoom && bytesUsed < byteCeiling) return true; //Nothing to do' there is still room                         counters = new EventCounter[countersToKeys.Count];                         countersToKeys.Keys.CopyTo(counters' 0); //Clone                      }                     //Lock for sorting so we have synchronized access to a.sortValue                     lock (sortLock) {                         //Pause values                         for (int i = 0; i < counters.Length; i++) {                             counters[i].sortValue = counters[i].GetValue();                         }                         //Sort lowest counters to the top using Quicksort                         Array.Sort<EventCounter>(counters' delegate(EventCounter a' EventCounter b) {                             return a.sortValue - b.sortValue;                         });                     }                     //Go back into lock                     lock (syncLock) {                         long removedBytes = 0;                         long goal = byteCeiling / 10; //10% is our goal if we are removing minimally.                         //Remove items                         for (int i = 0; i < counters.Length; i++) {                             EventCounter c = counters[i];                             if (mode == CleanupMode.MakeRoom && removedBytes >= goal) return true; //Done' we hit our goal!                             if (mode == CleanupMode.Maintenance && c.sortValue > 0) return true; //Done' We hit the end of the zeros                             if (mode == CleanupMode.Maintenance && c.GetValue() > 0) continue; //Skip counters that incremented while we were working.                             //Look up key                             T key;                             countersToKeys.TryGetValue(c' out key);                             if (key.Equals(default(T))) continue; //Skip counters that have already been removed                             //Remove counter                             countersToKeys.Remove(c);                             keysToCounters.Remove(key);                             //Increment our local byte removal counter                             removedBytes += c.CustomSize + itemSize;                              //Decrement global counter                             bytesUsed = bytesUsed - c.CustomSize - itemSize;                             //store removed keys                             if (removed != null) removed.Add(new KeyValuePair<T' int>(key' c.GetValue()));                         }                     }                 } finally {                     if (precision == EventCountingStrategy.ThreadingPrecision.Accurate) Monitor.Exit(syncLock);                 }             } finally {                 Monitor.Exit(cleanupLock);                  //Fire CounterRemoved event (may still be in syncLock)!                 if (removed != null && this.CounterRemoved != null) {                     foreach (KeyValuePair<T' int> p in removed) {                         CounterRemoved(this' p.Key' p.Value);                     }                 }             }
Magic Number,ImageResizer.Plugins.SourceMemCache,SourceMemCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,SourceMemCachePlugin,The following statement contains a magic number: cache = new ConstrainedCache<string' CachedVirtualFile>(StringComparer.OrdinalIgnoreCase' delegate(string key' CachedVirtualFile file) {                 return key.Length * 4 + file.BytesOccupied;             }' maxBytes' usageWindow' new TimeSpan(0' 1' 0));
Magic Number,ImageResizer.Plugins.SourceMemCache,SourceMemCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,GetFileIfCached,The following statement contains a magic number: if ("mem".Equals(queryString["scache"]' StringComparison.OrdinalIgnoreCase)) {                 locks.TryExecute(key' 3000' delegate() {                     c = cache.Get(key);                     if (c == null) {                         using (Stream data = original.Open()) {//Very long-running call                             c = new CachedVirtualFile(original.VirtualPath' data.CopyToBytes(true));                         }                         cache.Set(key' c);//Save to cache (may trigger cleanup)                     }                 });                 return c;             }
Magic Number,ImageResizer.Plugins.SourceMemCache,SourceMemCachePlugin,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,GetFileIfCachedAsync,The following statement contains a magic number: if ("mem".Equals(queryString["scache"]' StringComparison.OrdinalIgnoreCase))             {                 await asyncLocks.TryExecuteAsync(key' 3000' async delegate()                 {                     c = cache.Get(key);                     if (c == null)                     {                         using (Stream data = await original.OpenAsync())                         {//Very long-running call                             c = new CachedVirtualFile(original.VirtualPath' await data.CopyToBytesAsync(true' 0x1000));                         }                         cache.Set(key' c);//Save to cache (may trigger cleanup)                     }                 });                 return c;             }
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: unchecked {                 const int p = 16777619;                 int hash = (int)2166136261;                  for (int i = 0; i < data.Length; i++)                     hash = (hash ^ data[i]) * p;                  hash += hash << 13;                 hash ^= hash >> 7;                 hash += hash << 3;                 hash ^= hash >> 17;                 hash += hash << 5;                 return hash;             }
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: unchecked {                 const int p = 16777619;                 int hash = (int)2166136261;                  for (int i = 0; i < data.Length; i++)                     hash = (hash ^ data[i]) * p;                  hash += hash << 13;                 hash ^= hash >> 7;                 hash += hash << 3;                 hash ^= hash >> 17;                 hash += hash << 5;                 return hash;             }
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: unchecked {                 const int p = 16777619;                 int hash = (int)2166136261;                  for (int i = 0; i < data.Length; i++)                     hash = (hash ^ data[i]) * p;                  hash += hash << 13;                 hash ^= hash >> 7;                 hash += hash << 3;                 hash ^= hash >> 17;                 hash += hash << 5;                 return hash;             }
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: unchecked {                 const int p = 16777619;                 int hash = (int)2166136261;                  for (int i = 0; i < data.Length; i++)                     hash = (hash ^ data[i]) * p;                  hash += hash << 13;                 hash ^= hash >> 7;                 hash += hash << 3;                 hash ^= hash >> 17;                 hash += hash << 5;                 return hash;             }
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: unchecked {                 const int p = 16777619;                 int hash = (int)2166136261;                  for (int i = 0; i < data.Length; i++)                     hash = (hash ^ data[i]) * p;                  hash += hash << 13;                 hash ^= hash >> 7;                 hash += hash << 3;                 hash ^= hash >> 17;                 hash += hash << 5;                 return hash;             }
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: unchecked {                 const int p = 16777619;                 int hash = (int)2166136261;                  for (int i = 0; i < data.Length; i++)                     hash = (hash ^ data[i]) * p;                  hash += hash << 13;                 hash ^= hash >> 7;                 hash += hash << 3;                 hash ^= hash >> 17;                 hash += hash << 5;                 return hash;             }
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,C:\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: unchecked {                 const int p = 16777619;                 int hash = (int)2166136261;                  for (int i = 0; i < data.Length; i++)                     hash = (hash ^ data[i]) * p;                  hash += hash << 13;                 hash ^= hash >> 7;                 hash += hash << 3;                 hash ^= hash >> 17;                 hash += hash << 5;                 return hash;             }
