Implementation smell,Namespace,Class,File,Method,Description
Long Method,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The method has 121 lines of code.
Long Method,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The method has 126 lines of code.
Long Method,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The method has 120 lines of code.
Long Method,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The method has 112 lines of code.
Complex Method,ImageResizer.Plugins.LicenseVerifier,LicenseDetails,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,LicenseDetails,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,Cyclomatic complexity of the method is 12
Complex Method,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,DoTask,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,CleanFolder,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Start,Cyclomatic complexity of the method is 10
Complex Method,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,Cyclomatic complexity of the method is 8
Complex Method,ImageResizer.Plugins.SourceMemCache,EventCountingDictionary<T>,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,Cleanup,Cyclomatic complexity of the method is 12
Long Parameter List,ImageResizer.Plugins.LicenseVerifier,Computation,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,Computation,The method has 6 parameters. Parameters: c' trustedKeys' permanentIssueSink' mgr' clock' enforcementEnabled
Long Parameter List,ImageResizer.Plugins.LicenseVerifier,LicenseFetcher,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseFetcher.cs,LicenseFetcher,The method has 9 parameters. Parameters: clock' getClient' licenseResult' getInfo' sink' licenseId' licenseSecret' baseUrls' licenseFetchIntervalSeconds
Long Parameter List,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The method has 5 parameters. Parameters: keyBasis' extension' writeCallback' timeoutMs' asynchronous
Long Parameter List,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The method has 6 parameters. Parameters: result' physicalPath' relativePath' writeCallback' timeoutMs' recheckFS
Long Parameter List,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The method has 5 parameters. Parameters: keyBasis' extension' writeCallback' timeoutMs' asynchronous
Long Parameter List,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The method has 6 parameters. Parameters: result' physicalPath' relativePath' writeCallback' timeoutMs' recheckFS
Long Parameter List,ImageResizer.Plugins.SourceMemCache,ConstrainedCache<K;V>,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\ConstrainedCache.cs,ConstrainedCache,The method has 5 parameters. Parameters: keyComparer' calculator' maxBytes' usageWindow' minCleanupInterval
Long Identifier,ImageResizer.Plugins.DiskCache,CleanupStrategy,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,,The length of the parameter prohibitRemovalIfCreatedWithin is 30.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,AreFeaturesLicensed,The length of the statement  "                    $"License {b.Fields.Id} needs to be upgraded; it does not cover in-use features {notCovered.SelectMany(v => v).Distinct().Delimited("' ")}"' b.ToRedactedString()'" is 162.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,IsLicenseValid,The length of the statement  "                    $"License {details.Id} covers ImageResizer versions prior to {details.SubscriptionExpirationDate?.ToString("D")}' but you are using a build dated {GetBuildDate()?.ToString("D")}"'" is 179.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,IsLicenseValid,The length of the statement  "                permanentIssues.AcceptIssue(new Issue($"License {details.Id}" + (message != null ? $": {message}" : " is no longer valid")'" is 123.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,GetGracePeriodFor,The length of the statement  "                    $"License {chain.Id} was not found in the disk cache and could not be retrieved from the remote server within {graceMinutes} minutes."'" is 135.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,SalesMessage,The length of the statement  "                return "Need to change domains? Get a discounted upgrade to a floating license: https://imageresizing.net/licenses/convert";" is 124.
Long Statement,ImageResizer.Plugins.LicenseVerifier,Computation,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,SalesMessage,The length of the statement  "A universal license key would fix that. See if your purchase is eligible for a free key: https://imageresizing.net/licenses/convert";" is 133.
Long Statement,ImageResizer.Plugins.LicenseVerifier,DomainLookup,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\DomainLookup.cs,GetDomainMappings,The length of the statement  "                        $"You have mapped {from} to {to}. {to} is not one of the known domains: {string.Join(" "' knownDomains.OrderBy(s => s))}"'" is 122.
Long Statement,ImageResizer.Plugins.LicenseVerifier,LicenseChain,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseChain.cs,ToPublicString,The length of the statement  "                $"License {Id}{(IsRemote ? " (remote)" : "")}\n{string.Join("\n\n"' Licenses().Where(b => b.Fields.IsPublic()).Select(b => freshness(b) + b.ToRedactedString()))}\n");" is 166.
Long Statement,ImageResizer.Plugins.LicenseVerifier,LicenseChain,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseChain.cs,ToString,The length of the statement  "                $"License {Id} (remote={IsRemote})\n    {string.Join("\n\n"' Licenses().Select(b => freshness(b) + b.ToRedactedString())).Replace("\n"' "\n    ")}\n");" is 151.
Long Statement,ImageResizer.Plugins.LicenseVerifier,SignatureTestApp,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Test_Generic,The length of the statement  "                "28178177427582259905122756905913963624440517746414712044433894631438407111916149031583287058323879921298234454158166031934230083094710974550125942791690254427377300877691173542319534371793100994953897137837772694304619234054383162641475011138179669415510521009673718000682851222831185756777382795378538121010194881849505437499638792289283538921706236004391184253166867653735050981736002298838523242717690667046044130539971131293603078008447972889271580670305162199959939004819206804246872436611558871928921860176200657026263241409488257640191893499783065332541392967986495144643652353104461436623253327708136399114561");" is 621.
Long Statement,ImageResizer.Plugins.LicenseVerifier,SignatureTestApp,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Test_Generic,The length of the statement  "                "localhost:RG9tYWluOiBsb2NhbGhvc3QKT3duZXI6IEV2ZXJ5b25lCklzc3VlZDogMjAxNS0wMy0yOFQwOTozNjo1OVoKRmVhdHVyZXM6IFI0RWxpdGUgUjRDcmVhdGl2ZSBSNFBlcmZvcm1hbmNlCg==:h6D+kIXbF3qmvmW2gDpb+b4gdxBjnrkZLvSzXmEnqKAywNJNpTdFekpTOB4SwU14WbTeVyWwvFngHax7WuHBV+0WkQ5lDqKFaRW32vj8CJQeG8Wvnyj9PaNGaS/FpKhNjZbDEmh3qqirBp2NR0bpN4QbhP9NMy7+rOMo0nynAruwWvJKCnuf7mWWdb9a5uTZO9OUcSeS/tY8QaNeIhaCnhPe0Yx9qvOXe5nMnl10CR9ur+EtS54d1qzBGHqN/3oFhiB+xlqNELwz23qR4c8HxbTEyNarkG4CZx8CbbgJfHmPxAYGJTTBTPJ+cdah8MJR16Ta36cRZ2Buy8XYo/nf1g==";" is 502.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "            //2013-apr-25: What happens if the file is still being written to disk - it's present but not complete? To handle that' we use mayBeLocked." is 139.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                //May throw an IOException if the file cannot be opened' and is locked by an external processes for longer than timeoutMs. " is 122.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                //Looks like a miss. Let's enter a lock for the creation of the file. This is a different locking system than for writing to the file - far less contention' as it doesn't include the " is 182.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                //Lock execution using relativePath as the sync basis. Ignore casing differences. This prevents duplicate entries in the write queue and wasted CPU/RAM usage." is 158.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //Now' if the item we seek is in the queue' we have a memcached hit. If not' we should check the index. It's possible the item has been written to disk already." is 160.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did)." is 150.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //When t == null' and we're inside QueueLocks' all work on the file must be finished' so we have no need to consult mayBeLocked." is 128.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                            MemoryStream ms = new MemoryStream(4096);  //4K initial capacity is minimal' but this array will get copied around a lot' better to underestimate." is 146.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                                    if (!TryWriteFile(null' job.PhysicalPath' job.Key' delegate(Stream s) { ((MemoryStream)job.GetReadonlyStream()).CopyToAsync(s); return Task.FromResult(true); }' timeoutMs' true).Result)" is 185.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                                            lp.Logger.Warn("Failed to flush async write' timeout exceeded after {1}ms - {0}"'  result.RelativePath' swio.ElapsedMilliseconds);" is 130.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                                            lp.Logger.Trace("{0}ms: Async write started {1}ms after enqueue for {2}"' swio.ElapsedMilliseconds.ToString().PadLeft(4)' DateTime.UtcNow.Subtract(w.JobCreatedAt).Subtract(swio.Elapsed).TotalMilliseconds' result.RelativePath);" is 226.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                                //This is nested inside a queuelock because if we failed here' the next one will also. Better to force it to wait until the file is written to disk." is 148.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                                if (!await TryWriteFile(result' physicalPath' relativePath' async delegate(Stream s) { await ms.CopyToAsync(s); }' timeoutMs' false)) {" is 135.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The length of the statement  "                lp.Logger.Trace("{0}ms: {3}{1} for {2}' Key: {4}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' result.Result.ToString()' result.RelativePath' asynchronous ? (asyncFailed ? "AsyncHttpMode' fell back to sync write  " : "AsyncHttpMode+AsyncWrites ") : "AsyncHttpMode"' keyBasis);" is 308.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The length of the statement  "            //Lock execution using relativePath as the sync basis. Ignore casing differences. This locking is process-local' but we also have code to handle file locking." is 158.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The length of the statement  "                    //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did)." is 150.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The length of the statement  "                        // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data." is 203.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The length of the statement  "                            //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else." is 126.
Long Statement,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The length of the statement  "                            //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for " is 123.
Long Statement,ImageResizer.Plugins.DiskCache,CachedFolder,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Index\CachedFolder.cs,setCachedFileInfo,The length of the statement  "                    if (info == null && f == null) return; //If the folder doesn't exist' the file definitely doesn't. Already accomplished." is 120.
Long Statement,ImageResizer.Plugins.DiskCache,CachedFolder,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Index\CachedFolder.cs,getSortedSubfiles,The length of the statement  "                Array.Sort<KeyValuePair<string' CachedFileInfo>>(items' delegate(KeyValuePair<string' CachedFileInfo> a' KeyValuePair<string' CachedFileInfo> b) {" is 146.
Long Statement,ImageResizer.Plugins.DiskCache,CachedFolder,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Index\CachedFolder.cs,populateFiles,The length of the statement  "            Dictionary<string' CachedFileInfo> newFiles = new Dictionary<string' CachedFileInfo>(physicalFiles.Length' KeyComparer);" is 120.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,main,The length of the statement  "                if (lp.Logger != null) lp.Logger.Error("Contact support! A critical (and unexpected) exception occurred in the disk cache cleanup worker thread. This needs to be investigated. {0}"' ex.Message + ex.StackTrace);" is 210.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,main,The length of the statement  "                this.AcceptIssue(new Issue("Contact support! A critical (and unexpected) exception occurred in the disk cache cleanup worker thread. This needs to be investigated. "' ex.Message + ex.StackTrace' IssueSeverity.Critical));" is 220.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The length of the statement  "            string mutexKey = "ir.cachedir:" + cache.PhysicalCachePath.ToLowerInvariant().GetHashCode().ToString("x"' NumberFormatInfo.InvariantInfo);" is 138.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The length of the statement  "                        //In this case' another process (running as another user account) has opened the lock. Eventually it may be garbage collected." is 126.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The length of the statement  "                        else Thread.Sleep(10000); //Otherwise just sleep 10s and check again' waiting for the mutex to be garbage collected so we can recreate it." is 138.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The length of the statement  "                        //Don't flood the system even when it's not busy. 50% usage here. Wait for the length of time worked or the optimal work time' whichever is longer." is 147.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,GetIssues,The length of the statement  "                "This process is not currently managing disk cache cleanup. If configured as a web garden' keep in mind that the negligible performance gains are likely to be outweighed by the loss of cache optimization quality."' IssueSeverity.Warning));" is 239.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,GetIssues,The length of the statement  "                    issues.Add(new Issue("Your cache configuration may not be optimal. If this message persists' you should increase the 'subfolders' value in the <diskcache /> element in Web.config"'" is 180.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,GetIssues,The length of the statement  "                        "In the last 5 minutes' a cache folder exceeded both the optimum and maximum limits for file count. This usually indicates that your 'subfolders' setting is too low' and that cached images are being deleted shortly after their creation. \n" +" is 242.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,GetIssues,The length of the statement  "                        "To estimate the appropriate subfolders value' multiply the total number of images on the site times the average number of size variations' and divide by 400. I.e' 6'400 images with 2 variants would be 32. If in doubt' set the value higher' but ensure there is disk space available."' IssueSeverity.Error));" is 307.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,DoTask,The length of the statement  "            if (lp.Logger != null) lp.Logger.Trace("{2}ms: Executing task {0} {1} ({3} tasks remaining)"' item.Task.ToString()' item.RelativePath' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' queue.Count.ToString(NumberFormatInfo.InvariantInfo));" is 265.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,PopulateFolder,The length of the statement  "                    lp.Logger.Trace("{0}ms: Querying file system about {1}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' item.RelativePath);" is 152.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,PopulateFolder,The length of the statement  "                    childWorkItems.Add(new CleanupWorkItem(CleanupWorkItem.Kind.PopulateFolderRecursive' addSlash(item.RelativePath'false) + n' addSlash(item.PhysicalPath'true) + n));" is 163.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,RemoveFile,The length of the statement  "            item.LazyProvider = provider; //So if this item fails' we can queue 'item' again and the next task run will get the next alternative." is 133.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,CleanFolder,The length of the statement  "                //We could actually make this Populate non-recursive' since the recursive Clean would just insert Populates beforehand anyway." is 126.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,CleanFolder,The length of the statement  "                        new CleanupWorkItem(recursive ? CleanupWorkItem.Kind.PopulateFolderRecursive : CleanupWorkItem.Kind.PopulateFolder'item.RelativePath'item.PhysicalPath)'" is 152.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupWorkItem,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorkItem.cs,Equals,The length of the statement  "            return (other.Task == Task && other.RelativePath == RelativePath && other.PhysicalPath == PhysicalPath && other.LazyProvider == LazyProvider);" is 142.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "            //2013-apr-25: What happens if the file is still being written to disk - it's present but not complete? To handle that' we use mayBeLocked." is 139.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                //May throw an IOException if the file cannot be opened' and is locked by an external processes for longer than timeoutMs. " is 122.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                //Looks like a miss. Let's enter a lock for the creation of the file. This is a different locking system than for writing to the file - far less contention' as it doesn't include the " is 182.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                //Lock execution using relativePath as the sync basis. Ignore casing differences. This prevents duplicate entries in the write queue and wasted CPU/RAM usage." is 158.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //Now' if the item we seek is in the queue' we have a memcached hit. If not' we should check the index. It's possible the item has been written to disk already." is 160.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did)." is 150.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                        //When t == null' and we're inside QueueLocks' all work on the file must be finished' so we have no need to consult mayBeLocked." is 128.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                            MemoryStream ms = new MemoryStream(4096);  //4K initial capacity is minimal' but this array will get copied around a lot' better to underestimate." is 146.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                                    if (!TryWriteFile(null' job.PhysicalPath' job.Key' delegate(Stream s) { ((MemoryStream)job.GetReadonlyStream()).WriteTo(s); }' timeoutMs' true)) {" is 146.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                                            lp.Logger.Warn("Failed to flush async write' timeout exceeded after {1}ms - {0}"'  result.RelativePath' swio.ElapsedMilliseconds);" is 130.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                                            lp.Logger.Trace("{0}ms: Async write started {1}ms after enqueue for {2}"' swio.ElapsedMilliseconds.ToString().PadLeft(4)' DateTime.UtcNow.Subtract(w.JobCreatedAt).Subtract(swio.Elapsed).TotalMilliseconds' result.RelativePath);" is 226.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                                //This is nested inside a queuelock because if we failed here' the next one will also. Better to force it to wait until the file is written to disk." is 148.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The length of the statement  "                lp.Logger.Trace("{0}ms: {3}{1} for {2}' Key: {4}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' result.Result.ToString()' result.RelativePath' asynchronous ? (asyncFailed ? "Fallback to sync writes  " : "AsyncWrites ") : ""' keyBasis);" is 266.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The length of the statement  "            //Lock execution using relativePath as the sync basis. Ignore casing differences. This locking is process-local' but we also have code to handle file locking." is 158.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The length of the statement  "                    //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did)." is 150.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The length of the statement  "                        // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data." is 203.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The length of the statement  "                                //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else." is 126.
Long Statement,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The length of the statement  "                                //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for " is 123.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Install,The length of the statement  "            if (inAsyncMode == null) throw new InvalidOperationException("You must set Config.Current.Pipeline.UsingAsyncMode before installing DiskCache");" is 144.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Start,The length of the statement  "                if (AutoClean) cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);" is 139.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Start,The length of the statement  "                //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ). " is 132.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Process,The length of the statement  "            if (this.AsyncModuleMode) throw new InvalidOperationException("DiskCache cannot be used in synchronous mode if AsyncModuleMode=true");" is 134.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,ProcessAsync,The length of the statement  "            if (!this.AsyncModuleMode) throw new InvalidOperationException("DiskCache cannot be used in asynchronous mode if AsyncModuleMode=false");" is 137.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,ProcessAsync,The length of the statement  "            CacheResult r = await asyncCache.GetCachedFile(e.RequestCachingKey' e.EstimatedFileExtension' async delegate(Stream outStream){" is 127.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,ProcessAsync,The length of the statement  "                throw new ImageResizer.ImageProcessingException("Failed to acquire a lock on file \"" + r.PhysicalPath + "\" within " + CacheAccessTimeout + "ms. Caching failed.");" is 164.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Process,The length of the statement  "            CacheResult r = cache.GetCachedFile(e.RequestKey' e.SuggestedExtension' e.ResizeImageToStream' CacheAccessTimeout'AsyncWrites);" is 127.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,Process,The length of the statement  "                throw new ImageResizer.ImageProcessingException("Failed to acquire a lock on file \"" + r.PhysicalPath + "\" within " + CacheAccessTimeout + "ms. Caching failed.");" is 164.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,HasNTFSPermission,The length of the statement  "                File.WriteAllText(testFile' "You may delete this file - it is written and deleted just to verify permissions are configured correctly");" is 136.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "            if (!c.get("diskcache.hashModifiedDate"' true)) issues.Add(new Issue("DiskCache"' "V4.0 no longer supports hashModifiedDate=false. Please remove this attribute."' IssueSeverity.ConfigurationError));" is 198.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                issues.Add(new Issue("DiskCache"' "Failed to start: Write access to the cache directory is prohibited by your .NET trust level configuration."' " is 143.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                "Please configure your .NET trust level to permit writing to the cache directory. Most medium trust configurations allow this' but yours does not."' IssueSeverity.ConfigurationError));" is 184.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                issues.Add(new Issue("DiskCache"' "Not working: Your NTFS Security permissions are preventing the application from writing to the disk cache"'" is 142.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "    "Please give user " + GetExecutingUser() + " read and write access to directory \"" + PhysicalCacheDir + "\" to correct the problem. You can access NTFS security settings by right-clicking the aforementioned folder and choosing Properties' then Security."' IssueSeverity.ConfigurationError));" is 292.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "            if (!Started && !Enabled) issues.Add(new Issue("DiskCache"' "DiskCache is disabled in Web.config. Set enabled=true on the <diskcache /> element to fix."' null' IssueSeverity.ConfigurationError));" is 195.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                issues.Add(new Issue("DiskCache"' "The asyncBufferSize should not be set below 2 megabytes (2097152). Found in the <diskcache /> element in Web.config."'" is 153.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                    "A buffer that is too small will cause requests to be processed synchronously. Remember to set the value to at least 4x the maximum size of an output image."' IssueSeverity.ConfigurationError));" is 194.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                    "Both IIS and ASP.NET have trouble hosting websites with large numbers of folders over a network drive' such as a SAN. The cache will create " +" is 144.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The length of the statement  "                    Subfolders.ToString() + " subfolders. If the total number of network-hosted folders exceeds 100' you should contact support@imageresizing.net and consult the documentation for details on configuring IIS and ASP.NET for this situation."' IssueSeverity.Warning));" is 261.
Long Statement,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetInfoPairs,The length of the statement  "            list.Add(new KeyValuePair<string' string>("diskcache_drive_avail"' GetCacheDrive()?.AvailableFreeSpace.ToString() ?? ""));" is 122.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,LoadProperty,The length of the statement  "                if (!int.TryParse(value' NumberStyles.Integer' NumberFormatInfo.InvariantInfo' out iValue)) return; //We couldn't parse a value." is 128.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,LoadProperty,The length of the statement  "                if (int.TryParse(value' NumberStyles.Integer' NumberFormatInfo.InvariantInfo' out iValue)) tValue = new TimeSpan(0' 0' iValue);" is 127.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,MeetsCleanupCriteria,The length of the statement  "            return ((now.Subtract(i.AccessedUtc) > AvoidRemovalIfUsedWithin || AvoidRemovalIfUsedWithin <= new TimeSpan(0) || i.AccessedUtc == i.UpdatedUtc) &&" is 147.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,MeetsOverMaxCriteria,The length of the statement  "            return ((now.Subtract(i.AccessedUtc) > ProhibitRemovalIfUsedWithin || ProhibitRemovalIfUsedWithin <= new TimeSpan(0) || i.AccessedUtc == i.UpdatedUtc) &&" is 153.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,GetIssues,The length of the statement  "                    sb.AppendLine(s + " has been changed to " + v.ToString() + " instead of the suggested value' " + defaults[s].ToString());" is 121.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,GetIssues,The length of the statement  "                issues.Add(new Issue( "The cleanup strategy settings have been changed. This is not advised' and may have ill effects. " +" is 122.
Long Statement,ImageResizer.Plugins.DiskCache,CleanupStrategy,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupStrategy.cs,GetIssues,The length of the statement  "                "\nThe default settings for the cleanup strategy were carefully chosen' and should not be changed except at the suggestion of the author.\n" + sb.ToString()' IssueSeverity.Warning));" is 182.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCached,The length of the statement  "            if (this.AsyncModuleMode) throw new InvalidOperationException("SourceDiskCache cannot be used in synchronous mode if AsyncModuleMode=true");" is 140.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCached,The length of the statement  "            string key = original is IVirtualFileSourceCacheKey ? ((IVirtualFileSourceCacheKey)original).GetCacheKey(false) : original.VirtualPath;" is 135.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCachedAsync,The length of the statement  "            if (!this.AsyncModuleMode) throw new InvalidOperationException("SourceDiskCache cannot be used in asynchronous mode if AsyncModuleMode=false");" is 143.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCachedAsync,The length of the statement  "            string key = original is IVirtualFileSourceCacheKey ? ((IVirtualFileSourceCacheKey)original).GetCacheKey(false) : original.VirtualPath;" is 135.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Install,The length of the statement  "            if (inAsyncMode == null) throw new InvalidOperationException("You must set Config.Current.Pipeline.UsingAsyncMode before installing SourceDiskCache");" is 150.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The length of the statement  "                cleaner = new CleanupManager(this' AsyncModuleMode ? (ICleanableCache)asyncCache : (ICleanableCache)cache' cleanupStrategy);" is 124.
Long Statement,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The length of the statement  "                //so we don't eternally 'skip' files in the root or in other unused subfolders (since only 'accessed' subfolders are ever cleaned ). " is 132.
Long Statement,ImageResizer.Plugins.SourceMemCache,EventCountingDictionary<T>,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,Cleanup,The length of the statement  "            if (mode == CleanupMode.MakeRoom && byteCeiling < 1) return true; //We don't perform minimal cleanups unless a ceiling is specified." is 132.
Long Statement,ImageResizer.Plugins.SourceMemCache,EventCountingDictionary<T>,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,Cleanup,The length of the statement  "            //We have to weak lock method-level' because otherwise a background thread could be cleaning when GetOrAdd is called' and we could have a deadlock" is 146.
Long Statement,ImageResizer.Plugins.SourceMemCache,EventCountingDictionary<T>,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,Cleanup,The length of the statement  "                            if (mode == CleanupMode.Maintenance && c.GetValue() > 0) continue; //Skip counters that incremented while we were working." is 122.
Long Statement,ImageResizer.Plugins.SourceMemCache,SourceMemCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,GetFileIfCached,The length of the statement  "            string key = original is IVirtualFileSourceCacheKey ? ((IVirtualFileSourceCacheKey)original).GetCacheKey(true) : original.VirtualPath;" is 134.
Long Statement,ImageResizer.Plugins.SourceMemCache,SourceMemCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,GetFileIfCachedAsync,The length of the statement  "            string key = original is IVirtualFileSourceCacheKey ? ((IVirtualFileSourceCacheKey)original).GetCacheKey(true) : original.VirtualPath;" is 134.
Long Statement,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,Open,The length of the statement  "                else if (originalHash != CaluclateHash()) throw new AccessViolationException("A read-only memory stream was somehow modified.");" is 128.
Long Statement,ImageResizer.Plugins.DiskCache.Cleanup,CleanupQueue,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupQueue.cs,InsertRange,The length of the statement  "                ReverseEnumerable<CleanupWorkItem> reversed = new ReverseEnumerable<CleanupWorkItem>(new System.Collections.ObjectModel.ReadOnlyCollection<CleanupWorkItem>(items));" is 164.
Empty Catch Block,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The method has an empty catch block.
Empty Catch Block,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The method has an empty catch block.
Empty Catch Block,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,FlushAccessedDate,The method has an empty catch block.
Empty Catch Block,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,FlushAccessedDate,The method has an empty catch block.
Empty Catch Block,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The method has an empty catch block.
Empty Catch Block,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The method has an empty catch block.
Magic Number,ImageResizer.Plugins.LicenseVerifier,Computation,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\Computation.cs,GetGracePeriodFor,The following statement contains a magic number: var thirtySeconds = mgr.FirstHeartbeat.Value.AddSeconds(30);
Magic Number,ImageResizer.Plugins.LicenseVerifier,DomainLookup,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\DomainLookup.cs,DomainLookup,The following statement contains a magic number: suffixSearchList = knownDomains.Select(known =>                                            {                                                var d = known.TrimStart('.');                                                d = d.StartsWith("www.") ? d.Substring(4) : d;                                                return new KeyValuePair<string' string>("." + d' known);                                            })                                            .ToList();
Magic Number,ImageResizer.Plugins.LicenseVerifier,DomainLookup,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\DomainLookup.cs,ExplainNormalizations,The following statement contains a magic number: return LookupTableSize > 0                 ? $"The domain lookup table has {LookupTableSize} elements. Displaying {Math.Min(200' LookupTableSize)}:\n" +                    lookupTable.OrderByDescending(p => p.Value)                                                .Take(200)                                                .Select(pair => pair.Key == pair.Value ? pair.Key : $"{pair.Key} => {pair.Value}").Delimited("' ") +                   "\n"                 : "";
Magic Number,ImageResizer.Plugins.LicenseVerifier,DomainLookup,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\DomainLookup.cs,ExplainNormalizations,The following statement contains a magic number: return LookupTableSize > 0                 ? $"The domain lookup table has {LookupTableSize} elements. Displaying {Math.Min(200' LookupTableSize)}:\n" +                    lookupTable.OrderByDescending(p => p.Value)                                                .Take(200)                                                .Select(pair => pair.Key == pair.Value ? pair.Key : $"{pair.Key} => {pair.Value}").Delimited("' ") +                   "\n"                 : "";
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseChain,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseChain.cs,GetLicenseServers,The following statement contains a magic number: return newList.Concat(oldStack.Except(newList)).Take(10).ToArray();
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseChain,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseChain.cs,GetReportPairs,The following statement contains a magic number: var firstHearbeat = (long)(parent.FirstHeartbeat.GetValueOrDefault() -                                         new DateTimeOffset(1970' 1' 1' 0' 0' 0' 0' TimeSpan.Zero)).TotalSeconds;
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseFetcher,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseFetcher.cs,AdjustErrorDebounce,The following statement contains a magic number: error.IntervalTicks += (long) Math.Round(new Random().NextDouble() * clock.TicksPerSecond / 2.0);
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseFetcher,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseFetcher.cs,ConstructQuerystring,The following statement contains a magic number: return query.ToQueryString(7000);
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseManagerSingleton,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseManager.cs,AllowFetching,The following statement contains a magic number: oldestWrite.HasValue && now.Subtract(oldestWrite.Value) < TimeSpan.FromMinutes(60)
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseBlob,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Deserialize,The following statement contains a magic number: parts.Count < 2
Magic Number,ImageResizer.Plugins.LicenseVerifier,LicenseBlob,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Deserialize,The following statement contains a magic number: var dataBytes = Convert.FromBase64String(parts[parts.Count - 2]);
Magic Number,ImageResizer.Plugins.LicenseVerifier,SignatureTestApp,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Main,The following statement contains a magic number: var debug = args.ElementAtOrDefault(2) == "-d";
Magic Number,ImageResizer.Plugins.LicenseVerifier,SignatureTestApp,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Main,The following statement contains a magic number: exitCode = Test_Generic(log) ? 0 : 4;
Magic Number,ImageResizer.Plugins.LicenseVerifier,SignatureTestApp,D:\research\architectureSmells\repos\imazen_resizer\Plugins\LicenseVerifier\LicenseParsing.cs,Main,The following statement contains a magic number: exitCode = 2 ^ exitCode;
Magic Number,ImageResizer.Plugins.DiskCache.Async,AsyncWriteCollection,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Async\AsyncWriteCollection.cs,AsyncWriteCollection,The following statement contains a magic number: MaxQueueBytes = 1024 * 1024 * 10;
Magic Number,ImageResizer.Plugins.DiskCache.Async,AsyncWriteCollection,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Async\AsyncWriteCollection.cs,AsyncWriteCollection,The following statement contains a magic number: MaxQueueBytes = 1024 * 1024 * 10;
Magic Number,ImageResizer.Plugins.DiskCache.Async,AsyncWriteCollection,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Async\AsyncWriteCollection.cs,AsyncWriteCollection,The following statement contains a magic number: MaxQueueBytes = 1024 * 1024 * 10;
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,GetCachedFile,The following statement contains a magic number: lp.Logger.Trace("{0}ms: {3}{1} for {2}' Key: {4}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' result.Result.ToString()' result.RelativePath' asynchronous ? (asyncFailed ? "AsyncHttpMode' fell back to sync write  " : "AsyncHttpMode+AsyncWrites ") : "AsyncHttpMode"' keyBasis);
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The following statement contains a magic number: return await ((AsyncLockProvider)Locks).TryExecuteAsync(relativePath.ToUpperInvariant()' timeoutMs'                 async delegate() {                      //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                     if (!Index.exists(relativePath' physicalPath)) {                          //Create subdirectory if needed.                         if (!Directory.Exists(Path.GetDirectoryName(physicalPath))) {                             Directory.CreateDirectory(Path.GetDirectoryName(physicalPath));                             if (lp.Logger != null) lp.Logger.Debug("Creating missing parent directory {0}"' Path.GetDirectoryName(physicalPath));                         }                          //Open stream                          //Catch IOException' and if it is a file lock'                         // - (and hashmodified is true)' then it's another process writing to the file' and we can serve the file afterwards                         // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data.                         // I.e' hashmodified=true is the only supported setting for multi-process environments.                         //TODO: Catch UnathorizedAccessException and log issue about file permissions.                         //... If we can wait for a read handle for a specified timeout.                          IOException locked_exception = null;                          try                         {                             string tempFile = physicalPath + ".tmp_" + new Random().Next(int.MaxValue).ToString("x") + ".tmp";                              System.IO.FileStream fs = new FileStream(tempFile' FileMode.Create' FileAccess.Write' FileShare.None);                             bool finished = false;                             try                             {                                 using (fs)                                 {                                     //Run callback to write the cached data                                     await writeCallback(fs); //Can throw any number of exceptions.                                     await fs.FlushAsync();                                     fs.Flush(true);                                     finished = true;                                 }                             }                             finally                             {                                 //Don't leave half-written files around.                                 if (!finished)                                 {                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             bool moved = false;                             if (finished)                             {                                 try                                 {                                     File.Move(tempFile' physicalPath);                                     moved = true;                                 }                                 catch (IOException)                                 {                                     //Will throw IO exception if already exists. Which we consider a hit' so we delete the tempFile                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             if (moved)                             {                                 DateTime createdUtc = DateTime.UtcNow;                                 //Set the created date' so we know the last time we updated the cache.s                                 System.IO.File.SetCreationTimeUtc(physicalPath' createdUtc);                                 //Update index                                 //TODO: what should sourceModifiedUtc be when there is no modified date?                                 Index.setCachedFileInfo(relativePath' new CachedFileInfo(createdUtc' createdUtc' createdUtc));                                 //This was a cache miss                                 if (result != null) result.Result = CacheQueryResult.Miss;                             }                         }                         catch (IOException ex)                         {                              if (IsFileLocked(ex)) locked_exception = ex;                              else throw;                         }                         if (locked_exception != null)                         {                             //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else.                             //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for                              //reading within timeoutMs' simply do nothing and let the file be returned as a hit.                             Stopwatch waitForFile = new Stopwatch();                             bool opened = false;                             while (!opened && waitForFile.ElapsedMilliseconds < timeoutMs)                             {                                 waitForFile.Start();                                 bool waitABitMore = false;                                 try                                 {                                     using (FileStream temp = new FileStream(physicalPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                                         opened = true;                                 }                                 catch (IOException iex)                                 {                                     if (IsFileLocked(iex))                                         waitABitMore = true;                                      else throw iex;                                 }                                 if (waitABitMore) { await Task.Delay((int)Math.Min(30' Math.Round((float)timeoutMs / 3.0))); }                                 waitForFile.Stop();                             }                             if (!opened) throw locked_exception; //By not throwing an exception' it is considered a hit by the rest of the code.                          }                       }                 });
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,TryWriteFile,The following statement contains a magic number: return await ((AsyncLockProvider)Locks).TryExecuteAsync(relativePath.ToUpperInvariant()' timeoutMs'                 async delegate() {                      //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                     if (!Index.exists(relativePath' physicalPath)) {                          //Create subdirectory if needed.                         if (!Directory.Exists(Path.GetDirectoryName(physicalPath))) {                             Directory.CreateDirectory(Path.GetDirectoryName(physicalPath));                             if (lp.Logger != null) lp.Logger.Debug("Creating missing parent directory {0}"' Path.GetDirectoryName(physicalPath));                         }                          //Open stream                          //Catch IOException' and if it is a file lock'                         // - (and hashmodified is true)' then it's another process writing to the file' and we can serve the file afterwards                         // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data.                         // I.e' hashmodified=true is the only supported setting for multi-process environments.                         //TODO: Catch UnathorizedAccessException and log issue about file permissions.                         //... If we can wait for a read handle for a specified timeout.                          IOException locked_exception = null;                          try                         {                             string tempFile = physicalPath + ".tmp_" + new Random().Next(int.MaxValue).ToString("x") + ".tmp";                              System.IO.FileStream fs = new FileStream(tempFile' FileMode.Create' FileAccess.Write' FileShare.None);                             bool finished = false;                             try                             {                                 using (fs)                                 {                                     //Run callback to write the cached data                                     await writeCallback(fs); //Can throw any number of exceptions.                                     await fs.FlushAsync();                                     fs.Flush(true);                                     finished = true;                                 }                             }                             finally                             {                                 //Don't leave half-written files around.                                 if (!finished)                                 {                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             bool moved = false;                             if (finished)                             {                                 try                                 {                                     File.Move(tempFile' physicalPath);                                     moved = true;                                 }                                 catch (IOException)                                 {                                     //Will throw IO exception if already exists. Which we consider a hit' so we delete the tempFile                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             if (moved)                             {                                 DateTime createdUtc = DateTime.UtcNow;                                 //Set the created date' so we know the last time we updated the cache.s                                 System.IO.File.SetCreationTimeUtc(physicalPath' createdUtc);                                 //Update index                                 //TODO: what should sourceModifiedUtc be when there is no modified date?                                 Index.setCachedFileInfo(relativePath' new CachedFileInfo(createdUtc' createdUtc' createdUtc));                                 //This was a cache miss                                 if (result != null) result.Result = CacheQueryResult.Miss;                             }                         }                         catch (IOException ex)                         {                              if (IsFileLocked(ex)) locked_exception = ex;                              else throw;                         }                         if (locked_exception != null)                         {                             //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else.                             //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for                              //reading within timeoutMs' simply do nothing and let the file be returned as a hit.                             Stopwatch waitForFile = new Stopwatch();                             bool opened = false;                             while (!opened && waitForFile.ElapsedMilliseconds < timeoutMs)                             {                                 waitForFile.Start();                                 bool waitABitMore = false;                                 try                                 {                                     using (FileStream temp = new FileStream(physicalPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                                         opened = true;                                 }                                 catch (IOException iex)                                 {                                     if (IsFileLocked(iex))                                         waitABitMore = true;                                      else throw iex;                                 }                                 if (waitABitMore) { await Task.Delay((int)Math.Min(30' Math.Round((float)timeoutMs / 3.0))); }                                 waitForFile.Stop();                             }                             if (!opened) throw locked_exception; //By not throwing an exception' it is considered a hit by the rest of the code.                          }                       }                 });
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: int errorCode = System.Runtime.InteropServices.Marshal.GetHRForException(exception) & ((1 << 16) - 1);
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: return errorCode == 32 || errorCode == 33;
Magic Number,ImageResizer.Plugins.DiskCache,AsyncCustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\AsyncCustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: return errorCode == 32 || errorCode == 33;
Magic Number,ImageResizer.Plugins.DiskCache,CachedFolder,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Index\CachedFolder.cs,roughCompare,The following statement contains a magic number: return Math.Abs(d1.Ticks - d2.Ticks) < TimeSpan.TicksPerMillisecond * 5;
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,mainInner,The following statement contains a magic number: hasLock = cleanupLock.WaitOne(30000);
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,GetIssues,The following statement contains a magic number: this.lastFoundItemsOverMax > (DateTime.UtcNow.Subtract(new TimeSpan(0' 5' 0)).Ticks)
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,DoTask,The following statement contains a magic number: lp.Logger.Trace("{2}ms: Executing task {0} {1} ({3} tasks remaining)"' item.Task.ToString()' item.RelativePath' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' queue.Count.ToString(NumberFormatInfo.InvariantInfo));
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,PopulateFolder,The following statement contains a magic number: lp.Logger.Trace("{0}ms: Querying file system about {1}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' item.RelativePath);
Magic Number,ImageResizer.Plugins.DiskCache,CleanupWorker,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\Cleanup\CleanupWorker.cs,RemoveFile,The following statement contains a magic number: cache.Locks.TryExecute(item.RelativePath' 10' delegate() {                  //If the file is already gone' consider the mission a success.                 if (!System.IO.File.Exists(item.PhysicalPath)) {                     cache.Index.setCachedFileInfo(item.RelativePath' null);                     removedFile = true;                     return;                 }                 //Cool' we got a lock on the file.                 //Remove it from the cache. Better a miss than an invalidation.                 cache.Index.setCachedFileInfo(item.RelativePath' null);                 try {                     System.IO.File.Delete(item.PhysicalPath);                 } catch (IOException) {                     return; //The file is in use' or has an open handle. - try the next file.                 } catch (UnauthorizedAccessException) {                     return; //Invalid NTFS permissions or readonly file.  - try the next file                 }                  cache.Index.setCachedFileInfo(item.RelativePath' null); //In case it crossed paths.                 removedFile = true;             });
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,GetCachedFile,The following statement contains a magic number: lp.Logger.Trace("{0}ms: {3}{1} for {2}' Key: {4}"' sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4)' result.Result.ToString()' result.RelativePath' asynchronous ? (asyncFailed ? "Fallback to sync writes  " : "AsyncWrites ") : ""' keyBasis);
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The following statement contains a magic number: return Locks.TryExecute(relativePath.ToUpperInvariant()' timeoutMs'                 delegate() {                      //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                     if (!Index.exists(relativePath' physicalPath)) {                          //Create subdirectory if needed.                         if (!Directory.Exists(Path.GetDirectoryName(physicalPath))) {                             Directory.CreateDirectory(Path.GetDirectoryName(physicalPath));                             if (lp.Logger != null) lp.Logger.Debug("Creating missing parent directory {0}"' Path.GetDirectoryName(physicalPath));                         }                          //Open stream                          //Catch IOException' and if it is a file lock'                         // - (and hashmodified is true)' then it's another process writing to the file' and we can serve the file afterwards                         // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data.                         // I.e' hashmodified=true is the only supported setting for multi-process environments.                         //TODO: Catch UnathorizedAccessException and log issue about file permissions.                         //... If we can wait for a read handle for a specified timeout.                          try                         {                             string tempFile = physicalPath + ".tmp_" + new Random().Next(int.MaxValue).ToString("x") + ".tmp";                              System.IO.FileStream fs = new FileStream(tempFile' FileMode.Create' FileAccess.Write' FileShare.None);                             bool finished = false;                             try                             {                                 using (fs)                                 {                                     //Run callback to write the cached data                                     writeCallback(fs); //Can throw any number of exceptions.                                     fs.Flush(true);                                     finished = true;                                 }                             }                             finally                             {                                 //Don't leave half-written files around.                                 if (!finished)                                 {                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             bool moved = false;                             if (finished)                             {                                 try                                 {                                     File.Move(tempFile' physicalPath);                                     moved = true;                                 }                                 catch (IOException)                                 {                                     //Will throw IO exception if already exists. Which we consider a hit' so we delete the tempFile                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             if (moved)                             {                                 DateTime createdUtc = DateTime.UtcNow;                                 //Set the created date' so we know the last time we updated the cache.s                                 System.IO.File.SetCreationTimeUtc(physicalPath' createdUtc);                                 //Update index                                 //TODO: what should sourceModifiedUtc be when there is no modified date?                                 Index.setCachedFileInfo(relativePath' new CachedFileInfo(createdUtc' createdUtc' createdUtc));                                 //This was a cache miss                                 if (result != null) result.Result = CacheQueryResult.Miss;                             }                         }                         catch (IOException ex)                         {                              if (IsFileLocked(ex)) {                                 //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else.                                 //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for                                  //reading within timeoutMs' simply do nothing and let the file be returned as a hit.                                 Stopwatch waitForFile = new Stopwatch();                                 bool opened = false;                                 while (!opened && waitForFile.ElapsedMilliseconds < timeoutMs) {                                     waitForFile.Start();                                     try {                                         using (FileStream temp = new FileStream(physicalPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                                             opened = true;                                     } catch (IOException iex) {                                         if (IsFileLocked(iex))                                             Thread.Sleep((int)Math.Min(30' Math.Round((float)timeoutMs / 3.0)));                                         else throw iex;                                     }                                     waitForFile.Stop();                                 }                                 if (!opened) throw; //By not throwing an exception' it is considered a hit by the rest of the code.                              } else throw;                         }                      }                 });
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,TryWriteFile,The following statement contains a magic number: return Locks.TryExecute(relativePath.ToUpperInvariant()' timeoutMs'                 delegate() {                      //On the second check' use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).                     if (!Index.exists(relativePath' physicalPath)) {                          //Create subdirectory if needed.                         if (!Directory.Exists(Path.GetDirectoryName(physicalPath))) {                             Directory.CreateDirectory(Path.GetDirectoryName(physicalPath));                             if (lp.Logger != null) lp.Logger.Debug("Creating missing parent directory {0}"' Path.GetDirectoryName(physicalPath));                         }                          //Open stream                          //Catch IOException' and if it is a file lock'                         // - (and hashmodified is true)' then it's another process writing to the file' and we can serve the file afterwards                         // - (and hashmodified is false)' then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here' as we can't guarantee accurate image data.                         // I.e' hashmodified=true is the only supported setting for multi-process environments.                         //TODO: Catch UnathorizedAccessException and log issue about file permissions.                         //... If we can wait for a read handle for a specified timeout.                          try                         {                             string tempFile = physicalPath + ".tmp_" + new Random().Next(int.MaxValue).ToString("x") + ".tmp";                              System.IO.FileStream fs = new FileStream(tempFile' FileMode.Create' FileAccess.Write' FileShare.None);                             bool finished = false;                             try                             {                                 using (fs)                                 {                                     //Run callback to write the cached data                                     writeCallback(fs); //Can throw any number of exceptions.                                     fs.Flush(true);                                     finished = true;                                 }                             }                             finally                             {                                 //Don't leave half-written files around.                                 if (!finished)                                 {                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             bool moved = false;                             if (finished)                             {                                 try                                 {                                     File.Move(tempFile' physicalPath);                                     moved = true;                                 }                                 catch (IOException)                                 {                                     //Will throw IO exception if already exists. Which we consider a hit' so we delete the tempFile                                     try { if (File.Exists(tempFile)) File.Delete(tempFile); }                                     catch { }                                 }                             }                             if (moved)                             {                                 DateTime createdUtc = DateTime.UtcNow;                                 //Set the created date' so we know the last time we updated the cache.s                                 System.IO.File.SetCreationTimeUtc(physicalPath' createdUtc);                                 //Update index                                 //TODO: what should sourceModifiedUtc be when there is no modified date?                                 Index.setCachedFileInfo(relativePath' new CachedFileInfo(createdUtc' createdUtc' createdUtc));                                 //This was a cache miss                                 if (result != null) result.Result = CacheQueryResult.Miss;                             }                         }                         catch (IOException ex)                         {                              if (IsFileLocked(ex)) {                                 //Somehow in between verifying the file didn't exist and trying to create it' the file was created and locked by someone else.                                 //When hashModifiedDate==true' we don't care what the file contains' we just want it to exist. If the file is available for                                  //reading within timeoutMs' simply do nothing and let the file be returned as a hit.                                 Stopwatch waitForFile = new Stopwatch();                                 bool opened = false;                                 while (!opened && waitForFile.ElapsedMilliseconds < timeoutMs) {                                     waitForFile.Start();                                     try {                                         using (FileStream temp = new FileStream(physicalPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                                             opened = true;                                     } catch (IOException iex) {                                         if (IsFileLocked(iex))                                             Thread.Sleep((int)Math.Min(30' Math.Round((float)timeoutMs / 3.0)));                                         else throw iex;                                     }                                     waitForFile.Stop();                                 }                                 if (!opened) throw; //By not throwing an exception' it is considered a hit by the rest of the code.                              } else throw;                         }                      }                 });
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: int errorCode = System.Runtime.InteropServices.Marshal.GetHRForException(exception) & ((1 << 16) - 1);
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: return errorCode == 32 || errorCode == 33;
Magic Number,ImageResizer.Plugins.DiskCache,CustomDiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\CustomDiskCache.cs,IsFileLocked,The following statement contains a magic number: return errorCode == 32 || errorCode == 33;
Magic Number,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The following statement contains a magic number: this.AsyncBufferSize < 1024 * 1024 * 2
Magic Number,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The following statement contains a magic number: this.AsyncBufferSize < 1024 * 1024 * 2
Magic Number,ImageResizer.Plugins.DiskCache,DiskCache,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\DiskCache.cs,GetIssues,The following statement contains a magic number: this.AsyncBufferSize < 1024 * 1024 * 2
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,getSubfolder,The following statement contains a magic number: int bits = (int)Math.Ceiling(Math.Log(subfolders' 2));
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,getSubfolder,The following statement contains a magic number: Debug.Assert(bits <= hash.Length * 8);
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,getSubfolder,The following statement contains a magic number: byte[] subfolder = new byte[(int)Math.Ceiling((double)bits / 8.0)];
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,getSubfolder,The following statement contains a magic number: subfolder[0] = (byte)((int)subfolder[0] >> ((subfolder.Length * 8) - bits));
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,Base16Encode,The following statement contains a magic number: StringBuilder sb = new StringBuilder(bytes.Length * 2);
Magic Number,ImageResizer.Plugins.DiskCache,UrlHasher,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\UrlHasher.cs,Base16Encode,The following statement contains a magic number: sb.Append(b.ToString("x"' NumberFormatInfo.InvariantInfo).PadLeft(2' '0'));
Magic Number,ImageResizer.Plugins.DiskCache,WebConfigWriter,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\WebConfigWriter.cs,CheckWebConfigEvery5,The following statement contains a magic number: _lastCheckedWebConfig < DateTime.UtcNow.Subtract(new TimeSpan(0' 5' 0))
Magic Number,ImageResizer.Plugins.DiskCache,WebConfigWriter,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\WebConfigWriter.cs,CheckWebConfigEvery5,The following statement contains a magic number: _lastCheckedWebConfig < DateTime.UtcNow.Subtract(new TimeSpan(0' 5' 0))
Magic Number,ImageResizer.Plugins.MemCache,MemCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\OutputMemCache\MemCache.cs,MemCachePlugin,The following statement contains a magic number: cache = new ConstrainedCache<string' MemCacheResult>(StringComparer.OrdinalIgnoreCase' delegate(string key' MemCacheResult file) {                 return key.Length * 4 + file.BytesOccupied;             }' maxBytes' usageWindow' new TimeSpan(0' 1' 0));
Magic Number,ImageResizer.Plugins.MemCache,MemCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\OutputMemCache\MemCache.cs,Process,The following statement contains a magic number: locks.TryExecute(key' 3000' delegate() {                 c = cache.Get(key);                 if (c == null) {                     using (var data = new MemoryStream()){                         e.ResizeImageToStream(data);//Very long-running call                         c = new MemCacheResult(data.CopyToBytes(true));                     }                     cache.Set(key' c);//Save to cache (may trigger cleanup)                 }                 Serve(current' e' c);                 return;             });
Magic Number,ImageResizer.Plugins.MemCache,MemCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\OutputMemCache\MemCache.cs,ProcessAsync,The following statement contains a magic number: return asyncLocks.TryExecuteAsync(key' 3000' async delegate()             {                 c = cache.Get(key);                 if (c == null)                 {                     using (var data = new MemoryStream(4096))                     {                         await e.CreateAndWriteResultAsync(data'e);//Very long-running call                         c = new MemCacheResult(data.CopyToBytes(true));                     }                     cache.Set(key' c);//Save to cache (may trigger cleanup)                 }                 Serve(current' e' c);                 return;             });
Magic Number,ImageResizer.Plugins.MemCache,MemCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\OutputMemCache\MemCache.cs,ProcessAsync,The following statement contains a magic number: return asyncLocks.TryExecuteAsync(key' 3000' async delegate()             {                 c = cache.Get(key);                 if (c == null)                 {                     using (var data = new MemoryStream(4096))                     {                         await e.CreateAndWriteResultAsync(data'e);//Very long-running call                         c = new MemCacheResult(data.CopyToBytes(true));                     }                     cache.Set(key' c);//Save to cache (may trigger cleanup)                 }                 Serve(current' e' c);                 return;             });
Magic Number,ImageResizer.Plugins.MemCache,MemCacheHandler,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\OutputMemCache\MemCacheHandler.cs,ProcessRequestAsync,The following statement contains a magic number: context.Response.StatusCode = 200;
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCached,The following statement contains a magic number: var r = cache.GetCachedFile(key' ".cache"' delegate(Stream target)              {                  using (Stream data = original.Open())                  {//Very long-running call                      data.CopyToStream(target);                  }              }' 15 * 1000' true);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCached,The following statement contains a magic number: var r = cache.GetCachedFile(key' ".cache"' delegate(Stream target)              {                  using (Stream data = original.Open())                  {//Very long-running call                      data.CopyToStream(target);                  }              }' 15 * 1000' true);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCachedAsync,The following statement contains a magic number: var r = await asyncCache.GetCachedFile(key' ".cache"' async delegate(Stream target)             {                 using (Stream data = await original.OpenAsync())                 {//Very long-running call                     await data.CopyToAsync(target);                 }             }' 15 * 1000' true);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,GetFileIfCachedAsync,The following statement contains a magic number: var r = await asyncCache.GetCachedFile(key' ".cache"' async delegate(Stream target)             {                 using (Stream data = await original.OpenAsync())                 {//Very long-running call                     await data.CopyToAsync(target);                 }             }' 15 * 1000' true);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: cache = new CustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: asyncCache = new AsyncCustomDiskCache(this' PhysicalCacheDir' 4096' 1024 * 1024 * 30);
Magic Number,ImageResizer.Plugins.SourceDiskCache,SourceDiskCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceDiskCache\SourceDiskCache.cs,Start,The following statement contains a magic number: cleanupStrategy.TargetItemsPerFolder = 50;
Magic Number,ImageResizer.Plugins.SourceMemCache,ConstrainedCache<K;V>,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\ConstrainedCache.cs,ConstrainedCache,The following statement contains a magic number: s.CounterGranularity = 16;
Magic Number,ImageResizer.Plugins.SourceMemCache,ConstrainedCache<K;V>,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\ConstrainedCache.cs,Set,The following statement contains a magic number: usage.Increment(key' calculator(key' val) + 32);
Magic Number,ImageResizer.Plugins.SourceMemCache,EventCountingStrategy,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,EventCountingStrategy,The following statement contains a magic number: CounterGranularity = 8;
Magic Number,ImageResizer.Plugins.SourceMemCache,EventCountingStrategy,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,EventCountingStrategy,The following statement contains a magic number: MinimumCleanupInterval = new TimeSpan(0' 0' 20);
Magic Number,ImageResizer.Plugins.SourceMemCache,EventCountingDictionary<T>,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\EventCountingDictionary.cs,Cleanup,The following statement contains a magic number: long goal = byteCeiling / 10;
Magic Number,ImageResizer.Plugins.SourceMemCache,SourceMemCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,SourceMemCachePlugin,The following statement contains a magic number: cache = new ConstrainedCache<string' CachedVirtualFile>(StringComparer.OrdinalIgnoreCase' delegate(string key' CachedVirtualFile file) {                 return key.Length * 4 + file.BytesOccupied;             }' maxBytes' usageWindow' new TimeSpan(0' 1' 0));
Magic Number,ImageResizer.Plugins.SourceMemCache,SourceMemCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,GetFileIfCached,The following statement contains a magic number: locks.TryExecute(key' 3000' delegate() {                     c = cache.Get(key);                     if (c == null) {                         using (Stream data = original.Open()) {//Very long-running call                             c = new CachedVirtualFile(original.VirtualPath' data.CopyToBytes(true));                         }                         cache.Set(key' c);//Save to cache (may trigger cleanup)                     }                 });
Magic Number,ImageResizer.Plugins.SourceMemCache,SourceMemCachePlugin,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,GetFileIfCachedAsync,The following statement contains a magic number: await asyncLocks.TryExecuteAsync(key' 3000' async delegate()                 {                     c = cache.Get(key);                     if (c == null)                     {                         using (Stream data = await original.OpenAsync())                         {//Very long-running call                             c = new CachedVirtualFile(original.VirtualPath' await data.CopyToBytesAsync(true' 0x1000));                         }                         cache.Set(key' c);//Save to cache (may trigger cleanup)                     }                 });
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: const int p = 16777619;
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: int hash = (int)2166136261;
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: hash += hash << 13;
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: hash ^= hash >> 7;
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: hash += hash << 3;
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: hash ^= hash >> 17;
Magic Number,ImageResizer.Plugins.SourceMemCache,CachedVirtualFile,D:\research\architectureSmells\repos\imazen_resizer\Plugins\DiskCache\SourceMemCache\SourceMemCache.cs,CaluclateHash,The following statement contains a magic number: hash += hash << 5;
