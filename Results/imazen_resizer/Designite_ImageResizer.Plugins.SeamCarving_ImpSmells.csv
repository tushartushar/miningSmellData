Implementation smell,Namespace,Class,File,Method,Description
Long Method,ImageResizer.Plugins.SeamCarving,CairManager,C:\repos\imazen_resizer\Plugins\SeamCarving\CairManager.cs,CairyIt,The method has 103 lines of code.
Long Method,ImageResizer.Plugins.SeamCarving,SeamCarvingPlugin,C:\repos\imazen_resizer\Plugins\SeamCarving\SeamCarvingPlugin.cs,PreRenderImage,The method has 109 lines of code.
Long Method,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,Code,The method has 116 lines of code.
Long Method,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The method has 489 lines of code.
Long Method,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 166 lines of code.
Long Method,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The method has 103 lines of code.
Long Method,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,The method has 132 lines of code.
Complex Method,ImageResizer.Plugins.SeamCarving,CarveDataPlotter,C:\repos\imazen_resizer\Plugins\SeamCarving\CarveDataPlotter.cs,GetRemovalSpace,Cyclomatic complexity of the method is 9
Complex Method,ImageResizer.Plugins.SeamCarving,SeamCarvingPlugin,C:\repos\imazen_resizer\Plugins\SeamCarving\SeamCarvingPlugin.cs,PreRenderImage,Cyclomatic complexity of the method is 11
Complex Method,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 58
Complex Method,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 15
Complex Method,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 21
Long Parameter List,SevenZipReduced,ICoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZipReduced.Compression.RangeCoder,BitTreeEncoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Identifier,SevenZipReduced.Compression.LZMA,Base,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,ImageResizer.Plugins.SeamCarving,CarveDataPlotter,C:\repos\imazen_resizer\Plugins\SeamCarving\CarveDataPlotter.cs,SaveBitmapAs,The length of the statement  "                                g.FillRectangle(b' new Rectangle(x * block' y * block' block + Math.Min(0' width - (x + 1) * block)' block + Math.Min(0' height - (y + 1) * block)));" is 149.
Long Statement,ImageResizer.Plugins.SeamCarving,CairManager,C:\repos\imazen_resizer\Plugins\SeamCarving\CairManager.cs,GetCair,The length of the statement  "                string cairDir = HttpContext.Current == null ? Path.Combine(Path.GetTempPath()' Path.GetRandomFileName()) : HostingEnvironment.MapPath("~/App_Data/cair/");" is 155.
Long Statement,ImageResizer.Plugins.SeamCarving,CairManager,C:\repos\imazen_resizer\Plugins\SeamCarving\CairManager.cs,GetCair,The length of the statement  "                using (Stream input = Assembly.GetExecutingAssembly().GetManifestResourceStream("ImageResizer.Plugins.SeamCarving.pthreadVSE2.dll"))" is 132.
Long Statement,ImageResizer.Plugins.SeamCarving,CairManager,C:\repos\imazen_resizer\Plugins\SeamCarving\CairManager.cs,GetCair,The length of the statement  "                using (Stream input = Assembly.GetExecutingAssembly().GetManifestResourceStream("ImageResizer.Plugins.SeamCarving.CAIR.exe"))" is 125.
Long Statement,ImageResizer.Plugins.SeamCarving,CairManager,C:\repos\imazen_resizer\Plugins\SeamCarving\CairManager.cs,CairyIt,The length of the statement  "                throw new ImageProcessingException("Content-aware image processing failed - too many threads waiting. Try again later.");" is 121.
Long Statement,ImageResizer.Plugins.SeamCarving,CairManager,C:\repos\imazen_resizer\Plugins\SeamCarving\CairManager.cs,CairyIt,The length of the statement  "            //If there are any threads waiting in line' or if the permitted number of CAIR.exe instances has been reached' get in line" is 122.
Long Statement,ImageResizer.Plugins.SeamCarving,SeamCarvingPlugin,C:\repos\imazen_resizer\Plugins\SeamCarving\SeamCarvingPlugin.cs,PreRenderImage,The length of the statement  "                    if (s.preRenderBitmap != null && (tempWidth - s.preRenderBitmap.Width < 50 && tempHeight - s.preRenderBitmap.Height < 50)) {" is 124.
Long Statement,ImageResizer.Plugins.SeamCarving,SeamCarvingPlugin,C:\repos\imazen_resizer\Plugins\SeamCarving\SeamCarvingPlugin.cs,PreRenderImage,The length of the statement  "                                g.DrawImage(s.preRenderBitmap' new Rectangle(0' 0' tempWidth' tempHeight)' 0' 0' s.preRenderBitmap.Width' s.preRenderBitmap.Height' GraphicsUnit.Pixel' ia);" is 156.
Long Statement,ImageResizer.Plugins.SeamCarving,SeamCarvingPlugin,C:\repos\imazen_resizer\Plugins\SeamCarving\SeamCarvingPlugin.cs,PreRenderImage,The length of the statement  "                                g.DrawImage(s.sourceBitmap' new Rectangle(0' 0' tempWidth' tempHeight)' copyRect.X' copyRect.Y' copyRect.Width' copyRect.Height' GraphicsUnit.Pixel' ia);" is 153.
Long Statement,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "                            UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();" is 126.
Long Statement,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "                                    UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();" is 126.
Long Statement,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "                    _posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits);" is 125.
Magic Number,ImageResizer.Plugins.SeamCarving,CairJob,C:\repos\imazen_resizer\Plugins\SeamCarving\CairJob.cs,CairJob,The following statement contains a magic number: Timeout = 5000;
Magic Number,ImageResizer.Plugins.SeamCarving,CarveDataPlotter,C:\repos\imazen_resizer\Plugins\SeamCarving\CarveDataPlotter.cs,Init,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {                 byte v = (byte)(data[i] == '0' ? 0 : (data[i] == '1' ? 1 : (data[i] == '2' ? 2 : 3)));                 if (v == 3) throw new ArgumentOutOfRangeException("data"' "Invalid character '" + data[i] + "' at index " + i);                 Grid[i / Stride][i % Stride] = v;             }
Magic Number,ImageResizer.Plugins.SeamCarving,CarveDataPlotter,C:\repos\imazen_resizer\Plugins\SeamCarving\CarveDataPlotter.cs,Init,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {                 byte v = (byte)(data[i] == '0' ? 0 : (data[i] == '1' ? 1 : (data[i] == '2' ? 2 : 3)));                 if (v == 3) throw new ArgumentOutOfRangeException("data"' "Invalid character '" + data[i] + "' at index " + i);                 Grid[i / Stride][i % Stride] = v;             }
Magic Number,ImageResizer.Plugins.SeamCarving,CarveDataPlotter,C:\repos\imazen_resizer\Plugins\SeamCarving\CarveDataPlotter.cs,Init,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {                 byte v = (byte)(data[i] == '0' ? 0 : (data[i] == '1' ? 1 : (data[i] == '2' ? 2 : 3)));                 if (v == 3) throw new ArgumentOutOfRangeException("data"' "Invalid character '" + data[i] + "' at index " + i);                 Grid[i / Stride][i % Stride] = v;             }
Magic Number,ImageResizer.Plugins.SeamCarving,CarveDataPlotter,C:\repos\imazen_resizer\Plugins\SeamCarving\CarveDataPlotter.cs,SaveBitmapAs,The following statement contains a magic number: using (Bitmap bit = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb))             using (Graphics g = Graphics.FromImage(bit))             using (Brush keep = new SolidBrush(Color.FromArgb(255'Color.Green)))             using (Brush remove = new SolidBrush(Color.FromArgb(255'Color.Red))) {                 g.Clear(Color.Black);                 byte[][] gr = Grid;                 int block = blockSize;                 for (int y = 0; y < Rows; y++) {                     for (int x = 0; x < Stride; x++) {                         Brush b = (gr[y][x] == 1) ? keep : ((gr[y][x] == 2) ? remove : null);                         if (b != null){                             if ( y < Rows -1 && x < Stride -1)                                 g.FillRectangle(b' new Rectangle(x * block' y * block' block' block));                             else                                 g.FillRectangle(b' new Rectangle(x * block' y * block' block + Math.Min(0' width - (x + 1) * block)' block + Math.Min(0' height - (y + 1) * block)));                         }                     }                 }                  g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                                  bit.Save(path' ImageFormat.Bmp);             }
Magic Number,ImageResizer.Plugins.SeamCarving,CarveDataPlotter,C:\repos\imazen_resizer\Plugins\SeamCarving\CarveDataPlotter.cs,SaveBitmapAs,The following statement contains a magic number: using (Bitmap bit = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb))             using (Graphics g = Graphics.FromImage(bit))             using (Brush keep = new SolidBrush(Color.FromArgb(255'Color.Green)))             using (Brush remove = new SolidBrush(Color.FromArgb(255'Color.Red))) {                 g.Clear(Color.Black);                 byte[][] gr = Grid;                 int block = blockSize;                 for (int y = 0; y < Rows; y++) {                     for (int x = 0; x < Stride; x++) {                         Brush b = (gr[y][x] == 1) ? keep : ((gr[y][x] == 2) ? remove : null);                         if (b != null){                             if ( y < Rows -1 && x < Stride -1)                                 g.FillRectangle(b' new Rectangle(x * block' y * block' block' block));                             else                                 g.FillRectangle(b' new Rectangle(x * block' y * block' block + Math.Min(0' width - (x + 1) * block)' block + Math.Min(0' height - (y + 1) * block)));                         }                     }                 }                  g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                                  bit.Save(path' ImageFormat.Bmp);             }
Magic Number,ImageResizer.Plugins.SeamCarving,CarveDataPlotter,C:\repos\imazen_resizer\Plugins\SeamCarving\CarveDataPlotter.cs,SaveBitmapAs,The following statement contains a magic number: using (Bitmap bit = new Bitmap(width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb))             using (Graphics g = Graphics.FromImage(bit))             using (Brush keep = new SolidBrush(Color.FromArgb(255'Color.Green)))             using (Brush remove = new SolidBrush(Color.FromArgb(255'Color.Red))) {                 g.Clear(Color.Black);                 byte[][] gr = Grid;                 int block = blockSize;                 for (int y = 0; y < Rows; y++) {                     for (int x = 0; x < Stride; x++) {                         Brush b = (gr[y][x] == 1) ? keep : ((gr[y][x] == 2) ? remove : null);                         if (b != null){                             if ( y < Rows -1 && x < Stride -1)                                 g.FillRectangle(b' new Rectangle(x * block' y * block' block' block));                             else                                 g.FillRectangle(b' new Rectangle(x * block' y * block' block + Math.Min(0' width - (x + 1) * block)' block + Math.Min(0' height - (y + 1) * block)));                         }                     }                 }                  g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                                  bit.Save(path' ImageFormat.Bmp);             }
Magic Number,ImageResizer.Plugins.SeamCarving,CarveDataPlotter,C:\repos\imazen_resizer\Plugins\SeamCarving\CarveDataPlotter.cs,GetRemovalSpace,The following statement contains a magic number: for (int y = 0; y < Rows; y++) {                 for (int x = 0; x < Stride; x++) {                     if ((gr[y][x] == 2)) {                         if (y < Rows - 1 && x < Stride - 1) {                             rows[y] += blockSize;                             cols[x] += blockSize;                         } else {                             rows[y] += blockSize + Math.Min(0' w - (x + 1) * blockSize);                             cols[x] += blockSize + Math.Min(0' h - (y + 1) * blockSize);                         }                     }                 }             }
Magic Number,ImageResizer.Plugins.SeamCarving,LzwDecoder,C:\repos\imazen_resizer\Plugins\SeamCarving\LzwDecoder.cs,Decode,The following statement contains a magic number: var asis = alphabet != null ? alphabet.Length : 256;
Magic Number,ImageResizer.Plugins.SeamCarving,LzwDecoder,C:\repos\imazen_resizer\Plugins\SeamCarving\LzwDecoder.cs,Decode,The following statement contains a magic number: for (var i = 1; i < data.Length; i++) {                 var currCode = (int)data[i];                 if (currCode >= 128 && i < data.Length - 1) {                     currCode &= 0xEF; //Drop leading bit                     currCode = currCode << 8; //Shift to MSB                     currCode |= (int)data[i + 1]; //Combine with LSB.                     i++; //Skip forward so we don't read duplicate.                 }                 currCode--; //Since we offset everything +1 to avoid char 0                  if (currCode < asis) {                     phrase = Char.ConvertFromUtf32(alphabet != null ? alphabet[currCode] : currCode);                 } else {                     if (!dict.TryGetValue(currCode' out phrase))                         phrase = oldPhrase + Char.ConvertFromUtf32(currChar);                 }                 sb.Append(phrase);                 currChar = phrase[0];                 dict[code] = oldPhrase + phrase[0];                 code++;                 oldPhrase = phrase;             }
Magic Number,ImageResizer.Plugins.SeamCarving,LzwDecoder,C:\repos\imazen_resizer\Plugins\SeamCarving\LzwDecoder.cs,Decode,The following statement contains a magic number: for (var i = 1; i < data.Length; i++) {                 var currCode = (int)data[i];                 if (currCode >= 128 && i < data.Length - 1) {                     currCode &= 0xEF; //Drop leading bit                     currCode = currCode << 8; //Shift to MSB                     currCode |= (int)data[i + 1]; //Combine with LSB.                     i++; //Skip forward so we don't read duplicate.                 }                 currCode--; //Since we offset everything +1 to avoid char 0                  if (currCode < asis) {                     phrase = Char.ConvertFromUtf32(alphabet != null ? alphabet[currCode] : currCode);                 } else {                     if (!dict.TryGetValue(currCode' out phrase))                         phrase = oldPhrase + Char.ConvertFromUtf32(currChar);                 }                 sb.Append(phrase);                 currChar = phrase[0];                 dict[code] = oldPhrase + phrase[0];                 code++;                 oldPhrase = phrase;             }
Magic Number,ImageResizer.Plugins.SeamCarving,CairManager,C:\repos\imazen_resizer\Plugins\SeamCarving\CairManager.cs,CairyIt,The following statement contains a magic number: if (_concurrentWaitingThreads > 0 || (_maxConcurrentExecutions > 0 &&                     _concurrentExecutions > _maxConcurrentExecutions)) {                 try {                     Interlocked.Increment(ref _concurrentWaitingThreads);                     //Wait for a free slot                     while (_maxConcurrentExecutions > 0 &&                         _concurrentExecutions > _maxConcurrentExecutions) {                         turnstile.WaitOne(1000);                     }                 } finally {                     Interlocked.Decrement(ref _concurrentWaitingThreads);                 }             }
Magic Number,ImageResizer.Plugins.SeamCarving,SeamCarvingPlugin,C:\repos\imazen_resizer\Plugins\SeamCarving\SeamCarvingPlugin.cs,SeamCarvingPlugin,The following statement contains a magic number: Timeout = 5000;
Magic Number,ImageResizer.Plugins.SeamCarving,SeamCarvingPlugin,C:\repos\imazen_resizer\Plugins\SeamCarving\SeamCarvingPlugin.cs,PreRenderImage,The following statement contains a magic number: try {                 try {                      //Create a temporary bitmap that is 'halfway resized'' so we can efficiently perform seam carving.                      //Unless it's already been done for us by FreeImageResize or something                     if (s.preRenderBitmap != null && (tempWidth - s.preRenderBitmap.Width < 50 && tempHeight - s.preRenderBitmap.Height < 50)) {                         s.preRenderBitmap.Save(tempFile' ImageFormat.Bmp);                         tempWidth = s.preRenderBitmap.Width;                         tempHeight = s.preRenderBitmap.Height;                     } else {                         //Create the temporary bitmap and graphics.                         using (Bitmap temp = new Bitmap(tempWidth' tempHeight' PixelFormat.Format32bppArgb))                         using (Graphics g = Graphics.FromImage(temp))                         using (ImageAttributes ia = new ImageAttributes()) {                             //High quality everything                             g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;                             g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;                             g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;                             g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;                             g.CompositingMode = CompositingMode.SourceOver;                             ia.SetWrapMode(WrapMode.TileFlipXY);                             if (s.preRenderBitmap != null) {                                 g.DrawImage(s.preRenderBitmap' new Rectangle(0' 0' tempWidth' tempHeight)' 0' 0' s.preRenderBitmap.Width' s.preRenderBitmap.Height' GraphicsUnit.Pixel' ia);                             } else {                                 g.DrawImage(s.sourceBitmap' new Rectangle(0' 0' tempWidth' tempHeight)' copyRect.X' copyRect.Y' copyRect.Width' copyRect.Height' GraphicsUnit.Pixel' ia);                             }                             g.Flush(FlushIntention.Flush);                             //Save                             temp.Save(tempFile' ImageFormat.Bmp);                         }                     }                      string maskFile = carveData != null ? Path.GetTempFileName() : null;                     try {                         if (carveData != null)                             carveData.SaveBitmapAs(maskFile' tempWidth' tempHeight);                                                  Size intTargetSize = new Size((int)targetSize.Width' (int)targetSize.Height);                         CairJob job = new CairJob();                         if (maskFile != null) job.WeightPath = maskFile;                         job.SourcePath = tempFile;                         job.DestPath = outputTempFile;                         job.Size = intTargetSize;                         job.Filter = ftype;                         job.Timeout = Timeout;                         cair.CairyIt(job);                     } finally {                         if (maskFile != null) File.Delete(maskFile);                     }                  } finally {                     File.Delete(tempFile);                 }                  //Dispose old intermediate bitmap first                 if (s.preRenderBitmap != null) s.preRenderBitmap.Dispose();                  //Load the new intermediate file from disk                 s.preRenderBitmap = new Bitmap(outputTempFile);                 s.preRenderBitmap.MakeTransparent();                                  //Reset the s.copyRect to match the new bitmap                 s.copyRect = new RectangleF(new PointF(0'0)' new SizeF(targetSize.Width' targetSize.Height));              } finally {                 File.Delete(outputTempFile);             }
Magic Number,ImageResizer.Plugins.SeamCarving,SeamCarvingPlugin,C:\repos\imazen_resizer\Plugins\SeamCarving\SeamCarvingPlugin.cs,PreRenderImage,The following statement contains a magic number: try {                 try {                      //Create a temporary bitmap that is 'halfway resized'' so we can efficiently perform seam carving.                      //Unless it's already been done for us by FreeImageResize or something                     if (s.preRenderBitmap != null && (tempWidth - s.preRenderBitmap.Width < 50 && tempHeight - s.preRenderBitmap.Height < 50)) {                         s.preRenderBitmap.Save(tempFile' ImageFormat.Bmp);                         tempWidth = s.preRenderBitmap.Width;                         tempHeight = s.preRenderBitmap.Height;                     } else {                         //Create the temporary bitmap and graphics.                         using (Bitmap temp = new Bitmap(tempWidth' tempHeight' PixelFormat.Format32bppArgb))                         using (Graphics g = Graphics.FromImage(temp))                         using (ImageAttributes ia = new ImageAttributes()) {                             //High quality everything                             g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;                             g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;                             g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;                             g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;                             g.CompositingMode = CompositingMode.SourceOver;                             ia.SetWrapMode(WrapMode.TileFlipXY);                             if (s.preRenderBitmap != null) {                                 g.DrawImage(s.preRenderBitmap' new Rectangle(0' 0' tempWidth' tempHeight)' 0' 0' s.preRenderBitmap.Width' s.preRenderBitmap.Height' GraphicsUnit.Pixel' ia);                             } else {                                 g.DrawImage(s.sourceBitmap' new Rectangle(0' 0' tempWidth' tempHeight)' copyRect.X' copyRect.Y' copyRect.Width' copyRect.Height' GraphicsUnit.Pixel' ia);                             }                             g.Flush(FlushIntention.Flush);                             //Save                             temp.Save(tempFile' ImageFormat.Bmp);                         }                     }                      string maskFile = carveData != null ? Path.GetTempFileName() : null;                     try {                         if (carveData != null)                             carveData.SaveBitmapAs(maskFile' tempWidth' tempHeight);                                                  Size intTargetSize = new Size((int)targetSize.Width' (int)targetSize.Height);                         CairJob job = new CairJob();                         if (maskFile != null) job.WeightPath = maskFile;                         job.SourcePath = tempFile;                         job.DestPath = outputTempFile;                         job.Size = intTargetSize;                         job.Filter = ftype;                         job.Timeout = Timeout;                         cair.CairyIt(job);                     } finally {                         if (maskFile != null) File.Delete(maskFile);                     }                  } finally {                     File.Delete(tempFile);                 }                  //Dispose old intermediate bitmap first                 if (s.preRenderBitmap != null) s.preRenderBitmap.Dispose();                  //Load the new intermediate file from disk                 s.preRenderBitmap = new Bitmap(outputTempFile);                 s.preRenderBitmap.MakeTransparent();                                  //Reset the s.copyRect to match the new bitmap                 s.copyRect = new RectangleF(new PointF(0'0)' new SizeF(targetSize.Width' targetSize.Height));              } finally {                 File.Delete(outputTempFile);             }
Magic Number,SevenZipReduced,CRC,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,SevenZipReduced,CRC,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)             {                 uint r = i;                 for (int j = 0; j < 8; j++)                     if ((r & 1) != 0)                         r = (r >> 1) ^ kPoly;                     else                         r >>= 1;                 Table[i] = r;             }
Magic Number,SevenZipReduced,CRC,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)             {                 uint r = i;                 for (int j = 0; j < 8; j++)                     if ((r & 1) != 0)                         r = (r >> 1) ^ kPoly;                     else                         r >>= 1;                 Table[i] = r;             }
Magic Number,SevenZipReduced,CRC,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,SevenZipReduced,CRC,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Common\CRC.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)                 _value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                 else if (Index < 10) Index -= 3;                 else Index -= 6;
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                 else if (Index < 10) Index -= 3;                 else Index -= 6;
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                 else if (Index < 10) Index -= 3;                 else Index -= 6;
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                 else if (Index < 10) Index -= 3;                 else Index -= 6;
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZipReduced.Compression.LZMA,State,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaBase.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize)             {                 m_DictionarySize = dictionarySize;                 m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);                 uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));                 m_OutWindow.Create(blockSize);             }
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)                 throw new InvalidParamException();
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)                 throw new InvalidParamException();
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64)             {                 // UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);                     // while(nowPos64 < next)                 {                     uint posState = (uint)nowPos64 & m_PosStateMask;                     if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)                     {                         byte b;                         byte prevByte = m_OutWindow.GetByte(0);                         if (!state.IsCharState())                             b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'                                 (uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));                         else                             b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);                         m_OutWindow.PutByte(b);                         state.UpdateChar();                         nowPos64++;                     }                     else                     {                         uint len;                         if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)                         {                             if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)                             {                                 if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)                                 {                                     state.UpdateShortRep();                                     m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));                                     nowPos64++;                                     continue;                                 }                             }                             else                             {                                 UInt32 distance;                                 if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                 {                                     distance = rep1;                                 }                                 else                                 {                                     if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                         distance = rep2;                                     else                                     {                                         distance = rep3;                                         rep3 = rep2;                                     }                                     rep2 = rep1;                                 }                                 rep1 = rep0;                                 rep0 = distance;                             }                             len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + Base.kMatchMinLen;                             state.UpdateRep();                         }                         else                         {                             rep3 = rep2;                             rep2 = rep1;                             rep1 = rep0;                             len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);                             state.UpdateMatch();                             uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);                             if (posSlot >= Base.kStartPosModelIndex)                             {                                 int numDirectBits = (int)((posSlot >> 1) - 1);                                 rep0 = ((2 | (posSlot & 1)) << numDirectBits);                                 if (posSlot < Base.kEndPosModelIndex)                                     rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders'                                             rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);                                 else                                 {                                     rep0 += (m_RangeDecoder.DecodeDirectBits(                                         numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);                                     rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);                                 }                             }                             else                                 rep0 = posSlot;                         }                         if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck)                         {                             if (rep0 == 0xFFFFFFFF)                                 break;                             throw new DataErrorException();                         }                         m_OutWindow.CopyBlock(rep0' len);                         nowPos64 += len;                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)                 throw new InvalidParamException();
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                 dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZipReduced.Compression.LZMA,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                 dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZipReduced.Compression.LZMA,LiteralDecoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,SevenZipReduced.Compression.LZMA,Decoder2,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do                     {                         uint matchBit = (uint)(matchByte >> 7) & 1;                         matchByte <<= 1;                         uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);                         symbol = (symbol << 1) | bit;                         if (matchBit != bit)                         {                             while (symbol < 0x100)                                 symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);                             break;                         }                     }                     while (symbol < 0x100);
Magic Number,SevenZipReduced.Compression.LZMA,Decoder2,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do                     {                         uint matchBit = (uint)(matchByte >> 7) & 1;                         matchByte <<= 1;                         uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);                         symbol = (symbol << 1) | bit;                         if (matchBit != bit)                         {                             while (symbol < 0x100)                                 symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);                             break;                         }                     }                     while (symbol < 0x100);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: int c = 2;
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++)             {                 UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));                 for (UInt32 j = 0; j < k; j++' c++)                     g_FastPos[c] = slotFast;             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))                 return g_FastPos[pos];
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                 return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                 return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                 return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                 return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                 return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                 return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                 return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                 return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                 return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)             {                 LZ.BinTree bt = new LZ.BinTree();                 int numHashBytes = 4;                 if (_matchFinderType == EMatchFinderType.BT2)                     numHashBytes = 2;                 bt.SetType(numHashBytes);                 _matchFinder = bt;             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)             {                 LZ.BinTree bt = new LZ.BinTree();                 int numHashBytes = 4;                 if (_matchFinderType == EMatchFinderType.BT2)                     numHashBytes = 2;                 bt.SetType(numHashBytes);                 _matchFinder = bt;             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0)             {                 lenRes = _matchDistances[numDistancePairs - 2];                 if (lenRes == _numFastBytes)                     lenRes += _matchFinder.GetMatchLen((int)lenRes - 1' _matchDistances[numDistancePairs - 1]'                         Base.kMatchMaxLen - lenRes);             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0)             {                 price = _isRepG0[state.Index].GetPrice0();                 price += _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();             }             else             {                 price = _isRepG0[state.Index].GetPrice1();                 if (repIndex == 1)                     price += _isRepG1[state.Index].GetPrice0();                 else                 {                     price += _isRepG1[state.Index].GetPrice1();                     price += _isRepG2[state.Index].GetPrice(repIndex - 2);                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)             {                 backRes = 0xFFFFFFFF;                 return 1;             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)             {                 backRes = (UInt32)0xFFFFFFFF;                 return 1;             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)             {                 backRes = (UInt32)0xFFFFFFFF;                 return 1;             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if(lenEnd < 2)             {                 backRes = _optimum[1].BackPrev;                 return 1;             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do                 _optimum[len--].Price = kIfinityPrice;             while (len >= 2);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)             {                 UInt32 repLen = repLens[i];                 if (repLen < 2)                     continue;                 UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                 do                 {                     UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                     Optimal optimum = _optimum[repLen];                     if (curAndLenPrice < optimum.Price)                     {                         optimum.Price = curAndLenPrice;                         optimum.PosPrev = 0;                         optimum.BackPrev = i;                         optimum.Prev1IsChar = false;                     }                 }                 while (--repLen >= 2);             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)             {                 UInt32 repLen = repLens[i];                 if (repLen < 2)                     continue;                 UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                 do                 {                     UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                     Optimal optimum = _optimum[repLen];                     if (curAndLenPrice < optimum.Price)                     {                         optimum.Price = curAndLenPrice;                         optimum.PosPrev = 0;                         optimum.BackPrev = i;                         optimum.Prev1IsChar = false;                     }                 }                 while (--repLen >= 2);             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)             {                 UInt32 repLen = repLens[i];                 if (repLen < 2)                     continue;                 UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                 do                 {                     UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                     Optimal optimum = _optimum[repLen];                     if (curAndLenPrice < optimum.Price)                     {                         optimum.Price = curAndLenPrice;                         optimum.PosPrev = 0;                         optimum.BackPrev = i;                         optimum.Prev1IsChar = false;                     }                 }                 while (--repLen >= 2);             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)             {                 UInt32 offs = 0;                 while (len > _matchDistances[offs])                     offs += 2;                 for (; ; len++)                 {                     UInt32 distance = _matchDistances[offs + 1];                     UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);                     Optimal optimum = _optimum[len];                     if (curAndLenPrice < optimum.Price)                     {                         optimum.Price = curAndLenPrice;                         optimum.PosPrev = 0;                         optimum.BackPrev = distance + Base.kNumRepDistances;                         optimum.Prev1IsChar = false;                     }                     if (len == _matchDistances[offs])                     {                         offs += 2;                         if (offs == numDistancePairs)                             break;                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)             {                 UInt32 offs = 0;                 while (len > _matchDistances[offs])                     offs += 2;                 for (; ; len++)                 {                     UInt32 distance = _matchDistances[offs + 1];                     UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);                     Optimal optimum = _optimum[len];                     if (curAndLenPrice < optimum.Price)                     {                         optimum.Price = curAndLenPrice;                         optimum.PosPrev = 0;                         optimum.BackPrev = distance + Base.kNumRepDistances;                         optimum.Prev1IsChar = false;                     }                     if (len == _matchDistances[offs])                     {                         offs += 2;                         if (offs == numDistancePairs)                             break;                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)             {                 cur++;                 if (cur == lenEnd)                     return Backward(out backRes' cur);                 UInt32 newLen;                 ReadMatchDistances(out newLen' out numDistancePairs);                 if (newLen >= _numFastBytes)                 {                     _numDistancePairs = numDistancePairs;                     _longestMatchLength = newLen;                     _longestMatchWasFound = true;                     return Backward(out backRes' cur);                 }                 position++;                 UInt32 posPrev = _optimum[cur].PosPrev;                 Base.State state;                 if (_optimum[cur].Prev1IsChar)                 {                     posPrev--;                     if (_optimum[cur].Prev2)                     {                         state = _optimum[_optimum[cur].PosPrev2].State;                         if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     else                         state = _optimum[posPrev].State;                     state.UpdateChar();                 }                 else                     state = _optimum[posPrev].State;                 if (posPrev == cur - 1)                 {                     if (_optimum[cur].IsShortRep())                         state.UpdateShortRep();                     else                         state.UpdateChar();                 }                 else                 {                     UInt32 pos;                     if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                     {                         posPrev = _optimum[cur].PosPrev2;                         pos = _optimum[cur].BackPrev2;                         state.UpdateRep();                     }                     else                     {                         pos = _optimum[cur].BackPrev;                         if (pos < Base.kNumRepDistances)                             state.UpdateRep();                         else                             state.UpdateMatch();                     }                     Optimal opt = _optimum[posPrev];                     if (pos < Base.kNumRepDistances)                     {                         if (pos == 0)                         {                             reps[0] = opt.Backs0;                             reps[1] = opt.Backs1;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 1)                         {                             reps[0] = opt.Backs1;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs2;                             reps[3] = opt.Backs3;                         }                         else if (pos == 2)                         {                             reps[0] = opt.Backs2;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs3;                         }                         else                         {                             reps[0] = opt.Backs3;                             reps[1] = opt.Backs0;                             reps[2] = opt.Backs1;                             reps[3] = opt.Backs2;                         }                     }                     else                     {                         reps[0] = (pos - Base.kNumRepDistances);                         reps[1] = opt.Backs0;                         reps[2] = opt.Backs1;                         reps[3] = opt.Backs2;                     }                 }                 _optimum[cur].State = state;                 _optimum[cur].Backs0 = reps[0];                 _optimum[cur].Backs1 = reps[1];                 _optimum[cur].Backs2 = reps[2];                 _optimum[cur].Backs3 = reps[3];                 UInt32 curPrice = _optimum[cur].Price;                  currentByte = _matchFinder.GetIndexByte(0 - 1);                 matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                  posState = (position & _posStateMask);                  UInt32 curAnd1Price = curPrice +                     _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                     _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                     GetPrice(!state.IsCharState()' matchByte' currentByte);                  Optimal nextOptimum = _optimum[cur + 1];                  bool nextIsChar = false;                 if (curAnd1Price < nextOptimum.Price)                 {                     nextOptimum.Price = curAnd1Price;                     nextOptimum.PosPrev = cur;                     nextOptimum.MakeAsChar();                     nextIsChar = true;                 }                  matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                  if (matchByte == currentByte &&                     !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                 {                     UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                     if (shortRepPrice <= nextOptimum.Price)                     {                         nextOptimum.Price = shortRepPrice;                         nextOptimum.PosPrev = cur;                         nextOptimum.MakeAsShortRep();                         nextIsChar = true;                     }                 }                  UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                 numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                 numAvailableBytes = numAvailableBytesFull;                  if (numAvailableBytes < 2)                     continue;                 if (numAvailableBytes > _numFastBytes)                     numAvailableBytes = _numFastBytes;                 if (!nextIsChar && matchByte != currentByte)                 {                     // try Literal + rep0                     UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                     UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                     if (lenTest2 >= 2)                     {                         Base.State state2 = state;                         state2.UpdateChar();                         UInt32 posStateNext = (position + 1) & _posStateMask;                         UInt32 nextRepMatchPrice = curAnd1Price +                             _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                             _isRep[state2.Index].GetPrice1();                         {                             UInt32 offset = cur + 1 + lenTest2;                             while (lenEnd < offset)                                 _optimum[++lenEnd].Price = kIfinityPrice;                             UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                 0' lenTest2' state2' posStateNext);                             Optimal optimum = _optimum[offset];                             if (curAndLenPrice < optimum.Price)                             {                                 optimum.Price = curAndLenPrice;                                 optimum.PosPrev = cur + 1;                                 optimum.BackPrev = 0;                                 optimum.Prev1IsChar = true;                                 optimum.Prev2 = false;                             }                         }                     }                 }                  UInt32 startLen = 2; // speed optimization                   for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                 {                     UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                     if (lenTest < 2)                         continue;                     UInt32 lenTestTemp = lenTest;                     do                     {                         while (lenEnd < cur + lenTest)                             _optimum[++lenEnd].Price = kIfinityPrice;                         UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = repIndex;                             optimum.Prev1IsChar = false;                         }                     }                     while(--lenTest >= 2);                     lenTest = lenTestTemp;                      if (repIndex == 0)                         startLen = lenTest + 1;                      // if (_maxMode)                     if (lenTest < numAvailableBytesFull)                     {                         UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                         UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                         if (lenTest2 >= 2)                         {                             Base.State state2 = state;                             state2.UpdateRep();                             UInt32 posStateNext = (position + lenTest) & _posStateMask;                             UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                     _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                     _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                             state2.UpdateChar();                             posStateNext = (position + lenTest + 1) & _posStateMask;                             UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                             UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                                          // for(; lenTest2 >= 2; lenTest2--)                             {                                 UInt32 offset = lenTest + 1 + lenTest2;                                 while(lenEnd < cur + offset)                                     _optimum[++lenEnd].Price = kIfinityPrice;                                 UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                 Optimal optimum = _optimum[cur + offset];                                 if (curAndLenPrice < optimum.Price)                                  {                                     optimum.Price = curAndLenPrice;                                     optimum.PosPrev = cur + lenTest + 1;                                     optimum.BackPrev = 0;                                     optimum.Prev1IsChar = true;                                     optimum.Prev2 = true;                                     optimum.PosPrev2 = cur;                                     optimum.BackPrev2 = repIndex;                                 }                             }                         }                     }                 }                  if (newLen > numAvailableBytes)                 {                     newLen = numAvailableBytes;                     for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                     _matchDistances[numDistancePairs] = newLen;                     numDistancePairs += 2;                 }                 if (newLen >= startLen)                 {                     normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                     while (lenEnd < cur + newLen)                         _optimum[++lenEnd].Price = kIfinityPrice;                      UInt32 offs = 0;                     while (startLen > _matchDistances[offs])                         offs += 2;                      for (UInt32 lenTest = startLen; ; lenTest++)                     {                         UInt32 curBack = _matchDistances[offs + 1];                         UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                         Optimal optimum = _optimum[cur + lenTest];                         if (curAndLenPrice < optimum.Price)                         {                             optimum.Price = curAndLenPrice;                             optimum.PosPrev = cur;                             optimum.BackPrev = curBack + Base.kNumRepDistances;                             optimum.Prev1IsChar = false;                         }                          if (lenTest == _matchDistances[offs])                         {                             if (lenTest < numAvailableBytesFull)                             {                                 UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                 UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                 if (lenTest2 >= 2)                                 {                                     Base.State state2 = state;                                     state2.UpdateMatch();                                     UInt32 posStateNext = (position + lenTest) & _posStateMask;                                     UInt32 curAndLenCharPrice = curAndLenPrice +                                         _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                         _literalEncoder.GetSubCoder(position + lenTest'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                         GetPrice(true'                                         _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                         _matchFinder.GetIndexByte((Int32)lenTest - 1));                                     state2.UpdateChar();                                     posStateNext = (position + lenTest + 1) & _posStateMask;                                     UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                     UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                      UInt32 offset = lenTest + 1 + lenTest2;                                     while (lenEnd < cur + offset)                                         _optimum[++lenEnd].Price = kIfinityPrice;                                     curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                     optimum = _optimum[cur + offset];                                     if (curAndLenPrice < optimum.Price)                                     {                                         optimum.Price = curAndLenPrice;                                         optimum.PosPrev = cur + lenTest + 1;                                         optimum.BackPrev = 0;                                         optimum.Prev1IsChar = true;                                         optimum.Prev2 = true;                                         optimum.PosPrev2 = cur;                                         optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                     }                                 }                             }                             offs += 2;                             if (offs == numDistancePairs)                                 break;                         }                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)             {                 UInt32 pos;                 UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                                  UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                 UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;                 if (len == 1 && pos == 0xFFFFFFFF)                 {                     _isMatch[complexState].Encode(_rangeEncoder' 0);                     Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                     LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                     if (!_state.IsCharState())                     {                         Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                         subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                     }                     else                         subCoder.Encode(_rangeEncoder' curByte);                     _previousByte = curByte;                     _state.UpdateChar();                 }                 else                 {                     _isMatch[complexState].Encode(_rangeEncoder' 1);                     if (pos < Base.kNumRepDistances)                     {                         _isRep[_state.Index].Encode(_rangeEncoder' 1);                         if (pos == 0)                         {                             _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                             if (len == 1)                                 _isRep0Long[complexState].Encode(_rangeEncoder' 0);                             else                                 _isRep0Long[complexState].Encode(_rangeEncoder' 1);                         }                         else                         {                             _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                             if (pos == 1)                                 _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                             else                             {                                 _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                 _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                             }                         }                         if (len == 1)                             _state.UpdateShortRep();                         else                         {                             _repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                             _state.UpdateRep();                         }                         UInt32 distance = _repDistances[pos];                         if (pos != 0)                         {                             for (UInt32 i = pos; i >= 1; i--)                                 _repDistances[i] = _repDistances[i - 1];                             _repDistances[0] = distance;                         }                     }                     else                     {                         _isRep[_state.Index].Encode(_rangeEncoder' 0);                         _state.UpdateMatch();                         _lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                         pos -= Base.kNumRepDistances;                         UInt32 posSlot = GetPosSlot(pos);                         UInt32 lenToPosState = Base.GetLenToPosState(len);                         _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                          if (posSlot >= Base.kStartPosModelIndex)                         {                             int footerBits = (int)((posSlot >> 1) - 1);                             UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                             UInt32 posReduced = pos - baseVal;                              if (posSlot < Base.kEndPosModelIndex)                                 RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'                                         baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                             else                             {                                 _rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);                                 _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);                                 _alignPriceCount++;                             }                         }                         UInt32 distance = pos;                         for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)                             _repDistances[i] = _repDistances[i - 1];                         _repDistances[0] = distance;                         _matchPriceCount++;                     }                     _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                 }                 _additionalOffset -= len;                 nowPos64 += len;                 if (_additionalOffset == 0)                 {                     // if (!_fastMode)                     if (_matchPriceCount >= (1 << 7))                         FillDistancesPrices();                     if (_alignPriceCount >= Base.kAlignTableSize)                         FillAlignPrices();                     inSize = nowPos64;                     outSize = _rangeEncoder.GetProcessedSizeAdd();                     if (_matchFinder.GetNumAvailableBytes() == 0)                     {                         Flush((UInt32)nowPos64);                         return;                     }                      if (nowPos64 - progressPosValuePrev >= (1 << 12))                     {                         _finished = false;                         finished = false;                         return;                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)             {                 UInt32 pos;                 UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                                  UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                 UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;                 if (len == 1 && pos == 0xFFFFFFFF)                 {                     _isMatch[complexState].Encode(_rangeEncoder' 0);                     Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                     LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                     if (!_state.IsCharState())                     {                         Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                         subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                     }                     else                         subCoder.Encode(_rangeEncoder' curByte);                     _previousByte = curByte;                     _state.UpdateChar();                 }                 else                 {                     _isMatch[complexState].Encode(_rangeEncoder' 1);                     if (pos < Base.kNumRepDistances)                     {                         _isRep[_state.Index].Encode(_rangeEncoder' 1);                         if (pos == 0)                         {                             _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                             if (len == 1)                                 _isRep0Long[complexState].Encode(_rangeEncoder' 0);                             else                                 _isRep0Long[complexState].Encode(_rangeEncoder' 1);                         }                         else                         {                             _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                             if (pos == 1)                                 _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                             else                             {                                 _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                 _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                             }                         }                         if (len == 1)                             _state.UpdateShortRep();                         else                         {                             _repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                             _state.UpdateRep();                         }                         UInt32 distance = _repDistances[pos];                         if (pos != 0)                         {                             for (UInt32 i = pos; i >= 1; i--)                                 _repDistances[i] = _repDistances[i - 1];                             _repDistances[0] = distance;                         }                     }                     else                     {                         _isRep[_state.Index].Encode(_rangeEncoder' 0);                         _state.UpdateMatch();                         _lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                         pos -= Base.kNumRepDistances;                         UInt32 posSlot = GetPosSlot(pos);                         UInt32 lenToPosState = Base.GetLenToPosState(len);                         _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                          if (posSlot >= Base.kStartPosModelIndex)                         {                             int footerBits = (int)((posSlot >> 1) - 1);                             UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                             UInt32 posReduced = pos - baseVal;                              if (posSlot < Base.kEndPosModelIndex)                                 RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'                                         baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                             else                             {                                 _rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);                                 _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);                                 _alignPriceCount++;                             }                         }                         UInt32 distance = pos;                         for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)                             _repDistances[i] = _repDistances[i - 1];                         _repDistances[0] = distance;                         _matchPriceCount++;                     }                     _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                 }                 _additionalOffset -= len;                 nowPos64 += len;                 if (_additionalOffset == 0)                 {                     // if (!_fastMode)                     if (_matchPriceCount >= (1 << 7))                         FillDistancesPrices();                     if (_alignPriceCount >= Base.kAlignTableSize)                         FillAlignPrices();                     inSize = nowPos64;                     outSize = _rangeEncoder.GetProcessedSizeAdd();                     if (_matchFinder.GetNumAvailableBytes() == 0)                     {                         Flush((UInt32)nowPos64);                         return;                     }                      if (nowPos64 - progressPosValuePrev >= (1 << 12))                     {                         _finished = false;                         finished = false;                         return;                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)             {                 UInt32 pos;                 UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                                  UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                 UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;                 if (len == 1 && pos == 0xFFFFFFFF)                 {                     _isMatch[complexState].Encode(_rangeEncoder' 0);                     Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                     LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                     if (!_state.IsCharState())                     {                         Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                         subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                     }                     else                         subCoder.Encode(_rangeEncoder' curByte);                     _previousByte = curByte;                     _state.UpdateChar();                 }                 else                 {                     _isMatch[complexState].Encode(_rangeEncoder' 1);                     if (pos < Base.kNumRepDistances)                     {                         _isRep[_state.Index].Encode(_rangeEncoder' 1);                         if (pos == 0)                         {                             _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                             if (len == 1)                                 _isRep0Long[complexState].Encode(_rangeEncoder' 0);                             else                                 _isRep0Long[complexState].Encode(_rangeEncoder' 1);                         }                         else                         {                             _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                             if (pos == 1)                                 _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                             else                             {                                 _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                 _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                             }                         }                         if (len == 1)                             _state.UpdateShortRep();                         else                         {                             _repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                             _state.UpdateRep();                         }                         UInt32 distance = _repDistances[pos];                         if (pos != 0)                         {                             for (UInt32 i = pos; i >= 1; i--)                                 _repDistances[i] = _repDistances[i - 1];                             _repDistances[0] = distance;                         }                     }                     else                     {                         _isRep[_state.Index].Encode(_rangeEncoder' 0);                         _state.UpdateMatch();                         _lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                         pos -= Base.kNumRepDistances;                         UInt32 posSlot = GetPosSlot(pos);                         UInt32 lenToPosState = Base.GetLenToPosState(len);                         _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                          if (posSlot >= Base.kStartPosModelIndex)                         {                             int footerBits = (int)((posSlot >> 1) - 1);                             UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                             UInt32 posReduced = pos - baseVal;                              if (posSlot < Base.kEndPosModelIndex)                                 RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'                                         baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                             else                             {                                 _rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);                                 _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);                                 _alignPriceCount++;                             }                         }                         UInt32 distance = pos;                         for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)                             _repDistances[i] = _repDistances[i - 1];                         _repDistances[0] = distance;                         _matchPriceCount++;                     }                     _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                 }                 _additionalOffset -= len;                 nowPos64 += len;                 if (_additionalOffset == 0)                 {                     // if (!_fastMode)                     if (_matchPriceCount >= (1 << 7))                         FillDistancesPrices();                     if (_alignPriceCount >= Base.kAlignTableSize)                         FillAlignPrices();                     inSize = nowPos64;                     outSize = _rangeEncoder.GetProcessedSizeAdd();                     if (_matchFinder.GetNumAvailableBytes() == 0)                     {                         Flush((UInt32)nowPos64);                         return;                     }                      if (nowPos64 - progressPosValuePrev >= (1 << 12))                     {                         _finished = false;                         finished = false;                         return;                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)             {                 UInt32 pos;                 UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                                  UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                 UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;                 if (len == 1 && pos == 0xFFFFFFFF)                 {                     _isMatch[complexState].Encode(_rangeEncoder' 0);                     Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                     LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                     if (!_state.IsCharState())                     {                         Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                         subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                     }                     else                         subCoder.Encode(_rangeEncoder' curByte);                     _previousByte = curByte;                     _state.UpdateChar();                 }                 else                 {                     _isMatch[complexState].Encode(_rangeEncoder' 1);                     if (pos < Base.kNumRepDistances)                     {                         _isRep[_state.Index].Encode(_rangeEncoder' 1);                         if (pos == 0)                         {                             _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                             if (len == 1)                                 _isRep0Long[complexState].Encode(_rangeEncoder' 0);                             else                                 _isRep0Long[complexState].Encode(_rangeEncoder' 1);                         }                         else                         {                             _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                             if (pos == 1)                                 _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                             else                             {                                 _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                 _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                             }                         }                         if (len == 1)                             _state.UpdateShortRep();                         else                         {                             _repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                             _state.UpdateRep();                         }                         UInt32 distance = _repDistances[pos];                         if (pos != 0)                         {                             for (UInt32 i = pos; i >= 1; i--)                                 _repDistances[i] = _repDistances[i - 1];                             _repDistances[0] = distance;                         }                     }                     else                     {                         _isRep[_state.Index].Encode(_rangeEncoder' 0);                         _state.UpdateMatch();                         _lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                         pos -= Base.kNumRepDistances;                         UInt32 posSlot = GetPosSlot(pos);                         UInt32 lenToPosState = Base.GetLenToPosState(len);                         _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                          if (posSlot >= Base.kStartPosModelIndex)                         {                             int footerBits = (int)((posSlot >> 1) - 1);                             UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                             UInt32 posReduced = pos - baseVal;                              if (posSlot < Base.kEndPosModelIndex)                                 RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'                                         baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                             else                             {                                 _rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);                                 _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);                                 _alignPriceCount++;                             }                         }                         UInt32 distance = pos;                         for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)                             _repDistances[i] = _repDistances[i - 1];                         _repDistances[0] = distance;                         _matchPriceCount++;                     }                     _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                 }                 _additionalOffset -= len;                 nowPos64 += len;                 if (_additionalOffset == 0)                 {                     // if (!_fastMode)                     if (_matchPriceCount >= (1 << 7))                         FillDistancesPrices();                     if (_alignPriceCount >= Base.kAlignTableSize)                         FillAlignPrices();                     inSize = nowPos64;                     outSize = _rangeEncoder.GetProcessedSizeAdd();                     if (_matchFinder.GetNumAvailableBytes() == 0)                     {                         Flush((UInt32)nowPos64);                         return;                     }                      if (nowPos64 - progressPosValuePrev >= (1 << 12))                     {                         _finished = false;                         finished = false;                         return;                     }                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                 properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                 properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++)             {                  UInt32 posSlot = GetPosSlot(i);                 int footerBits = (int)((posSlot >> 1) - 1);                 UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                 tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders'                      baseVal - posSlot - 1' footerBits' i - baseVal);             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)             {                 object prop = properties[i];                 switch (propIDs[i])                 {                     case CoderPropID.NumFastBytes:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 numFastBytes = (Int32)prop;                         if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                             throw new InvalidParamException();                         _numFastBytes = (UInt32)numFastBytes;                         break;                     }                     case CoderPropID.Algorithm:                     {                         /*                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 maximize = (Int32)prop;                         _fastMode = (maximize == 0);                         _maxMode = (maximize >= 2);                         */                         break;                     }                     case CoderPropID.MatchFinder:                     {                         if (!(prop is String))                             throw new InvalidParamException();                         EMatchFinderType matchFinderIndexPrev = _matchFinderType;                         int m = FindMatchFinder(((string)prop).ToUpper());                         if (m < 0)                             throw new InvalidParamException();                         _matchFinderType = (EMatchFinderType)m;                         if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                             {                             _dictionarySizePrev = 0xFFFFFFFF;                             _matchFinder = null;                             }                         break;                     }                     case CoderPropID.DictionarySize:                     {                         const int kDicLogSizeMaxCompress = 30;                         if (!(prop is Int32))                             throw new InvalidParamException(); ;                         Int32 dictionarySize = (Int32)prop;                         if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                             dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                             throw new InvalidParamException();                         _dictionarySize = (UInt32)dictionarySize;                         int dicLogSize;                         for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                             if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                 break;                         _distTableSize = (UInt32)dicLogSize * 2;                         break;                     }                     case CoderPropID.PosStateBits:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 v = (Int32)prop;                         if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                             throw new InvalidParamException();                         _posStateBits = (int)v;                         _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                         break;                     }                     case CoderPropID.LitPosBits:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 v = (Int32)prop;                         if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                             throw new InvalidParamException();                         _numLiteralPosStateBits = (int)v;                         break;                     }                     case CoderPropID.LitContextBits:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 v = (Int32)prop;                         if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                             throw new InvalidParamException(); ;                         _numLiteralContextBits = (int)v;                         break;                     }                     case CoderPropID.EndMarker:                     {                         if (!(prop is Boolean))                             throw new InvalidParamException();                         SetWriteEndMarkerMode((Boolean)prop);                         break;                     }                     default:                         throw new InvalidParamException();                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)             {                 object prop = properties[i];                 switch (propIDs[i])                 {                     case CoderPropID.NumFastBytes:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 numFastBytes = (Int32)prop;                         if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                             throw new InvalidParamException();                         _numFastBytes = (UInt32)numFastBytes;                         break;                     }                     case CoderPropID.Algorithm:                     {                         /*                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 maximize = (Int32)prop;                         _fastMode = (maximize == 0);                         _maxMode = (maximize >= 2);                         */                         break;                     }                     case CoderPropID.MatchFinder:                     {                         if (!(prop is String))                             throw new InvalidParamException();                         EMatchFinderType matchFinderIndexPrev = _matchFinderType;                         int m = FindMatchFinder(((string)prop).ToUpper());                         if (m < 0)                             throw new InvalidParamException();                         _matchFinderType = (EMatchFinderType)m;                         if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                             {                             _dictionarySizePrev = 0xFFFFFFFF;                             _matchFinder = null;                             }                         break;                     }                     case CoderPropID.DictionarySize:                     {                         const int kDicLogSizeMaxCompress = 30;                         if (!(prop is Int32))                             throw new InvalidParamException(); ;                         Int32 dictionarySize = (Int32)prop;                         if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                             dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                             throw new InvalidParamException();                         _dictionarySize = (UInt32)dictionarySize;                         int dicLogSize;                         for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                             if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                 break;                         _distTableSize = (UInt32)dicLogSize * 2;                         break;                     }                     case CoderPropID.PosStateBits:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 v = (Int32)prop;                         if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                             throw new InvalidParamException();                         _posStateBits = (int)v;                         _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                         break;                     }                     case CoderPropID.LitPosBits:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 v = (Int32)prop;                         if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                             throw new InvalidParamException();                         _numLiteralPosStateBits = (int)v;                         break;                     }                     case CoderPropID.LitContextBits:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 v = (Int32)prop;                         if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                             throw new InvalidParamException(); ;                         _numLiteralContextBits = (int)v;                         break;                     }                     case CoderPropID.EndMarker:                     {                         if (!(prop is Boolean))                             throw new InvalidParamException();                         SetWriteEndMarkerMode((Boolean)prop);                         break;                     }                     default:                         throw new InvalidParamException();                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)             {                 object prop = properties[i];                 switch (propIDs[i])                 {                     case CoderPropID.NumFastBytes:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 numFastBytes = (Int32)prop;                         if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                             throw new InvalidParamException();                         _numFastBytes = (UInt32)numFastBytes;                         break;                     }                     case CoderPropID.Algorithm:                     {                         /*                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 maximize = (Int32)prop;                         _fastMode = (maximize == 0);                         _maxMode = (maximize >= 2);                         */                         break;                     }                     case CoderPropID.MatchFinder:                     {                         if (!(prop is String))                             throw new InvalidParamException();                         EMatchFinderType matchFinderIndexPrev = _matchFinderType;                         int m = FindMatchFinder(((string)prop).ToUpper());                         if (m < 0)                             throw new InvalidParamException();                         _matchFinderType = (EMatchFinderType)m;                         if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                             {                             _dictionarySizePrev = 0xFFFFFFFF;                             _matchFinder = null;                             }                         break;                     }                     case CoderPropID.DictionarySize:                     {                         const int kDicLogSizeMaxCompress = 30;                         if (!(prop is Int32))                             throw new InvalidParamException(); ;                         Int32 dictionarySize = (Int32)prop;                         if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                             dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                             throw new InvalidParamException();                         _dictionarySize = (UInt32)dictionarySize;                         int dicLogSize;                         for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                             if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                 break;                         _distTableSize = (UInt32)dicLogSize * 2;                         break;                     }                     case CoderPropID.PosStateBits:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 v = (Int32)prop;                         if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                             throw new InvalidParamException();                         _posStateBits = (int)v;                         _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                         break;                     }                     case CoderPropID.LitPosBits:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 v = (Int32)prop;                         if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                             throw new InvalidParamException();                         _numLiteralPosStateBits = (int)v;                         break;                     }                     case CoderPropID.LitContextBits:                     {                         if (!(prop is Int32))                             throw new InvalidParamException();                         Int32 v = (Int32)prop;                         if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                             throw new InvalidParamException(); ;                         _numLiteralContextBits = (int)v;                         break;                     }                     case CoderPropID.EndMarker:                     {                         if (!(prop is Boolean))                             throw new InvalidParamException();                         SetWriteEndMarkerMode((Boolean)prop);                         break;                     }                     default:                         throw new InvalidParamException();                 }             }
Magic Number,SevenZipReduced.Compression.LZMA,LiteralEncoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,SevenZipReduced.Compression.LZMA,Encoder2,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,Encode,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                     {                         uint bit = (uint)((symbol >> i) & 1);                         m_Encoders[context].Encode(rangeEncoder' bit);                         context = (context << 1) | bit;                     }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder2,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                     {                         uint bit = (uint)((symbol >> i) & 1);                         uint state = context;                         if (same)                         {                             uint matchBit = (uint)((matchByte >> i) & 1);                             state += ((1 + matchBit) << 8);                             same = (matchBit == bit);                         }                         m_Encoders[state].Encode(rangeEncoder' bit);                         context = (context << 1) | bit;                     }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder2,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                     {                         uint bit = (uint)((symbol >> i) & 1);                         uint state = context;                         if (same)                         {                             uint matchBit = (uint)((matchByte >> i) & 1);                             state += ((1 + matchBit) << 8);                             same = (matchBit == bit);                         }                         m_Encoders[state].Encode(rangeEncoder' bit);                         context = (context << 1) | bit;                     }
Magic Number,SevenZipReduced.Compression.LZMA,Encoder2,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,SevenZipReduced.Compression.LZMA,Encoder2,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: if (matchMode)                     {                         for (; i >= 0; i--)                         {                             uint matchBit = (uint)(matchByte >> i) & 1;                             uint bit = (uint)(symbol >> i) & 1;                             price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);                             context = (context << 1) | bit;                             if (matchBit != bit)                             {                                 i--;                                 break;                             }                         }                     }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)             {                 kNumHashDirectBytes = 0;                 kMinMatchCheck = 4;                 kFixHashSize = kHash2Size + kHash3Size;             }             else             {                 kNumHashDirectBytes = 2;                 kMinMatchCheck = 2 + 1;                 kFixHashSize = 0;             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)             {                 kNumHashDirectBytes = 0;                 kMinMatchCheck = 4;                 kFixHashSize = kHash2Size + kHash3Size;             }             else             {                 kNumHashDirectBytes = 2;                 kMinMatchCheck = 2 + 1;                 kFixHashSize = 0;             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)             {                 kNumHashDirectBytes = 0;                 kMinMatchCheck = 4;                 kFixHashSize = kHash2Size + kHash3Size;             }             else             {                 kNumHashDirectBytes = 2;                 kMinMatchCheck = 2 + 1;                 kFixHashSize = 0;             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)                 throw new Exception();
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                     matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                     matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)                 _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)             {                 hs = historySize - 1;                 hs |= (hs >> 1);                 hs |= (hs >> 2);                 hs |= (hs >> 4);                 hs |= (hs >> 8);                 hs >>= 1;                 hs |= 0xFFFF;                 if (hs > (1 << 24))                     hs >>= 1;                 _hashMask = hs;                 hs++;                 hs += kFixHashSize;             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)             {                 hs = historySize - 1;                 hs |= (hs >> 1);                 hs |= (hs >> 2);                 hs |= (hs >> 4);                 hs |= (hs >> 8);                 hs >>= 1;                 hs |= 0xFFFF;                 if (hs > (1 << 24))                     hs >>= 1;                 _hashMask = hs;                 hs++;                 hs += kFixHashSize;             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)             {                 hs = historySize - 1;                 hs |= (hs >> 1);                 hs |= (hs >> 2);                 hs |= (hs >> 4);                 hs |= (hs >> 8);                 hs >>= 1;                 hs |= 0xFFFF;                 if (hs > (1 << 24))                     hs >>= 1;                 _hashMask = hs;                 hs++;                 hs += kFixHashSize;             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)             {                 hs = historySize - 1;                 hs |= (hs >> 1);                 hs |= (hs >> 2);                 hs |= (hs >> 4);                 hs |= (hs >> 8);                 hs >>= 1;                 hs |= 0xFFFF;                 if (hs > (1 << 24))                     hs >>= 1;                 _hashMask = hs;                 hs++;                 hs += kFixHashSize;             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)             {                 UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                 hash2Value = temp & (kHash2Size - 1);                 temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                 hash3Value = temp & (kHash3Size - 1);                 hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;             }             else                 hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)             {                 UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                 hash2Value = temp & (kHash2Size - 1);                 temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                 hash3Value = temp & (kHash3Size - 1);                 hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;             }             else                 hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)             {                 UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                 hash2Value = temp & (kHash2Size - 1);                 temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                 hash3Value = temp & (kHash3Size - 1);                 hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;             }             else                 hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)             {                 UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                 hash2Value = temp & (kHash2Size - 1);                 temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                 hash3Value = temp & (kHash3Size - 1);                 hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;             }             else                 hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)             {                 UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                 hash2Value = temp & (kHash2Size - 1);                 temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                 hash3Value = temp & (kHash3Size - 1);                 hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;             }             else                 hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)             {                 UInt32 curMatch2 = _hash[hash2Value];                 UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                 _hash[hash2Value] = _pos;                 _hash[kHash3Offset + hash3Value] = _pos;                 if (curMatch2 > matchMinPos)                     if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                     {                         distances[offset++] = maxLen = 2;                         distances[offset++] = _pos - curMatch2 - 1;                     }                 if (curMatch3 > matchMinPos)                     if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                     {                         if (curMatch3 == curMatch2)                             offset -= 2;                         distances[offset++] = maxLen = 3;                         distances[offset++] = _pos - curMatch3 - 1;                         curMatch2 = curMatch3;                     }                 if (offset != 0 && curMatch2 == curMatch)                 {                     offset -= 2;                     maxLen = kStartMaxLen;                 }             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)             {                 UInt32 curMatch2 = _hash[hash2Value];                 UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                 _hash[hash2Value] = _pos;                 _hash[kHash3Offset + hash3Value] = _pos;                 if (curMatch2 > matchMinPos)                     if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                     {                         distances[offset++] = maxLen = 2;                         distances[offset++] = _pos - curMatch2 - 1;                     }                 if (curMatch3 > matchMinPos)                     if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                     {                         if (curMatch3 == curMatch2)                             offset -= 2;                         distances[offset++] = maxLen = 3;                         distances[offset++] = _pos - curMatch3 - 1;                         curMatch2 = curMatch3;                     }                 if (offset != 0 && curMatch2 == curMatch)                 {                     offset -= 2;                     maxLen = kStartMaxLen;                 }             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)             {                 UInt32 curMatch2 = _hash[hash2Value];                 UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                 _hash[hash2Value] = _pos;                 _hash[kHash3Offset + hash3Value] = _pos;                 if (curMatch2 > matchMinPos)                     if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                     {                         distances[offset++] = maxLen = 2;                         distances[offset++] = _pos - curMatch2 - 1;                     }                 if (curMatch3 > matchMinPos)                     if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                     {                         if (curMatch3 == curMatch2)                             offset -= 2;                         distances[offset++] = maxLen = 3;                         distances[offset++] = _pos - curMatch3 - 1;                         curMatch2 = curMatch3;                     }                 if (offset != 0 && curMatch2 == curMatch)                 {                     offset -= 2;                     maxLen = kStartMaxLen;                 }             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)             {                 UInt32 curMatch2 = _hash[hash2Value];                 UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                 _hash[hash2Value] = _pos;                 _hash[kHash3Offset + hash3Value] = _pos;                 if (curMatch2 > matchMinPos)                     if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                     {                         distances[offset++] = maxLen = 2;                         distances[offset++] = _pos - curMatch2 - 1;                     }                 if (curMatch3 > matchMinPos)                     if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                     {                         if (curMatch3 == curMatch2)                             offset -= 2;                         distances[offset++] = maxLen = 3;                         distances[offset++] = _pos - curMatch3 - 1;                         curMatch2 = curMatch3;                     }                 if (offset != 0 && curMatch2 == curMatch)                 {                     offset -= 2;                     maxLen = kStartMaxLen;                 }             }
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do             {                 UInt32 lenLimit;                 if (_pos + _matchMaxLen <= _streamPos)                     lenLimit = _matchMaxLen;                 else                 {                     lenLimit = _streamPos - _pos;                     if (lenLimit < kMinMatchCheck)                     {                         MovePos();                         continue;                     }                 }                  UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                 UInt32 cur = _bufferOffset + _pos;                  UInt32 hashValue;                  if (HASH_ARRAY)                 {                     UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                     UInt32 hash2Value = temp & (kHash2Size - 1);                     _hash[hash2Value] = _pos;                     temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                     UInt32 hash3Value = temp & (kHash3Size - 1);                     _hash[kHash3Offset + hash3Value] = _pos;                     hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                 }                 else                     hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                  UInt32 curMatch = _hash[kFixHashSize + hashValue];                 _hash[kFixHashSize + hashValue] = _pos;                  UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                 UInt32 ptr1 = (_cyclicBufferPos << 1);                  UInt32 len0' len1;                 len0 = len1 = kNumHashDirectBytes;                  UInt32 count = _cutValue;                 while (true)                 {                     if (curMatch <= matchMinPos || count-- == 0)                     {                         _son[ptr0] = _son[ptr1] = kEmptyHashValue;                         break;                     }                      UInt32 delta = _pos - curMatch;                     UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                 (_cyclicBufferPos - delta) :                                 (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                      UInt32 pby1 = _bufferOffset + curMatch;                     UInt32 len = Math.Min(len0' len1);                     if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                     {                         while (++len != lenLimit)                             if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                 break;                         if (len == lenLimit)                         {                             _son[ptr1] = _son[cyclicPos];                             _son[ptr0] = _son[cyclicPos + 1];                             break;                         }                     }                     if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                     {                         _son[ptr1] = curMatch;                         ptr1 = cyclicPos + 1;                         curMatch = _son[ptr1];                         len1 = len;                     }                     else                     {                         _son[ptr0] = curMatch;                         ptr0 = cyclicPos;                         curMatch = _son[ptr0];                         len0 = len;                     }                 }                 MovePos();             }             while (--num != 0);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do             {                 UInt32 lenLimit;                 if (_pos + _matchMaxLen <= _streamPos)                     lenLimit = _matchMaxLen;                 else                 {                     lenLimit = _streamPos - _pos;                     if (lenLimit < kMinMatchCheck)                     {                         MovePos();                         continue;                     }                 }                  UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                 UInt32 cur = _bufferOffset + _pos;                  UInt32 hashValue;                  if (HASH_ARRAY)                 {                     UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                     UInt32 hash2Value = temp & (kHash2Size - 1);                     _hash[hash2Value] = _pos;                     temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                     UInt32 hash3Value = temp & (kHash3Size - 1);                     _hash[kHash3Offset + hash3Value] = _pos;                     hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                 }                 else                     hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                  UInt32 curMatch = _hash[kFixHashSize + hashValue];                 _hash[kFixHashSize + hashValue] = _pos;                  UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                 UInt32 ptr1 = (_cyclicBufferPos << 1);                  UInt32 len0' len1;                 len0 = len1 = kNumHashDirectBytes;                  UInt32 count = _cutValue;                 while (true)                 {                     if (curMatch <= matchMinPos || count-- == 0)                     {                         _son[ptr0] = _son[ptr1] = kEmptyHashValue;                         break;                     }                      UInt32 delta = _pos - curMatch;                     UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                 (_cyclicBufferPos - delta) :                                 (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                      UInt32 pby1 = _bufferOffset + curMatch;                     UInt32 len = Math.Min(len0' len1);                     if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                     {                         while (++len != lenLimit)                             if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                 break;                         if (len == lenLimit)                         {                             _son[ptr1] = _son[cyclicPos];                             _son[ptr0] = _son[cyclicPos + 1];                             break;                         }                     }                     if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                     {                         _son[ptr1] = curMatch;                         ptr1 = cyclicPos + 1;                         curMatch = _son[ptr1];                         len1 = len;                     }                     else                     {                         _son[ptr0] = curMatch;                         ptr0 = cyclicPos;                         curMatch = _son[ptr0];                         len0 = len;                     }                 }                 MovePos();             }             while (--num != 0);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do             {                 UInt32 lenLimit;                 if (_pos + _matchMaxLen <= _streamPos)                     lenLimit = _matchMaxLen;                 else                 {                     lenLimit = _streamPos - _pos;                     if (lenLimit < kMinMatchCheck)                     {                         MovePos();                         continue;                     }                 }                  UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                 UInt32 cur = _bufferOffset + _pos;                  UInt32 hashValue;                  if (HASH_ARRAY)                 {                     UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                     UInt32 hash2Value = temp & (kHash2Size - 1);                     _hash[hash2Value] = _pos;                     temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                     UInt32 hash3Value = temp & (kHash3Size - 1);                     _hash[kHash3Offset + hash3Value] = _pos;                     hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                 }                 else                     hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                  UInt32 curMatch = _hash[kFixHashSize + hashValue];                 _hash[kFixHashSize + hashValue] = _pos;                  UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                 UInt32 ptr1 = (_cyclicBufferPos << 1);                  UInt32 len0' len1;                 len0 = len1 = kNumHashDirectBytes;                  UInt32 count = _cutValue;                 while (true)                 {                     if (curMatch <= matchMinPos || count-- == 0)                     {                         _son[ptr0] = _son[ptr1] = kEmptyHashValue;                         break;                     }                      UInt32 delta = _pos - curMatch;                     UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                 (_cyclicBufferPos - delta) :                                 (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                      UInt32 pby1 = _bufferOffset + curMatch;                     UInt32 len = Math.Min(len0' len1);                     if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                     {                         while (++len != lenLimit)                             if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                 break;                         if (len == lenLimit)                         {                             _son[ptr1] = _son[cyclicPos];                             _son[ptr0] = _son[cyclicPos + 1];                             break;                         }                     }                     if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                     {                         _son[ptr1] = curMatch;                         ptr1 = cyclicPos + 1;                         curMatch = _son[ptr1];                         len1 = len;                     }                     else                     {                         _son[ptr0] = curMatch;                         ptr0 = cyclicPos;                         curMatch = _son[ptr0];                         len0 = len;                     }                 }                 MovePos();             }             while (--num != 0);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do             {                 UInt32 lenLimit;                 if (_pos + _matchMaxLen <= _streamPos)                     lenLimit = _matchMaxLen;                 else                 {                     lenLimit = _streamPos - _pos;                     if (lenLimit < kMinMatchCheck)                     {                         MovePos();                         continue;                     }                 }                  UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                 UInt32 cur = _bufferOffset + _pos;                  UInt32 hashValue;                  if (HASH_ARRAY)                 {                     UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                     UInt32 hash2Value = temp & (kHash2Size - 1);                     _hash[hash2Value] = _pos;                     temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                     UInt32 hash3Value = temp & (kHash3Size - 1);                     _hash[kHash3Offset + hash3Value] = _pos;                     hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                 }                 else                     hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                  UInt32 curMatch = _hash[kFixHashSize + hashValue];                 _hash[kFixHashSize + hashValue] = _pos;                  UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                 UInt32 ptr1 = (_cyclicBufferPos << 1);                  UInt32 len0' len1;                 len0 = len1 = kNumHashDirectBytes;                  UInt32 count = _cutValue;                 while (true)                 {                     if (curMatch <= matchMinPos || count-- == 0)                     {                         _son[ptr0] = _son[ptr1] = kEmptyHashValue;                         break;                     }                      UInt32 delta = _pos - curMatch;                     UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                 (_cyclicBufferPos - delta) :                                 (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                      UInt32 pby1 = _bufferOffset + curMatch;                     UInt32 len = Math.Min(len0' len1);                     if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                     {                         while (++len != lenLimit)                             if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                 break;                         if (len == lenLimit)                         {                             _son[ptr1] = _son[cyclicPos];                             _son[ptr0] = _son[cyclicPos + 1];                             break;                         }                     }                     if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                     {                         _son[ptr1] = curMatch;                         ptr1 = cyclicPos + 1;                         curMatch = _son[ptr1];                         len1 = len;                     }                     else                     {                         _son[ptr0] = curMatch;                         ptr0 = cyclicPos;                         curMatch = _son[ptr0];                         len0 = len;                     }                 }                 MovePos();             }             while (--num != 0);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do             {                 UInt32 lenLimit;                 if (_pos + _matchMaxLen <= _streamPos)                     lenLimit = _matchMaxLen;                 else                 {                     lenLimit = _streamPos - _pos;                     if (lenLimit < kMinMatchCheck)                     {                         MovePos();                         continue;                     }                 }                  UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                 UInt32 cur = _bufferOffset + _pos;                  UInt32 hashValue;                  if (HASH_ARRAY)                 {                     UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                     UInt32 hash2Value = temp & (kHash2Size - 1);                     _hash[hash2Value] = _pos;                     temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                     UInt32 hash3Value = temp & (kHash3Size - 1);                     _hash[kHash3Offset + hash3Value] = _pos;                     hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                 }                 else                     hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                  UInt32 curMatch = _hash[kFixHashSize + hashValue];                 _hash[kFixHashSize + hashValue] = _pos;                  UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                 UInt32 ptr1 = (_cyclicBufferPos << 1);                  UInt32 len0' len1;                 len0 = len1 = kNumHashDirectBytes;                  UInt32 count = _cutValue;                 while (true)                 {                     if (curMatch <= matchMinPos || count-- == 0)                     {                         _son[ptr0] = _son[ptr1] = kEmptyHashValue;                         break;                     }                      UInt32 delta = _pos - curMatch;                     UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                 (_cyclicBufferPos - delta) :                                 (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                      UInt32 pby1 = _bufferOffset + curMatch;                     UInt32 len = Math.Min(len0' len1);                     if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                     {                         while (++len != lenLimit)                             if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                 break;                         if (len == lenLimit)                         {                             _son[ptr1] = _son[cyclicPos];                             _son[ptr0] = _son[cyclicPos + 1];                             break;                         }                     }                     if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                     {                         _son[ptr1] = curMatch;                         ptr1 = cyclicPos + 1;                         curMatch = _son[ptr1];                         len1 = len;                     }                     else                     {                         _son[ptr0] = curMatch;                         ptr0 = cyclicPos;                         curMatch = _son[ptr0];                         len0 = len;                     }                 }                 MovePos();             }             while (--num != 0);
Magic Number,SevenZipReduced.Compression.LZ,BinTree,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,SevenZipReduced.Compression.RangeCoder,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)                 ShiftLow();
Magic Number,SevenZipReduced.Compression.RangeCoder,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue)             {                 Range <<= 8;                 ShiftLow();             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)             {                 byte temp = _cache;                 do                 {                     Stream.WriteByte((byte)(temp + (Low >> 32)));                     temp = 0xFF;                 }                 while (--_cacheSize != 0);                 _cache = (byte)(((uint)Low) >> 24);             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)             {                 byte temp = _cache;                 do                 {                     Stream.WriteByte((byte)(temp + (Low >> 32)));                     temp = 0xFF;                 }                 while (--_cacheSize != 0);                 _cache = (byte)(((uint)Low) >> 24);             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)             {                 byte temp = _cache;                 do                 {                     Stream.WriteByte((byte)(temp + (Low >> 32)));                     temp = 0xFF;                 }                 while (--_cacheSize != 0);                 _cache = (byte)(((uint)Low) >> 24);             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,SevenZipReduced.Compression.RangeCoder,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--)             {                 Range >>= 1;                 if (((v >> i) & 1) == 1)                     Low += Range;                 if (Range < kTopValue)                 {                     Range <<= 8;                     ShiftLow();                 }             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue)             {                 Range <<= 8;                 ShiftLow();             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Encoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +                 Stream.Position - StartPosition + 4;
Magic Number,SevenZipReduced.Compression.RangeCoder,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)                 Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZipReduced.Compression.RangeCoder,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)                 Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZipReduced.Compression.RangeCoder,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)             {                 Code = (Code << 8) | (byte)Stream.ReadByte();                 Range <<= 8;             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)             {                 Code = (Code << 8) | (byte)Stream.ReadByte();                 Range <<= 8;             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)             {                 Code = (Code << 8) | (byte)Stream.ReadByte();                 Range <<= 8;             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)             {                 Code = (Code << 8) | (byte)Stream.ReadByte();                 Range <<= 8;             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)             {                 range >>= 1;                 /*                 result <<= 1;                 if (code >= range)                 {                     code -= range;                     result |= 1;                 }                 */                 uint t = (code - range) >> 31;                 code -= range & (t - 1);                 result = (result << 1) | (1 - t);                  if (range < kTopValue)                 {                     code = (code << 8) | (byte)Stream.ReadByte();                     range <<= 8;                 }             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)             {                 range >>= 1;                 /*                 result <<= 1;                 if (code >= range)                 {                     code -= range;                     result |= 1;                 }                 */                 uint t = (code - range) >> 31;                 code -= range & (t - 1);                 result = (result << 1) | (1 - t);                  if (range < kTopValue)                 {                     code = (code << 8) | (byte)Stream.ReadByte();                     range <<= 8;                 }             }
Magic Number,SevenZipReduced.Compression.RangeCoder,Decoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)             {                 range >>= 1;                 /*                 result <<= 1;                 if (code >= range)                 {                     code -= range;                     result |= 1;                 }                 */                 uint t = (code - range) >> 31;                 code -= range & (t - 1);                 result = (result << 1) | (1 - t);                  if (range < kTopValue)                 {                     code = (code << 8) | (byte)Stream.ReadByte();                     range <<= 8;                 }             }
Magic Number,SevenZipReduced.Compression.RangeCoder,BitEncoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue)             {                 encoder.Range <<= 8;                 encoder.ShiftLow();             }
Magic Number,SevenZipReduced.Compression.RangeCoder,BitDecoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)             {                 rangeDecoder.Range = newBound;                 Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                 if (rangeDecoder.Range < Decoder.kTopValue)                 {                     rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                     rangeDecoder.Range <<= 8;                 }                 return 0;             }             else             {                 rangeDecoder.Range -= newBound;                 rangeDecoder.Code -= newBound;                 Prob -= (Prob) >> kNumMoveBits;                 if (rangeDecoder.Range < Decoder.kTopValue)                 {                     rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                     rangeDecoder.Range <<= 8;                 }                 return 1;             }
Magic Number,SevenZipReduced.Compression.RangeCoder,BitDecoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)             {                 rangeDecoder.Range = newBound;                 Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                 if (rangeDecoder.Range < Decoder.kTopValue)                 {                     rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                     rangeDecoder.Range <<= 8;                 }                 return 0;             }             else             {                 rangeDecoder.Range -= newBound;                 rangeDecoder.Code -= newBound;                 Prob -= (Prob) >> kNumMoveBits;                 if (rangeDecoder.Range < Decoder.kTopValue)                 {                     rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                     rangeDecoder.Range <<= 8;                 }                 return 1;             }
Magic Number,SevenZipReduced.Compression.RangeCoder,BitDecoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)             {                 rangeDecoder.Range = newBound;                 Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                 if (rangeDecoder.Range < Decoder.kTopValue)                 {                     rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                     rangeDecoder.Range <<= 8;                 }                 return 0;             }             else             {                 rangeDecoder.Range -= newBound;                 rangeDecoder.Code -= newBound;                 Prob -= (Prob) >> kNumMoveBits;                 if (rangeDecoder.Range < Decoder.kTopValue)                 {                     rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                     rangeDecoder.Range <<= 8;                 }                 return 1;             }
Magic Number,SevenZipReduced.Compression.RangeCoder,BitDecoder,C:\repos\imazen_resizer\Plugins\SeamCarving\SevenZipReduced\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)             {                 rangeDecoder.Range = newBound;                 Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                 if (rangeDecoder.Range < Decoder.kTopValue)                 {                     rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                     rangeDecoder.Range <<= 8;                 }                 return 0;             }             else             {                 rangeDecoder.Range -= newBound;                 rangeDecoder.Code -= newBound;                 Prob -= (Prob) >> kNumMoveBits;                 if (rangeDecoder.Range < Decoder.kTopValue)                 {                     rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                     rangeDecoder.Range <<= 8;                 }                 return 1;             }
