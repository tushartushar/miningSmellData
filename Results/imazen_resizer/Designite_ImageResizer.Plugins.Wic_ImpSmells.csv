Implementation smell,Namespace,Class,File,Method,Description
Long Method,ImageResizer.Plugins.Wic,WicBitmapPadder,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBitmapPadder.cs,CopyPixels,The method has 127 lines of code.
Long Method,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The method has 120 lines of code.
Long Method,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The method has 131 lines of code.
Complex Method,ImageResizer.Plugins.Wic,WicBitmapPadder,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBitmapPadder.cs,CopyPixels,Cyclomatic complexity of the method is 34
Complex Method,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,Cyclomatic complexity of the method is 17
Complex Method,ImageResizer.Plugins.Wic.InteropServices.ComTypes,PropVariantMarshaler,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\PropVariant.cs,MarshalManagedToNative,Cyclomatic complexity of the method is 15
Complex Method,ImageResizer.Plugins.Wic.InteropServices.ComTypes,PropVariantMarshaler,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\PropVariant.cs,MarshalNativeToManaged,Cyclomatic complexity of the method is 58
Complex Method,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,Cyclomatic complexity of the method is 18
Long Parameter List,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,CreateBitmapFromMemory,The method has 8 parameters.
Long Parameter List,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,CopyPixels,The method has 5 parameters.
Long Parameter List,ImageResizer.Plugins.Wic,WicBitmapPadder,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBitmapPadder.cs,WicBitmapPadder,The method has 7 parameters.
Long Parameter List,ImageResizer.Plugins.Wic.InteropServices.ComTypes,IPropertyBag2,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\ComTypes\WinCodec.cs,Read,The method has 5 parameters.
Long Parameter List,ImageResizer.Plugins.Wic.InteropServices.ComTypes,IWICFormatConverter,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\ComTypes\WinCodec.cs,Initialize,The method has 6 parameters.
Long Parameter List,ImageResizer.Plugins.Wic.InteropServices.ComTypes,IWICBitmapSourceTransform,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\ComTypes\WinCodec.cs,CopyPixels,The method has 8 parameters.
Long Parameter List,ImageResizer.Plugins.Wic.InteropServices.ComTypes,IWICImagingFactory,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\ComTypes\WinCodec.cs,CreateBitmapFromSourceRect,The method has 5 parameters.
Long Parameter List,ImageResizer.Plugins.Wic.InteropServices.ComTypes,IWICImagingFactory,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\ComTypes\WinCodec.cs,CreateBitmapFromMemory,The method has 6 parameters.
Long Parameter List,ImageResizer.Plugins.Wic.InteropServices.ComTypes,IWICComponentFactory,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\ComTypes\WinCodecSdk.cs,CreateBitmapFromSourceRect,The method has 5 parameters.
Long Parameter List,ImageResizer.Plugins.Wic.InteropServices.ComTypes,IWICComponentFactory,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\ComTypes\WinCodecSdk.cs,CreateBitmapFromMemory,The method has 6 parameters.
Long Parameter List,ImageResizer.Plugins.Wic.InteropServices,MemoryIStream,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\MemoryIStream.cs,MemoryIStream,The method has 5 parameters.
Long Statement,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,BitsPerPixel,The length of the statement  "				FieldInfo[] members = typeof(Consts).GetFields (System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public); " is 127.
Long Statement,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The length of the statement  "		long result = CreateBitmapFromMemory (factory' (uint)bit.Width' (uint)bit.Height' ref pixelFormat' (uint)bd.Stride' (uint)(bd.Stride * bd.Height)' bd.Scan0' out b); " is 164.
Long Statement,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The length of the statement  "		//b = factory.CreateBitmapFromMemory((uint)bit.Width' (uint)bit.Height' ConversionUtils.FromPixelFormat(bit.PixelFormat)' (uint)bd.Stride' (uint)(bd.Stride * bd.Height)' bd.Scan0); " is 180.
Long Statement,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The length of the statement  "				colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL); " is 158.
Long Statement,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,FromWic,The length of the statement  "			converter.Initialize (source' Consts.GUID_WICPixelFormat32bppBGRA' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.9f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom); " is 173.
Long Statement,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ConvertColor,The length of the statement  "	if (pixelFormat == Consts.GUID_WICPixelFormat32bppBGR || pixelFormat == Consts.GUID_WICPixelFormat32bppBGRA || pixelFormat == Consts.GUID_WICPixelFormat32bppPBGRA) " is 163.
Long Statement,ImageResizer.Plugins.Wic,WicBitmapPadder,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBitmapPadder.cs,CopyPixels,The length of the statement  "				Array.Copy (cachedRowPadding' 0' destBuffer' (destStride * (j + top + Math.Max (0' crop.Height)))' (crop.Width + left + right) * bpp); " is 134.
Long Statement,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJob,The length of the statement  "	//This step gets a Stream instance' copies it to a MemoryStream' then accesses the underlying buffer to get the byte[] and length we need. " is 138.
Long Statement,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJob,The length of the statement  "		s = c.CurrentImageBuilder.GetStreamFromSource (job.Source' job.Settings' ref disposeStream' out path' out restoreStreamPosition); " is 129.
Long Statement,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The length of the statement  "		if (!string.IsNullOrEmpty (q ["page"]) && !int.TryParse (q ["page"]' NumberStyles.Number' NumberFormatInfo.InvariantInfo' out frameIndex)) " is 138.
Long Statement,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The length of the statement  "			if (!string.IsNullOrEmpty (q ["frame"]) && !int.TryParse (q ["frame"]' NumberStyles.Number' NumberFormatInfo.InvariantInfo' out frameIndex)) " is 140.
Long Statement,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The length of the statement  "		if (!EnableHighQualityCubic && interpolationMode == WICBitmapInterpolationMode.WICBitmapInterpolationModeHighQualityCubic) { " is 124.
Long Statement,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The length of the statement  "		if (state.copyRect.Left != 0 || state.copyRect.Top != 0 || state.copyRect.Width != state.originalSize.Width || state.copyRect.Height != state.originalSize.Height) { " is 164.
Long Statement,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The length of the statement  "			var padder = new WicBitmapPadder (imageData' imageDest.X' imageDest.Y' state.destSize.Width - (imageDest.X + imageDest.Width)' state.destSize.Height - (imageDest.Y + imageDest.Height)' bgcolor' null); " is 200.
Long Statement,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,GetIssues,The length of the statement  "		issues.Add (new Issue ("WIC should only be used Windows 7' Server 2008' or higher to prevent stability issues."' IssueSeverity.Critical)); " is 138.
Long Statement,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,GetSupportedFileExtensions,The length of the statement  "	//But those codecs only give us Author' CLSID' FriendlyName' SpecVersion' VendorGUID' and Version. No list of supported file extensions. " is 136.
Long Statement,ImageResizer.Plugins.Wic.InteropServices.ComTypes,PropVariantMarshaler,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\PropVariant.cs,MarshalManagedToNative,The length of the statement  "	} else if ((obj.GetType ().Equals (typeof(byte[]))) || (obj.GetType ().Equals (typeof(sbyte[]))) || (obj.GetType ().Equals (typeof(Int16[]))) || (obj.GetType ().Equals (typeof(UInt16[]))) || (obj.GetType ().Equals (typeof(Int32[]))) || (obj.GetType ().Equals (typeof(UInt32[]))) || (obj.GetType ().Equals (typeof(Int64[]))) || (obj.GetType ().Equals (typeof(UInt64[]))) || (obj.GetType ().Equals (typeof(float[]))) || (obj.GetType ().Equals (typeof(double[])))) { " is 463.
Long Statement,ImageResizer.Plugins.Wic.InteropServices.ComTypes,PropVariantMarshaler,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\PropVariant.cs,MarshalNativeToManaged,The length of the statement  "	if ((0 == (unmanagedPropVariant.vt & (ushort)VarEnum.VT_VECTOR)) && (unmanagedPropVariant.vt != (ushort)VarEnum.VT_BLOB)) { " is 123.
Long Statement,ImageResizer.Plugins.WicDecoder,WicDecoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicDecoder.cs,Decode,The length of the statement  "		if (!string.IsNullOrEmpty (settings ["page"]) && !int.TryParse (settings ["page"]' NumberStyles.Number' NumberFormatInfo.InvariantInfo' out frameIndex)) " is 152.
Long Statement,ImageResizer.Plugins.WicDecoder,WicDecoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicDecoder.cs,Decode,The length of the statement  "			if (!string.IsNullOrEmpty (settings ["frame"]) && !int.TryParse (settings ["frame"]' NumberStyles.Number' NumberFormatInfo.InvariantInfo' out frameIndex)) " is 154.
Long Statement,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The length of the statement  "			//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions) " is 128.
Long Statement,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The length of the statement  "                         * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom); " is 259.
Long Statement,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The length of the statement  "		//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut. " is 127.
Long Statement,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The length of the statement  "		// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed " is 143.
Long Statement,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The length of the statement  "		if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) { " is 138.
Long Statement,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The length of the statement  "                         * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom); " is 305.
Complex Conditional,ImageResizer.Plugins.Wic,WicBitmapPadder,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBitmapPadder.cs,CopyPixels,The conditional expression  "left == 0 && top == 0 && right == 0 && bottom == 0"  is complex.
Complex Conditional,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The conditional expression  "state.copyRect.Left != 0 || state.copyRect.Top != 0 || state.copyRect.Width != state.originalSize.Width || state.copyRect.Height != state.originalSize.Height"  is complex.
Complex Conditional,ImageResizer.Plugins.Wic.InteropServices.ComTypes,PropVariantMarshaler,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\PropVariant.cs,MarshalManagedToNative,The conditional expression  "(obj.GetType ().Equals (typeof(byte[]))) || (obj.GetType ().Equals (typeof(sbyte[]))) || (obj.GetType ().Equals (typeof(Int16[]))) || (obj.GetType ().Equals (typeof(UInt16[]))) || (obj.GetType ().Equals (typeof(Int32[]))) || (obj.GetType ().Equals (typeof(UInt32[]))) || (obj.GetType ().Equals (typeof(Int64[]))) || (obj.GetType ().Equals (typeof(UInt64[]))) || (obj.GetType ().Equals (typeof(float[]))) || (obj.GetType ().Equals (typeof(double[])))"  is complex.
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: try {  	//Create WIC bitmap directly from unmanaged memory  	long result = CreateBitmapFromMemory (factory' (uint)bit.Width' (uint)bit.Height' ref pixelFormat' (uint)bd.Stride' (uint)(bd.Stride * bd.Height)' bd.Scan0' out b);  	//b = factory.CreateBitmapFromMemory((uint)bit.Width' (uint)bit.Height' ConversionUtils.FromPixelFormat(bit.PixelFormat)' (uint)bd.Stride' (uint)(bd.Stride * bd.Height)' bd.Scan0);  	if (result == 0x80070057)  		throw new ArgumentException ();  	if (result < 0)  		throw new Exception ("HRESULT " + result);  	//Copy the bitmap palette if it exists  	var sPalette = bit.Palette;  	if (sPalette.Entries.Length > 0) {  		p = factory.CreatePalette ();  		uint[] colors = new uint[sPalette.Entries.Length];  		for (int i = 0; i < sPalette.Entries.Length; i++) {  			colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  		}  		p.InitializeCustom (colors' (uint)colors.Length);  		b.SetPalette (p);  	}  	return b;  } finally {  	bit.UnlockBits (bd);  	if (p != null)  		Marshal.ReleaseComObject (p);  }  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: try {  	//Create WIC bitmap directly from unmanaged memory  	long result = CreateBitmapFromMemory (factory' (uint)bit.Width' (uint)bit.Height' ref pixelFormat' (uint)bd.Stride' (uint)(bd.Stride * bd.Height)' bd.Scan0' out b);  	//b = factory.CreateBitmapFromMemory((uint)bit.Width' (uint)bit.Height' ConversionUtils.FromPixelFormat(bit.PixelFormat)' (uint)bd.Stride' (uint)(bd.Stride * bd.Height)' bd.Scan0);  	if (result == 0x80070057)  		throw new ArgumentException ();  	if (result < 0)  		throw new Exception ("HRESULT " + result);  	//Copy the bitmap palette if it exists  	var sPalette = bit.Palette;  	if (sPalette.Entries.Length > 0) {  		p = factory.CreatePalette ();  		uint[] colors = new uint[sPalette.Entries.Length];  		for (int i = 0; i < sPalette.Entries.Length; i++) {  			colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  		}  		p.InitializeCustom (colors' (uint)colors.Length);  		b.SetPalette (p);  	}  	return b;  } finally {  	bit.UnlockBits (bd);  	if (p != null)  		Marshal.ReleaseComObject (p);  }  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: try {  	//Create WIC bitmap directly from unmanaged memory  	long result = CreateBitmapFromMemory (factory' (uint)bit.Width' (uint)bit.Height' ref pixelFormat' (uint)bd.Stride' (uint)(bd.Stride * bd.Height)' bd.Scan0' out b);  	//b = factory.CreateBitmapFromMemory((uint)bit.Width' (uint)bit.Height' ConversionUtils.FromPixelFormat(bit.PixelFormat)' (uint)bd.Stride' (uint)(bd.Stride * bd.Height)' bd.Scan0);  	if (result == 0x80070057)  		throw new ArgumentException ();  	if (result < 0)  		throw new Exception ("HRESULT " + result);  	//Copy the bitmap palette if it exists  	var sPalette = bit.Palette;  	if (sPalette.Entries.Length > 0) {  		p = factory.CreatePalette ();  		uint[] colors = new uint[sPalette.Entries.Length];  		for (int i = 0; i < sPalette.Entries.Length; i++) {  			colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  		}  		p.InitializeCustom (colors' (uint)colors.Length);  		b.SetPalette (p);  	}  	return b;  } finally {  	bit.UnlockBits (bd);  	if (p != null)  		Marshal.ReleaseComObject (p);  }  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: if (sPalette.Entries.Length > 0) {  	p = factory.CreatePalette ();  	uint[] colors = new uint[sPalette.Entries.Length];  	for (int i = 0; i < sPalette.Entries.Length; i++) {  		colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  	}  	p.InitializeCustom (colors' (uint)colors.Length);  	b.SetPalette (p);  }  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: if (sPalette.Entries.Length > 0) {  	p = factory.CreatePalette ();  	uint[] colors = new uint[sPalette.Entries.Length];  	for (int i = 0; i < sPalette.Entries.Length; i++) {  		colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  	}  	p.InitializeCustom (colors' (uint)colors.Length);  	b.SetPalette (p);  }  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: if (sPalette.Entries.Length > 0) {  	p = factory.CreatePalette ();  	uint[] colors = new uint[sPalette.Entries.Length];  	for (int i = 0; i < sPalette.Entries.Length; i++) {  		colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  	}  	p.InitializeCustom (colors' (uint)colors.Length);  	b.SetPalette (p);  }  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: for (int i = 0; i < sPalette.Entries.Length; i++) {  	colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  }  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: for (int i = 0; i < sPalette.Entries.Length; i++) {  	colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  }  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: for (int i = 0; i < sPalette.Entries.Length; i++) {  	colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  }  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ToWic,The following statement contains a magic number: colors [i] = (uint)(((sPalette.Entries [i].A << 24) | (sPalette.Entries [i].R << 16) | (sPalette.Entries [i].G << 8) | sPalette.Entries [i].B) & 0xffffffffL);  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ConvertColor,The following statement contains a magic number: if (pixelFormat == Consts.GUID_WICPixelFormat8bppGray)  	return new byte[] {  		(byte)Math.Min (0' Math.Max (255' (float)color.B * 0.081f + (float)color.G * 0.419f + (float)color.R * 0.5f))  	};  
Magic Number,ImageResizer.Plugins.Wic,ConversionUtils,F:\newReposMay17\imazen_resizer\Plugins\Wic\ConversionUtils.cs,ConvertColor,The following statement contains a magic number: return new byte[] {  	(byte)Math.Min (0' Math.Max (255' (float)color.B * 0.081f + (float)color.G * 0.419f + (float)color.R * 0.5f))  };  
Magic Number,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The following statement contains a magic number: try {  	//Create the factory  	IWICComponentFactory factory = (IWICComponentFactory)new WICImagingFactory ();  	com.Add (factory);  	//Wrap the byte[] with a IWICStream instance  	var streamWrapper = factory.CreateStream ();  	streamWrapper.InitializeFromMemory (data' (uint)lData);  	com.Add (streamWrapper);  	var decoder = factory.CreateDecoderFromStream (streamWrapper' null' WICDecodeOptions.WICDecodeMetadataCacheOnLoad);  	com.Add (decoder);  	//Figure out which frame to work with  	int frameIndex = 0;  	if (!string.IsNullOrEmpty (q ["page"]) && !int.TryParse (q ["page"]' NumberStyles.Number' NumberFormatInfo.InvariantInfo' out frameIndex))  		if (!string.IsNullOrEmpty (q ["frame"]) && !int.TryParse (q ["frame"]' NumberStyles.Number' NumberFormatInfo.InvariantInfo' out frameIndex))  			frameIndex = 0;  	//So users can use 1-based numbers  	frameIndex--;  	if (frameIndex > 0) {  		int frameCount = (int)decoder.GetFrameCount ();  		//Don't let the user go past the end.  		if (frameIndex >= frameCount)  			frameIndex = frameCount - 1;  	}  	IWICBitmapFrameDecode frame = decoder.GetFrame ((uint)Math.Max (0' frameIndex));  	com.Add (frame);  	WICBitmapInterpolationMode interpolationMode = WICBitmapInterpolationMode.WICBitmapInterpolationModeHighQualityCubic;  	if ("nearest".Equals (settings ["w.filter"]' StringComparison.OrdinalIgnoreCase))  		interpolationMode = WICBitmapInterpolationMode.WICBitmapInterpolationModeNearestNeighbor;  	if ("bicubic".Equals (settings ["w.filter"]' StringComparison.OrdinalIgnoreCase))  		interpolationMode = WICBitmapInterpolationMode.WICBitmapInterpolationModeCubic;  	if ("linear".Equals (settings ["w.filter"]' StringComparison.OrdinalIgnoreCase))  		interpolationMode = WICBitmapInterpolationMode.WICBitmapInterpolationModeLinear;  	if ("nearestneighbor".Equals (settings ["w.filter"]' StringComparison.OrdinalIgnoreCase))  		interpolationMode = WICBitmapInterpolationMode.WICBitmapInterpolationModeLinear;  	if ("highqualitycubic".Equals (settings ["w.filter"]' StringComparison.OrdinalIgnoreCase))  		interpolationMode = WICBitmapInterpolationMode.WICBitmapInterpolationModeHighQualityCubic;  	//Fall back to fant if EnableHighQualityCubic=false  	if (!EnableHighQualityCubic && interpolationMode == WICBitmapInterpolationMode.WICBitmapInterpolationModeHighQualityCubic) {  		interpolationMode = WICBitmapInterpolationMode.WICBitmapInterpolationModeFant;  	}  	//Find the original image size  	uint origWidth' origHeight;  	frame.GetSize (out origWidth' out origHeight);  	Size orig = new Size ((int)origWidth' (int)origHeight);  	job.ResultInfo ["source.width"] = (int)origWidth;  	job.ResultInfo ["source.height"] = (int)origHeight;  	Guid pixelFormat;  	frame.GetPixelFormat (out pixelFormat);  	//Calculate the new size of the image and the canvas.  	ImageState state = new ImageState (settings' orig' true);  	state.Job = job;  	c.CurrentImageBuilder.Process (state);  	Rectangle imageDest = PolygonMath.ToRectangle (PolygonMath.GetBoundingBox (state.layout ["image"]));  	IWICBitmapSource imageData = frame;  	//Are we cropping? then daisy-chain a clipper  	if (state.copyRect.Left != 0 || state.copyRect.Top != 0 || state.copyRect.Width != state.originalSize.Width || state.copyRect.Height != state.originalSize.Height) {  		//Cropping is absurdly slow... 4x slower than resizing!  		//Cropping after resizing (unintuitively) is faster.  		if (imageDest.Width != state.originalSize.Width || imageDest.Height != state.originalSize.Height) {  			double sx = (double)imageDest.Width / (double)state.copyRect.Width;  			double sy = (double)imageDest.Height / (double)state.copyRect.Height;  			uint uncroppedDestWidth = (uint)Math.Round (sx * state.originalSize.Width);  			uint uncroppedDestHeight = (uint)Math.Round (sy * state.originalSize.Height);  			var scaler = factory.CreateBitmapScaler ();  			scaler.Initialize (imageData' uncroppedDestWidth' uncroppedDestHeight' interpolationMode);  			com.Add (scaler);  			//TODO: cropping is not consistent with GDI.  			var clipper = factory.CreateBitmapClipper ();  			clipper.Initialize (scaler' new WICRect {  				X = (int)Math.Floor ((double)state.copyRect.X * sx)'  				Y = (int)Math.Floor ((double)state.copyRect.Y * sy)'  				Width = imageDest.Width'  				Height = imageDest.Height  			});  			com.Add (clipper);  			imageData = clipper;  		} else {  			var clipper = factory.CreateBitmapClipper ();  			clipper.Initialize (imageData' new WICRect {  				X = (int)state.copyRect.X'  				Y = (int)state.copyRect.Y'  				Width = (int)state.copyRect.Width'  				Height = (int)state.copyRect.Height  			});  			com.Add (clipper);  			imageData = clipper;  		}  		//If we're scaling but not cropping.  	} else if (imageDest.Width != state.originalSize.Width || imageDest.Height != state.originalSize.Height) {  		var scaler = factory.CreateBitmapScaler ();  		scaler.Initialize (imageData' (uint)imageDest.Width' (uint)imageDest.Height' interpolationMode);  		com.Add (scaler);  		imageData = scaler;  	}  	//Are we padding? Then we have to do an intermediate write.  	if (state.destSize.Width != imageDest.Width || state.destSize.Height != imageDest.Height) {  		byte[] bgcolor = ConversionUtils.ConvertColor (job.Settings.BackgroundColor' pixelFormat);  		for (int i = 0; i < bgcolor.Length; i++)  			bgcolor [i] = 255;  		//White  		var padder = new WicBitmapPadder (imageData' imageDest.X' imageDest.Y' state.destSize.Width - (imageDest.X + imageDest.Width)' state.destSize.Height - (imageDest.Y + imageDest.Height)' bgcolor' null);  		imageData = padder;  	}  	//Now encode imageData and be done with it...  	return Encode (factory' imageData' imageDest.Size' job);  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The following statement contains a magic number: if (state.destSize.Width != imageDest.Width || state.destSize.Height != imageDest.Height) {  	byte[] bgcolor = ConversionUtils.ConvertColor (job.Settings.BackgroundColor' pixelFormat);  	for (int i = 0; i < bgcolor.Length; i++)  		bgcolor [i] = 255;  	//White  	var padder = new WicBitmapPadder (imageData' imageDest.X' imageDest.Y' state.destSize.Width - (imageDest.X + imageDest.Width)' state.destSize.Height - (imageDest.Y + imageDest.Height)' bgcolor' null);  	imageData = padder;  }  
Magic Number,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The following statement contains a magic number: for (int i = 0; i < bgcolor.Length; i++)  	bgcolor [i] = 255;  
Magic Number,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,BuildJobWic,The following statement contains a magic number: bgcolor [i] = 255;  
Magic Number,ImageResizer.Plugins.WicBuilder,WicBuilderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicBuilder.cs,GetIssues,The following statement contains a magic number: if (Environment.OSVersion.Version.Major < 6)  	issues.Add (new Issue ("WIC should only be used Windows 7' Server 2008' or higher to prevent stability issues."' IssueSeverity.Critical));  
Magic Number,ImageResizer.Plugins.Wic.InteropServices,MemoryIStream,F:\newReposMay17\imazen_resizer\Plugins\Wic\InteropServices\MemoryIStream.cs,Stat,The following statement contains a magic number: pstatstg = new System.Runtime.InteropServices.ComTypes.STATSTG {  	type = 2  };  
Magic Number,ImageResizer.Plugins.WicDecoder,WicDecoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicDecoder.cs,GetIssues,The following statement contains a magic number: if (Environment.OSVersion.Version.Major < 6)  	issues.Add (new Issue ("WIC should only be used on Windows 7' Server 2008' or higher."' IssueSeverity.Critical));  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: try {  	//Find the GUID of the destination format  	Guid guidEncoder = GetOutputFormatWicGuid ();  	//Find out the data's pixel format  	Guid pFormat = Guid.Empty;  	data.GetPixelFormat (out pFormat);  	//Create the encoder  	var encoder = factory.CreateEncoder (guidEncoder' null);  	com.Add (encoder);  	//And initialize it  	encoder.Initialize (outputStream' WICBitmapEncoderCacheOption.WICBitmapEncoderNoCache);  	// Create the output frame and property bag  	IWICBitmapFrameEncode outputFrame;  	var propertyBagArray = new IPropertyBag2[1];  	encoder.CreateNewFrame (out outputFrame' propertyBagArray);  	//An array is used instead of an out parameter... I have no idea why  	com.Add (outputFrame);  	//The property bag is a COM object...  	var propBag = propertyBagArray [0];  	com.Add (propBag);  	//Adjust encoder settings if it's a JPEG  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		//JPEG  		//ImageQuality 0..1  		//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  		//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  		var qualityOption = new PROPBAG2[1];  		qualityOption [0].pstrName = "ImageQuality";  		propBag.Write (1' qualityOption' new object[] {  			((float)Math.Max (0' Math.Min (100' Quality))) / 100  		});  		WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  		//411 NOT SUPPPORTED BY WIC - only by freeimage  		if ("420".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  		if ("422".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  		if ("444".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  		if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  			var samplingOption = new PROPBAG2[1];  			samplingOption [0].pstrName = "JpegYCrCbSubsampling";  			samplingOption [0].vt = VarEnum.VT_UI1;  			propBag.Write (1' samplingOption' new object[] {  				(byte)subsampling  			});  		}  	}  	//PNG interlace  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		var interlaceOption = new PROPBAG2[1];  		interlaceOption [0].pstrName = "InterlaceOption";  		propBag.Write (1' interlaceOption' new object[] {  			Interlace ?? false  		});  	}  	//Apply the property bag  	outputFrame.Initialize (propBag);  	//Convert the bitmap to the correct pixel format for encoding.  	//JPEG: encodes as GUID_WICPixelFormat24bppBGR or GUID_WICPixelFormat8bppGray.  	//If the original pixel format has an alpha channel' we need to specify a matte color.  	//UPDATE - IWICFormatConverter doesn't let you specify a matte color. Disabling code  	if (false && guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		ConversionUtils.HasAlphaAbility (pFormat);  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' Consts.GUID_WICPixelFormat24bppBGR)) {  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  			//Oops' we didn't do anything - there's no way to specify a matte color!  		}  	}  	//GIF encodes as GUID_WICPixelFormat8bppIndexed  	//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut.  	//PNG encodes as EVERYTHING! Way too many formats supported.  	// If the user is specifying a colors setting' we need to  	// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed  	if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  		Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  		int colors = this.Colors;  		if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  			if (colors <= 2)  				target = Consts.GUID_WICPixelFormat1bppIndexed;  			if (colors <= 4)  				target = Consts.GUID_WICPixelFormat2bppIndexed;  			if (colors <= 32)  				target = Consts.GUID_WICPixelFormat4bppIndexed;  		}  		if (colors < 0)  			colors = 256;  		if (colors < 2)  			colors = 2;  		if (colors > 256)  			colors = 256;  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' target)) {  			var palette = factory.CreatePalette ();  			com.Add (palette);  			palette.InitializeFromBitmap (data' (uint)colors' true);  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  		}  	}  	//Get size  	uint fw' fh;  	data.GetSize (out fw' out fh);  	//Set destination frame size  	outputFrame.SetSize (fw' fh);  	// Write the data to the output frame  	outputFrame.WriteSource (data' null);  	outputFrame.Commit ();  	encoder.Commit ();  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: try {  	//Find the GUID of the destination format  	Guid guidEncoder = GetOutputFormatWicGuid ();  	//Find out the data's pixel format  	Guid pFormat = Guid.Empty;  	data.GetPixelFormat (out pFormat);  	//Create the encoder  	var encoder = factory.CreateEncoder (guidEncoder' null);  	com.Add (encoder);  	//And initialize it  	encoder.Initialize (outputStream' WICBitmapEncoderCacheOption.WICBitmapEncoderNoCache);  	// Create the output frame and property bag  	IWICBitmapFrameEncode outputFrame;  	var propertyBagArray = new IPropertyBag2[1];  	encoder.CreateNewFrame (out outputFrame' propertyBagArray);  	//An array is used instead of an out parameter... I have no idea why  	com.Add (outputFrame);  	//The property bag is a COM object...  	var propBag = propertyBagArray [0];  	com.Add (propBag);  	//Adjust encoder settings if it's a JPEG  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		//JPEG  		//ImageQuality 0..1  		//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  		//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  		var qualityOption = new PROPBAG2[1];  		qualityOption [0].pstrName = "ImageQuality";  		propBag.Write (1' qualityOption' new object[] {  			((float)Math.Max (0' Math.Min (100' Quality))) / 100  		});  		WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  		//411 NOT SUPPPORTED BY WIC - only by freeimage  		if ("420".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  		if ("422".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  		if ("444".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  		if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  			var samplingOption = new PROPBAG2[1];  			samplingOption [0].pstrName = "JpegYCrCbSubsampling";  			samplingOption [0].vt = VarEnum.VT_UI1;  			propBag.Write (1' samplingOption' new object[] {  				(byte)subsampling  			});  		}  	}  	//PNG interlace  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		var interlaceOption = new PROPBAG2[1];  		interlaceOption [0].pstrName = "InterlaceOption";  		propBag.Write (1' interlaceOption' new object[] {  			Interlace ?? false  		});  	}  	//Apply the property bag  	outputFrame.Initialize (propBag);  	//Convert the bitmap to the correct pixel format for encoding.  	//JPEG: encodes as GUID_WICPixelFormat24bppBGR or GUID_WICPixelFormat8bppGray.  	//If the original pixel format has an alpha channel' we need to specify a matte color.  	//UPDATE - IWICFormatConverter doesn't let you specify a matte color. Disabling code  	if (false && guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		ConversionUtils.HasAlphaAbility (pFormat);  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' Consts.GUID_WICPixelFormat24bppBGR)) {  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  			//Oops' we didn't do anything - there's no way to specify a matte color!  		}  	}  	//GIF encodes as GUID_WICPixelFormat8bppIndexed  	//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut.  	//PNG encodes as EVERYTHING! Way too many formats supported.  	// If the user is specifying a colors setting' we need to  	// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed  	if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  		Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  		int colors = this.Colors;  		if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  			if (colors <= 2)  				target = Consts.GUID_WICPixelFormat1bppIndexed;  			if (colors <= 4)  				target = Consts.GUID_WICPixelFormat2bppIndexed;  			if (colors <= 32)  				target = Consts.GUID_WICPixelFormat4bppIndexed;  		}  		if (colors < 0)  			colors = 256;  		if (colors < 2)  			colors = 2;  		if (colors > 256)  			colors = 256;  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' target)) {  			var palette = factory.CreatePalette ();  			com.Add (palette);  			palette.InitializeFromBitmap (data' (uint)colors' true);  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  		}  	}  	//Get size  	uint fw' fh;  	data.GetSize (out fw' out fh);  	//Set destination frame size  	outputFrame.SetSize (fw' fh);  	// Write the data to the output frame  	outputFrame.WriteSource (data' null);  	outputFrame.Commit ();  	encoder.Commit ();  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: try {  	//Find the GUID of the destination format  	Guid guidEncoder = GetOutputFormatWicGuid ();  	//Find out the data's pixel format  	Guid pFormat = Guid.Empty;  	data.GetPixelFormat (out pFormat);  	//Create the encoder  	var encoder = factory.CreateEncoder (guidEncoder' null);  	com.Add (encoder);  	//And initialize it  	encoder.Initialize (outputStream' WICBitmapEncoderCacheOption.WICBitmapEncoderNoCache);  	// Create the output frame and property bag  	IWICBitmapFrameEncode outputFrame;  	var propertyBagArray = new IPropertyBag2[1];  	encoder.CreateNewFrame (out outputFrame' propertyBagArray);  	//An array is used instead of an out parameter... I have no idea why  	com.Add (outputFrame);  	//The property bag is a COM object...  	var propBag = propertyBagArray [0];  	com.Add (propBag);  	//Adjust encoder settings if it's a JPEG  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		//JPEG  		//ImageQuality 0..1  		//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  		//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  		var qualityOption = new PROPBAG2[1];  		qualityOption [0].pstrName = "ImageQuality";  		propBag.Write (1' qualityOption' new object[] {  			((float)Math.Max (0' Math.Min (100' Quality))) / 100  		});  		WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  		//411 NOT SUPPPORTED BY WIC - only by freeimage  		if ("420".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  		if ("422".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  		if ("444".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  		if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  			var samplingOption = new PROPBAG2[1];  			samplingOption [0].pstrName = "JpegYCrCbSubsampling";  			samplingOption [0].vt = VarEnum.VT_UI1;  			propBag.Write (1' samplingOption' new object[] {  				(byte)subsampling  			});  		}  	}  	//PNG interlace  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		var interlaceOption = new PROPBAG2[1];  		interlaceOption [0].pstrName = "InterlaceOption";  		propBag.Write (1' interlaceOption' new object[] {  			Interlace ?? false  		});  	}  	//Apply the property bag  	outputFrame.Initialize (propBag);  	//Convert the bitmap to the correct pixel format for encoding.  	//JPEG: encodes as GUID_WICPixelFormat24bppBGR or GUID_WICPixelFormat8bppGray.  	//If the original pixel format has an alpha channel' we need to specify a matte color.  	//UPDATE - IWICFormatConverter doesn't let you specify a matte color. Disabling code  	if (false && guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		ConversionUtils.HasAlphaAbility (pFormat);  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' Consts.GUID_WICPixelFormat24bppBGR)) {  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  			//Oops' we didn't do anything - there's no way to specify a matte color!  		}  	}  	//GIF encodes as GUID_WICPixelFormat8bppIndexed  	//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut.  	//PNG encodes as EVERYTHING! Way too many formats supported.  	// If the user is specifying a colors setting' we need to  	// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed  	if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  		Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  		int colors = this.Colors;  		if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  			if (colors <= 2)  				target = Consts.GUID_WICPixelFormat1bppIndexed;  			if (colors <= 4)  				target = Consts.GUID_WICPixelFormat2bppIndexed;  			if (colors <= 32)  				target = Consts.GUID_WICPixelFormat4bppIndexed;  		}  		if (colors < 0)  			colors = 256;  		if (colors < 2)  			colors = 2;  		if (colors > 256)  			colors = 256;  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' target)) {  			var palette = factory.CreatePalette ();  			com.Add (palette);  			palette.InitializeFromBitmap (data' (uint)colors' true);  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  		}  	}  	//Get size  	uint fw' fh;  	data.GetSize (out fw' out fh);  	//Set destination frame size  	outputFrame.SetSize (fw' fh);  	// Write the data to the output frame  	outputFrame.WriteSource (data' null);  	outputFrame.Commit ();  	encoder.Commit ();  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: try {  	//Find the GUID of the destination format  	Guid guidEncoder = GetOutputFormatWicGuid ();  	//Find out the data's pixel format  	Guid pFormat = Guid.Empty;  	data.GetPixelFormat (out pFormat);  	//Create the encoder  	var encoder = factory.CreateEncoder (guidEncoder' null);  	com.Add (encoder);  	//And initialize it  	encoder.Initialize (outputStream' WICBitmapEncoderCacheOption.WICBitmapEncoderNoCache);  	// Create the output frame and property bag  	IWICBitmapFrameEncode outputFrame;  	var propertyBagArray = new IPropertyBag2[1];  	encoder.CreateNewFrame (out outputFrame' propertyBagArray);  	//An array is used instead of an out parameter... I have no idea why  	com.Add (outputFrame);  	//The property bag is a COM object...  	var propBag = propertyBagArray [0];  	com.Add (propBag);  	//Adjust encoder settings if it's a JPEG  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		//JPEG  		//ImageQuality 0..1  		//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  		//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  		var qualityOption = new PROPBAG2[1];  		qualityOption [0].pstrName = "ImageQuality";  		propBag.Write (1' qualityOption' new object[] {  			((float)Math.Max (0' Math.Min (100' Quality))) / 100  		});  		WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  		//411 NOT SUPPPORTED BY WIC - only by freeimage  		if ("420".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  		if ("422".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  		if ("444".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  		if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  			var samplingOption = new PROPBAG2[1];  			samplingOption [0].pstrName = "JpegYCrCbSubsampling";  			samplingOption [0].vt = VarEnum.VT_UI1;  			propBag.Write (1' samplingOption' new object[] {  				(byte)subsampling  			});  		}  	}  	//PNG interlace  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		var interlaceOption = new PROPBAG2[1];  		interlaceOption [0].pstrName = "InterlaceOption";  		propBag.Write (1' interlaceOption' new object[] {  			Interlace ?? false  		});  	}  	//Apply the property bag  	outputFrame.Initialize (propBag);  	//Convert the bitmap to the correct pixel format for encoding.  	//JPEG: encodes as GUID_WICPixelFormat24bppBGR or GUID_WICPixelFormat8bppGray.  	//If the original pixel format has an alpha channel' we need to specify a matte color.  	//UPDATE - IWICFormatConverter doesn't let you specify a matte color. Disabling code  	if (false && guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		ConversionUtils.HasAlphaAbility (pFormat);  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' Consts.GUID_WICPixelFormat24bppBGR)) {  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  			//Oops' we didn't do anything - there's no way to specify a matte color!  		}  	}  	//GIF encodes as GUID_WICPixelFormat8bppIndexed  	//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut.  	//PNG encodes as EVERYTHING! Way too many formats supported.  	// If the user is specifying a colors setting' we need to  	// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed  	if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  		Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  		int colors = this.Colors;  		if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  			if (colors <= 2)  				target = Consts.GUID_WICPixelFormat1bppIndexed;  			if (colors <= 4)  				target = Consts.GUID_WICPixelFormat2bppIndexed;  			if (colors <= 32)  				target = Consts.GUID_WICPixelFormat4bppIndexed;  		}  		if (colors < 0)  			colors = 256;  		if (colors < 2)  			colors = 2;  		if (colors > 256)  			colors = 256;  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' target)) {  			var palette = factory.CreatePalette ();  			com.Add (palette);  			palette.InitializeFromBitmap (data' (uint)colors' true);  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  		}  	}  	//Get size  	uint fw' fh;  	data.GetSize (out fw' out fh);  	//Set destination frame size  	outputFrame.SetSize (fw' fh);  	// Write the data to the output frame  	outputFrame.WriteSource (data' null);  	outputFrame.Commit ();  	encoder.Commit ();  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: try {  	//Find the GUID of the destination format  	Guid guidEncoder = GetOutputFormatWicGuid ();  	//Find out the data's pixel format  	Guid pFormat = Guid.Empty;  	data.GetPixelFormat (out pFormat);  	//Create the encoder  	var encoder = factory.CreateEncoder (guidEncoder' null);  	com.Add (encoder);  	//And initialize it  	encoder.Initialize (outputStream' WICBitmapEncoderCacheOption.WICBitmapEncoderNoCache);  	// Create the output frame and property bag  	IWICBitmapFrameEncode outputFrame;  	var propertyBagArray = new IPropertyBag2[1];  	encoder.CreateNewFrame (out outputFrame' propertyBagArray);  	//An array is used instead of an out parameter... I have no idea why  	com.Add (outputFrame);  	//The property bag is a COM object...  	var propBag = propertyBagArray [0];  	com.Add (propBag);  	//Adjust encoder settings if it's a JPEG  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		//JPEG  		//ImageQuality 0..1  		//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  		//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  		var qualityOption = new PROPBAG2[1];  		qualityOption [0].pstrName = "ImageQuality";  		propBag.Write (1' qualityOption' new object[] {  			((float)Math.Max (0' Math.Min (100' Quality))) / 100  		});  		WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  		//411 NOT SUPPPORTED BY WIC - only by freeimage  		if ("420".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  		if ("422".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  		if ("444".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  		if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  			var samplingOption = new PROPBAG2[1];  			samplingOption [0].pstrName = "JpegYCrCbSubsampling";  			samplingOption [0].vt = VarEnum.VT_UI1;  			propBag.Write (1' samplingOption' new object[] {  				(byte)subsampling  			});  		}  	}  	//PNG interlace  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		var interlaceOption = new PROPBAG2[1];  		interlaceOption [0].pstrName = "InterlaceOption";  		propBag.Write (1' interlaceOption' new object[] {  			Interlace ?? false  		});  	}  	//Apply the property bag  	outputFrame.Initialize (propBag);  	//Convert the bitmap to the correct pixel format for encoding.  	//JPEG: encodes as GUID_WICPixelFormat24bppBGR or GUID_WICPixelFormat8bppGray.  	//If the original pixel format has an alpha channel' we need to specify a matte color.  	//UPDATE - IWICFormatConverter doesn't let you specify a matte color. Disabling code  	if (false && guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		ConversionUtils.HasAlphaAbility (pFormat);  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' Consts.GUID_WICPixelFormat24bppBGR)) {  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  			//Oops' we didn't do anything - there's no way to specify a matte color!  		}  	}  	//GIF encodes as GUID_WICPixelFormat8bppIndexed  	//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut.  	//PNG encodes as EVERYTHING! Way too many formats supported.  	// If the user is specifying a colors setting' we need to  	// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed  	if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  		Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  		int colors = this.Colors;  		if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  			if (colors <= 2)  				target = Consts.GUID_WICPixelFormat1bppIndexed;  			if (colors <= 4)  				target = Consts.GUID_WICPixelFormat2bppIndexed;  			if (colors <= 32)  				target = Consts.GUID_WICPixelFormat4bppIndexed;  		}  		if (colors < 0)  			colors = 256;  		if (colors < 2)  			colors = 2;  		if (colors > 256)  			colors = 256;  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' target)) {  			var palette = factory.CreatePalette ();  			com.Add (palette);  			palette.InitializeFromBitmap (data' (uint)colors' true);  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  		}  	}  	//Get size  	uint fw' fh;  	data.GetSize (out fw' out fh);  	//Set destination frame size  	outputFrame.SetSize (fw' fh);  	// Write the data to the output frame  	outputFrame.WriteSource (data' null);  	outputFrame.Commit ();  	encoder.Commit ();  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: try {  	//Find the GUID of the destination format  	Guid guidEncoder = GetOutputFormatWicGuid ();  	//Find out the data's pixel format  	Guid pFormat = Guid.Empty;  	data.GetPixelFormat (out pFormat);  	//Create the encoder  	var encoder = factory.CreateEncoder (guidEncoder' null);  	com.Add (encoder);  	//And initialize it  	encoder.Initialize (outputStream' WICBitmapEncoderCacheOption.WICBitmapEncoderNoCache);  	// Create the output frame and property bag  	IWICBitmapFrameEncode outputFrame;  	var propertyBagArray = new IPropertyBag2[1];  	encoder.CreateNewFrame (out outputFrame' propertyBagArray);  	//An array is used instead of an out parameter... I have no idea why  	com.Add (outputFrame);  	//The property bag is a COM object...  	var propBag = propertyBagArray [0];  	com.Add (propBag);  	//Adjust encoder settings if it's a JPEG  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		//JPEG  		//ImageQuality 0..1  		//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  		//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  		var qualityOption = new PROPBAG2[1];  		qualityOption [0].pstrName = "ImageQuality";  		propBag.Write (1' qualityOption' new object[] {  			((float)Math.Max (0' Math.Min (100' Quality))) / 100  		});  		WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  		//411 NOT SUPPPORTED BY WIC - only by freeimage  		if ("420".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  		if ("422".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  		if ("444".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  		if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  			var samplingOption = new PROPBAG2[1];  			samplingOption [0].pstrName = "JpegYCrCbSubsampling";  			samplingOption [0].vt = VarEnum.VT_UI1;  			propBag.Write (1' samplingOption' new object[] {  				(byte)subsampling  			});  		}  	}  	//PNG interlace  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		var interlaceOption = new PROPBAG2[1];  		interlaceOption [0].pstrName = "InterlaceOption";  		propBag.Write (1' interlaceOption' new object[] {  			Interlace ?? false  		});  	}  	//Apply the property bag  	outputFrame.Initialize (propBag);  	//Convert the bitmap to the correct pixel format for encoding.  	//JPEG: encodes as GUID_WICPixelFormat24bppBGR or GUID_WICPixelFormat8bppGray.  	//If the original pixel format has an alpha channel' we need to specify a matte color.  	//UPDATE - IWICFormatConverter doesn't let you specify a matte color. Disabling code  	if (false && guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		ConversionUtils.HasAlphaAbility (pFormat);  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' Consts.GUID_WICPixelFormat24bppBGR)) {  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  			//Oops' we didn't do anything - there's no way to specify a matte color!  		}  	}  	//GIF encodes as GUID_WICPixelFormat8bppIndexed  	//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut.  	//PNG encodes as EVERYTHING! Way too many formats supported.  	// If the user is specifying a colors setting' we need to  	// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed  	if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  		Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  		int colors = this.Colors;  		if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  			if (colors <= 2)  				target = Consts.GUID_WICPixelFormat1bppIndexed;  			if (colors <= 4)  				target = Consts.GUID_WICPixelFormat2bppIndexed;  			if (colors <= 32)  				target = Consts.GUID_WICPixelFormat4bppIndexed;  		}  		if (colors < 0)  			colors = 256;  		if (colors < 2)  			colors = 2;  		if (colors > 256)  			colors = 256;  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' target)) {  			var palette = factory.CreatePalette ();  			com.Add (palette);  			palette.InitializeFromBitmap (data' (uint)colors' true);  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  		}  	}  	//Get size  	uint fw' fh;  	data.GetSize (out fw' out fh);  	//Set destination frame size  	outputFrame.SetSize (fw' fh);  	// Write the data to the output frame  	outputFrame.WriteSource (data' null);  	outputFrame.Commit ();  	encoder.Commit ();  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: try {  	//Find the GUID of the destination format  	Guid guidEncoder = GetOutputFormatWicGuid ();  	//Find out the data's pixel format  	Guid pFormat = Guid.Empty;  	data.GetPixelFormat (out pFormat);  	//Create the encoder  	var encoder = factory.CreateEncoder (guidEncoder' null);  	com.Add (encoder);  	//And initialize it  	encoder.Initialize (outputStream' WICBitmapEncoderCacheOption.WICBitmapEncoderNoCache);  	// Create the output frame and property bag  	IWICBitmapFrameEncode outputFrame;  	var propertyBagArray = new IPropertyBag2[1];  	encoder.CreateNewFrame (out outputFrame' propertyBagArray);  	//An array is used instead of an out parameter... I have no idea why  	com.Add (outputFrame);  	//The property bag is a COM object...  	var propBag = propertyBagArray [0];  	com.Add (propBag);  	//Adjust encoder settings if it's a JPEG  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		//JPEG  		//ImageQuality 0..1  		//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  		//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  		var qualityOption = new PROPBAG2[1];  		qualityOption [0].pstrName = "ImageQuality";  		propBag.Write (1' qualityOption' new object[] {  			((float)Math.Max (0' Math.Min (100' Quality))) / 100  		});  		WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  		//411 NOT SUPPPORTED BY WIC - only by freeimage  		if ("420".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  		if ("422".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  		if ("444".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  		if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  			var samplingOption = new PROPBAG2[1];  			samplingOption [0].pstrName = "JpegYCrCbSubsampling";  			samplingOption [0].vt = VarEnum.VT_UI1;  			propBag.Write (1' samplingOption' new object[] {  				(byte)subsampling  			});  		}  	}  	//PNG interlace  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		var interlaceOption = new PROPBAG2[1];  		interlaceOption [0].pstrName = "InterlaceOption";  		propBag.Write (1' interlaceOption' new object[] {  			Interlace ?? false  		});  	}  	//Apply the property bag  	outputFrame.Initialize (propBag);  	//Convert the bitmap to the correct pixel format for encoding.  	//JPEG: encodes as GUID_WICPixelFormat24bppBGR or GUID_WICPixelFormat8bppGray.  	//If the original pixel format has an alpha channel' we need to specify a matte color.  	//UPDATE - IWICFormatConverter doesn't let you specify a matte color. Disabling code  	if (false && guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		ConversionUtils.HasAlphaAbility (pFormat);  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' Consts.GUID_WICPixelFormat24bppBGR)) {  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  			//Oops' we didn't do anything - there's no way to specify a matte color!  		}  	}  	//GIF encodes as GUID_WICPixelFormat8bppIndexed  	//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut.  	//PNG encodes as EVERYTHING! Way too many formats supported.  	// If the user is specifying a colors setting' we need to  	// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed  	if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  		Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  		int colors = this.Colors;  		if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  			if (colors <= 2)  				target = Consts.GUID_WICPixelFormat1bppIndexed;  			if (colors <= 4)  				target = Consts.GUID_WICPixelFormat2bppIndexed;  			if (colors <= 32)  				target = Consts.GUID_WICPixelFormat4bppIndexed;  		}  		if (colors < 0)  			colors = 256;  		if (colors < 2)  			colors = 2;  		if (colors > 256)  			colors = 256;  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' target)) {  			var palette = factory.CreatePalette ();  			com.Add (palette);  			palette.InitializeFromBitmap (data' (uint)colors' true);  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  		}  	}  	//Get size  	uint fw' fh;  	data.GetSize (out fw' out fh);  	//Set destination frame size  	outputFrame.SetSize (fw' fh);  	// Write the data to the output frame  	outputFrame.WriteSource (data' null);  	outputFrame.Commit ();  	encoder.Commit ();  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: try {  	//Find the GUID of the destination format  	Guid guidEncoder = GetOutputFormatWicGuid ();  	//Find out the data's pixel format  	Guid pFormat = Guid.Empty;  	data.GetPixelFormat (out pFormat);  	//Create the encoder  	var encoder = factory.CreateEncoder (guidEncoder' null);  	com.Add (encoder);  	//And initialize it  	encoder.Initialize (outputStream' WICBitmapEncoderCacheOption.WICBitmapEncoderNoCache);  	// Create the output frame and property bag  	IWICBitmapFrameEncode outputFrame;  	var propertyBagArray = new IPropertyBag2[1];  	encoder.CreateNewFrame (out outputFrame' propertyBagArray);  	//An array is used instead of an out parameter... I have no idea why  	com.Add (outputFrame);  	//The property bag is a COM object...  	var propBag = propertyBagArray [0];  	com.Add (propBag);  	//Adjust encoder settings if it's a JPEG  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		//JPEG  		//ImageQuality 0..1  		//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  		//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  		var qualityOption = new PROPBAG2[1];  		qualityOption [0].pstrName = "ImageQuality";  		propBag.Write (1' qualityOption' new object[] {  			((float)Math.Max (0' Math.Min (100' Quality))) / 100  		});  		WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  		//411 NOT SUPPPORTED BY WIC - only by freeimage  		if ("420".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  		if ("422".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  		if ("444".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  		if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  			var samplingOption = new PROPBAG2[1];  			samplingOption [0].pstrName = "JpegYCrCbSubsampling";  			samplingOption [0].vt = VarEnum.VT_UI1;  			propBag.Write (1' samplingOption' new object[] {  				(byte)subsampling  			});  		}  	}  	//PNG interlace  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		var interlaceOption = new PROPBAG2[1];  		interlaceOption [0].pstrName = "InterlaceOption";  		propBag.Write (1' interlaceOption' new object[] {  			Interlace ?? false  		});  	}  	//Apply the property bag  	outputFrame.Initialize (propBag);  	//Convert the bitmap to the correct pixel format for encoding.  	//JPEG: encodes as GUID_WICPixelFormat24bppBGR or GUID_WICPixelFormat8bppGray.  	//If the original pixel format has an alpha channel' we need to specify a matte color.  	//UPDATE - IWICFormatConverter doesn't let you specify a matte color. Disabling code  	if (false && guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		ConversionUtils.HasAlphaAbility (pFormat);  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' Consts.GUID_WICPixelFormat24bppBGR)) {  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  			//Oops' we didn't do anything - there's no way to specify a matte color!  		}  	}  	//GIF encodes as GUID_WICPixelFormat8bppIndexed  	//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut.  	//PNG encodes as EVERYTHING! Way too many formats supported.  	// If the user is specifying a colors setting' we need to  	// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed  	if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  		Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  		int colors = this.Colors;  		if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  			if (colors <= 2)  				target = Consts.GUID_WICPixelFormat1bppIndexed;  			if (colors <= 4)  				target = Consts.GUID_WICPixelFormat2bppIndexed;  			if (colors <= 32)  				target = Consts.GUID_WICPixelFormat4bppIndexed;  		}  		if (colors < 0)  			colors = 256;  		if (colors < 2)  			colors = 2;  		if (colors > 256)  			colors = 256;  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' target)) {  			var palette = factory.CreatePalette ();  			com.Add (palette);  			palette.InitializeFromBitmap (data' (uint)colors' true);  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  		}  	}  	//Get size  	uint fw' fh;  	data.GetSize (out fw' out fh);  	//Set destination frame size  	outputFrame.SetSize (fw' fh);  	// Write the data to the output frame  	outputFrame.WriteSource (data' null);  	outputFrame.Commit ();  	encoder.Commit ();  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: try {  	//Find the GUID of the destination format  	Guid guidEncoder = GetOutputFormatWicGuid ();  	//Find out the data's pixel format  	Guid pFormat = Guid.Empty;  	data.GetPixelFormat (out pFormat);  	//Create the encoder  	var encoder = factory.CreateEncoder (guidEncoder' null);  	com.Add (encoder);  	//And initialize it  	encoder.Initialize (outputStream' WICBitmapEncoderCacheOption.WICBitmapEncoderNoCache);  	// Create the output frame and property bag  	IWICBitmapFrameEncode outputFrame;  	var propertyBagArray = new IPropertyBag2[1];  	encoder.CreateNewFrame (out outputFrame' propertyBagArray);  	//An array is used instead of an out parameter... I have no idea why  	com.Add (outputFrame);  	//The property bag is a COM object...  	var propBag = propertyBagArray [0];  	com.Add (propBag);  	//Adjust encoder settings if it's a JPEG  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		//JPEG  		//ImageQuality 0..1  		//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  		//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  		var qualityOption = new PROPBAG2[1];  		qualityOption [0].pstrName = "ImageQuality";  		propBag.Write (1' qualityOption' new object[] {  			((float)Math.Max (0' Math.Min (100' Quality))) / 100  		});  		WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  		//411 NOT SUPPPORTED BY WIC - only by freeimage  		if ("420".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  		if ("422".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  		if ("444".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  		if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  			var samplingOption = new PROPBAG2[1];  			samplingOption [0].pstrName = "JpegYCrCbSubsampling";  			samplingOption [0].vt = VarEnum.VT_UI1;  			propBag.Write (1' samplingOption' new object[] {  				(byte)subsampling  			});  		}  	}  	//PNG interlace  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		var interlaceOption = new PROPBAG2[1];  		interlaceOption [0].pstrName = "InterlaceOption";  		propBag.Write (1' interlaceOption' new object[] {  			Interlace ?? false  		});  	}  	//Apply the property bag  	outputFrame.Initialize (propBag);  	//Convert the bitmap to the correct pixel format for encoding.  	//JPEG: encodes as GUID_WICPixelFormat24bppBGR or GUID_WICPixelFormat8bppGray.  	//If the original pixel format has an alpha channel' we need to specify a matte color.  	//UPDATE - IWICFormatConverter doesn't let you specify a matte color. Disabling code  	if (false && guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		ConversionUtils.HasAlphaAbility (pFormat);  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' Consts.GUID_WICPixelFormat24bppBGR)) {  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  			//Oops' we didn't do anything - there's no way to specify a matte color!  		}  	}  	//GIF encodes as GUID_WICPixelFormat8bppIndexed  	//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut.  	//PNG encodes as EVERYTHING! Way too many formats supported.  	// If the user is specifying a colors setting' we need to  	// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed  	if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  		Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  		int colors = this.Colors;  		if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  			if (colors <= 2)  				target = Consts.GUID_WICPixelFormat1bppIndexed;  			if (colors <= 4)  				target = Consts.GUID_WICPixelFormat2bppIndexed;  			if (colors <= 32)  				target = Consts.GUID_WICPixelFormat4bppIndexed;  		}  		if (colors < 0)  			colors = 256;  		if (colors < 2)  			colors = 2;  		if (colors > 256)  			colors = 256;  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' target)) {  			var palette = factory.CreatePalette ();  			com.Add (palette);  			palette.InitializeFromBitmap (data' (uint)colors' true);  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  		}  	}  	//Get size  	uint fw' fh;  	data.GetSize (out fw' out fh);  	//Set destination frame size  	outputFrame.SetSize (fw' fh);  	// Write the data to the output frame  	outputFrame.WriteSource (data' null);  	outputFrame.Commit ();  	encoder.Commit ();  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: try {  	//Find the GUID of the destination format  	Guid guidEncoder = GetOutputFormatWicGuid ();  	//Find out the data's pixel format  	Guid pFormat = Guid.Empty;  	data.GetPixelFormat (out pFormat);  	//Create the encoder  	var encoder = factory.CreateEncoder (guidEncoder' null);  	com.Add (encoder);  	//And initialize it  	encoder.Initialize (outputStream' WICBitmapEncoderCacheOption.WICBitmapEncoderNoCache);  	// Create the output frame and property bag  	IWICBitmapFrameEncode outputFrame;  	var propertyBagArray = new IPropertyBag2[1];  	encoder.CreateNewFrame (out outputFrame' propertyBagArray);  	//An array is used instead of an out parameter... I have no idea why  	com.Add (outputFrame);  	//The property bag is a COM object...  	var propBag = propertyBagArray [0];  	com.Add (propBag);  	//Adjust encoder settings if it's a JPEG  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		//JPEG  		//ImageQuality 0..1  		//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  		//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  		var qualityOption = new PROPBAG2[1];  		qualityOption [0].pstrName = "ImageQuality";  		propBag.Write (1' qualityOption' new object[] {  			((float)Math.Max (0' Math.Min (100' Quality))) / 100  		});  		WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  		//411 NOT SUPPPORTED BY WIC - only by freeimage  		if ("420".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  		if ("422".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  		if ("444".Equals (Subsampling))  			subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  		if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  			var samplingOption = new PROPBAG2[1];  			samplingOption [0].pstrName = "JpegYCrCbSubsampling";  			samplingOption [0].vt = VarEnum.VT_UI1;  			propBag.Write (1' samplingOption' new object[] {  				(byte)subsampling  			});  		}  	}  	//PNG interlace  	if (guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		var interlaceOption = new PROPBAG2[1];  		interlaceOption [0].pstrName = "InterlaceOption";  		propBag.Write (1' interlaceOption' new object[] {  			Interlace ?? false  		});  	}  	//Apply the property bag  	outputFrame.Initialize (propBag);  	//Convert the bitmap to the correct pixel format for encoding.  	//JPEG: encodes as GUID_WICPixelFormat24bppBGR or GUID_WICPixelFormat8bppGray.  	//If the original pixel format has an alpha channel' we need to specify a matte color.  	//UPDATE - IWICFormatConverter doesn't let you specify a matte color. Disabling code  	if (false && guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  		ConversionUtils.HasAlphaAbility (pFormat);  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' Consts.GUID_WICPixelFormat24bppBGR)) {  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' Consts.GUID_WICPixelFormat24bppBGR' WICBitmapDitherType.WICBitmapDitherTypeNone' null' 0.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  			//Oops' we didn't do anything - there's no way to specify a matte color!  		}  	}  	//GIF encodes as GUID_WICPixelFormat8bppIndexed  	//If the current format is > 8bpp' quantization may be required' and we may need to manually build the palette with Median Cut.  	//PNG encodes as EVERYTHING! Way too many formats supported.  	// If the user is specifying a colors setting' we need to  	// convert to GUID_WICPixelFormat8bppIndexed' GUID_WICPixelFormat4bppIndexed' GUID_WICPixelFormat2bppIndexed' or GUID_WICPixelFormat1bppIndexed  	if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  		Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  		int colors = this.Colors;  		if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  			if (colors <= 2)  				target = Consts.GUID_WICPixelFormat1bppIndexed;  			if (colors <= 4)  				target = Consts.GUID_WICPixelFormat2bppIndexed;  			if (colors <= 32)  				target = Consts.GUID_WICPixelFormat4bppIndexed;  		}  		if (colors < 0)  			colors = 256;  		if (colors < 2)  			colors = 2;  		if (colors > 256)  			colors = 256;  		var conv = factory.CreateFormatConverter ();  		com.Add (conv);  		if (conv.CanConvert (pFormat' target)) {  			var palette = factory.CreatePalette ();  			com.Add (palette);  			palette.InitializeFromBitmap (data' (uint)colors' true);  			/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  			data = conv;  		}  	}  	//Get size  	uint fw' fh;  	data.GetSize (out fw' out fh);  	//Set destination frame size  	outputFrame.SetSize (fw' fh);  	// Write the data to the output frame  	outputFrame.WriteSource (data' null);  	outputFrame.Commit ();  	encoder.Commit ();  } finally {  	//Manually cleanup all the com reference counts' aggressively  	while (com.Count > 0) {  		Marshal.ReleaseComObject (com [com.Count - 1]);  		//In reverse order' so no item is ever deleted out from under another.  		com.RemoveAt (com.Count - 1);  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  	//JPEG  	//ImageQuality 0..1  	//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  	//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  	var qualityOption = new PROPBAG2[1];  	qualityOption [0].pstrName = "ImageQuality";  	propBag.Write (1' qualityOption' new object[] {  		((float)Math.Max (0' Math.Min (100' Quality))) / 100  	});  	WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  	//411 NOT SUPPPORTED BY WIC - only by freeimage  	if ("420".Equals (Subsampling))  		subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  	if ("422".Equals (Subsampling))  		subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  	if ("444".Equals (Subsampling))  		subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  	if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  		var samplingOption = new PROPBAG2[1];  		samplingOption [0].pstrName = "JpegYCrCbSubsampling";  		samplingOption [0].vt = VarEnum.VT_UI1;  		propBag.Write (1' samplingOption' new object[] {  			(byte)subsampling  		});  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (guidEncoder.Equals (Consts.GUID_ContainerFormatJpeg)) {  	//JPEG  	//ImageQuality 0..1  	//"JpegYCrCbSubsampling"  WICJpegYCrCbSubsamplingOption.  	//Configure encoder settings (see http://msdn.microsoft.com/en-us/library/windows/desktop/ee719871(v=vs.85).aspx#encoderoptions)  	var qualityOption = new PROPBAG2[1];  	qualityOption [0].pstrName = "ImageQuality";  	propBag.Write (1' qualityOption' new object[] {  		((float)Math.Max (0' Math.Min (100' Quality))) / 100  	});  	WICJpegYCrCbSubsamplingOption subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault;  	//411 NOT SUPPPORTED BY WIC - only by freeimage  	if ("420".Equals (Subsampling))  		subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling420;  	if ("422".Equals (Subsampling))  		subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling422;  	if ("444".Equals (Subsampling))  		subsampling = WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsampling444;  	if (subsampling != WICJpegYCrCbSubsamplingOption.WICJpegYCrCbSubsamplingDefault) {  		var samplingOption = new PROPBAG2[1];  		samplingOption [0].pstrName = "JpegYCrCbSubsampling";  		samplingOption [0].vt = VarEnum.VT_UI1;  		propBag.Write (1' samplingOption' new object[] {  			(byte)subsampling  		});  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: propBag.Write (1' qualityOption' new object[] {  	((float)Math.Max (0' Math.Min (100' Quality))) / 100  });  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: propBag.Write (1' qualityOption' new object[] {  	((float)Math.Max (0' Math.Min (100' Quality))) / 100  });  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  	Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  	int colors = this.Colors;  	if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		if (colors <= 2)  			target = Consts.GUID_WICPixelFormat1bppIndexed;  		if (colors <= 4)  			target = Consts.GUID_WICPixelFormat2bppIndexed;  		if (colors <= 32)  			target = Consts.GUID_WICPixelFormat4bppIndexed;  	}  	if (colors < 0)  		colors = 256;  	if (colors < 2)  		colors = 2;  	if (colors > 256)  		colors = 256;  	var conv = factory.CreateFormatConverter ();  	com.Add (conv);  	if (conv.CanConvert (pFormat' target)) {  		var palette = factory.CreatePalette ();  		com.Add (palette);  		palette.InitializeFromBitmap (data' (uint)colors' true);  		/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  		data = conv;  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  	Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  	int colors = this.Colors;  	if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		if (colors <= 2)  			target = Consts.GUID_WICPixelFormat1bppIndexed;  		if (colors <= 4)  			target = Consts.GUID_WICPixelFormat2bppIndexed;  		if (colors <= 32)  			target = Consts.GUID_WICPixelFormat4bppIndexed;  	}  	if (colors < 0)  		colors = 256;  	if (colors < 2)  		colors = 2;  	if (colors > 256)  		colors = 256;  	var conv = factory.CreateFormatConverter ();  	com.Add (conv);  	if (conv.CanConvert (pFormat' target)) {  		var palette = factory.CreatePalette ();  		com.Add (palette);  		palette.InitializeFromBitmap (data' (uint)colors' true);  		/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  		data = conv;  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  	Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  	int colors = this.Colors;  	if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		if (colors <= 2)  			target = Consts.GUID_WICPixelFormat1bppIndexed;  		if (colors <= 4)  			target = Consts.GUID_WICPixelFormat2bppIndexed;  		if (colors <= 32)  			target = Consts.GUID_WICPixelFormat4bppIndexed;  	}  	if (colors < 0)  		colors = 256;  	if (colors < 2)  		colors = 2;  	if (colors > 256)  		colors = 256;  	var conv = factory.CreateFormatConverter ();  	com.Add (conv);  	if (conv.CanConvert (pFormat' target)) {  		var palette = factory.CreatePalette ();  		com.Add (palette);  		palette.InitializeFromBitmap (data' (uint)colors' true);  		/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  		data = conv;  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  	Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  	int colors = this.Colors;  	if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		if (colors <= 2)  			target = Consts.GUID_WICPixelFormat1bppIndexed;  		if (colors <= 4)  			target = Consts.GUID_WICPixelFormat2bppIndexed;  		if (colors <= 32)  			target = Consts.GUID_WICPixelFormat4bppIndexed;  	}  	if (colors < 0)  		colors = 256;  	if (colors < 2)  		colors = 2;  	if (colors > 256)  		colors = 256;  	var conv = factory.CreateFormatConverter ();  	com.Add (conv);  	if (conv.CanConvert (pFormat' target)) {  		var palette = factory.CreatePalette ();  		com.Add (palette);  		palette.InitializeFromBitmap (data' (uint)colors' true);  		/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  		data = conv;  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  	Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  	int colors = this.Colors;  	if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		if (colors <= 2)  			target = Consts.GUID_WICPixelFormat1bppIndexed;  		if (colors <= 4)  			target = Consts.GUID_WICPixelFormat2bppIndexed;  		if (colors <= 32)  			target = Consts.GUID_WICPixelFormat4bppIndexed;  	}  	if (colors < 0)  		colors = 256;  	if (colors < 2)  		colors = 2;  	if (colors > 256)  		colors = 256;  	var conv = factory.CreateFormatConverter ();  	com.Add (conv);  	if (conv.CanConvert (pFormat' target)) {  		var palette = factory.CreatePalette ();  		com.Add (palette);  		palette.InitializeFromBitmap (data' (uint)colors' true);  		/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  		data = conv;  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  	Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  	int colors = this.Colors;  	if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		if (colors <= 2)  			target = Consts.GUID_WICPixelFormat1bppIndexed;  		if (colors <= 4)  			target = Consts.GUID_WICPixelFormat2bppIndexed;  		if (colors <= 32)  			target = Consts.GUID_WICPixelFormat4bppIndexed;  	}  	if (colors < 0)  		colors = 256;  	if (colors < 2)  		colors = 2;  	if (colors > 256)  		colors = 256;  	var conv = factory.CreateFormatConverter ();  	com.Add (conv);  	if (conv.CanConvert (pFormat' target)) {  		var palette = factory.CreatePalette ();  		com.Add (palette);  		palette.InitializeFromBitmap (data' (uint)colors' true);  		/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  		data = conv;  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  	Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  	int colors = this.Colors;  	if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		if (colors <= 2)  			target = Consts.GUID_WICPixelFormat1bppIndexed;  		if (colors <= 4)  			target = Consts.GUID_WICPixelFormat2bppIndexed;  		if (colors <= 32)  			target = Consts.GUID_WICPixelFormat4bppIndexed;  	}  	if (colors < 0)  		colors = 256;  	if (colors < 2)  		colors = 2;  	if (colors > 256)  		colors = 256;  	var conv = factory.CreateFormatConverter ();  	com.Add (conv);  	if (conv.CanConvert (pFormat' target)) {  		var palette = factory.CreatePalette ();  		com.Add (palette);  		palette.InitializeFromBitmap (data' (uint)colors' true);  		/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  		data = conv;  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if ((guidEncoder.Equals (Consts.GUID_ContainerFormatPng) && this.Colors != -1) || (guidEncoder.Equals (Consts.GUID_ContainerFormatGif))) {  	Guid target = Consts.GUID_WICPixelFormat8bppIndexed;  	int colors = this.Colors;  	if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  		if (colors <= 2)  			target = Consts.GUID_WICPixelFormat1bppIndexed;  		if (colors <= 4)  			target = Consts.GUID_WICPixelFormat2bppIndexed;  		if (colors <= 32)  			target = Consts.GUID_WICPixelFormat4bppIndexed;  	}  	if (colors < 0)  		colors = 256;  	if (colors < 2)  		colors = 2;  	if (colors > 256)  		colors = 256;  	var conv = factory.CreateFormatConverter ();  	com.Add (conv);  	if (conv.CanConvert (pFormat' target)) {  		var palette = factory.CreatePalette ();  		com.Add (palette);  		palette.InitializeFromBitmap (data' (uint)colors' true);  		/*dither' pIPalette' alphaThresholdPercent' and paletteTranslate are used to mitigate color loss when                           * converting to a reduced bit-depth format. For conversions that do not need these settings' the                           * following parameters values should be used: dither set to WICBitmapDitherTypeNone' pIPalette set to NULL'                           * alphaThresholdPercent set to 0.0f' and paletteTranslate set to WICBitmapPaletteTypeCustom.*/conv.Initialize (data' target' this.Dither ? WICBitmapDitherType.WICBitmapDitherTypeErrorDiffusion : WICBitmapDitherType.WICBitmapDitherTypeNone' palette' 50.0f' WICBitmapPaletteType.WICBitmapPaletteTypeCustom);  		data = conv;  	}  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  	if (colors <= 2)  		target = Consts.GUID_WICPixelFormat1bppIndexed;  	if (colors <= 4)  		target = Consts.GUID_WICPixelFormat2bppIndexed;  	if (colors <= 32)  		target = Consts.GUID_WICPixelFormat4bppIndexed;  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  	if (colors <= 2)  		target = Consts.GUID_WICPixelFormat1bppIndexed;  	if (colors <= 4)  		target = Consts.GUID_WICPixelFormat2bppIndexed;  	if (colors <= 32)  		target = Consts.GUID_WICPixelFormat4bppIndexed;  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors > 0 && guidEncoder.Equals (Consts.GUID_ContainerFormatPng)) {  	if (colors <= 2)  		target = Consts.GUID_WICPixelFormat1bppIndexed;  	if (colors <= 4)  		target = Consts.GUID_WICPixelFormat2bppIndexed;  	if (colors <= 32)  		target = Consts.GUID_WICPixelFormat4bppIndexed;  }  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors <= 2)  	target = Consts.GUID_WICPixelFormat1bppIndexed;  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors <= 4)  	target = Consts.GUID_WICPixelFormat2bppIndexed;  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors <= 32)  	target = Consts.GUID_WICPixelFormat4bppIndexed;  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors < 0)  	colors = 256;  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: colors = 256;  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors < 2)  	colors = 2;  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors < 2)  	colors = 2;  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: colors = 2;  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors > 256)  	colors = 256;  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: if (colors > 256)  	colors = 256;  
Magic Number,ImageResizer.Plugins.WicEncoder,WicEncoderPlugin,F:\newReposMay17\imazen_resizer\Plugins\Wic\WicEncoder.cs,EncodeToStream,The following statement contains a magic number: colors = 256;  
