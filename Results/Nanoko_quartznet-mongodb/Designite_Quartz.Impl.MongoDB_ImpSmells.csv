Implementation smell,Namespace,Class,File,Method,Description
Long Identifier,Quartz.Impl.MongoDB,JobStore,C:\repos\Nanoko_quartznet-mongodb\src\Quartz.Impl.MongoDB\JobStore.cs,AcquireNextTriggers,The length of the parameter acquiredJobKeysForNoConcurrentExec is 34.
Long Statement,Quartz.Impl.MongoDB,DateTimeOffsetSerializer,C:\repos\Nanoko_quartznet-mongodb\src\Quartz.Impl.MongoDB\DateTimeOffsetSerializer.cs,Deserialize,The length of the statement  "                        value = DateTime.ParseExact(bsonReader.ReadString()' formats' null' DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal); " is 135.
Long Statement,Quartz.Impl.MongoDB,DateTimeOffsetSerializer,C:\repos\Nanoko_quartznet-mongodb\src\Quartz.Impl.MongoDB\DateTimeOffsetSerializer.cs,Serialize,The length of the statement  "                    var message = string.Format("'{0}' is not a valid DateTimeOffset representation."' dateTimeSerializationOptions.Representation); " is 128.
Long Statement,Quartz.Impl.MongoDB,JobStore,C:\repos\Nanoko_quartznet-mongodb\src\Quartz.Impl.MongoDB\JobStore.cs,StoreCalendar,The length of the statement  "                    throw new ObjectAlreadyExistsException(string.Format(CultureInfo.InvariantCulture' "Calendar with name '{0}' already exists."' name)); " is 134.
Long Statement,Quartz.Impl.MongoDB,SetSerializer<T>,C:\repos\Nanoko_quartznet-mongodb\src\Quartz.Impl.MongoDB\SetSerializer.cs,Deserialize,The length of the statement  "            var enumerable = (IEnumerable<T>)enumerableSerializer.Deserialize(bsonReader' typeof(ISet<T>)' typeof(HashSet<T>)' options); " is 124.
Magic Number,Quartz.Impl.MongoDB,JobStore,C:\repos\Nanoko_quartznet-mongodb\src\Quartz.Impl.MongoDB\JobStore.cs,AcquireNextTriggers,The following statement contains a magic number: lock (lockObject)              {                  // multiple instances management                  this.Schedulers.Save(new BsonDocument()                      .SetElement(new BsonElement("_id"' this.instanceId))                      .SetElement(new BsonElement("Expires"' (SystemTime.Now() + new TimeSpan(0' 10' 0)).UtcDateTime))                      .SetElement(new BsonElement("State"' "Running")));                    this.Schedulers.Remove(                      Query.LT("Expires"' SystemTime.Now().UtcDateTime));                    IEnumerable<BsonValue> activeInstances = this.Schedulers.Distinct("_id");                    this.Triggers.Update(                      Query.NotIn("SchedulerInstanceId"' activeInstances)'                      Update.Unset("SchedulerInstanceId")                          .Set("State"' "Waiting"));                    List<IOperableTrigger> result = new List<IOperableTrigger>();                  Collection.ISet<JobKey> acquiredJobKeysForNoConcurrentExec = new Collection.HashSet<JobKey>();                  DateTimeOffset? firstAcquiredTriggerFireTime = null;                                    var candidates = this.Triggers.FindAs<Spi.IOperableTrigger>(                      Query.And(                          Query.EQ("State"' "Waiting")'                          Query.LTE("nextFireTimeUtc"' (noLaterThan + timeWindow).UtcDateTime)))                      .OrderBy(t => t.GetNextFireTimeUtc()).ThenByDescending(t => t.Priority);                                    foreach (IOperableTrigger trigger in candidates)                  {                      if (trigger.GetNextFireTimeUtc() == null)                      {                          continue;                      }                        // it's possible that we've selected triggers way outside of the max fire ahead time for batches                       // (up to idleWaitTime + fireAheadTime) so we need to make sure not to include such triggers.                        // So we select from the first next trigger to fire up until the max fire ahead time after that...                      // which will perfectly honor the fireAheadTime window because the no firing will occur until                      // the first acquired trigger's fire time arrives.                      if (firstAcquiredTriggerFireTime != null                           && trigger.GetNextFireTimeUtc() > (firstAcquiredTriggerFireTime.Value + timeWindow))                      {                          break;                      }                        if (this.ApplyMisfire(trigger))                      {                          if (trigger.GetNextFireTimeUtc() == null                              || trigger.GetNextFireTimeUtc() > noLaterThan + timeWindow)                          {                              continue;                          }                      }                        // If trigger's job is set as @DisallowConcurrentExecution' and it has already been added to result' then                      // put it back into the timeTriggers set and continue to search for next trigger.                      JobKey jobKey = trigger.JobKey;                      IJobDetail job = this.Jobs.FindOneByIdAs<IJobDetail>(jobKey.ToBsonDocument());                                            if (job.ConcurrentExecutionDisallowed)                      {                          if (acquiredJobKeysForNoConcurrentExec.Contains(jobKey))                          {                              continue; // go to next trigger in store.                          }                          else                          {                              acquiredJobKeysForNoConcurrentExec.Add(jobKey);                          }                      }                        trigger.FireInstanceId = this.GetFiredTriggerRecordId();                      var acquired = this.Triggers.FindAndModify(                          Query.And(                              Query.EQ("_id"' trigger.Key.ToBsonDocument())'                              Query.EQ("State"' "Waiting"))'                          SortBy.Null'                          Update.Set("State"' "Acquired")                              .Set("SchedulerInstanceId"' this.instanceId)                              .Set("FireInstanceId"' trigger.FireInstanceId));                        if (acquired.ModifiedDocument != null)                      {                          result.Add(trigger);                            if (firstAcquiredTriggerFireTime == null)                          {                              firstAcquiredTriggerFireTime = trigger.GetNextFireTimeUtc();                          }                      }                        if (result.Count == maxCount)                      {                          break;                      }                  }                    return result;              }
