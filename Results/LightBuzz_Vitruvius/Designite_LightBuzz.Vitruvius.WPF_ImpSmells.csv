Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,LightBuzz.Vitruvius.WPF,CanvasExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\CanvasExtensions.cs,DrawLine,The method has 5 parameters. Parameters: canvas' first' second' color' thickness
Long Statement,LightBuzz.Vitruvius.Controls,KinectCursor,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectCursor.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/LightBuzz.Vitruvius.WPF;component/controls/kinectcursor.xaml"' System.UriKind.Relative); " is 134.
Long Statement,LightBuzz.Vitruvius.Controls,KinectHoverButton,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectHoverButton.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/LightBuzz.Vitruvius.WPF;component/controls/kinecthoverbutton.xaml"' System.UriKind.Relative); " is 139.
Long Statement,LightBuzz.Vitruvius.Controls,KinectHoverButton,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectHoverButton.xaml.cs,Connect,The length of the statement  "            ((LightBuzz.Vitruvius.Controls.KinectHoverButton)(target)).Loaded += new System.Windows.RoutedEventHandler(this.UserControl_Loaded); " is 132.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,DrawJoint,The length of the statement  "                    ColorImagePoint colorPoint = CoordinateMapper.MapSkeletonPointToColorPoint(joint.Position' ColorImageFormat.RgbResolution640x480Fps30); " is 135.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,DrawJoint,The length of the statement  "                    DepthImagePoint depthPoint = CoordinateMapper.MapSkeletonPointToDepthPoint(joint.Position' DepthImageFormat.Resolution320x240Fps30); " is 132.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,DrawBone,The length of the statement  "            if (first.TrackingState == JointTrackingState.NotTracked || second.TrackingState == JointTrackingState.NotTracked) return; " is 122.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,DrawBone,The length of the statement  "                    ColorImagePoint colorFirstPoint = CoordinateMapper.MapSkeletonPointToColorPoint(first.Position' ColorImageFormat.RgbResolution640x480Fps30); " is 140.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,DrawBone,The length of the statement  "                    ColorImagePoint colorSecondPoint = CoordinateMapper.MapSkeletonPointToColorPoint(second.Position' ColorImageFormat.RgbResolution640x480Fps30); " is 142.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,DrawBone,The length of the statement  "                    DepthImagePoint depthFirstPoint = CoordinateMapper.MapSkeletonPointToDepthPoint(first.Position' DepthImageFormat.Resolution320x240Fps30); " is 137.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,DrawBone,The length of the statement  "                    DepthImagePoint depthSecondPoint = CoordinateMapper.MapSkeletonPointToDepthPoint(second.Position' DepthImageFormat.Resolution320x240Fps30); " is 139.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,Update,The length of the statement  "            if (double.IsNaN(canvas.Width) || double.IsNaN(canvas.Height) || canvas.Width == 0.0 || canvas.Height == 0.0 || double.IsInfinity(canvas.Width) || double.IsInfinity(canvas.Height)) " is 180.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,UserControl_SizeChanged,The length of the statement  "            canvas.Width = canvas.Height = 0.0; //note: need to clear this too for "SetCanvasSize()" to be called next time Update method is called " is 135.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/LightBuzz.Vitruvius.WPF;component/controls/kinectviewer.xaml"' System.UriKind.Relative); " is 134.
Long Statement,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,Connect,The length of the statement  "            ((LightBuzz.Vitruvius.Controls.KinectViewer)(target)).SizeChanged += new System.Windows.SizeChangedEventHandler(this.UserControl_SizeChanged); " is 142.
Long Statement,LightBuzz.Vitruvius.WPF,CanvasExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\CanvasExtensions.cs,DrawLine,The length of the statement  "            if (first.TrackingState == JointTrackingState.NotTracked || second.TrackingState == JointTrackingState.NotTracked) return; " is 122.
Long Statement,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateRawFrame,The length of the statement  "            for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4) " is 134.
Long Statement,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GeneratePlayerFrame,The length of the statement  "            for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4) " is 134.
Complex Conditional,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,Update,The conditional expression  "double.IsNaN(canvas.Width) || double.IsNaN(canvas.Height) || canvas.Width == 0.0 || canvas.Height == 0.0 || double.IsInfinity(canvas.Width) || double.IsInfinity(canvas.Height)"  is complex.
Magic Number,LightBuzz.Vitruvius.Controls,KinectHoverButton,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectHoverButton.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 10 "..\..\..\Controls\KinectHoverButton.xaml"              ((LightBuzz.Vitruvius.Controls.KinectHoverButton)(target)).Loaded += new System.Windows.RoutedEventHandler(this.UserControl_Loaded);                            #line default              #line hidden              return;              case 2:              this.Mask = ((System.Windows.Media.SolidColorBrush)(target));              return;              case 3:              this.Effect = ((System.Windows.Media.LinearGradientBrush)(target));              return;              case 4:              this.Icon = ((System.Windows.Controls.Image)(target));              return;              case 5:              this.Text = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,LightBuzz.Vitruvius.Controls,KinectHoverButton,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectHoverButton.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 10 "..\..\..\Controls\KinectHoverButton.xaml"              ((LightBuzz.Vitruvius.Controls.KinectHoverButton)(target)).Loaded += new System.Windows.RoutedEventHandler(this.UserControl_Loaded);                            #line default              #line hidden              return;              case 2:              this.Mask = ((System.Windows.Media.SolidColorBrush)(target));              return;              case 3:              this.Effect = ((System.Windows.Media.LinearGradientBrush)(target));              return;              case 4:              this.Icon = ((System.Windows.Controls.Image)(target));              return;              case 5:              this.Text = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,LightBuzz.Vitruvius.Controls,KinectHoverButton,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectHoverButton.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 10 "..\..\..\Controls\KinectHoverButton.xaml"              ((LightBuzz.Vitruvius.Controls.KinectHoverButton)(target)).Loaded += new System.Windows.RoutedEventHandler(this.UserControl_Loaded);                            #line default              #line hidden              return;              case 2:              this.Mask = ((System.Windows.Media.SolidColorBrush)(target));              return;              case 3:              this.Effect = ((System.Windows.Media.LinearGradientBrush)(target));              return;              case 4:              this.Icon = ((System.Windows.Controls.Image)(target));              return;              case 5:              this.Text = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,LightBuzz.Vitruvius.Controls,KinectHoverButton,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectHoverButton.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 10 "..\..\..\Controls\KinectHoverButton.xaml"              ((LightBuzz.Vitruvius.Controls.KinectHoverButton)(target)).Loaded += new System.Windows.RoutedEventHandler(this.UserControl_Loaded);                            #line default              #line hidden              return;              case 2:              this.Mask = ((System.Windows.Media.SolidColorBrush)(target));              return;              case 3:              this.Effect = ((System.Windows.Media.LinearGradientBrush)(target));              return;              case 4:              this.Icon = ((System.Windows.Controls.Image)(target));              return;              case 5:              this.Text = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,KinectViewer,The following statement contains a magic number: SetValue(RenderTransformOriginProperty' new Point(0.5' 0.5));
Magic Number,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,KinectViewer,The following statement contains a magic number: SetValue(RenderTransformOriginProperty' new Point(0.5' 0.5));
Magic Number,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,DrawJoint,The following statement contains a magic number: Canvas.SetLeft(ellipse' point.X - ellipse.Width / 2);
Magic Number,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,DrawJoint,The following statement contains a magic number: Canvas.SetTop(ellipse' point.Y - ellipse.Height / 2);
Magic Number,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 10 "..\..\..\Controls\KinectViewer.xaml"              ((LightBuzz.Vitruvius.Controls.KinectViewer)(target)).SizeChanged += new System.Windows.SizeChangedEventHandler(this.UserControl_SizeChanged);                            #line default              #line hidden              return;              case 2:              this.camera = ((System.Windows.Controls.Image)(target));              return;              case 3:              this.canvas = ((System.Windows.Controls.Canvas)(target));              return;              }
Magic Number,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 10 "..\..\..\Controls\KinectViewer.xaml"              ((LightBuzz.Vitruvius.Controls.KinectViewer)(target)).SizeChanged += new System.Windows.SizeChangedEventHandler(this.UserControl_SizeChanged);                            #line default              #line hidden              return;              case 2:              this.camera = ((System.Windows.Controls.Image)(target));              return;              case 3:              this.canvas = ((System.Windows.Controls.Canvas)(target));              return;              }
Magic Number,LightBuzz.Vitruvius.WPF,CanvasExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\CanvasExtensions.cs,DrawPoint,The following statement contains a magic number: Canvas.SetLeft(ellipse' joint.Position.X - ellipse.Width / 2);
Magic Number,LightBuzz.Vitruvius.WPF,CanvasExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\CanvasExtensions.cs,DrawPoint,The following statement contains a magic number: Canvas.SetTop(ellipse' joint.Position.Y - ellipse.Height / 2);
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = _depthData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = _depthData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      _pixels[colorIndex + BLUE_INDEX] = 255;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 255;                      _pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 255;                  }                    // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  _pixels[colorIndex + BLUE_INDEX] = intensity;                  _pixels[colorIndex + GREEN_INDEX] = intensity;                  _pixels[colorIndex + RED_INDEX] = intensity;                    // Color all players "gold".                  if (player > 0)                  {                      _pixels[colorIndex + BLUE_INDEX] = Colors.Gold.B;                      _pixels[colorIndex + GREEN_INDEX] = Colors.Gold.G;                      _pixels[colorIndex + RED_INDEX] = Colors.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = _depthData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = _depthData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      _pixels[colorIndex + BLUE_INDEX] = 255;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 255;                      _pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 255;                  }                    // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  _pixels[colorIndex + BLUE_INDEX] = intensity;                  _pixels[colorIndex + GREEN_INDEX] = intensity;                  _pixels[colorIndex + RED_INDEX] = intensity;                    // Color all players "gold".                  if (player > 0)                  {                      _pixels[colorIndex + BLUE_INDEX] = Colors.Gold.B;                      _pixels[colorIndex + GREEN_INDEX] = Colors.Gold.G;                      _pixels[colorIndex + RED_INDEX] = Colors.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = _depthData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = _depthData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      _pixels[colorIndex + BLUE_INDEX] = 255;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 255;                      _pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 255;                  }                    // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  _pixels[colorIndex + BLUE_INDEX] = intensity;                  _pixels[colorIndex + GREEN_INDEX] = intensity;                  _pixels[colorIndex + RED_INDEX] = intensity;                    // Color all players "gold".                  if (player > 0)                  {                      _pixels[colorIndex + BLUE_INDEX] = Colors.Gold.B;                      _pixels[colorIndex + GREEN_INDEX] = Colors.Gold.G;                      _pixels[colorIndex + RED_INDEX] = Colors.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = _depthData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = _depthData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      _pixels[colorIndex + BLUE_INDEX] = 255;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 255;                      _pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 255;                  }                    // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  _pixels[colorIndex + BLUE_INDEX] = intensity;                  _pixels[colorIndex + GREEN_INDEX] = intensity;                  _pixels[colorIndex + RED_INDEX] = intensity;                    // Color all players "gold".                  if (player > 0)                  {                      _pixels[colorIndex + BLUE_INDEX] = Colors.Gold.B;                      _pixels[colorIndex + GREEN_INDEX] = Colors.Gold.G;                      _pixels[colorIndex + RED_INDEX] = Colors.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = _depthData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = _depthData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      _pixels[colorIndex + BLUE_INDEX] = 255;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 255;                      _pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 255;                  }                    // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  _pixels[colorIndex + BLUE_INDEX] = intensity;                  _pixels[colorIndex + GREEN_INDEX] = intensity;                  _pixels[colorIndex + RED_INDEX] = intensity;                    // Color all players "gold".                  if (player > 0)                  {                      _pixels[colorIndex + BLUE_INDEX] = Colors.Gold.B;                      _pixels[colorIndex + GREEN_INDEX] = Colors.Gold.G;                      _pixels[colorIndex + RED_INDEX] = Colors.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = _depthData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = _depthData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      _pixels[colorIndex + BLUE_INDEX] = 255;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 255;                      _pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 255;                  }                    // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  _pixels[colorIndex + BLUE_INDEX] = intensity;                  _pixels[colorIndex + GREEN_INDEX] = intensity;                  _pixels[colorIndex + RED_INDEX] = intensity;                    // Color all players "gold".                  if (player > 0)                  {                      _pixels[colorIndex + BLUE_INDEX] = Colors.Gold.B;                      _pixels[colorIndex + GREEN_INDEX] = Colors.Gold.G;                      _pixels[colorIndex + RED_INDEX] = Colors.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = _depthData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = _depthData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      _pixels[colorIndex + BLUE_INDEX] = 255;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 255;                      _pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 255;                  }                    // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  _pixels[colorIndex + BLUE_INDEX] = intensity;                  _pixels[colorIndex + GREEN_INDEX] = intensity;                  _pixels[colorIndex + RED_INDEX] = intensity;                    // Color all players "gold".                  if (player > 0)                  {                      _pixels[colorIndex + BLUE_INDEX] = Colors.Gold.B;                      _pixels[colorIndex + GREEN_INDEX] = Colors.Gold.G;                      _pixels[colorIndex + RED_INDEX] = Colors.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = _depthData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = _depthData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      _pixels[colorIndex + BLUE_INDEX] = 255;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 255;                      _pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 255;                  }                    // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  _pixels[colorIndex + BLUE_INDEX] = intensity;                  _pixels[colorIndex + GREEN_INDEX] = intensity;                  _pixels[colorIndex + RED_INDEX] = intensity;                    // Color all players "gold".                  if (player > 0)                  {                      _pixels[colorIndex + BLUE_INDEX] = Colors.Gold.B;                      _pixels[colorIndex + GREEN_INDEX] = Colors.Gold.G;                      _pixels[colorIndex + RED_INDEX] = Colors.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GeneratePlayerFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < _depthData.Length && colorIndex < _pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = _depthData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = _depthData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // Color all players "gold".                  if (player > 0)                  {                      _pixels[colorIndex + BLUE_INDEX] = Colors.Gold.B;                      _pixels[colorIndex + GREEN_INDEX] = Colors.Gold.G;                      _pixels[colorIndex + RED_INDEX] = Colors.Gold.R;                  }                  else                  {                      _pixels[colorIndex + BLUE_INDEX] = 0;                      _pixels[colorIndex + GREEN_INDEX] = 0;                      _pixels[colorIndex + RED_INDEX] = 0;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateDarkFrame,The following statement contains a magic number: int loThreshold = 1220;
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateDarkFrame,The following statement contains a magic number: int hiThreshold = 3048;
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateDarkFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < _depthData.Length; i++' j += Constants.BYTES_PER_PIXEL)              {                  int depth = _depthData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    int gray = (depth < loThreshold || depth > hiThreshold) ? 0xFF : (255 * depth / 0xFFF);                    _pixels[j] = _pixels[j + 1] = _pixels[j + 2] = (byte)gray;              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateDarkFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < _depthData.Length; i++' j += Constants.BYTES_PER_PIXEL)              {                  int depth = _depthData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    int gray = (depth < loThreshold || depth > hiThreshold) ? 0xFF : (255 * depth / 0xFFF);                    _pixels[j] = _pixels[j + 1] = _pixels[j + 2] = (byte)gray;              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: int loThreshold = 1220;
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: int hiThreshold = 3048;
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: int bytesPerPixel = 4;
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: byte[] rgb = new byte[3];
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < _depthData.Length; i++' j += bytesPerPixel)              {                  depth = _depthData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      _pixels[j] = 0x00;                      _pixels[j + 1] = 0x00;                      _pixels[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        _pixels[j] = rgb[2];  //Blue                      _pixels[j + 1] = rgb[1];  //Green                      _pixels[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < _depthData.Length; i++' j += bytesPerPixel)              {                  depth = _depthData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      _pixels[j] = 0x00;                      _pixels[j + 1] = 0x00;                      _pixels[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        _pixels[j] = rgb[2];  //Blue                      _pixels[j + 1] = rgb[1];  //Green                      _pixels[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < _depthData.Length; i++' j += bytesPerPixel)              {                  depth = _depthData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      _pixels[j] = 0x00;                      _pixels[j + 1] = 0x00;                      _pixels[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        _pixels[j] = rgb[2];  //Blue                      _pixels[j + 1] = rgb[1];  //Green                      _pixels[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < _depthData.Length; i++' j += bytesPerPixel)              {                  depth = _depthData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      _pixels[j] = 0x00;                      _pixels[j + 1] = 0x00;                      _pixels[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        _pixels[j] = rgb[2];  //Blue                      _pixels[j + 1] = rgb[1];  //Green                      _pixels[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < _depthData.Length; i++' j += bytesPerPixel)              {                  depth = _depthData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      _pixels[j] = 0x00;                      _pixels[j + 1] = 0x00;                      _pixels[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        _pixels[j] = rgb[2];  //Blue                      _pixels[j + 1] = rgb[1];  //Green                      _pixels[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < _depthData.Length; i++' j += bytesPerPixel)              {                  depth = _depthData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      _pixels[j] = 0x00;                      _pixels[j + 1] = 0x00;                      _pixels[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        _pixels[j] = rgb[2];  //Blue                      _pixels[j + 1] = rgb[1];  //Green                      _pixels[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: hue %= 360.0;
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: saturation /= 100.0;
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: lightness /= 100.0;
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: if (saturation == 0.0)              {                  red = lightness;                  green = lightness;                  blue = lightness;              }              else              {                  double huePrime = hue / 60.0;                  int x = (int)huePrime;                  double xPrime = huePrime - (double)x;                  double L0 = lightness * (1.0 - saturation);                  double L1 = lightness * (1.0 - (saturation * xPrime));                  double L2 = lightness * (1.0 - (saturation * (1.0 - xPrime)));                    switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: if (saturation == 0.0)              {                  red = lightness;                  green = lightness;                  blue = lightness;              }              else              {                  double huePrime = hue / 60.0;                  int x = (int)huePrime;                  double xPrime = huePrime - (double)x;                  double L0 = lightness * (1.0 - saturation);                  double L1 = lightness * (1.0 - (saturation * xPrime));                  double L2 = lightness * (1.0 - (saturation * (1.0 - xPrime)));                    switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: if (saturation == 0.0)              {                  red = lightness;                  green = lightness;                  blue = lightness;              }              else              {                  double huePrime = hue / 60.0;                  int x = (int)huePrime;                  double xPrime = huePrime - (double)x;                  double L0 = lightness * (1.0 - saturation);                  double L1 = lightness * (1.0 - (saturation * xPrime));                  double L2 = lightness * (1.0 - (saturation * (1.0 - xPrime)));                    switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: if (saturation == 0.0)              {                  red = lightness;                  green = lightness;                  blue = lightness;              }              else              {                  double huePrime = hue / 60.0;                  int x = (int)huePrime;                  double xPrime = huePrime - (double)x;                  double L0 = lightness * (1.0 - saturation);                  double L1 = lightness * (1.0 - (saturation * xPrime));                  double L2 = lightness * (1.0 - (saturation * (1.0 - xPrime)));                    switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: if (saturation == 0.0)              {                  red = lightness;                  green = lightness;                  blue = lightness;              }              else              {                  double huePrime = hue / 60.0;                  int x = (int)huePrime;                  double xPrime = huePrime - (double)x;                  double L0 = lightness * (1.0 - saturation);                  double L1 = lightness * (1.0 - (saturation * xPrime));                  double L2 = lightness * (1.0 - (saturation * (1.0 - xPrime)));                    switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }              }
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: rgb[0] = (byte)(255.0 * red);
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: rgb[1] = (byte)(255.0 * green);
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: rgb[2] = (byte)(255.0 * blue);
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: rgb[2] = (byte)(255.0 * blue);
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,CalculateIntensityFromDepth,The following statement contains a magic number: return (byte)(255 - (255 * Math.Max(distance - MIN_DEPTH_DISTANCE' 0) / (MAX_DEPTH_DISTANCE_OFFSET)));
Magic Number,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,CalculateIntensityFromDepth,The following statement contains a magic number: return (byte)(255 - (255 * Math.Max(distance - MIN_DEPTH_DISTANCE' 0) / (MAX_DEPTH_DISTANCE_OFFSET)));
Missing Default,LightBuzz.Vitruvius.Controls,KinectCursor,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectCursor.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.root = ((System.Windows.Shapes.Path)(target));              return;              }
Missing Default,LightBuzz.Vitruvius.Controls,KinectHoverButton,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectHoverButton.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:                            #line 10 "..\..\..\Controls\KinectHoverButton.xaml"              ((LightBuzz.Vitruvius.Controls.KinectHoverButton)(target)).Loaded += new System.Windows.RoutedEventHandler(this.UserControl_Loaded);                            #line default              #line hidden              return;              case 2:              this.Mask = ((System.Windows.Media.SolidColorBrush)(target));              return;              case 3:              this.Effect = ((System.Windows.Media.LinearGradientBrush)(target));              return;              case 4:              this.Icon = ((System.Windows.Controls.Image)(target));              return;              case 5:              this.Text = ((System.Windows.Controls.TextBlock)(target));              return;              }
Missing Default,LightBuzz.Vitruvius.Controls,KinectViewer,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Controls\KinectViewer.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:                            #line 10 "..\..\..\Controls\KinectViewer.xaml"              ((LightBuzz.Vitruvius.Controls.KinectViewer)(target)).SizeChanged += new System.Windows.SizeChangedEventHandler(this.UserControl_SizeChanged);                            #line default              #line hidden              return;              case 2:              this.camera = ((System.Windows.Controls.Image)(target));              return;              case 3:              this.canvas = ((System.Windows.Controls.Canvas)(target));              return;              }
Missing Default,LightBuzz.Vitruvius.WPF,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WPF\Extensions\DepthExtensions.cs,ConvertHslToRgb,The following switch statement is missing a default case: switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }
