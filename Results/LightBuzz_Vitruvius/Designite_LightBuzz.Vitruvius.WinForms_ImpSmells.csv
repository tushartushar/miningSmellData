Implementation smell,Namespace,Class,File,Method,Description
Long Statement,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateRawFrame,The length of the statement  "            for (int depthIndex = 0' colorIndex = 0; depthIndex < pixelData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4) " is 132.
Long Statement,LightBuzz.Vitruvius.WinForms,ImageExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\ImageExtensions.cs,ToBitmap,The length of the statement  "            BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' width' height)' ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 121.
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: byte[] pixels = new byte[frame.Height * frame.Width * 4];
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < pixelData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = pixelData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = pixelData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      pixels[colorIndex + BLUE_INDEX] = 255;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 255;                      pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 255;                  }                      // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  pixels[colorIndex + BLUE_INDEX] = intensity;                  pixels[colorIndex + GREEN_INDEX] = intensity;                  pixels[colorIndex + RED_INDEX] = intensity;                      // Color all players "gold".                  if (player > 0)                  {                      pixels[colorIndex + BLUE_INDEX] = Color.Gold.B;                      pixels[colorIndex + GREEN_INDEX] = Color.Gold.G;                      pixels[colorIndex + RED_INDEX] = Color.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < pixelData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = pixelData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = pixelData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      pixels[colorIndex + BLUE_INDEX] = 255;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 255;                      pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 255;                  }                      // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  pixels[colorIndex + BLUE_INDEX] = intensity;                  pixels[colorIndex + GREEN_INDEX] = intensity;                  pixels[colorIndex + RED_INDEX] = intensity;                      // Color all players "gold".                  if (player > 0)                  {                      pixels[colorIndex + BLUE_INDEX] = Color.Gold.B;                      pixels[colorIndex + GREEN_INDEX] = Color.Gold.G;                      pixels[colorIndex + RED_INDEX] = Color.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < pixelData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = pixelData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = pixelData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      pixels[colorIndex + BLUE_INDEX] = 255;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 255;                      pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 255;                  }                      // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  pixels[colorIndex + BLUE_INDEX] = intensity;                  pixels[colorIndex + GREEN_INDEX] = intensity;                  pixels[colorIndex + RED_INDEX] = intensity;                      // Color all players "gold".                  if (player > 0)                  {                      pixels[colorIndex + BLUE_INDEX] = Color.Gold.B;                      pixels[colorIndex + GREEN_INDEX] = Color.Gold.G;                      pixels[colorIndex + RED_INDEX] = Color.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < pixelData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = pixelData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = pixelData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      pixels[colorIndex + BLUE_INDEX] = 255;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 255;                      pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 255;                  }                      // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  pixels[colorIndex + BLUE_INDEX] = intensity;                  pixels[colorIndex + GREEN_INDEX] = intensity;                  pixels[colorIndex + RED_INDEX] = intensity;                      // Color all players "gold".                  if (player > 0)                  {                      pixels[colorIndex + BLUE_INDEX] = Color.Gold.B;                      pixels[colorIndex + GREEN_INDEX] = Color.Gold.G;                      pixels[colorIndex + RED_INDEX] = Color.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < pixelData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = pixelData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = pixelData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      pixels[colorIndex + BLUE_INDEX] = 255;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 255;                      pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 255;                  }                      // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  pixels[colorIndex + BLUE_INDEX] = intensity;                  pixels[colorIndex + GREEN_INDEX] = intensity;                  pixels[colorIndex + RED_INDEX] = intensity;                      // Color all players "gold".                  if (player > 0)                  {                      pixels[colorIndex + BLUE_INDEX] = Color.Gold.B;                      pixels[colorIndex + GREEN_INDEX] = Color.Gold.G;                      pixels[colorIndex + RED_INDEX] = Color.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < pixelData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = pixelData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = pixelData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      pixels[colorIndex + BLUE_INDEX] = 255;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 255;                      pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 255;                  }                      // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  pixels[colorIndex + BLUE_INDEX] = intensity;                  pixels[colorIndex + GREEN_INDEX] = intensity;                  pixels[colorIndex + RED_INDEX] = intensity;                      // Color all players "gold".                  if (player > 0)                  {                      pixels[colorIndex + BLUE_INDEX] = Color.Gold.B;                      pixels[colorIndex + GREEN_INDEX] = Color.Gold.G;                      pixels[colorIndex + RED_INDEX] = Color.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < pixelData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = pixelData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = pixelData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      pixels[colorIndex + BLUE_INDEX] = 255;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 255;                      pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 255;                  }                      // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  pixels[colorIndex + BLUE_INDEX] = intensity;                  pixels[colorIndex + GREEN_INDEX] = intensity;                  pixels[colorIndex + RED_INDEX] = intensity;                      // Color all players "gold".                  if (player > 0)                  {                      pixels[colorIndex + BLUE_INDEX] = Color.Gold.B;                      pixels[colorIndex + GREEN_INDEX] = Color.Gold.G;                      pixels[colorIndex + RED_INDEX] = Color.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateRawFrame,The following statement contains a magic number: for (int depthIndex = 0' colorIndex = 0; depthIndex < pixelData.Length && colorIndex < pixels.Length; depthIndex++' colorIndex += 4)              {                  // Get the player (requires skeleton tracking enabled for values).                  int player = pixelData[depthIndex] & DepthImageFrame.PlayerIndexBitmask;                    // Get the depth value.                  int depth = pixelData[depthIndex] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    // .9M or 2.95'                  if (depth <= 900) // ---> We are very close.                  {                      pixels[colorIndex + BLUE_INDEX] = 255;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 0;                    }                  // .9M - 2M or 2.95' - 6.56'                  else if (depth > 900 && depth < 2000) // ---> We are a bit further away.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 255;                      pixels[colorIndex + RED_INDEX] = 0;                  }                  // 2M+ or 6.56'+                  else if (depth > 2000) // ---> We are the farthest.                  {                      pixels[colorIndex + BLUE_INDEX] = 0;                      pixels[colorIndex + GREEN_INDEX] = 0;                      pixels[colorIndex + RED_INDEX] = 255;                  }                      // Equal coloring for monochromatic histogram.                  byte intensity = CalculateIntensityFromDepth(depth);                  pixels[colorIndex + BLUE_INDEX] = intensity;                  pixels[colorIndex + GREEN_INDEX] = intensity;                  pixels[colorIndex + RED_INDEX] = intensity;                      // Color all players "gold".                  if (player > 0)                  {                      pixels[colorIndex + BLUE_INDEX] = Color.Gold.B;                      pixels[colorIndex + GREEN_INDEX] = Color.Gold.G;                      pixels[colorIndex + RED_INDEX] = Color.Gold.R;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateDarkFrame,The following statement contains a magic number: int loThreshold = 1220;
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateDarkFrame,The following statement contains a magic number: int hiThreshold = 3048;
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateDarkFrame,The following statement contains a magic number: int bytesPerPixel = 4;
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateDarkFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < pixelData.Length; i++' j += bytesPerPixel)              {                  depth = pixelData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      gray = 0xFF;                  }                  else                  {                      gray = (255 * depth / 0xFFF);                  }                    enhPixelData[j] = (byte)gray;                  enhPixelData[j + 1] = (byte)gray;                  enhPixelData[j + 2] = (byte)gray;              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateDarkFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < pixelData.Length; i++' j += bytesPerPixel)              {                  depth = pixelData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      gray = 0xFF;                  }                  else                  {                      gray = (255 * depth / 0xFFF);                  }                    enhPixelData[j] = (byte)gray;                  enhPixelData[j + 1] = (byte)gray;                  enhPixelData[j + 2] = (byte)gray;              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: int loThreshold = 1220;
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: int hiThreshold = 3048;
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: int bytesPerPixel = 4;
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: byte[] rgb = new byte[3];
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < pixelData.Length; i++' j += bytesPerPixel)              {                  depth = pixelData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      enhPixelData[j] = 0x00;                      enhPixelData[j + 1] = 0x00;                      enhPixelData[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        enhPixelData[j] = rgb[2];  //Blue                      enhPixelData[j + 1] = rgb[1];  //Green                      enhPixelData[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < pixelData.Length; i++' j += bytesPerPixel)              {                  depth = pixelData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      enhPixelData[j] = 0x00;                      enhPixelData[j + 1] = 0x00;                      enhPixelData[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        enhPixelData[j] = rgb[2];  //Blue                      enhPixelData[j + 1] = rgb[1];  //Green                      enhPixelData[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < pixelData.Length; i++' j += bytesPerPixel)              {                  depth = pixelData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      enhPixelData[j] = 0x00;                      enhPixelData[j + 1] = 0x00;                      enhPixelData[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        enhPixelData[j] = rgb[2];  //Blue                      enhPixelData[j + 1] = rgb[1];  //Green                      enhPixelData[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < pixelData.Length; i++' j += bytesPerPixel)              {                  depth = pixelData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      enhPixelData[j] = 0x00;                      enhPixelData[j + 1] = 0x00;                      enhPixelData[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        enhPixelData[j] = rgb[2];  //Blue                      enhPixelData[j + 1] = rgb[1];  //Green                      enhPixelData[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < pixelData.Length; i++' j += bytesPerPixel)              {                  depth = pixelData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      enhPixelData[j] = 0x00;                      enhPixelData[j + 1] = 0x00;                      enhPixelData[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        enhPixelData[j] = rgb[2];  //Blue                      enhPixelData[j + 1] = rgb[1];  //Green                      enhPixelData[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,GenerateColoredFrame,The following statement contains a magic number: for (int i = 0' j = 0; i < pixelData.Length; i++' j += bytesPerPixel)              {                  depth = pixelData[i] >> DepthImageFrame.PlayerIndexBitmaskWidth;                    if (depth < loThreshold || depth > hiThreshold)                  {                      enhPixelData[j] = 0x00;                      enhPixelData[j + 1] = 0x00;                      enhPixelData[j + 2] = 0x00;                  }                  else                  {                      hue = ((360 * depth / 0xFFF) + loThreshold);                      ConvertHslToRgb(hue' 100' 100' rgb);                        enhPixelData[j] = rgb[2];  //Blue                      enhPixelData[j + 1] = rgb[1];  //Green                      enhPixelData[j + 2] = rgb[0];  //Red                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: hue = hue % 360.0;
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: saturation = saturation / 100.0;
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: lightness = lightness / 100.0;
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: if (saturation == 0.0)              {                  red = lightness;                  green = lightness;                  blue = lightness;              }              else              {                  double huePrime = hue / 60.0;                  int x = (int)huePrime;                  double xPrime = huePrime - (double)x;                  double L0 = lightness * (1.0 - saturation);                  double L1 = lightness * (1.0 - (saturation * xPrime));                  double L2 = lightness * (1.0 - (saturation * (1.0 - xPrime)));                    switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: if (saturation == 0.0)              {                  red = lightness;                  green = lightness;                  blue = lightness;              }              else              {                  double huePrime = hue / 60.0;                  int x = (int)huePrime;                  double xPrime = huePrime - (double)x;                  double L0 = lightness * (1.0 - saturation);                  double L1 = lightness * (1.0 - (saturation * xPrime));                  double L2 = lightness * (1.0 - (saturation * (1.0 - xPrime)));                    switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: if (saturation == 0.0)              {                  red = lightness;                  green = lightness;                  blue = lightness;              }              else              {                  double huePrime = hue / 60.0;                  int x = (int)huePrime;                  double xPrime = huePrime - (double)x;                  double L0 = lightness * (1.0 - saturation);                  double L1 = lightness * (1.0 - (saturation * xPrime));                  double L2 = lightness * (1.0 - (saturation * (1.0 - xPrime)));                    switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: if (saturation == 0.0)              {                  red = lightness;                  green = lightness;                  blue = lightness;              }              else              {                  double huePrime = hue / 60.0;                  int x = (int)huePrime;                  double xPrime = huePrime - (double)x;                  double L0 = lightness * (1.0 - saturation);                  double L1 = lightness * (1.0 - (saturation * xPrime));                  double L2 = lightness * (1.0 - (saturation * (1.0 - xPrime)));                    switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: if (saturation == 0.0)              {                  red = lightness;                  green = lightness;                  blue = lightness;              }              else              {                  double huePrime = hue / 60.0;                  int x = (int)huePrime;                  double xPrime = huePrime - (double)x;                  double L0 = lightness * (1.0 - saturation);                  double L1 = lightness * (1.0 - (saturation * xPrime));                  double L2 = lightness * (1.0 - (saturation * (1.0 - xPrime)));                    switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }              }
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: rgb[0] = (byte)(255.0 * red);
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: rgb[1] = (byte)(255.0 * green);
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: rgb[2] = (byte)(255.0 * blue);
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following statement contains a magic number: rgb[2] = (byte)(255.0 * blue);
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,CalculateIntensityFromDepth,The following statement contains a magic number: return (byte)(255 - (255 * Math.Max(distance - MIN_DEPTH_DISTANCE' 0) / (MAX_DEPTH_DISTANCE_OFFSET)));
Magic Number,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,CalculateIntensityFromDepth,The following statement contains a magic number: return (byte)(255 - (255 * Math.Max(distance - MIN_DEPTH_DISTANCE' 0) / (MAX_DEPTH_DISTANCE_OFFSET)));
Missing Default,LightBuzz.Vitruvius.WinForms,DepthExtensions,C:\repos\LightBuzz_Vitruvius\Kinect v1\LightBuzz.Vitruvius.WinForms\DepthExtensions.cs,ConvertHslToRgb,The following switch statement is missing a default case: switch (x)                  {                      case 0:                          red = lightness;                          green = L2;                          blue = L0;                          break;                      case 1:                          red = L1;                          green = lightness;                          blue = L0;                          break;                      case 2:                          red = L0;                          green = lightness;                          blue = L2;                          break;                      case 3:                          red = L0;                          green = L1;                          blue = lightness;                          break;                      case 4:                          red = L2;                          green = L0;                          blue = lightness;                          break;                      case 5:                          red = lightness;                          green = L0;                          blue = L1;                          break;                  }
