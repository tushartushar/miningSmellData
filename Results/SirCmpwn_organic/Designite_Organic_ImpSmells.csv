Implementation smell,Namespace,Class,File,Method,Description
Long Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,Assemble,The method has 556 lines of code.
Long Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,The method has 198 lines of code.
Long Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,MatchString,The method has 130 lines of code.
Long Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseDirectives,The method has 478 lines of code.
Long Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseExpression,The method has 319 lines of code.
Long Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,Main,The method has 249 lines of code.
Long Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,CreateListing,The method has 134 lines of code.
Complex Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,Assemble,Cyclomatic complexity of the method is 104
Complex Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,Cyclomatic complexity of the method is 48
Complex Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,MatchString,Cyclomatic complexity of the method is 24
Complex Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseDirectives,Cyclomatic complexity of the method is 97
Complex Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseExpression,Cyclomatic complexity of the method is 69
Complex Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateParenthesis,Cyclomatic complexity of the method is 9
Complex Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,GetOperands,Cyclomatic complexity of the method is 12
Complex Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,HasOperators,Cyclomatic complexity of the method is 10
Complex Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,Main,Cyclomatic complexity of the method is 55
Complex Method,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,CreateListing,Cyclomatic complexity of the method is 25
Complex Method,Organic,Extensions,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Extensions.cs,SafeSplit,Cyclomatic complexity of the method is 8
Complex Method,Organic,Extensions,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Extensions.cs,Unescape,Cyclomatic complexity of the method is 18
Complex Method,Organic,ListEntry,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\ListEntry.cs,GetFriendlyErrorMessage,Cyclomatic complexity of the method is 14
Long Parameter List,Organic,ListEntry,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\ListEntry.cs,ListEntry,The method has 5 parameters. Parameters: LineValue' File' LineNumber' Address' Listed
Long Parameter List,Organic,ListEntry,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\ListEntry.cs,ListEntry,The method has 5 parameters. Parameters: LineValue' File' LineNumber' Address' ErrorCode
Long Parameter List,Organic,ListEntry,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\ListEntry.cs,ListEntry,The method has 6 parameters. Parameters: LineValue' File' LineNumber' Address' ErrorCode' Listed
Long Parameter List,Organic,ListEntry,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\ListEntry.cs,ListEntry,The method has 5 parameters. Parameters: LineValue' File' LineNumber' Output' Address
Long Parameter List,Organic,ListEntry,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\ListEntry.cs,ListEntry,The method has 6 parameters. Parameters: LineValue' File' LineNumber' Output' Address' Listed
Long Parameter List,Organic,ListEntry,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\ListEntry.cs,ListEntry,The method has 7 parameters. Parameters: LineValue' File' LineNumber' Output' Address' Listed' WarningCode
Long Parameter List,Organic,ListEntry,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\ListEntry.cs,ListEntry,The method has 6 parameters. Parameters: LineValue' File' LineNumber' Output' Address' ErrorCode
Long Parameter List,Organic,ListEntry,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\ListEntry.cs,ListEntry,The method has 7 parameters. Parameters: LineValue' File' LineNumber' Output' Address' ErrorCode' Listed
Long Parameter List,Organic,ListEntry,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\ListEntry.cs,ListEntry,The method has 6 parameters. Parameters: LineValue' File' LineNumber' Output' Address' WarningCode
Long Statement,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,The length of the statement  "                        output[TableInsertionIndex].Output = new ushort[] { (ushort)RelocatedAddresses.Count }.Concat(RelocatedAddresses).ToArray(); " is 124.
Long Statement,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,The length of the statement  "                                if ((result.Value == 0xFFFF || result.Value <= 30) && !ForceLongLiterals && TableInsertionIndex == -1 && output[i].ValueA.value == 0x1F) " is 136.
Long Statement,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseDirectives,The length of the statement  "                else if (directive.ToLower().StartsWith("equ") || directive.ToLower().StartsWith("define") || directive.ToLower().StartsWith("equate")) " is 135.
Long Statement,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseDirectives,The length of the statement  "                            output.Add(new ListEntry(line' FileNames.Peek()' LineNumbers.Peek()' new ushort[result.Value]' currentAddress' !noList)); " is 121.
Long Statement,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseExpression,The length of the statement  "                    expressionResult.Value = (ushort)(left.Value > 0 ^ right.Value > 1 ? 1 : 0); // between boolean operators' ^ is ^^ in C# " is 120.
Long Statement,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateParenthesis,The length of the statement  "                ExpressionResult subExpression = ParseExpression(value.Substring(openingParenthesis + 1' closingParenthesis - (openingParenthesis + 1))); " is 137.
Long Statement,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,SearchPlugins,The length of the statement  "                if (node.Attribute("name").Value.ToLower().Contains(terms) || node.Attribute("description").Value.ToLower().Contains(terms)) " is 124.
Complex Conditional,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,Assemble,The conditional expression  "label.Contains(' ') || label.Contains('\t') || !(char.IsLetter(label[0]) || label[0] == '.' || label[0] == '_')"  is complex.
Complex Conditional,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,Assemble,The conditional expression  "valueA.value == valueB.value && valueA.value != 0x1E && valueB.value != 0x1E && opcode.value == 0x1"  is complex.
Complex Conditional,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,The conditional expression  "(result.Value == 0xFFFF || result.Value <= 30) && !ForceLongLiterals && TableInsertionIndex == -1 && output[i].ValueA.value == 0x1F"  is complex.
Complex Conditional,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseExpression,The conditional expression  "(!left.Successful || !right.Successful) && operands[1] != "===" && operands[1] != "!==""  is complex.
Complex Conditional,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,HasOperators,The conditional expression  "c == s[index] && !instring && !inchar && !inrelative"  is complex.
Complex Conditional,Organic,Extensions,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Extensions.cs,TrimExcessWhitespace,The conditional expression  "!(char.IsWhiteSpace(value[i]) && previousWhitespace) || inString || inChar"  is complex.
Empty Catch Block,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,LoadPlugins,The method has an empty catch block.
Empty Catch Block,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,CreateJson,The method has an empty catch block.
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,LoadTable,The following statement contains a magic number: OpcodeTable.Add(parts[2]' byte.Parse(parts[1]' NumberStyles.HexNumber));
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,The following statement contains a magic number: iterations > 10000
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,The following statement contains a magic number: output[i].Output[0] = (ushort)(value | (valueB << 5) | (valueA << 10));
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,The following statement contains a magic number: output[i].Output[0] = (ushort)(value | (valueB << 5) | (valueA << 10));
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,The following statement contains a magic number: (result.Value == 0xFFFF || result.Value <= 30) && !ForceLongLiterals && TableInsertionIndex == -1 && output[i].ValueA.value == 0x1F
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,The following statement contains a magic number: output[i].Output[0] = (ushort)(value | (valueB << 5) | (valueA << 10));
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,EvaluateAssembly,The following statement contains a magic number: output[i].Output[0] = (ushort)(value | (valueB << 5) | (valueA << 10));
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseExpression,The following statement contains a magic number: value.Length < 3
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseExpression,The following statement contains a magic number: value = value.Substring(1' value.Length - 2).Unescape();
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseExpression,The following statement contains a magic number: expressionResult = ParseExpression(operands[2]);
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseExpression,The following statement contains a magic number: ExpressionResult right = ParseExpression(operands[2]);
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseExpression,The following statement contains a magic number: switch (operands[1])              {                  case "*":                      expressionResult.Value = (ushort)(left.Value * right.Value);                      break;                  case "/":                      expressionResult.Value =  (ushort)(left.Value / right.Value);                      break;                  case "+":                      expressionResult.Value =  (ushort)(left.Value + right.Value);                      break;                  case "-":                      expressionResult.Value =  (ushort)(left.Value - right.Value);                      break;                  case "<<":                      expressionResult.Value =  (ushort)(left.Value << right.Value);                      break;                  case ">>":                      expressionResult.Value =  (ushort)(left.Value >> right.Value);                      break;                  case "|":                      expressionResult.Value =  (ushort)(left.Value | right.Value);                      break;                  case "^":                      expressionResult.Value =  (ushort)(left.Value ^ right.Value);                      break;                  case "&":                      expressionResult.Value =  (ushort)(left.Value & right.Value);                      break;                  case "%":                      expressionResult.Value =  (ushort)(left.Value % right.Value);                      break;                  case "==":                      expressionResult.Value =  (ushort)(left.Value == right.Value ? 1 : 0);                      break;                  case "!=":                  case "<>":                      expressionResult.Value =  (ushort)(left.Value != right.Value ? 1 : 0);                      break;                  case "<":                      expressionResult.Value =  (ushort)(left.Value < right.Value ? 1 : 0);                      break;                  case ">":                      expressionResult.Value =  (ushort)(left.Value > right.Value ? 1 : 0);                      break;                  case "<=":                      expressionResult.Value =  (ushort)(left.Value <= right.Value ? 1 : 0);                      break;                  case ">=":                      expressionResult.Value =  (ushort)(left.Value >= right.Value ? 1 : 0);                      break;                  case "===":                      expressionResult.Value = (ushort)(operands[0].ToLower().Trim() == operands[2].ToLower().Trim() ? 1 : 0);                      break;                  case "!==":                      expressionResult.Value = (ushort)(operands[0].ToLower().Trim() != operands[2].ToLower().Trim() ? 1 : 0);                      break;                  case "&&":                      expressionResult.Value = (ushort)(left.Value > 0 && right.Value > 1 ? 1 : 0);                      break;                  case "||":                      expressionResult.Value = (ushort)(left.Value > 0 || right.Value > 1 ? 1 : 0);                      break;                  case "^^":                      expressionResult.Value = (ushort)(left.Value > 0 ^ right.Value > 1 ? 1 : 0); // between boolean operators' ^ is ^^ in C#                      break;                  default:                      expressionResult.Successful = false;                      return expressionResult;              }
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseExpression,The following statement contains a magic number: switch (operands[1])              {                  case "*":                      expressionResult.Value = (ushort)(left.Value * right.Value);                      break;                  case "/":                      expressionResult.Value =  (ushort)(left.Value / right.Value);                      break;                  case "+":                      expressionResult.Value =  (ushort)(left.Value + right.Value);                      break;                  case "-":                      expressionResult.Value =  (ushort)(left.Value - right.Value);                      break;                  case "<<":                      expressionResult.Value =  (ushort)(left.Value << right.Value);                      break;                  case ">>":                      expressionResult.Value =  (ushort)(left.Value >> right.Value);                      break;                  case "|":                      expressionResult.Value =  (ushort)(left.Value | right.Value);                      break;                  case "^":                      expressionResult.Value =  (ushort)(left.Value ^ right.Value);                      break;                  case "&":                      expressionResult.Value =  (ushort)(left.Value & right.Value);                      break;                  case "%":                      expressionResult.Value =  (ushort)(left.Value % right.Value);                      break;                  case "==":                      expressionResult.Value =  (ushort)(left.Value == right.Value ? 1 : 0);                      break;                  case "!=":                  case "<>":                      expressionResult.Value =  (ushort)(left.Value != right.Value ? 1 : 0);                      break;                  case "<":                      expressionResult.Value =  (ushort)(left.Value < right.Value ? 1 : 0);                      break;                  case ">":                      expressionResult.Value =  (ushort)(left.Value > right.Value ? 1 : 0);                      break;                  case "<=":                      expressionResult.Value =  (ushort)(left.Value <= right.Value ? 1 : 0);                      break;                  case ">=":                      expressionResult.Value =  (ushort)(left.Value >= right.Value ? 1 : 0);                      break;                  case "===":                      expressionResult.Value = (ushort)(operands[0].ToLower().Trim() == operands[2].ToLower().Trim() ? 1 : 0);                      break;                  case "!==":                      expressionResult.Value = (ushort)(operands[0].ToLower().Trim() != operands[2].ToLower().Trim() ? 1 : 0);                      break;                  case "&&":                      expressionResult.Value = (ushort)(left.Value > 0 && right.Value > 1 ? 1 : 0);                      break;                  case "||":                      expressionResult.Value = (ushort)(left.Value > 0 || right.Value > 1 ? 1 : 0);                      break;                  case "^^":                      expressionResult.Value = (ushort)(left.Value > 0 ^ right.Value > 1 ? 1 : 0); // between boolean operators' ^ is ^^ in C#                      break;                  default:                      expressionResult.Successful = false;                      return expressionResult;              }
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,Main,The following statement contains a magic number: switch (arg)  						{  							case "-h":  							case "-?":  							case "/h":  							case "/?":  							case "--help":  								DisplayHelp();  								return 1;  							case "-o":  							case "--output":  							case "--output-file":  								outputFile = args[++i];  								break;  							case "--input-file":  								inputFile = args[++i];  								break;  							case "-e":  							case "--equate":  								ExpressionResult result = assembler.ParseExpression(args[i + 2]);  								if (!result.Successful)  								{  									Console.WriteLine("Error: " + ListEntry.GetFriendlyErrorMessage(ErrorCode.IllegalExpression));  									return 1;  								}  								assembler.Values.Add(args[i + 1].ToLower()' result.Value);  								i += 2;  								break;  							case "-l":  							case "--listing":  								listingFile = args[++i];  								break;  							case "--little-endian":  								bigEndian = false;  								break;  							case "--long-literals":  								assembler.ForceLongLiterals = true;  								break;  							case "--quiet":  							case "-q":  								quiet = true;  								break;  							case "--pipe":  							case "-p":  								pipe = args[++i];  								break;  							case "--json":  								jsonFile = args[++i];  								break;  							case "--include":  							case "-i":  								assembler.IncludePath = Environment.GetEnvironmentVariable("ORGINCLUDE") + ";" + args[++i];  								break;  							case "--plugins":  								ListPlugins(assembler);  								return 0;  							case "--working-directory":  							case "-w":  								workingDirectory = args[++i];  								break;  							case "--verbose":  							case "-v":  								verbose = true;  								break;  							case "--debug-mode":  								Console.ReadKey();  								break;  							case "--install":  								assembler.InstallPlugin(args[++i]);  								return 0;  							case "--remove":  								assembler.RemovePlugin(args[++i]);  								return 0;  							case "--search":  								assembler.SearchPlugins(args[++i]);  								return 0;  							case "--info":  								assembler.GetInfo(args[++i]);  								return 0;  							default:  								HandleParameterEventArgs hpea = new HandleParameterEventArgs(arg);  								hpea.Arguments = args;  								hpea.Index = i;  								if (assembler.TryHandleParameter != null)  									assembler.TryHandleParameter(assembler' hpea);  								if (!hpea.Handled)  								{  									Console.WriteLine("Error: Invalid parameter: " + arg + "\nUse Organic.exe --help for usage information.");  									return 1;  								}  								else  									i = hpea.Index;  								if (hpea.StopProgram)  									return 0;  								break;  						}
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,Main,The following statement contains a magic number: switch (arg)  						{  							case "-h":  							case "-?":  							case "/h":  							case "/?":  							case "--help":  								DisplayHelp();  								return 1;  							case "-o":  							case "--output":  							case "--output-file":  								outputFile = args[++i];  								break;  							case "--input-file":  								inputFile = args[++i];  								break;  							case "-e":  							case "--equate":  								ExpressionResult result = assembler.ParseExpression(args[i + 2]);  								if (!result.Successful)  								{  									Console.WriteLine("Error: " + ListEntry.GetFriendlyErrorMessage(ErrorCode.IllegalExpression));  									return 1;  								}  								assembler.Values.Add(args[i + 1].ToLower()' result.Value);  								i += 2;  								break;  							case "-l":  							case "--listing":  								listingFile = args[++i];  								break;  							case "--little-endian":  								bigEndian = false;  								break;  							case "--long-literals":  								assembler.ForceLongLiterals = true;  								break;  							case "--quiet":  							case "-q":  								quiet = true;  								break;  							case "--pipe":  							case "-p":  								pipe = args[++i];  								break;  							case "--json":  								jsonFile = args[++i];  								break;  							case "--include":  							case "-i":  								assembler.IncludePath = Environment.GetEnvironmentVariable("ORGINCLUDE") + ";" + args[++i];  								break;  							case "--plugins":  								ListPlugins(assembler);  								return 0;  							case "--working-directory":  							case "-w":  								workingDirectory = args[++i];  								break;  							case "--verbose":  							case "-v":  								verbose = true;  								break;  							case "--debug-mode":  								Console.ReadKey();  								break;  							case "--install":  								assembler.InstallPlugin(args[++i]);  								return 0;  							case "--remove":  								assembler.RemovePlugin(args[++i]);  								return 0;  							case "--search":  								assembler.SearchPlugins(args[++i]);  								return 0;  							case "--info":  								assembler.GetInfo(args[++i]);  								return 0;  							default:  								HandleParameterEventArgs hpea = new HandleParameterEventArgs(arg);  								hpea.Arguments = args;  								hpea.Index = i;  								if (assembler.TryHandleParameter != null)  									assembler.TryHandleParameter(assembler' hpea);  								if (!hpea.Handled)  								{  									Console.WriteLine("Error: Invalid parameter: " + arg + "\nUse Organic.exe --help for usage information.");  									return 1;  								}  								else  									i = hpea.Index;  								if (hpea.StopProgram)  									return 0;  								break;  						}
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,CreateListing,The following statement contains a magic number: int length = maxFileLength + entry.LineNumber.ToString().Length + 9;
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,CreateListing,The following statement contains a magic number: tsb.WriteAt(maxLength + 25' listentry.Code);
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,CreateListing,The following statement contains a magic number: j < 8 && i + j < listentry.Output.Length
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,CreateListing,The following statement contains a magic number: tsb.WriteAt(maxLength + 30' data.Remove(data.Length - 1));
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,LongHex,The following statement contains a magic number: value.Length < 4
Magic Number,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,DumpArray,The following statement contains a magic number: val.Length < 4
Duplicate Code,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,Assemble,The method contains a code clone-set at the following line numbers (starting from the method definition): ((152' 179)' (206' 233)' (249' 276))
Duplicate Code,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,Assemble,The method contains a code clone-set at the following line numbers (starting from the method definition): ((206' 237)' (249' 280))
Duplicate Code,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseDirectives,The method contains a code clone-set at the following line numbers (starting from the method definition): ((157' 176)' (191' 210)' (225' 244))
Duplicate Code,Organic,Assembler,D:\research\architectureSmells\repos1\SirCmpwn_organic\Organic\Assembler.cs,ParseDirectives,The method contains a code clone-set at the following line numbers (starting from the method definition): ((191' 212)' (225' 246))
