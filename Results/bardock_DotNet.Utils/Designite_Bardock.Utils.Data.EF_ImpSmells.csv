Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Bardock.Utils.Data.EF,DbContextBase,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\DbContextBase.cs,DbContextBase,The method has 5 parameters. Parameters: exceptionMapper' entityAdder' entityUpdater' entityDeleter' entityDetacher
Long Parameter List,Bardock.Utils.Data.EF,DbContextBase,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\DbContextBase.cs,DbContextBase,The method has 6 parameters. Parameters: nameOrConnectionString' exceptionMapper' entityAdder' entityUpdater' entityDeleter' entityDetacher
Long Parameter List,Bardock.Utils.Data.EF,DbContextBase,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\DbContextBase.cs,DbContextBase,The method has 7 parameters. Parameters: existingConnection' contextOwnsConnection' exceptionMapper' entityAdder' entityUpdater' entityDeleter' entityDetacher
Long Parameter List,Bardock.Utils.Data.EF,DbContextBase,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\DbContextBase.cs,DbContextBase,The method has 7 parameters. Parameters: objectContext' dbContextOwnsObjectContext' exceptionMapper' entityAdder' entityUpdater' entityDeleter' entityDetacher
Long Parameter List,Bardock.Utils.Data.EF,DbContextBase,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\DbContextBase.cs,DbContextBase,The method has 7 parameters. Parameters: nameOrConnectionString' model' exceptionMapper' entityAdder' entityUpdater' entityDeleter' entityDetacher
Long Parameter List,Bardock.Utils.Data.EF,DbContextBase,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\DbContextBase.cs,DbContextBase,The method has 8 parameters. Parameters: existingConnection' model' contextOwnsConnection' exceptionMapper' entityAdder' entityUpdater' entityDeleter' entityDetacher
Long Parameter List,Bardock.Utils.Data.EF,DbContextBase,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\DbContextBase.cs,Init,The method has 5 parameters. Parameters: exceptionMapper' entityAdder' entityUpdater' entityDeleter' entityDetacher
Long Statement,Bardock.Utils.Data.EF,EntityTypeConfigurationExtensions,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\EntityTypeConfigurationExtensions.cs,HasIndex,The length of the statement  "                            // check if required overload is: Property<T>(Expression<Func<TStructuralType' T?>> propertyExpression) where T : struct " is 120.
Long Statement,Bardock.Utils.Data.EF,EntityTypeConfigurationExtensions,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\EntityTypeConfigurationExtensions.cs,HasIndex,The length of the statement  "                var propertyConfig = propertyMethod.Invoke(config' new[] { prop.ToExpression<TEntity>().ToLambda() }) as PrimitivePropertyConfiguration; " is 136.
Magic Number,Bardock.Utils.Data.EF,EntityTypeConfiguration,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\DbModelBuilderExtensions.cs,GetToTableMethod,The following statement contains a magic number: var paramsCount = withSchema ? 2 : 1;
Magic Number,Bardock.Utils.Data.EF,EntityTypeConfigurationExtensions,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\EntityTypeConfigurationExtensions.cs,HasIndex,The following statement contains a magic number: foreach (var prop in fieldsProperties)              {                  var propertyMethod = config.GetType().GetMethods()                      .Where(x => x.Name == "Property")                      .Select(x => new                      {                          Method = x'                          PropertyType = GetPropertyTypeOfPropertyMethod(x)'                      })                      .Select(x => new                      {                          Method = x.Method'                          Priority = x.PropertyType == prop.PropertyType ? 1 :                              // check if required overload is: Property<T>(Expression<Func<TStructuralType' T>> propertyExpression) where T : struct                              x.PropertyType.IsGenericParameter(nullable: false) && prop.PropertyType.IsValueType(nullable: false) ? 2 :                              // check if required overload is: Property<T>(Expression<Func<TStructuralType' T?>> propertyExpression) where T : struct                              x.PropertyType.IsGenericParameter(nullable: true) && prop.PropertyType.IsValueType(nullable: true) ? 3 : 0                      })                      .Where(x => x.Priority != 0)                      .OrderBy(x => x.Priority)                      .Select(x => x.Method)                      .First();                    if (propertyMethod.IsGenericMethod)                      propertyMethod = propertyMethod.MakeGenericMethod(prop.PropertyType.GetNullableUnderlyingType() ?? prop.PropertyType);                    var propertyConfig = propertyMethod.Invoke(config' new[] { prop.ToExpression<TEntity>().ToLambda() }) as PrimitivePropertyConfiguration;                    propertyConfig                      .HasColumnAnnotation(                          "Index"'                          new IndexAnnotation(                              new IndexAttribute(name' i + 1) { IsUnique = isUnique })); ;                  i++;              }
Magic Number,Bardock.Utils.Data.EF,EntityTypeConfigurationExtensions,C:\repos\bardock_DotNet.Utils\src\Bardock.Utils.Data.EF\EntityTypeConfigurationExtensions.cs,HasIndex,The following statement contains a magic number: foreach (var prop in fieldsProperties)              {                  var propertyMethod = config.GetType().GetMethods()                      .Where(x => x.Name == "Property")                      .Select(x => new                      {                          Method = x'                          PropertyType = GetPropertyTypeOfPropertyMethod(x)'                      })                      .Select(x => new                      {                          Method = x.Method'                          Priority = x.PropertyType == prop.PropertyType ? 1 :                              // check if required overload is: Property<T>(Expression<Func<TStructuralType' T>> propertyExpression) where T : struct                              x.PropertyType.IsGenericParameter(nullable: false) && prop.PropertyType.IsValueType(nullable: false) ? 2 :                              // check if required overload is: Property<T>(Expression<Func<TStructuralType' T?>> propertyExpression) where T : struct                              x.PropertyType.IsGenericParameter(nullable: true) && prop.PropertyType.IsValueType(nullable: true) ? 3 : 0                      })                      .Where(x => x.Priority != 0)                      .OrderBy(x => x.Priority)                      .Select(x => x.Method)                      .First();                    if (propertyMethod.IsGenericMethod)                      propertyMethod = propertyMethod.MakeGenericMethod(prop.PropertyType.GetNullableUnderlyingType() ?? prop.PropertyType);                    var propertyConfig = propertyMethod.Invoke(config' new[] { prop.ToExpression<TEntity>().ToLambda() }) as PrimitivePropertyConfiguration;                    propertyConfig                      .HasColumnAnnotation(                          "Index"'                          new IndexAnnotation(                              new IndexAttribute(name' i + 1) { IsUnique = isUnique })); ;                  i++;              }
