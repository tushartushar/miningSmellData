Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The method has 281 lines of code.
Long Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The method has 125 lines of code.
Long Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetBytes,The method has 118 lines of code.
Long Method,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,GetDocument,The method has 142 lines of code.
Complex Method,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,Cyclomatic complexity of the method is 11
Complex Method,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,FromInt32,Cyclomatic complexity of the method is 13
Complex Method,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,Cyclomatic complexity of the method is 20
Complex Method,Mono.Security.X509.Extensions,ExtendedKeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ExtendedKeyUsageExtension.cs,ToString,Cyclomatic complexity of the method is 22
Complex Method,Mono.Security.X509.Extensions,GeneralNames,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\GeneralNames.cs,GeneralNames,Cyclomatic complexity of the method is 10
Complex Method,Mono.Security.X509.Extensions,GeneralNames,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\GeneralNames.cs,GeneralNames,Cyclomatic complexity of the method is 37
Complex Method,Mono.Security.X509.Extensions,GeneralNames,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\GeneralNames.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,Mono.Security.X509.Extensions,KeyAttributesExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyAttributesExtension.cs,Decode,Cyclomatic complexity of the method is 14
Complex Method,Mono.Security.X509.Extensions,KeyAttributesExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyAttributesExtension.cs,ToString,Cyclomatic complexity of the method is 24
Complex Method,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,Mono.Security.X509.Extensions,NetscapeCertTypeExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\NetscapeCertTypeExtension.cs,ToString,Cyclomatic complexity of the method is 14
Complex Method,Mono.Security.X509.Extensions,PrivateKeyUsagePeriodExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrivateKeyUsagePeriodExtension.cs,Decode,Cyclomatic complexity of the method is 10
Complex Method,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 12
Complex Method,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,Parse,Cyclomatic complexity of the method is 11
Complex Method,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,Cyclomatic complexity of the method is 22
Complex Method,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiKeyBlob,Cyclomatic complexity of the method is 8
Complex Method,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,HashNameFromOid,Cyclomatic complexity of the method is 13
Complex Method,Mono.Security.Cryptography,PKCS8,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS8.cs,GetType,Cyclomatic complexity of the method is 9
Complex Method,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,GenerateKeyPair,Cyclomatic complexity of the method is 9
Complex Method,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,DecryptValue,Cyclomatic complexity of the method is 8
Complex Method,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,ImportParameters,Cyclomatic complexity of the method is 13
Complex Method,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,Dispose,Cyclomatic complexity of the method is 11
Complex Method,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,ToXmlString,Cyclomatic complexity of the method is 8
Complex Method,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,Cyclomatic complexity of the method is 118
Complex Method,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,Cyclomatic complexity of the method is 15
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,Decode,Cyclomatic complexity of the method is 27
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,Cyclomatic complexity of the method is 62
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,AddPrivateKey,Cyclomatic complexity of the method is 12
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,ReadSafeBag,Cyclomatic complexity of the method is 43
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,Pkcs8ShroudedKeyBagSafeBag,Cyclomatic complexity of the method is 19
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,KeyBagSafeBag,Cyclomatic complexity of the method is 19
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,SecretBagSafeBag,Cyclomatic complexity of the method is 17
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,CertificateSafeBag,Cyclomatic complexity of the method is 17
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetBytes,Cyclomatic complexity of the method is 27
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,Cyclomatic complexity of the method is 14
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,AddPkcs8ShroudedKeyBag,Cyclomatic complexity of the method is 15
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemovePkcs8ShroudedKeyBag,Cyclomatic complexity of the method is 15
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,AddKeyBag,Cyclomatic complexity of the method is 14
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveKeyBag,Cyclomatic complexity of the method is 14
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAsymmetricAlgorithm,Cyclomatic complexity of the method is 29
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSecret,Cyclomatic complexity of the method is 11
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetCertificate,Cyclomatic complexity of the method is 11
Complex Method,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,Cyclomatic complexity of the method is 25
Complex Method,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,AppendEntry,Cyclomatic complexity of the method is 26
Complex Method,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,GetAttributeFromOid,Cyclomatic complexity of the method is 17
Complex Method,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,ReadEscaped,Cyclomatic complexity of the method is 14
Complex Method,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,ReadValue,Cyclomatic complexity of the method is 21
Complex Method,Mono.Security.X509,X509Builder,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Builder.cs,GetOid,Cyclomatic complexity of the method is 9
Complex Method,Mono.Security.X509,X509Certificate,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Certificate.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,Couchbase.Lite.Listener,CouchbaseLiteRouter,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteRouter.cs,HandleRequest,Cyclomatic complexity of the method is 12
Complex Method,Couchbase.Lite.Listener,DBMonitorCouchbaseResponseState,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DBMonitorCouchbaseResponseState.cs,DatabaseChanged,Cyclomatic complexity of the method is 10
Complex Method,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,WriteChangesBodyJson,Cyclomatic complexity of the method is 10
Complex Method,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,ProcessBody,Cyclomatic complexity of the method is 10
Complex Method,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,UpdateDocument,Cyclomatic complexity of the method is 15
Complex Method,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,ApplyOptions,Cyclomatic complexity of the method is 10
Complex Method,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,UpdateDb,Cyclomatic complexity of the method is 11
Complex Method,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,WriteToContext,Cyclomatic complexity of the method is 15
Complex Method,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,ProcessRequestRanges,Cyclomatic complexity of the method is 11
Long Parameter List,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,DecodeTLV,The method has 5 parameters.
Long Parameter List,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Verify_v15,The method has 5 parameters.
Long Parameter List,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,UpdateDocument,The method has 7 parameters.
Long Parameter List,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,ApplyOptions,The method has 5 parameters.
Long Parameter List,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,UpdateDb,The method has 5 parameters.
Long Parameter List,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,UpdateAttachment,The method has 5 parameters.
Long Parameter List,Couchbase.Lite.Listener.Tcp,CouchbaseLiteTcpListener,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\TCP\CouchbaseLiteTcpListener.cs,CouchbaseLiteTcpListener,The method has 5 parameters.
Long Statement,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,FromDateTime,The length of the statement  "		return new ASN1 (0x17' Encoding.ASCII.GetBytes (dt.ToUniversalTime ().ToString ("yyMMddHHmmss"' CultureInfo.InvariantCulture) + "Z")); " is 134.
Long Statement,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,FromDateTime,The length of the statement  "		return new ASN1 (0x18' Encoding.ASCII.GetBytes (dt.ToUniversalTime ().ToString ("yyyyMMddHHmmss"' CultureInfo.InvariantCulture) + "Z")); " is 136.
Long Statement,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The length of the statement  "				if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) { " is 225.
Long Statement,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,Decrypt,The length of the statement  "	return Decrypt (ed.EncryptionAlgorithm.ContentType' ed.EncryptionAlgorithm.Content [0].Value' ASN1Convert.ToInt32 (ed.EncryptionAlgorithm.Content [1])' ed.EncryptedContent); " is 173.
Long Statement,Couchbase.Lite.Listener,CouchbaseLiteRouter,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteRouter.cs,ProcessResponse,The length of the statement  "			Log.To.Router.I (TAG' "{0} {1} => {2} ({3})"' context.Method' context.RequestUrl.PathAndQuery' responseObject.Status' responseObject.StatusMessage); " is 148.
Long Statement,Couchbase.Lite.Listener,CouchbaseLiteRouter,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteRouter.cs,CheckForAltMethod,The length of the statement  "	Log.To.Router.I (TAG' "{0} method not found for endpoint {1}' searching for alternate..."' context.Method' context.RequestUrl.PathAndQuery); " is 140.
Long Statement,Couchbase.Lite.Listener,CouchbaseLiteRouter,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteRouter.cs,CheckForAltMethod,The length of the statement  "	bool hasAltMethod = _Delete.HasLogicForRequest (request) || _Get.HasLogicForRequest (request) || _Post.HasLogicForRequest (request) || _Put.HasLogicForRequest (request); " is 169.
Long Statement,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,GetChanges,The length of the statement  "		if ((context.ChangesFeedMode >= ChangesFeedMode.Continuous) || (context.ChangesFeedMode == ChangesFeedMode.LongPoll && !changes.Any ())) { " is 138.
Long Statement,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,ExecuteTemporaryViewFunction,The length of the statement  "	if (context.RequestHeaders ["Content-Type"] == null || !context.RequestHeaders ["Content-Type"].StartsWith ("application/json")) { " is 130.
Long Statement,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,ChangesDictForRev,The length of the statement  "		var rev2 = DocumentMethods.ApplyOptions (responseState.ContentOptions' rev' responseState.Context' responseState.Db' status); " is 125.
Long Statement,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,CreateDocument,The length of the statement  "	return PerformLogicWithDocumentBody (context' (db' body) => UpdateDb (context' db' null' body' false)).AsDefaultState (); " is 121.
Long Statement,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,UpdateDocument,The length of the statement  "			Log.To.Router.I (TAG' "Attempting to insert local {0} on top of {1} from PUT request"' rev' prevRevId != null ? prevRevId.ToString () : "<root>"); " is 146.
Long Statement,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,UpdateDocument,The length of the statement  "			Log.To.Router.I (TAG' "Attempting to insert {0} on top of {1} from PUT request"' rev' prevRevId != null ? prevRevId.ToString () : "<root>"); " is 140.
Long Statement,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,GetAttachment,The length of the statement  "		bool acceptEncoded = acceptEncoding != null && acceptEncoding.Contains ("gzip") && context.RequestHeaders ["Range"] == null; " is 124.
Long Statement,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,DeleteAttachment,The length of the statement  "	return DatabaseMethods.PerformLogicWithDatabase (context' true' db => UpdateAttachment (context' db' context.AttachmentName' context.DocumentName' null)).AsDefaultState (); " is 172.
Long Statement,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,ApplyOptions,The length of the statement  "	if ((options & (DocumentContentOptions.IncludeRevs | DocumentContentOptions.IncludeRevsInfo | DocumentContentOptions.IncludeConflicts | DocumentContentOptions.IncludeAttachments | DocumentContentOptions.IncludeLocalSeq) | DocumentContentOptions.IncludeExpiration) != 0) { " is 271.
Long Statement,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,UpdateAttachment,The length of the statement  "	RevisionInternal rev = db.UpdateAttachment (attachment' body' context.RequestHeaders ["Content-Type"]' AttachmentEncoding.None' docId' (context.GetQueryParam ("rev") ?? context.IfMatch ()).AsRevID ()' source); " is 209.
Long Statement,Couchbase.Lite.Listener,CouchbaseListenerContext,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseListenerContext.cs,BodyAs,The length of the statement  "			throw Misc.CreateExceptionAndLog (Log.To.Router' e' StatusCode.RequestTimeout' Tag' "IOException when attempting to read body"); " is 128.
Long Statement,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,WriteData,The length of the statement  "	Log.To.Router.V (TAG' "Attempting to send data over the wire: {0}"' new SecureLogString (data.ToArray ()' LogMessageSensitivity.PotentiallyInsecure)); " is 150.
Long Statement,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,WriteData,The length of the statement  "		Log.To.Router.W (TAG' "Failed to send data: {0}"' new SecureLogString (data.ToArray ()' LogMessageSensitivity.PotentiallyInsecure)); " is 132.
Long Statement,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,SendContinuousLine,The length of the statement  "	Log.To.Router.V (TAG' "Sending continous change chunk: {0}"' new SecureLogJsonString (changesDict' LogMessageSensitivity.PotentiallyInsecure)); " is 143.
Long Statement,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,ProcessRequestRanges,The length of the statement  "	if (_responseWriter.StatusCode != 200 || (_requestMethod != "GET" && _requestMethod != "HEAD") || _binaryBody == null) { " is 120.
Long Statement,Couchbase.Lite.Listener,JSViewCompiler,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\JSViewCompiler.cs,CompileMap,The length of the statement  "	var engine = new Engine ().SetValue ("log"' new Action<object> (line => Log.To.Router.I ("JSViewCompiler"' line.ToString ()))); " is 127.
Long Statement,Couchbase.Lite.Listener,JSViewCompiler,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\JSViewCompiler.cs,CompileReduce,The length of the statement  "	var engine = new Engine ().Execute (source).SetValue ("log"' new Action<object> (line => Log.To.Router.I ("JSViewCompiler"' line.ToString ()))); " is 144.
Long Statement,Couchbase.Lite.Listener,JSFilterCompiler,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\JSFilterCompiler.cs,CompileFilter,The length of the statement  "		var engine = new Engine ().SetValue ("log"' new Action<object> (line => Log.To.Router.I ("JSFilterCompiler"' line.ToString ()))); " is 129.
Long Statement,Couchbase.Lite.Listener,JSFilterCompiler,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\JSFilterCompiler.cs,CompileFilter,The length of the statement  "		var retVal = engine.Execute (filterSource).Invoke ("_f1"' new NoThrowDictionary (rev.Properties)' new NoThrowDictionary (filterParams)); " is 136.
Long Statement,Couchbase.Lite.Listener.Tcp,CouchbaseLiteTcpListener,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\TCP\CouchbaseLiteTcpListener.cs,GetCredential,The length of the statement  "	Log.To.Listener.V (TAG' "Request from user {0}' so require password {1}"' new SecureLogString (identity.Name' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (password' LogMessageSensitivity.Insecure)); " is 218.
Long Statement,Couchbase.Lite.Listener.Tcp,CouchbaseLiteTcpListener,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\TCP\CouchbaseLiteTcpListener.cs,ProcessRequest,The length of the statement  "	var isLocal = System.Net.IPAddress.IsLoopback (context.Request.RemoteEndPoint.Address) || context.Request.LocalEndPoint == context.Request.RemoteEndPoint; " is 154.
Long Statement,Couchbase.Lite.Listener.Tcp,CouchbaseLiteTcpListener,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\TCP\CouchbaseLiteTcpListener.cs,ProcessRequest,The length of the statement  "		Log.To.Listener.I (TAG' "Received new {0} remote connection from {1}"' _usesTLS ? "secure" : "plain"' context.Request.RemoteEndPoint.Address); " is 142.
Long Statement,Couchbase.Lite.Listener.Tcp,CouchbaseLiteTcpListener,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\TCP\CouchbaseLiteTcpListener.cs,ProcessRequest,The length of the statement  "	var getContext = Task.Factory.FromAsync<HttpListenerContext> (_listener.BeginGetContext' _listener.EndGetContext' null); " is 120.
Long Statement,Couchbase.Lite.Listener.Tcp,CouchbaseLiteTcpListener,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\TCP\CouchbaseLiteTcpListener.cs,ProcessRequest,The length of the statement  "	var uriBuilder = new UriBuilder (_usesTLS ? "https" : "http"' context.Request.LocalEndPoint.Address.ToString ()' context.Request.LocalEndPoint.Port); " is 149.
Long Statement,Couchbase.Lite.Listener.Tcp,CouchbaseLiteTcpListener,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\TCP\CouchbaseLiteTcpListener.cs,Start,The length of the statement  "	var getContext = Task.Factory.FromAsync<HttpListenerContext> (_listener.BeginGetContext' _listener.EndGetContext' null); " is 120.
Long Statement,Couchbase.Lite.Security,X509Manager,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\X509\X509Manager.cs,GetExistingPersistentCertificate,The length of the statement  "			Log.To.Listener.E (Tag' "Certificate name doesn't match for {0}' " + "expecting {1} but found {2}' throwing..."' filePath' certificateName' retVal.Subject.Substring (3)); " is 170.
Long Statement,Couchbase.Lite.Security,X509Manager,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\X509\X509Manager.cs,GetExistingPersistentCertificate,The length of the statement  "			throw new InvalidDataException (String.Format ("Certificate name doesn't match for {0}' " + "expecting {1} but found {2}"' filePath' certificateName' retVal.Subject.Substring (3))); " is 181.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The conditional expression  "(blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352)"  is complex.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The conditional expression  "(blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344)"  is complex.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The conditional expression  "(blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352)"  is complex.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The conditional expression  "(blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344)"  is complex.
Complex Conditional,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,ExportParameters,The conditional expression  "(p != null) && (q != null) && (dp != null) && (dq != null) && (qInv != null)"  is complex.
Complex Conditional,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The conditional expression  "(l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))"  is complex.
Complex Conditional,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,ProcessRequestRanges,The conditional expression  "_responseWriter.StatusCode != 200 || (_requestMethod != "GET" && _requestMethod != "HEAD") || _binaryBody == null"  is complex.
Virtual Method Call from Constructor,Mono.Security.X509,X509Extension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Extension.cs,X509Extension,The constructor "X509Extension" calls a virtual method "Decode".
Virtual Method Call from Constructor,Mono.Security.X509,X509Extension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Extension.cs,X509Extension,The constructor "X509Extension" calls a virtual method "Decode".
Empty Catch Block,Mono.Security.X509,X509Extension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Extension.cs,X509Extension,The method has an empty catch block.
Empty Catch Block,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,TryClose,The method has an empty catch block.
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,ASN1,The following statement contains a magic number: if (nLength > 0x80) {  	// composed length  	nLenLength = nLength - 0x80;  	nLength = 0;  	for (int i = 0; i < nLenLength; i++) {  		nLength *= 256;  		nLength += data [i + 2];  	}  } else if (nLength == 0x80) {  	// undefined length encoding  	throw new NotSupportedException ("Undefined length encoding.");  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,ASN1,The following statement contains a magic number: if (nLength > 0x80) {  	// composed length  	nLenLength = nLength - 0x80;  	nLength = 0;  	for (int i = 0; i < nLenLength; i++) {  		nLength *= 256;  		nLength += data [i + 2];  	}  } else if (nLength == 0x80) {  	// undefined length encoding  	throw new NotSupportedException ("Undefined length encoding.");  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,ASN1,The following statement contains a magic number: for (int i = 0; i < nLenLength; i++) {  	nLength *= 256;  	nLength += data [i + 2];  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,ASN1,The following statement contains a magic number: for (int i = 0; i < nLenLength; i++) {  	nLength *= 256;  	nLength += data [i + 2];  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,ASN1,The following statement contains a magic number: nLength *= 256;  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,ASN1,The following statement contains a magic number: nLength += data [i + 2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,ASN1,The following statement contains a magic number: Buffer.BlockCopy (data' (2 + nLenLength)' m_aValue' 0' nLength);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,ASN1,The following statement contains a magic number: if ((m_nTag & 0x20) == 0x20) {  	int nStart = (2 + nLenLength);  	Decode (data' ref nStart' data.Length);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (val != null) {  	int nLength = val.Length;  	// special for length > 127  	if (nLength > 127) {  		if (nLength <= Byte.MaxValue) {  			der = new byte[3 + nLength];  			Buffer.BlockCopy (val' 0' der' 3' nLength);  			nLengthLen = 0x81;  			der [2] = (byte)(nLength);  		} else if (nLength <= UInt16.MaxValue) {  			der = new byte[4 + nLength];  			Buffer.BlockCopy (val' 0' der' 4' nLength);  			nLengthLen = 0x82;  			der [2] = (byte)(nLength >> 8);  			der [3] = (byte)(nLength);  		} else if (nLength <= 0xFFFFFF) {  			// 24 bits  			der = new byte[5 + nLength];  			Buffer.BlockCopy (val' 0' der' 5' nLength);  			nLengthLen = 0x83;  			der [2] = (byte)(nLength >> 16);  			der [3] = (byte)(nLength >> 8);  			der [4] = (byte)(nLength);  		} else {  			// max (Length is an integer) 32 bits  			der = new byte[6 + nLength];  			Buffer.BlockCopy (val' 0' der' 6' nLength);  			nLengthLen = 0x84;  			der [2] = (byte)(nLength >> 24);  			der [3] = (byte)(nLength >> 16);  			der [4] = (byte)(nLength >> 8);  			der [5] = (byte)(nLength);  		}  	} else {  		// basic case (no encoding)  		der = new byte[2 + nLength];  		Buffer.BlockCopy (val' 0' der' 2' nLength);  		nLengthLen = nLength;  	}  	if (m_aValue == null)  		m_aValue = val;  } else  	der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength > 127) {  	if (nLength <= Byte.MaxValue) {  		der = new byte[3 + nLength];  		Buffer.BlockCopy (val' 0' der' 3' nLength);  		nLengthLen = 0x81;  		der [2] = (byte)(nLength);  	} else if (nLength <= UInt16.MaxValue) {  		der = new byte[4 + nLength];  		Buffer.BlockCopy (val' 0' der' 4' nLength);  		nLengthLen = 0x82;  		der [2] = (byte)(nLength >> 8);  		der [3] = (byte)(nLength);  	} else if (nLength <= 0xFFFFFF) {  		// 24 bits  		der = new byte[5 + nLength];  		Buffer.BlockCopy (val' 0' der' 5' nLength);  		nLengthLen = 0x83;  		der [2] = (byte)(nLength >> 16);  		der [3] = (byte)(nLength >> 8);  		der [4] = (byte)(nLength);  	} else {  		// max (Length is an integer) 32 bits  		der = new byte[6 + nLength];  		Buffer.BlockCopy (val' 0' der' 6' nLength);  		nLengthLen = 0x84;  		der [2] = (byte)(nLength >> 24);  		der [3] = (byte)(nLength >> 16);  		der [4] = (byte)(nLength >> 8);  		der [5] = (byte)(nLength);  	}  } else {  	// basic case (no encoding)  	der = new byte[2 + nLength];  	Buffer.BlockCopy (val' 0' der' 2' nLength);  	nLengthLen = nLength;  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= Byte.MaxValue) {  	der = new byte[3 + nLength];  	Buffer.BlockCopy (val' 0' der' 3' nLength);  	nLengthLen = 0x81;  	der [2] = (byte)(nLength);  } else if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der = new byte[3 + nLength];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: Buffer.BlockCopy (val' 0' der' 3' nLength);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [2] = (byte)(nLength);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= UInt16.MaxValue) {  	der = new byte[4 + nLength];  	Buffer.BlockCopy (val' 0' der' 4' nLength);  	nLengthLen = 0x82;  	der [2] = (byte)(nLength >> 8);  	der [3] = (byte)(nLength);  } else if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der = new byte[4 + nLength];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: Buffer.BlockCopy (val' 0' der' 4' nLength);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [2] = (byte)(nLength >> 8);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [2] = (byte)(nLength >> 8);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [3] = (byte)(nLength);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: if (nLength <= 0xFFFFFF) {  	// 24 bits  	der = new byte[5 + nLength];  	Buffer.BlockCopy (val' 0' der' 5' nLength);  	nLengthLen = 0x83;  	der [2] = (byte)(nLength >> 16);  	der [3] = (byte)(nLength >> 8);  	der [4] = (byte)(nLength);  } else {  	// max (Length is an integer) 32 bits  	der = new byte[6 + nLength];  	Buffer.BlockCopy (val' 0' der' 6' nLength);  	nLengthLen = 0x84;  	der [2] = (byte)(nLength >> 24);  	der [3] = (byte)(nLength >> 16);  	der [4] = (byte)(nLength >> 8);  	der [5] = (byte)(nLength);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der = new byte[5 + nLength];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: Buffer.BlockCopy (val' 0' der' 5' nLength);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [2] = (byte)(nLength >> 16);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [2] = (byte)(nLength >> 16);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [3] = (byte)(nLength >> 8);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [3] = (byte)(nLength >> 8);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [4] = (byte)(nLength);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der = new byte[6 + nLength];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: Buffer.BlockCopy (val' 0' der' 6' nLength);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [2] = (byte)(nLength >> 24);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [2] = (byte)(nLength >> 24);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [3] = (byte)(nLength >> 16);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [3] = (byte)(nLength >> 16);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [4] = (byte)(nLength >> 8);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [4] = (byte)(nLength >> 8);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der [5] = (byte)(nLength);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der = new byte[2 + nLength];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: Buffer.BlockCopy (val' 0' der' 2' nLength);  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,GetBytes,The following statement contains a magic number: der = new byte[2];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,DecodeTLV,The following statement contains a magic number: if ((length & 0x80) == 0x80) {  	int nLengthLen = length & 0x7F;  	length = 0;  	for (int i = 0; i < nLengthLen; i++)  		length = length * 256 + asn1 [pos++];  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,DecodeTLV,The following statement contains a magic number: for (int i = 0; i < nLengthLen; i++)  	length = length * 256 + asn1 [pos++];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,DecodeTLV,The following statement contains a magic number: length = length * 256 + asn1 [pos++];  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,ToString,The following statement contains a magic number: for (int i = 0; i < Value.Length; i++) {  	hexLine.AppendFormat ("{0} "' Value [i].ToString ("X2"));  	if ((i + 1) % 16 == 0)  		hexLine.AppendFormat (Environment.NewLine);  }  
Magic Number,Mono.Security,ASN1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1.cs,ToString,The following statement contains a magic number: if ((i + 1) % 16 == 0)  	hexLine.AppendFormat (Environment.NewLine);  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,FromDateTime,The following statement contains a magic number: if (dt.Year < 2050) {  	// UTCTIME  	return new ASN1 (0x17' Encoding.ASCII.GetBytes (dt.ToUniversalTime ().ToString ("yyMMddHHmmss"' CultureInfo.InvariantCulture) + "Z"));  } else {  	// GENERALIZEDTIME  	return new ASN1 (0x18' Encoding.ASCII.GetBytes (dt.ToUniversalTime ().ToString ("yyyyMMddHHmmss"' CultureInfo.InvariantCulture) + "Z"));  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,FromInt32,The following statement contains a magic number: switch (x) {  case 0:  	asn1.Value = integer;  	break;  case 4:  	asn1.Value = new byte[1];  	break;  default:  	byte[] smallerInt = new byte[4 - x];  	Buffer.BlockCopy (integer' x' smallerInt' 0' smallerInt.Length);  	asn1.Value = smallerInt;  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,FromInt32,The following statement contains a magic number: switch (x) {  case 0:  	asn1.Value = integer;  	break;  case 4:  	asn1.Value = new byte[1];  	break;  default:  	byte[] smallerInt = new byte[4 - x];  	Buffer.BlockCopy (integer' x' smallerInt' 0' smallerInt.Length);  	asn1.Value = smallerInt;  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToInt32,The following statement contains a magic number: for (int i = 0; i < asn1.Value.Length; i++)  	x = (x << 8) + asn1.Value [i];  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToInt32,The following statement contains a magic number: x = (x << 8) + asn1.Value [i];  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToOid,The following statement contains a magic number: if (x > 2) {  	// Handle special case for large y if x = 2  	y += (byte)((x - 2) * 40);  	x = 2;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToOid,The following statement contains a magic number: if (x > 2) {  	// Handle special case for large y if x = 2  	y += (byte)((x - 2) * 40);  	x = 2;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToOid,The following statement contains a magic number: if (x > 2) {  	// Handle special case for large y if x = 2  	y += (byte)((x - 2) * 40);  	x = 2;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToOid,The following statement contains a magic number: if (x > 2) {  	// Handle special case for large y if x = 2  	y += (byte)((x - 2) * 40);  	x = 2;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToOid,The following statement contains a magic number: y += (byte)((x - 2) * 40);  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToOid,The following statement contains a magic number: y += (byte)((x - 2) * 40);  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToOid,The following statement contains a magic number: x = 2;  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToOid,The following statement contains a magic number: for (x = 1; x < aOID.Length; x++) {  	val = ((val << 7) | ((byte)(aOID [x] & 0x7F)));  	if (!((aOID [x] & 0x80) == 0x80)) {  		sb.Append (".");  		sb.Append (val.ToString (CultureInfo.InvariantCulture));  		val = 0;  	}  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToOid,The following statement contains a magic number: val = ((val << 7) | ((byte)(aOID [x] & 0x7F)));  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: if (year >= 50)  	t = "19" + t;  else  	t = "20" + t;  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  
Magic Number,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following statement contains a magic number: t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetUIntBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]  	};  else  	return new byte[] {  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetUIntBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]  	};  else  	return new byte[] {  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetUIntBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]  	};  else  	return new byte[] {  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetUIntBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]  	};  else  	return new byte[] {  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetUIntBytes,The following statement contains a magic number: return new byte[] {  	bytes [0]'  	bytes [1]'  	bytes [2]'  	bytes [3]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetUIntBytes,The following statement contains a magic number: return new byte[] {  	bytes [0]'  	bytes [1]'  	bytes [2]'  	bytes [3]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetUIntBytes,The following statement contains a magic number: return new byte[] {  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetUIntBytes,The following statement contains a magic number: return new byte[] {  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  	return new byte[] {  		bytes [0]'  		bytes [1]'  		bytes [2]'  		bytes [3]'  		bytes [4]'  		bytes [5]'  		bytes [6]'  		bytes [7]  	};  else  	return new byte[] {  		bytes [7]'  		bytes [6]'  		bytes [5]'  		bytes [4]'  		bytes [3]'  		bytes [2]'  		bytes [1]'  		bytes [0]  	};  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [0]'  	bytes [1]'  	bytes [2]'  	bytes [3]'  	bytes [4]'  	bytes [5]'  	bytes [6]'  	bytes [7]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [0]'  	bytes [1]'  	bytes [2]'  	bytes [3]'  	bytes [4]'  	bytes [5]'  	bytes [6]'  	bytes [7]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [0]'  	bytes [1]'  	bytes [2]'  	bytes [3]'  	bytes [4]'  	bytes [5]'  	bytes [6]'  	bytes [7]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [0]'  	bytes [1]'  	bytes [2]'  	bytes [3]'  	bytes [4]'  	bytes [5]'  	bytes [6]'  	bytes [7]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [0]'  	bytes [1]'  	bytes [2]'  	bytes [3]'  	bytes [4]'  	bytes [5]'  	bytes [6]'  	bytes [7]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [0]'  	bytes [1]'  	bytes [2]'  	bytes [3]'  	bytes [4]'  	bytes [5]'  	bytes [6]'  	bytes [7]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [7]'  	bytes [6]'  	bytes [5]'  	bytes [4]'  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [7]'  	bytes [6]'  	bytes [5]'  	bytes [4]'  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [7]'  	bytes [6]'  	bytes [5]'  	bytes [4]'  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [7]'  	bytes [6]'  	bytes [5]'  	bytes [4]'  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [7]'  	bytes [6]'  	bytes [5]'  	bytes [4]'  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,GetULongBytes,The following statement contains a magic number: return new byte[] {  	bytes [7]'  	bytes [6]'  	bytes [5]'  	bytes [4]'  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  };  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	dst [0] = src [startIndex];  	dst [1] = src [startIndex + 1];  	dst [2] = src [startIndex + 2];  	dst [3] = src [startIndex + 3];  } else {  	dst [0] = src [startIndex + 3];  	dst [1] = src [startIndex + 2];  	dst [2] = src [startIndex + 1];  	dst [3] = src [startIndex];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	dst [0] = src [startIndex];  	dst [1] = src [startIndex + 1];  	dst [2] = src [startIndex + 2];  	dst [3] = src [startIndex + 3];  } else {  	dst [0] = src [startIndex + 3];  	dst [1] = src [startIndex + 2];  	dst [2] = src [startIndex + 1];  	dst [3] = src [startIndex];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	dst [0] = src [startIndex];  	dst [1] = src [startIndex + 1];  	dst [2] = src [startIndex + 2];  	dst [3] = src [startIndex + 3];  } else {  	dst [0] = src [startIndex + 3];  	dst [1] = src [startIndex + 2];  	dst [2] = src [startIndex + 1];  	dst [3] = src [startIndex];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	dst [0] = src [startIndex];  	dst [1] = src [startIndex + 1];  	dst [2] = src [startIndex + 2];  	dst [3] = src [startIndex + 3];  } else {  	dst [0] = src [startIndex + 3];  	dst [1] = src [startIndex + 2];  	dst [2] = src [startIndex + 1];  	dst [3] = src [startIndex];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	dst [0] = src [startIndex];  	dst [1] = src [startIndex + 1];  	dst [2] = src [startIndex + 2];  	dst [3] = src [startIndex + 3];  } else {  	dst [0] = src [startIndex + 3];  	dst [1] = src [startIndex + 2];  	dst [2] = src [startIndex + 1];  	dst [3] = src [startIndex];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	dst [0] = src [startIndex];  	dst [1] = src [startIndex + 1];  	dst [2] = src [startIndex + 2];  	dst [3] = src [startIndex + 3];  } else {  	dst [0] = src [startIndex + 3];  	dst [1] = src [startIndex + 2];  	dst [2] = src [startIndex + 1];  	dst [3] = src [startIndex];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	dst [0] = src [startIndex];  	dst [1] = src [startIndex + 1];  	dst [2] = src [startIndex + 2];  	dst [3] = src [startIndex + 3];  } else {  	dst [0] = src [startIndex + 3];  	dst [1] = src [startIndex + 2];  	dst [2] = src [startIndex + 1];  	dst [3] = src [startIndex];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	dst [0] = src [startIndex];  	dst [1] = src [startIndex + 1];  	dst [2] = src [startIndex + 2];  	dst [3] = src [startIndex + 3];  } else {  	dst [0] = src [startIndex + 3];  	dst [1] = src [startIndex + 2];  	dst [2] = src [startIndex + 1];  	dst [3] = src [startIndex];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: dst [2] = src [startIndex + 2];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: dst [2] = src [startIndex + 2];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: dst [3] = src [startIndex + 3];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: dst [3] = src [startIndex + 3];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: dst [0] = src [startIndex + 3];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: dst [1] = src [startIndex + 2];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: dst [2] = src [startIndex + 1];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,UIntFromBytes,The following statement contains a magic number: dst [3] = src [startIndex];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,ULongFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	for (int i = 0; i < 8; ++i)  		dst [i] = src [startIndex + i];  } else {  	for (int i = 0; i < 8; ++i)  		dst [i] = src [startIndex + (7 - i)];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,ULongFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	for (int i = 0; i < 8; ++i)  		dst [i] = src [startIndex + i];  } else {  	for (int i = 0; i < 8; ++i)  		dst [i] = src [startIndex + (7 - i)];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,ULongFromBytes,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  	for (int i = 0; i < 8; ++i)  		dst [i] = src [startIndex + i];  } else {  	for (int i = 0; i < 8; ++i)  		dst [i] = src [startIndex + (7 - i)];  }  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,ULongFromBytes,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  	dst [i] = src [startIndex + i];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,ULongFromBytes,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  	dst [i] = src [startIndex + (7 - i)];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,ULongFromBytes,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  	dst [i] = src [startIndex + (7 - i)];  
Magic Number,Mono.Security,BitConverterLE,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BitConverterLE.cs,ULongFromBytes,The following statement contains a magic number: dst [i] = src [startIndex + (7 - i)];  
Magic Number,Mono.Security.X509.Extensions,AuthorityKeyIdentifierExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\AuthorityKeyIdentifierExtension.cs,ToString,The following statement contains a magic number: if (aki != null) {  	// [0] KeyIdentifier  	int x = 0;  	sb.Append ("KeyID=");  	while (x < aki.Length) {  		sb.Append (aki [x].ToString ("X2"' CultureInfo.InvariantCulture));  		if (x % 2 == 1)  			sb.Append (" ");  		x++;  	}  	// [1] GeneralNames  	// TODO  	// [2] CertificateSerialNumber  	// TODO  }  
Magic Number,Mono.Security.X509.Extensions,AuthorityKeyIdentifierExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\AuthorityKeyIdentifierExtension.cs,ToString,The following statement contains a magic number: while (x < aki.Length) {  	sb.Append (aki [x].ToString ("X2"' CultureInfo.InvariantCulture));  	if (x % 2 == 1)  		sb.Append (" ");  	x++;  }  
Magic Number,Mono.Security.X509.Extensions,AuthorityKeyIdentifierExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\AuthorityKeyIdentifierExtension.cs,ToString,The following statement contains a magic number: if (x % 2 == 1)  	sb.Append (" ");  
Magic Number,Mono.Security.X509.Extensions,GeneralNames,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\GeneralNames.cs,GeneralNames,The following statement contains a magic number: for (int i = 0; i < sequence.Count; i++) {  	switch (sequence [i].Tag) {  	case 0x81:  		// rfc822Name			[1]	IA5String  		if (rfc822Name == null)  			rfc822Name = new ArrayList ();  		rfc822Name.Add (Encoding.ASCII.GetString (sequence [i].Value));  		break;  	case 0x82:  		// dNSName				[2]     IA5String  		if (dnsName == null)  			dnsName = new ArrayList ();  		dnsName.Add (Encoding.ASCII.GetString (sequence [i].Value));  		break;  	case 0x84:  	// directoryName			[4]     Name  	case 0xA4:  		if (directoryNames == null)  			directoryNames = new ArrayList ();  		directoryNames.Add (X501.ToString (sequence [i] [0]));  		break;  	case 0x86:  		// uniformResourceIdentifier	[6]     IA5String  		if (uris == null)  			uris = new ArrayList ();  		uris.Add (Encoding.ASCII.GetString (sequence [i].Value));  		break;  	case 0x87:  		// iPAddress				[7]     OCTET STRING  		if (ipAddr == null)  			ipAddr = new ArrayList ();  		byte[] bytes = sequence [i].Value;  		string space = (bytes.Length == 4) ? "." : ":";  		StringBuilder sb = new StringBuilder ();  		for (int j = 0; j < bytes.Length; j++) {  			sb.Append (bytes [j].ToString ());  			if (j < bytes.Length - 1)  				sb.Append (space);  		}  		ipAddr.Add (sb.ToString ());  		if (ipAddr == null)  			ipAddr = new ArrayList ();  		break;  	default:  		break;  	}  }  
Magic Number,Mono.Security.X509.Extensions,GeneralNames,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\GeneralNames.cs,GeneralNames,The following statement contains a magic number: switch (sequence [i].Tag) {  case 0x81:  	// rfc822Name			[1]	IA5String  	if (rfc822Name == null)  		rfc822Name = new ArrayList ();  	rfc822Name.Add (Encoding.ASCII.GetString (sequence [i].Value));  	break;  case 0x82:  	// dNSName				[2]     IA5String  	if (dnsName == null)  		dnsName = new ArrayList ();  	dnsName.Add (Encoding.ASCII.GetString (sequence [i].Value));  	break;  case 0x84:  // directoryName			[4]     Name  case 0xA4:  	if (directoryNames == null)  		directoryNames = new ArrayList ();  	directoryNames.Add (X501.ToString (sequence [i] [0]));  	break;  case 0x86:  	// uniformResourceIdentifier	[6]     IA5String  	if (uris == null)  		uris = new ArrayList ();  	uris.Add (Encoding.ASCII.GetString (sequence [i].Value));  	break;  case 0x87:  	// iPAddress				[7]     OCTET STRING  	if (ipAddr == null)  		ipAddr = new ArrayList ();  	byte[] bytes = sequence [i].Value;  	string space = (bytes.Length == 4) ? "." : ":";  	StringBuilder sb = new StringBuilder ();  	for (int j = 0; j < bytes.Length; j++) {  		sb.Append (bytes [j].ToString ());  		if (j < bytes.Length - 1)  			sb.Append (space);  	}  	ipAddr.Add (sb.ToString ());  	if (ipAddr == null)  		ipAddr = new ArrayList ();  	break;  default:  	break;  }  
Magic Number,Mono.Security.X509.Extensions,KeyAttributesExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyAttributesExtension.cs,Decode,The following statement contains a magic number: if (n < seq.Count) {  	ASN1 item = seq [n];  	if (item.Tag == 0x03) {  		n++;  		int i = 1;  		// byte zero has the number of unused bits (ASN1's BITSTRING)  		while (i < item.Value.Length)  			kubits = (kubits << 8) + item.Value [i++];  	}  }  
Magic Number,Mono.Security.X509.Extensions,KeyAttributesExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyAttributesExtension.cs,Decode,The following statement contains a magic number: if (item.Tag == 0x03) {  	n++;  	int i = 1;  	// byte zero has the number of unused bits (ASN1's BITSTRING)  	while (i < item.Value.Length)  		kubits = (kubits << 8) + item.Value [i++];  }  
Magic Number,Mono.Security.X509.Extensions,KeyAttributesExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyAttributesExtension.cs,Decode,The following statement contains a magic number: while (i < item.Value.Length)  	kubits = (kubits << 8) + item.Value [i++];  
Magic Number,Mono.Security.X509.Extensions,KeyAttributesExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyAttributesExtension.cs,Decode,The following statement contains a magic number: kubits = (kubits << 8) + item.Value [i++];  
Magic Number,Mono.Security.X509.Extensions,KeyAttributesExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyAttributesExtension.cs,ToString,The following statement contains a magic number: if (keyId != null) {  	sb.Append ("KeyID=");  	int x = 0;  	while (x < keyId.Length) {  		sb.Append (keyId [x].ToString ("X2"' CultureInfo.InvariantCulture));  		if (x % 2 == 1)  			sb.Append (" ");  		x++;  	}  	sb.Append (Environment.NewLine);  }  
Magic Number,Mono.Security.X509.Extensions,KeyAttributesExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyAttributesExtension.cs,ToString,The following statement contains a magic number: while (x < keyId.Length) {  	sb.Append (keyId [x].ToString ("X2"' CultureInfo.InvariantCulture));  	if (x % 2 == 1)  		sb.Append (" ");  	x++;  }  
Magic Number,Mono.Security.X509.Extensions,KeyAttributesExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyAttributesExtension.cs,ToString,The following statement contains a magic number: if (x % 2 == 1)  	sb.Append (" ");  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Decode,The following statement contains a magic number: while (i < bitString.Value.Length)  	kubits = (kubits << 8) + bitString.Value [i++];  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Decode,The following statement contains a magic number: kubits = (kubits << 8) + bitString.Value [i++];  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: if (ku > 0) {  	// count the unused bits  	for (unused = 15; unused > 0; unused--) {  		if ((ku & 0x8000) == 0x8000)  			break;  		ku <<= 1;  	}  	if (kubits > Byte.MaxValue) {  		unused -= 8;  		extnValue.Add (new ASN1 (0x03' new byte[] {  			unused'  			(byte)kubits'  			(byte)(kubits >> 8)  		}));  	} else {  		extnValue.Add (new ASN1 (0x03' new byte[] {  			unused'  			(byte)kubits  		}));  	}  } else {  	// note: a BITSTRING with a 0 length is invalid (in ASN.1)' so would an  	// empty OCTETSTRING (at the parent level) so we're encoding a 0  	extnValue.Add (new ASN1 (0x03' new byte[] {  		7'  		0  	}));  }  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: if (ku > 0) {  	// count the unused bits  	for (unused = 15; unused > 0; unused--) {  		if ((ku & 0x8000) == 0x8000)  			break;  		ku <<= 1;  	}  	if (kubits > Byte.MaxValue) {  		unused -= 8;  		extnValue.Add (new ASN1 (0x03' new byte[] {  			unused'  			(byte)kubits'  			(byte)(kubits >> 8)  		}));  	} else {  		extnValue.Add (new ASN1 (0x03' new byte[] {  			unused'  			(byte)kubits  		}));  	}  } else {  	// note: a BITSTRING with a 0 length is invalid (in ASN.1)' so would an  	// empty OCTETSTRING (at the parent level) so we're encoding a 0  	extnValue.Add (new ASN1 (0x03' new byte[] {  		7'  		0  	}));  }  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: if (ku > 0) {  	// count the unused bits  	for (unused = 15; unused > 0; unused--) {  		if ((ku & 0x8000) == 0x8000)  			break;  		ku <<= 1;  	}  	if (kubits > Byte.MaxValue) {  		unused -= 8;  		extnValue.Add (new ASN1 (0x03' new byte[] {  			unused'  			(byte)kubits'  			(byte)(kubits >> 8)  		}));  	} else {  		extnValue.Add (new ASN1 (0x03' new byte[] {  			unused'  			(byte)kubits  		}));  	}  } else {  	// note: a BITSTRING with a 0 length is invalid (in ASN.1)' so would an  	// empty OCTETSTRING (at the parent level) so we're encoding a 0  	extnValue.Add (new ASN1 (0x03' new byte[] {  		7'  		0  	}));  }  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: if (ku > 0) {  	// count the unused bits  	for (unused = 15; unused > 0; unused--) {  		if ((ku & 0x8000) == 0x8000)  			break;  		ku <<= 1;  	}  	if (kubits > Byte.MaxValue) {  		unused -= 8;  		extnValue.Add (new ASN1 (0x03' new byte[] {  			unused'  			(byte)kubits'  			(byte)(kubits >> 8)  		}));  	} else {  		extnValue.Add (new ASN1 (0x03' new byte[] {  			unused'  			(byte)kubits  		}));  	}  } else {  	// note: a BITSTRING with a 0 length is invalid (in ASN.1)' so would an  	// empty OCTETSTRING (at the parent level) so we're encoding a 0  	extnValue.Add (new ASN1 (0x03' new byte[] {  		7'  		0  	}));  }  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: for (unused = 15; unused > 0; unused--) {  	if ((ku & 0x8000) == 0x8000)  		break;  	ku <<= 1;  }  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: unused = 15
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: if (kubits > Byte.MaxValue) {  	unused -= 8;  	extnValue.Add (new ASN1 (0x03' new byte[] {  		unused'  		(byte)kubits'  		(byte)(kubits >> 8)  	}));  } else {  	extnValue.Add (new ASN1 (0x03' new byte[] {  		unused'  		(byte)kubits  	}));  }  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: if (kubits > Byte.MaxValue) {  	unused -= 8;  	extnValue.Add (new ASN1 (0x03' new byte[] {  		unused'  		(byte)kubits'  		(byte)(kubits >> 8)  	}));  } else {  	extnValue.Add (new ASN1 (0x03' new byte[] {  		unused'  		(byte)kubits  	}));  }  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: unused -= 8;  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: extnValue.Add (new ASN1 (0x03' new byte[] {  	unused'  	(byte)kubits'  	(byte)(kubits >> 8)  }));  
Magic Number,Mono.Security.X509.Extensions,KeyUsageExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyUsageExtension.cs,Encode,The following statement contains a magic number: extnValue.Add (new ASN1 (0x03' new byte[] {  	7'  	0  }));  
Magic Number,Mono.Security.X509.Extensions,NetscapeCertTypeExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\NetscapeCertTypeExtension.cs,Decode,The following statement contains a magic number: while (i < bitString.Value.Length)  	ctbits = (ctbits << 8) + bitString.Value [i++];  
Magic Number,Mono.Security.X509.Extensions,NetscapeCertTypeExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\NetscapeCertTypeExtension.cs,Decode,The following statement contains a magic number: ctbits = (ctbits << 8) + bitString.Value [i++];  
Magic Number,Mono.Security.X509.Extensions,SubjectKeyIdentifierExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SubjectKeyIdentifierExtension.cs,ToString,The following statement contains a magic number: while (x < ski.Length) {  	sb.Append (ski [x].ToString ("X2"' CultureInfo.InvariantCulture));  	if (x % 2 == 1)  		sb.Append (" ");  	x++;  }  
Magic Number,Mono.Security.X509.Extensions,SubjectKeyIdentifierExtension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SubjectKeyIdentifierExtension.cs,ToString,The following statement contains a magic number: if (x % 2 == 1)  	sb.Append (" ");  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: length = (uint)inData.Length >> 2;  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  	data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  	data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  	data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  	data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  	data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  	data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  	data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  	data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  	data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: i -= 4
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [j] = (uint)((inData [i - 3] << (3 * 8)) | (inData [i - 2] << (2 * 8)) | (inData [i - 1] << (1 * 8)) | (inData [i]));  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  case 1:  	data [length - 1] = (uint)inData [0];  	break;  case 2:  	data [length - 1] = (uint)((inData [0] << 8) | inData [1]);  	break;  case 3:  	data [length - 1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]);  	break;  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  case 1:  	data [length - 1] = (uint)inData [0];  	break;  case 2:  	data [length - 1] = (uint)((inData [0] << 8) | inData [1]);  	break;  case 3:  	data [length - 1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]);  	break;  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  case 1:  	data [length - 1] = (uint)inData [0];  	break;  case 2:  	data [length - 1] = (uint)((inData [0] << 8) | inData [1]);  	break;  case 3:  	data [length - 1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]);  	break;  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  case 1:  	data [length - 1] = (uint)inData [0];  	break;  case 2:  	data [length - 1] = (uint)((inData [0] << 8) | inData [1]);  	break;  case 3:  	data [length - 1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]);  	break;  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  case 1:  	data [length - 1] = (uint)inData [0];  	break;  case 2:  	data [length - 1] = (uint)((inData [0] << 8) | inData [1]);  	break;  case 3:  	data [length - 1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]);  	break;  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  case 1:  	data [length - 1] = (uint)inData [0];  	break;  case 2:  	data [length - 1] = (uint)((inData [0] << 8) | inData [1]);  	break;  case 3:  	data [length - 1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]);  	break;  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [length - 1] = (uint)((inData [0] << 8) | inData [1]);  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [length - 1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]);  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [length - 1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]);  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data [length - 1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]);  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint[2] {  	(uint)ul'  	(uint)(ul >> 32)  };  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint[2] {  	(uint)ul'  	(uint)(ul >> 32)  };  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following statement contains a magic number: length = 2;  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,Parse,The following statement contains a magic number: for (; i < len; i++) {  	c = number [i];  	if (c == '\0') {  		i = len;  		continue;  	}  	if (c >= '0' && c <= '9') {  		val = val * 10 + (c - '0');  		digits_seen = true;  	} else {  		if (Char.IsWhiteSpace (c)) {  			for (i++; i < len; i++) {  				if (!Char.IsWhiteSpace (number [i]))  					throw new FormatException ();  			}  			break;  		} else  			throw new FormatException ();  	}  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,Parse,The following statement contains a magic number: if (c >= '0' && c <= '9') {  	val = val * 10 + (c - '0');  	digits_seen = true;  } else {  	if (Char.IsWhiteSpace (c)) {  		for (i++; i < len; i++) {  			if (!Char.IsWhiteSpace (number [i]))  				throw new FormatException ();  		}  		break;  	} else  		throw new FormatException ();  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,Parse,The following statement contains a magic number: val = val * 10 + (c - '0');  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,GenerateRandom,The following statement contains a magic number: Buffer.BlockCopy (random' 0' ret.data' 0' (int)dwords << 2);  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,GenerateRandom,The following statement contains a magic number: if (remBits != 0) {  	uint mask = (uint)(0x01 << (remBits - 1));  	ret.data [dwords - 1] |= mask;  	mask = (uint)(0xFFFFFFFF >> (32 - remBits));  	ret.data [dwords - 1] &= mask;  } else  	ret.data [dwords - 1] |= 0x80000000;  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,GenerateRandom,The following statement contains a magic number: mask = (uint)(0xFFFFFFFF >> (32 - remBits));  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,Randomize,The following statement contains a magic number: Buffer.BlockCopy (random' 0' data' 0' (int)dwords << 2);  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,Randomize,The following statement contains a magic number: if (remBits != 0) {  	uint mask = (uint)(0x01 << (remBits - 1));  	data [dwords - 1] |= mask;  	mask = (uint)(0xFFFFFFFF >> (32 - remBits));  	data [dwords - 1] &= mask;  } else  	data [dwords - 1] |= 0x80000000;  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,Randomize,The following statement contains a magic number: mask = (uint)(0xFFFFFFFF >> (32 - remBits));  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BitCount,The following statement contains a magic number: bits += ((length - 1) << 5);  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,GetBytes,The following statement contains a magic number: if (numBytesInWord == 0)  	numBytesInWord = 4;  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,GetBytes,The following statement contains a magic number: numBytesInWord = 4;  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--) {  	uint val = data [i];  	for (int j = numBytesInWord - 1; j >= 0; j--) {  		result [pos + j] = (byte)(val & 0xFF);  		val >>= 8;  	}  	pos += numBytesInWord;  	numBytesInWord = 4;  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--) {  	uint val = data [i];  	for (int j = numBytesInWord - 1; j >= 0; j--) {  		result [pos + j] = (byte)(val & 0xFF);  		val >>= 8;  	}  	pos += numBytesInWord;  	numBytesInWord = 4;  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int j = numBytesInWord - 1; j >= 0; j--) {  	result [pos + j] = (byte)(val & 0xFF);  	val >>= 8;  }  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,GetBytes,The following statement contains a magic number: val >>= 8;  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,GetBytes,The following statement contains a magic number: numBytesInWord = 4;  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,ToString,The following statement contains a magic number: return ToString (10);  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,Incr2,The following statement contains a magic number: data [0] += 2;  
Magic Number,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,Incr2,The following statement contains a magic number: if (data [0] < 2) {  	// Account for the first carry  	data [++i]++;  	// Keep adding until no carry  	while (data [i++] == 0x0)  		data [i]++;  	// See if we increased the data length  	if (length == (uint)i)  		length++;  }  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 100)  	Rounds = 27;  else if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 27;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 150)  	Rounds = 18;  else if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 18;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 200)  	Rounds = 15;  else if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 15;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 250)  	Rounds = 12;  else if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 12;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 300)  	Rounds = 9;  else if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 9;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 350)  	Rounds = 8;  else if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 8;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 400)  	Rounds = 7;  else if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 7;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 500)  	Rounds = 6;  else if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 6;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 600)  	Rounds = 5;  else if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 5;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 800)  	Rounds = 4;  else if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 4;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if (bc <= 1250)  	Rounds = 3;  else  	Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 3;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds = 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: switch (confidence) {  case ConfidenceFactor.ExtraLow:  	Rounds >>= 2;  	return Rounds != 0 ? Rounds : 1;  case ConfidenceFactor.Low:  	Rounds >>= 1;  	return Rounds != 0 ? Rounds : 1;  case ConfidenceFactor.Medium:  	return Rounds;  case ConfidenceFactor.High:  	return Rounds << 1;  case ConfidenceFactor.ExtraHigh:  	return Rounds << 2;  case ConfidenceFactor.Provable:  	throw new Exception ("The Rabin-Miller test can not be executed in a way such that its results are provable");  default:  	throw new ArgumentOutOfRangeException ("confidence");  }  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: switch (confidence) {  case ConfidenceFactor.ExtraLow:  	Rounds >>= 2;  	return Rounds != 0 ? Rounds : 1;  case ConfidenceFactor.Low:  	Rounds >>= 1;  	return Rounds != 0 ? Rounds : 1;  case ConfidenceFactor.Medium:  	return Rounds;  case ConfidenceFactor.High:  	return Rounds << 1;  case ConfidenceFactor.ExtraHigh:  	return Rounds << 2;  case ConfidenceFactor.Provable:  	throw new Exception ("The Rabin-Miller test can not be executed in a way such that its results are provable");  default:  	throw new ArgumentOutOfRangeException ("confidence");  }  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: Rounds >>= 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: return Rounds << 2;  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,Test,The following statement contains a magic number: if (n.BitCount () < 33)  	return SmallPrimeSppTest (n' confidence);  else  	return RabinMillerTest (n' confidence);  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: if (n.BitCount () > 100)  	y = mr.Pow (2' r);  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: if (n.BitCount () > 100)  	y = mr.Pow (2' r);  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: y = mr.Pow (2' r);  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: for (int round = 0; round < t; round++) {  	if ((round > 0) || (y == null)) {  		BigInteger a = null;  		// check for 2 <= a <= n - 2  		// ...but we already did a == 2 previously as an optimization  		do {  			a = BigInteger.GenerateRandom (bits);  		} while ((a <= 2) && (a >= n_minus_1));  		y = mr.Pow (a' r);  	}  	if (y == 1)  		continue;  	for (int j = 0; ((j < s) && (y != n_minus_1)); j++) {  		y = mr.Pow (y' 2);  		if (y == 1)  			return false;  	}  	if (y != n_minus_1)  		return false;  }  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: for (int round = 0; round < t; round++) {  	if ((round > 0) || (y == null)) {  		BigInteger a = null;  		// check for 2 <= a <= n - 2  		// ...but we already did a == 2 previously as an optimization  		do {  			a = BigInteger.GenerateRandom (bits);  		} while ((a <= 2) && (a >= n_minus_1));  		y = mr.Pow (a' r);  	}  	if (y == 1)  		continue;  	for (int j = 0; ((j < s) && (y != n_minus_1)); j++) {  		y = mr.Pow (y' 2);  		if (y == 1)  			return false;  	}  	if (y != n_minus_1)  		return false;  }  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: if ((round > 0) || (y == null)) {  	BigInteger a = null;  	// check for 2 <= a <= n - 2  	// ...but we already did a == 2 previously as an optimization  	do {  		a = BigInteger.GenerateRandom (bits);  	} while ((a <= 2) && (a >= n_minus_1));  	y = mr.Pow (a' r);  }  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: do {  	a = BigInteger.GenerateRandom (bits);  } while ((a <= 2) && (a >= n_minus_1));  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: for (int j = 0; ((j < s) && (y != n_minus_1)); j++) {  	y = mr.Pow (y' 2);  	if (y == 1)  		return false;  }  
Magic Number,Mono.Math.Prime,PrimalityTests,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: y = mr.Pow (y' 2);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,GetBytesLE,The following statement contains a magic number: return new byte[] {  	(byte)(val & 0xff)'  	(byte)((val >> 8) & 0xff)'  	(byte)((val >> 16) & 0xff)'  	(byte)((val >> 24) & 0xff)  };  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,GetBytesLE,The following statement contains a magic number: return new byte[] {  	(byte)(val & 0xff)'  	(byte)((val >> 8) & 0xff)'  	(byte)((val >> 16) & 0xff)'  	(byte)((val >> 24) & 0xff)  };  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,GetBytesLE,The following statement contains a magic number: return new byte[] {  	(byte)(val & 0xff)'  	(byte)((val >> 8) & 0xff)'  	(byte)((val >> 16) & 0xff)'  	(byte)((val >> 24) & 0xff)  };  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.X = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  	Array.Reverse (dsap.X);  	pos += 20;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: dsap.Q = new byte[20];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: dsap.X = new byte[20];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: Buffer.BlockCopy (blob' pos' dsap.X' 0' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: pos += 4;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: dsap.Seed = new byte[20];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPrivateKeyBlobDSA,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [5] = 0x24;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [8] = 0x52;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [9] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [10] = 0x41;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [11] = 0x32;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [12] = bitlen [0];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [13] = bitlen [1];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: pos = 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [5] = 0x22;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [8] = 0x44;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [9] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [10] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [11] = 0x32;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [12] = bitlen [0];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [13] = bitlen [1];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (part' 0' blob' pos' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (part' 0' blob' pos' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (GetBytesLE (p.Counter)' 0' blob' pos' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: pos += 4;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (part' 0' blob' pos' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	#if INSIDE_CORLIB && MOBILE  					RSA rsa = RSA.Create (); 				rsa.ImportParameters (rsap); #else  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	#endif  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent = new byte[3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [0] = blob [offset + 18];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [1] = blob [offset + 17];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [2] = blob [offset + 16];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [2] = blob [offset + 16];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  		// DWORD magic  		throw new CryptographicException ("Invalid blob header");  	int bitlen = ToInt32LE (blob' offset + 12);  	DSAParameters dsap = new DSAParameters ();  	int bytelen = bitlen >> 3;  	int pos = offset + 16;  	dsap.P = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.P' 0' bytelen);  	Array.Reverse (dsap.P);  	pos += bytelen;  	dsap.Q = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  	Array.Reverse (dsap.Q);  	pos += 20;  	dsap.G = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.G' 0' bytelen);  	Array.Reverse (dsap.G);  	pos += bytelen;  	dsap.Y = new byte[bytelen];  	Buffer.BlockCopy (blob' pos' dsap.Y' 0' bytelen);  	Array.Reverse (dsap.Y);  	pos += bytelen;  	dsap.Counter = ToInt32LE (blob' pos);  	pos += 4;  	dsap.Seed = new byte[20];  	Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  	Array.Reverse (dsap.Seed);  	pos += 20;  	DSA dsa = (DSA)DSA.Create ();  	dsa.ImportParameters (dsap);  	return dsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31535344))  	// DWORD magic  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: dsap.Q = new byte[20];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: Buffer.BlockCopy (blob' pos' dsap.Q' 0' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: pos += 4;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: dsap.Seed = new byte[20];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: Buffer.BlockCopy (blob' pos' dsap.Seed' 0' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiPublicKeyBlobDSA,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [5] = 0x24;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [8] = 0x52;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [9] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [10] = 0x41;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [11] = 0x31;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [12] = bitlen [0];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [13] = bitlen [1];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: pos = 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [5] = 0x22;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [8] = 0x44;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [9] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [10] = 0x53;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [11] = 0x31;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [12] = bitlen [0];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [13] = bitlen [1];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [14] = bitlen [2];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: blob [15] = bitlen [3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (part' 0' blob' pos' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: pos += 20;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (GetBytesLE (p.Counter)' 0' blob' pos' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: pos += 4;  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,ToCapiPublicKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (part' 0' blob' pos' 20);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: if (blob [offset + 12] == 0x06) {  	return FromCapiPublicKeyBlob (blob' offset + 12);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: if (blob [offset + 12] == 0x06) {  	return FromCapiPublicKeyBlob (blob' offset + 12);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: return FromCapiPublicKeyBlob (blob' offset + 12);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromHexChar,The following statement contains a magic number: if ((c >= 'a') && (c <= 'f'))  	return (byte)(c - 'a' + 10);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromHexChar,The following statement contains a magic number: return (byte)(c - 'a' + 10);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromHexChar,The following statement contains a magic number: if ((c >= 'A') && (c <= 'F'))  	return (byte)(c - 'A' + 10);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromHexChar,The following statement contains a magic number: return (byte)(c - 'A' + 10);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromHex,The following statement contains a magic number: while (n < result.Length) {  	result [n] = (byte)(FromHexChar (hex [i++]) << 4);  	result [n++] += FromHexChar (hex [i++]);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromHex,The following statement contains a magic number: result [n] = (byte)(FromHexChar (hex [i++]) << 4);  
Magic Number,Mono.Security.Cryptography,KeyPairPersistence,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyPairPersistence.cs,CanSecure,The following statement contains a magic number: if ((platform == 4) || (platform == 128) || (platform == 6))  	return true;  
Magic Number,Mono.Security.Cryptography,KeyPairPersistence,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyPairPersistence.cs,CanSecure,The following statement contains a magic number: if ((platform == 4) || (platform == 128) || (platform == 6))  	return true;  
Magic Number,Mono.Security.Cryptography,KeyPairPersistence,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\KeyPairPersistence.cs,CanSecure,The following statement contains a magic number: if ((platform == 4) || (platform == 128) || (platform == 6))  	return true;  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Encrypt_OAEP,The following statement contains a magic number: if (M.Length > size - 2 * hLen - 2)  	throw new CryptographicException ("message too long");  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Encrypt_OAEP,The following statement contains a magic number: if (M.Length > size - 2 * hLen - 2)  	throw new CryptographicException ("message too long");  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Decrypt_OAEP,The following statement contains a magic number: if ((size < (2 * hLen + 2)) || (C.Length != size))  	throw new CryptographicException ("decryption error");  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Decrypt_OAEP,The following statement contains a magic number: if ((size < (2 * hLen + 2)) || (C.Length != size))  	throw new CryptographicException ("decryption error");  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Encrypt_v15,The following statement contains a magic number: if (M.Length > size - 11)  	throw new CryptographicException ("message too long");  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Encrypt_v15,The following statement contains a magic number: Buffer.BlockCopy (PS' 0' EM' 2' PSLength);  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Decrypt_v15,The following statement contains a magic number: if ((size < 11) || (C.Length > size))  	throw new CryptographicException ("decryption error");  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Verify_v15,The following statement contains a magic number: for (i = 2; i < EM2.Length - hashValue.Length - 1; i++) {  	if (EM2 [i] != 0xFF)  		return false;  }  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Verify_v15,The following statement contains a magic number: i = 2
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Encode_v15,The following statement contains a magic number: if (hashValue.Length != (hash.HashSize >> 3))  	throw new CryptographicException ("bad hash length for " + hash.ToString ());  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Encode_v15,The following statement contains a magic number: for (int i = 2; i < PSLength + 2; i++)  	EM [i] = 0xff;  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Encode_v15,The following statement contains a magic number: for (int i = 2; i < PSLength + 2; i++)  	EM [i] = 0xff;  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,Encode_v15,The following statement contains a magic number: Buffer.BlockCopy (t' 0' EM' PSLength + 3' t.Length);  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,MGF1,The following statement contains a magic number: for (int counter = 0; counter < iterations; counter++) {  	// a.	Convert counter to an octet string C of length 4 octets  	byte[] C = I2OSP (counter' 4);  	// b.	Concatenate the hash of the seed mgfSeed and C to the octet string T:  	//	T = T || Hash (mgfSeed || C)  	Buffer.BlockCopy (mgfSeed' 0' toBeHashed' 0' mgfSeedLength);  	Buffer.BlockCopy (C' 0' toBeHashed' mgfSeedLength' 4);  	byte[] output = hash.ComputeHash (toBeHashed);  	Buffer.BlockCopy (output' 0' T' pos' hLen);  	pos += hLen;  }  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,MGF1,The following statement contains a magic number: for (int counter = 0; counter < iterations; counter++) {  	// a.	Convert counter to an octet string C of length 4 octets  	byte[] C = I2OSP (counter' 4);  	// b.	Concatenate the hash of the seed mgfSeed and C to the octet string T:  	//	T = T || Hash (mgfSeed || C)  	Buffer.BlockCopy (mgfSeed' 0' toBeHashed' 0' mgfSeedLength);  	Buffer.BlockCopy (C' 0' toBeHashed' mgfSeedLength' 4);  	byte[] output = hash.ComputeHash (toBeHashed);  	Buffer.BlockCopy (output' 0' T' pos' hLen);  	pos += hLen;  }  
Magic Number,Mono.Security.Cryptography,PKCS1,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS1.cs,MGF1,The following statement contains a magic number: Buffer.BlockCopy (C' 0' toBeHashed' mgfSeedLength' 4);  
Magic Number,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,RSAManaged,The following statement contains a magic number: LegalKeySizesValue [0] = new KeySizes (384' 16384' 8);  
Magic Number,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,RSAManaged,The following statement contains a magic number: LegalKeySizesValue [0] = new KeySizes (384' 16384' 8);  
Magic Number,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,RSAManaged,The following statement contains a magic number: LegalKeySizesValue [0] = new KeySizes (384' 16384' 8);  
Magic Number,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,ExportParameters,The following statement contains a magic number: if (includePrivateParameters) {  	// some parameters are required for exporting the private key  	if (d == null)  		throw new CryptographicException ("Missing private key");  	param.D = d.GetBytes ();  	// hack for bugzilla #57941 where D wasn't provided  	if (param.D.Length != param.Modulus.Length) {  		byte[] normalizedD = new byte[param.Modulus.Length];  		Buffer.BlockCopy (param.D' 0' normalizedD' (normalizedD.Length - param.D.Length)' param.D.Length);  		param.D = normalizedD;  	}  	// but CRT parameters are optionals  	if ((p != null) && (q != null) && (dp != null) && (dq != null) && (qInv != null)) {  		// and we include them only if we have them all  		int length = (KeySize >> 4);  		param.P = GetPaddedValue (p' length);  		param.Q = GetPaddedValue (q' length);  		param.DP = GetPaddedValue (dp' length);  		param.DQ = GetPaddedValue (dq' length);  		param.InverseQ = GetPaddedValue (qInv' length);  	}  }  
Magic Number,Mono.Security.Cryptography,RSAManaged,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\RSAManaged.cs,ExportParameters,The following statement contains a magic number: if ((p != null) && (q != null) && (dp != null) && (dq != null) && (qInv != null)) {  	// and we include them only if we have them all  	int length = (KeySize >> 4);  	param.P = GetPaddedValue (p' length);  	param.Q = GetPaddedValue (q' length);  	param.DP = GetPaddedValue (dp' length);  	param.DQ = GetPaddedValue (dq' length);  	param.InverseQ = GetPaddedValue (qInv' length);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,MiniParser,The following statement contains a magic number: twoCharBuff = new int[2];  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Xlat,The following statement contains a magic number: for (; --n >= 0;) {  	ushort code = tbl [p];  	if (charCode == (code >> 12))  		return (code & 0xFFF);  	p++;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Xlat,The following statement contains a magic number: if (charCode == (code >> 12))  	return (code & 0xFFF);  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	++this.col;  	currCh = reader.Read ();  	if (currCh == -1) {  		if (stateCode != 0) {  			FatalErr ("Unexpected EOF");  		}  		break;  	}  	int charCode = "<>/?=&'\"![ ]\t\r\n".IndexOf ((char)currCh) & 0xF;  	if (charCode == (int)CharKind.CR)  		continue;  	// ignore  	// whitepace ::= (#x20 | #x9 | #xd | #xa)+  	if (charCode == (int)CharKind.TAB)  		charCode = (int)CharKind.SPACE;  	// tab == space  	if (charCode == (int)CharKind.EOL) {  		this.col = 0;  		this.line++;  		charCode = (int)CharKind.SPACE;  	}  	int actionCode = MiniParser.Xlat (charCode' stateCode);  	stateCode = actionCode & 0xFF;  	// Ignore newline inside attribute value.  	if (currCh == '\n' && (stateCode == 0xE || stateCode == 0xF))  		continue;  	actionCode >>= 8;  	if (stateCode >= 0x80) {  		if (stateCode == 0xFF) {  			FatalErr ("State dispatch error.");  		} else {  			FatalErr (errors [stateCode ^ 0x80]);  		}  	}  	switch (actionCode) {  	case (int)ActionCode.START_ELEM:  		handler.OnStartElement (elementName' attrList);  		if (currCh != '/') {  			tagStack.Push (elementName);  		} else {  			handler.OnEndElement (elementName);  		}  		attrList.Clear ();  		break;  	case (int)ActionCode.END_ELEM:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		string endName = null;  		if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  			if (endName == null) {  				FatalErr ("Tag stack underflow");  			} else {  				FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  			}  		}  		handler.OnEndElement (elementName);  		break;  	case (int)ActionCode.END_NAME:  		elementName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		if (currCh != '/' && currCh != '>')  			break;  		goto case (int)ActionCode.START_ELEM;  	case (int)ActionCode.SET_ATTR_NAME:  		lastAttrName = sbChars.ToString ();  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.SET_ATTR_VAL:  		if (lastAttrName == null)  			FatalErr ("Internal error.");  		attrList.Add (lastAttrName' sbChars.ToString ());  		sbChars = new StringBuilder ();  		lastAttrName = null;  		break;  	case (int)ActionCode.SEND_CHARS:  		handler.OnChars (sbChars.ToString ());  		sbChars = new StringBuilder ();  		break;  	case (int)ActionCode.START_CDATA:  		string cdata = "CDATA[";  		isComment = false;  		isDTD = false;  		if (currCh == '-') {  			currCh = reader.Read ();  			if (currCh != '-')  				FatalErr ("Invalid comment");  			this.col++;  			isComment = true;  			twoCharBuff [0] = -1;  			twoCharBuff [1] = -1;  		} else {  			if (currCh != '[') {  				isDTD = true;  				bracketSwitch = 0;  				break;  			}  			for (int i = 0; i < cdata.Length; i++) {  				if (reader.Read () != cdata [i]) {  					this.col += i + 1;  					break;  				}  			}  			this.col += cdata.Length;  			seenCData = true;  		}  		break;  	case (int)ActionCode.END_CDATA:  		int n = 0;  		currCh = ']';  		while (currCh == ']') {  			currCh = reader.Read ();  			n++;  		}  		if (currCh != '>') {  			for (int i = 0; i < n; i++)  				sbChars.Append (']');  			sbChars.Append ((char)currCh);  			stateCode = 0x12;  		} else {  			for (int i = 0; i < n - 2; i++)  				sbChars.Append (']');  			seenCData = false;  		}  		this.col += n;  		break;  	case (int)ActionCode.ERROR:  		FatalErr (String.Format ("Error {0}"' stateCode));  		break;  	case (int)ActionCode.STATE_CHANGE:  		break;  	case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  		sbChars = new StringBuilder ();  		if (currCh != '<')  			goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  		break;  	case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  		sbChars.Append ((char)currCh);  		break;  	case (int)ActionCode.ACC_CDATA:  		if (isComment) {  			if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  				isComment = false;  				stateCode = 0;  			} else {  				twoCharBuff [0] = twoCharBuff [1];  				twoCharBuff [1] = currCh;  			}  		} else if (isDTD) {  			if (currCh == '<' || currCh == '>')  				bracketSwitch ^= 1;  			if (currCh == '>' && bracketSwitch != 0) {  				isDTD = false;  				stateCode = 0;  			}  		} else {  			if (this.splitCData && sbChars.Length > 0 && seenCData) {  				handler.OnChars (sbChars.ToString ());  				sbChars = new StringBuilder ();  			}  			seenCData = false;  			sbChars.Append ((char)currCh);  		}  		break;  	case (int)ActionCode.PROC_CHAR_REF:  		currCh = reader.Read ();  		int cl = this.col + 1;  		if (currCh == '#') {  			// character reference  			int r = 10;  			int chCode = 0;  			int nDigits = 0;  			currCh = reader.Read ();  			cl++;  			if (currCh == 'x') {  				currCh = reader.Read ();  				cl++;  				r = 16;  			}  			NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  			while (true) {  				int x = -1;  				if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  					try {  						x = Int32.Parse (new string ((char)currCh' 1)' style);  					} catch (FormatException) {  						x = -1;  					}  				}  				if (x == -1)  					break;  				chCode *= r;  				chCode += x;  				nDigits++;  				currCh = reader.Read ();  				cl++;  			}  			if (currCh == ';' && nDigits > 0) {  				sbChars.Append ((char)chCode);  			} else {  				FatalErr ("Bad char ref");  			}  		} else {  			// entity reference  			string entityRefChars = "aglmopqstu";  			// amp | apos | quot | gt | lt  			string entities = "&'\"><";  			int pos = 0;  			int entIdx = 0xF;  			int predShift = 0;  			int sbLen = sbChars.Length;  			while (true) {  				if (pos != 0xF)  					pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  				if (pos == 0xF)  					FatalErr (errors [7]);  				sbChars.Append ((char)currCh);  				int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  				int lBr = (path >> 4) & 0xF;  				int rBr = path & 0xF;  				int lPred = path >> 12;  				int rPred = (path >> 8) & 0xF;  				currCh = reader.Read ();  				cl++;  				pos = 0xF;  				if (lBr != 0xF && currCh == entityRefChars [lBr]) {  					if (lPred < 0xE)  						entIdx = lPred;  					//								pred = lPred;  					predShift = 12;  					// left  				} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  					if (rPred < 0xE)  						entIdx = rPred;  					//								pred = rPred;  					predShift = 8;  					// right  				} else if (currCh == ';') {  					if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  						break;  					continue;  					// pos == 0xF  				}  				pos = 0;  			}  			int l = cl - this.col - 1;  			if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  				sbChars.Length = sbLen;  				sbChars.Append (entities [entIdx]);  			} else  				FatalErr (errors [7]);  		}  		this.col = cl;  		break;  	default:  		FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  		break;  	}  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: actionCode >>= 8;  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: switch (actionCode) {  case (int)ActionCode.START_ELEM:  	handler.OnStartElement (elementName' attrList);  	if (currCh != '/') {  		tagStack.Push (elementName);  	} else {  		handler.OnEndElement (elementName);  	}  	attrList.Clear ();  	break;  case (int)ActionCode.END_ELEM:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	string endName = null;  	if (tagStack.Count == 0 || elementName != (endName = tagStack.Pop () as string)) {  		if (endName == null) {  			FatalErr ("Tag stack underflow");  		} else {  			FatalErr (String.Format ("Expected end tag '{0}' but found '{1}'"' elementName' endName));  		}  	}  	handler.OnEndElement (elementName);  	break;  case (int)ActionCode.END_NAME:  	elementName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	if (currCh != '/' && currCh != '>')  		break;  	goto case (int)ActionCode.START_ELEM;  case (int)ActionCode.SET_ATTR_NAME:  	lastAttrName = sbChars.ToString ();  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.SET_ATTR_VAL:  	if (lastAttrName == null)  		FatalErr ("Internal error.");  	attrList.Add (lastAttrName' sbChars.ToString ());  	sbChars = new StringBuilder ();  	lastAttrName = null;  	break;  case (int)ActionCode.SEND_CHARS:  	handler.OnChars (sbChars.ToString ());  	sbChars = new StringBuilder ();  	break;  case (int)ActionCode.START_CDATA:  	string cdata = "CDATA[";  	isComment = false;  	isDTD = false;  	if (currCh == '-') {  		currCh = reader.Read ();  		if (currCh != '-')  			FatalErr ("Invalid comment");  		this.col++;  		isComment = true;  		twoCharBuff [0] = -1;  		twoCharBuff [1] = -1;  	} else {  		if (currCh != '[') {  			isDTD = true;  			bracketSwitch = 0;  			break;  		}  		for (int i = 0; i < cdata.Length; i++) {  			if (reader.Read () != cdata [i]) {  				this.col += i + 1;  				break;  			}  		}  		this.col += cdata.Length;  		seenCData = true;  	}  	break;  case (int)ActionCode.END_CDATA:  	int n = 0;  	currCh = ']';  	while (currCh == ']') {  		currCh = reader.Read ();  		n++;  	}  	if (currCh != '>') {  		for (int i = 0; i < n; i++)  			sbChars.Append (']');  		sbChars.Append ((char)currCh);  		stateCode = 0x12;  	} else {  		for (int i = 0; i < n - 2; i++)  			sbChars.Append (']');  		seenCData = false;  	}  	this.col += n;  	break;  case (int)ActionCode.ERROR:  	FatalErr (String.Format ("Error {0}"' stateCode));  	break;  case (int)ActionCode.STATE_CHANGE:  	break;  case (int)ActionCode.FLUSH_CHARS_STATE_CHANGE:  	sbChars = new StringBuilder ();  	if (currCh != '<')  		goto case (int)ActionCode.ACC_CHARS_STATE_CHANGE;  	break;  case (int)ActionCode.ACC_CHARS_STATE_CHANGE:  	sbChars.Append ((char)currCh);  	break;  case (int)ActionCode.ACC_CDATA:  	if (isComment) {  		if (currCh == '>' && twoCharBuff [0] == '-' && twoCharBuff [1] == '-') {  			isComment = false;  			stateCode = 0;  		} else {  			twoCharBuff [0] = twoCharBuff [1];  			twoCharBuff [1] = currCh;  		}  	} else if (isDTD) {  		if (currCh == '<' || currCh == '>')  			bracketSwitch ^= 1;  		if (currCh == '>' && bracketSwitch != 0) {  			isDTD = false;  			stateCode = 0;  		}  	} else {  		if (this.splitCData && sbChars.Length > 0 && seenCData) {  			handler.OnChars (sbChars.ToString ());  			sbChars = new StringBuilder ();  		}  		seenCData = false;  		sbChars.Append ((char)currCh);  	}  	break;  case (int)ActionCode.PROC_CHAR_REF:  	currCh = reader.Read ();  	int cl = this.col + 1;  	if (currCh == '#') {  		// character reference  		int r = 10;  		int chCode = 0;  		int nDigits = 0;  		currCh = reader.Read ();  		cl++;  		if (currCh == 'x') {  			currCh = reader.Read ();  			cl++;  			r = 16;  		}  		NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  		while (true) {  			int x = -1;  			if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  				try {  					x = Int32.Parse (new string ((char)currCh' 1)' style);  				} catch (FormatException) {  					x = -1;  				}  			}  			if (x == -1)  				break;  			chCode *= r;  			chCode += x;  			nDigits++;  			currCh = reader.Read ();  			cl++;  		}  		if (currCh == ';' && nDigits > 0) {  			sbChars.Append ((char)chCode);  		} else {  			FatalErr ("Bad char ref");  		}  	} else {  		// entity reference  		string entityRefChars = "aglmopqstu";  		// amp | apos | quot | gt | lt  		string entities = "&'\"><";  		int pos = 0;  		int entIdx = 0xF;  		int predShift = 0;  		int sbLen = sbChars.Length;  		while (true) {  			if (pos != 0xF)  				pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  			if (pos == 0xF)  				FatalErr (errors [7]);  			sbChars.Append ((char)currCh);  			int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  			int lBr = (path >> 4) & 0xF;  			int rBr = path & 0xF;  			int lPred = path >> 12;  			int rPred = (path >> 8) & 0xF;  			currCh = reader.Read ();  			cl++;  			pos = 0xF;  			if (lBr != 0xF && currCh == entityRefChars [lBr]) {  				if (lPred < 0xE)  					entIdx = lPred;  				//								pred = lPred;  				predShift = 12;  				// left  			} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  				if (rPred < 0xE)  					entIdx = rPred;  				//								pred = rPred;  				predShift = 8;  				// right  			} else if (currCh == ';') {  				if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  					break;  				continue;  				// pos == 0xF  			}  			pos = 0;  		}  		int l = cl - this.col - 1;  		if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  			sbChars.Length = sbLen;  			sbChars.Append (entities [entIdx]);  		} else  			FatalErr (errors [7]);  	}  	this.col = cl;  	break;  default:  	FatalErr (String.Format ("Unexpected action code - {0}."' actionCode));  	break;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh != '>') {  	for (int i = 0; i < n; i++)  		sbChars.Append (']');  	sbChars.Append ((char)currCh);  	stateCode = 0x12;  } else {  	for (int i = 0; i < n - 2; i++)  		sbChars.Append (']');  	seenCData = false;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: for (int i = 0; i < n - 2; i++)  	sbChars.Append (']');  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == '#') {  	// character reference  	int r = 10;  	int chCode = 0;  	int nDigits = 0;  	currCh = reader.Read ();  	cl++;  	if (currCh == 'x') {  		currCh = reader.Read ();  		cl++;  		r = 16;  	}  	NumberStyles style = r == 16 ? NumberStyles.HexNumber : NumberStyles.Integer;  	while (true) {  		int x = -1;  		if (Char.IsNumber ((char)currCh) || "abcdef".IndexOf (Char.ToLower ((char)currCh)) != -1) {  			try {  				x = Int32.Parse (new string ((char)currCh' 1)' style);  			} catch (FormatException) {  				x = -1;  			}  		}  		if (x == -1)  			break;  		chCode *= r;  		chCode += x;  		nDigits++;  		currCh = reader.Read ();  		cl++;  	}  	if (currCh == ';' && nDigits > 0) {  		sbChars.Append ((char)chCode);  	} else {  		FatalErr ("Bad char ref");  	}  } else {  	// entity reference  	string entityRefChars = "aglmopqstu";  	// amp | apos | quot | gt | lt  	string entities = "&'\"><";  	int pos = 0;  	int entIdx = 0xF;  	int predShift = 0;  	int sbLen = sbChars.Length;  	while (true) {  		if (pos != 0xF)  			pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  		if (pos == 0xF)  			FatalErr (errors [7]);  		sbChars.Append ((char)currCh);  		int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  		int lBr = (path >> 4) & 0xF;  		int rBr = path & 0xF;  		int lPred = path >> 12;  		int rPred = (path >> 8) & 0xF;  		currCh = reader.Read ();  		cl++;  		pos = 0xF;  		if (lBr != 0xF && currCh == entityRefChars [lBr]) {  			if (lPred < 0xE)  				entIdx = lPred;  			//								pred = lPred;  			predShift = 12;  			// left  		} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  			if (rPred < 0xE)  				entIdx = rPred;  			//								pred = rPred;  			predShift = 8;  			// right  		} else if (currCh == ';') {  			if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  				break;  			continue;  			// pos == 0xF  		}  		pos = 0;  	}  	int l = cl - this.col - 1;  	if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  		sbChars.Length = sbLen;  		sbChars.Append (entities [entIdx]);  	} else  		FatalErr (errors [7]);  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (currCh == 'x') {  	currCh = reader.Read ();  	cl++;  	r = 16;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: r = 16;  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	if (pos != 0xF)  		pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  	if (pos == 0xF)  		FatalErr (errors [7]);  	sbChars.Append ((char)currCh);  	int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  	int lBr = (path >> 4) & 0xF;  	int rBr = path & 0xF;  	int lPred = path >> 12;  	int rPred = (path >> 8) & 0xF;  	currCh = reader.Read ();  	cl++;  	pos = 0xF;  	if (lBr != 0xF && currCh == entityRefChars [lBr]) {  		if (lPred < 0xE)  			entIdx = lPred;  		//								pred = lPred;  		predShift = 12;  		// left  	} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  		if (rPred < 0xE)  			entIdx = rPred;  		//								pred = rPred;  		predShift = 8;  		// right  	} else if (currCh == ';') {  		if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  			break;  		continue;  		// pos == 0xF  	}  	pos = 0;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	if (pos != 0xF)  		pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  	if (pos == 0xF)  		FatalErr (errors [7]);  	sbChars.Append ((char)currCh);  	int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  	int lBr = (path >> 4) & 0xF;  	int rBr = path & 0xF;  	int lPred = path >> 12;  	int rPred = (path >> 8) & 0xF;  	currCh = reader.Read ();  	cl++;  	pos = 0xF;  	if (lBr != 0xF && currCh == entityRefChars [lBr]) {  		if (lPred < 0xE)  			entIdx = lPred;  		//								pred = lPred;  		predShift = 12;  		// left  	} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  		if (rPred < 0xE)  			entIdx = rPred;  		//								pred = rPred;  		predShift = 8;  		// right  	} else if (currCh == ';') {  		if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  			break;  		continue;  		// pos == 0xF  	}  	pos = 0;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	if (pos != 0xF)  		pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  	if (pos == 0xF)  		FatalErr (errors [7]);  	sbChars.Append ((char)currCh);  	int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  	int lBr = (path >> 4) & 0xF;  	int rBr = path & 0xF;  	int lPred = path >> 12;  	int rPred = (path >> 8) & 0xF;  	currCh = reader.Read ();  	cl++;  	pos = 0xF;  	if (lBr != 0xF && currCh == entityRefChars [lBr]) {  		if (lPred < 0xE)  			entIdx = lPred;  		//								pred = lPred;  		predShift = 12;  		// left  	} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  		if (rPred < 0xE)  			entIdx = rPred;  		//								pred = rPred;  		predShift = 8;  		// right  	} else if (currCh == ';') {  		if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  			break;  		continue;  		// pos == 0xF  	}  	pos = 0;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	if (pos != 0xF)  		pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  	if (pos == 0xF)  		FatalErr (errors [7]);  	sbChars.Append ((char)currCh);  	int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  	int lBr = (path >> 4) & 0xF;  	int rBr = path & 0xF;  	int lPred = path >> 12;  	int rPred = (path >> 8) & 0xF;  	currCh = reader.Read ();  	cl++;  	pos = 0xF;  	if (lBr != 0xF && currCh == entityRefChars [lBr]) {  		if (lPred < 0xE)  			entIdx = lPred;  		//								pred = lPred;  		predShift = 12;  		// left  	} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  		if (rPred < 0xE)  			entIdx = rPred;  		//								pred = rPred;  		predShift = 8;  		// right  	} else if (currCh == ';') {  		if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  			break;  		continue;  		// pos == 0xF  	}  	pos = 0;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	if (pos != 0xF)  		pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  	if (pos == 0xF)  		FatalErr (errors [7]);  	sbChars.Append ((char)currCh);  	int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  	int lBr = (path >> 4) & 0xF;  	int rBr = path & 0xF;  	int lPred = path >> 12;  	int rPred = (path >> 8) & 0xF;  	currCh = reader.Read ();  	cl++;  	pos = 0xF;  	if (lBr != 0xF && currCh == entityRefChars [lBr]) {  		if (lPred < 0xE)  			entIdx = lPred;  		//								pred = lPred;  		predShift = 12;  		// left  	} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  		if (rPred < 0xE)  			entIdx = rPred;  		//								pred = rPred;  		predShift = 8;  		// right  	} else if (currCh == ';') {  		if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  			break;  		continue;  		// pos == 0xF  	}  	pos = 0;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: while (true) {  	if (pos != 0xF)  		pos = entityRefChars.IndexOf ((char)currCh) & 0xF;  	if (pos == 0xF)  		FatalErr (errors [7]);  	sbChars.Append ((char)currCh);  	int path = "\uFF35\u3F8F\u4F8F\u0F5F\uFF78\uE1F4\u2299\uEEFF\uEEFF\uFF4F" [pos];  	int lBr = (path >> 4) & 0xF;  	int rBr = path & 0xF;  	int lPred = path >> 12;  	int rPred = (path >> 8) & 0xF;  	currCh = reader.Read ();  	cl++;  	pos = 0xF;  	if (lBr != 0xF && currCh == entityRefChars [lBr]) {  		if (lPred < 0xE)  			entIdx = lPred;  		//								pred = lPred;  		predShift = 12;  		// left  	} else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  		if (rPred < 0xE)  			entIdx = rPred;  		//								pred = rPred;  		predShift = 8;  		// right  	} else if (currCh == ';') {  		if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  			break;  		continue;  		// pos == 0xF  	}  	pos = 0;  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (pos == 0xF)  	FatalErr (errors [7]);  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: FatalErr (errors [7]);  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (lBr != 0xF && currCh == entityRefChars [lBr]) {  	if (lPred < 0xE)  		entIdx = lPred;  	//								pred = lPred;  	predShift = 12;  	// left  } else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  	if (rPred < 0xE)  		entIdx = rPred;  	//								pred = rPred;  	predShift = 8;  	// right  } else if (currCh == ';') {  	if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  		break;  	continue;  	// pos == 0xF  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (lBr != 0xF && currCh == entityRefChars [lBr]) {  	if (lPred < 0xE)  		entIdx = lPred;  	//								pred = lPred;  	predShift = 12;  	// left  } else if (rBr != 0xF && currCh == entityRefChars [rBr]) {  	if (rPred < 0xE)  		entIdx = rPred;  	//								pred = rPred;  	predShift = 8;  	// right  } else if (currCh == ';') {  	if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  		break;  	continue;  	// pos == 0xF  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: predShift = 12;  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if (rBr != 0xF && currCh == entityRefChars [rBr]) {  	if (rPred < 0xE)  		entIdx = rPred;  	//								pred = rPred;  	predShift = 8;  	// right  } else if (currCh == ';') {  	if (entIdx != 0xF && predShift != 0 && ((path >> predShift) & 0xF) == 0xE)  		break;  	continue;  	// pos == 0xF  }  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: predShift = 8;  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  	sbChars.Length = sbLen;  	sbChars.Append (entities [entIdx]);  } else  	FatalErr (errors [7]);  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: if ((l > 0 && l < 5) && (StrEquals ("amp"' sbChars' sbLen' l) || StrEquals ("apos"' sbChars' sbLen' l) || StrEquals ("quot"' sbChars' sbLen' l) || StrEquals ("lt"' sbChars' sbLen' l) || StrEquals ("gt"' sbChars' sbLen' l))) {  	sbChars.Length = sbLen;  	sbChars.Append (entities [entIdx]);  } else  	FatalErr (errors [7]);  
Magic Number,Mono.Xml,MiniParser,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\MiniParser.cs,Parse,The following statement contains a magic number: FatalErr (errors [7]);  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {  	//  	// STEP 2.1 Sieve out numbers divisible by the first 9 primes  	//  	if (pMod1 % 3 == 0)  		goto biNotPrime;  	if (pMod1 % 5 == 0)  		goto biNotPrime;  	if (pMod1 % 7 == 0)  		goto biNotPrime;  	if (pMod1 % 11 == 0)  		goto biNotPrime;  	if (pMod1 % 13 == 0)  		goto biNotPrime;  	if (pMod1 % 17 == 0)  		goto biNotPrime;  	if (pMod1 % 19 == 0)  		goto biNotPrime;  	if (pMod1 % 23 == 0)  		goto biNotPrime;  	if (pMod1 % 29 == 0)  		goto biNotPrime;  	//  	// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  	//  	for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  		if (curVal % SmallPrimes [p] == 0)  			goto biNotPrime;  	}  	//  	// STEP 2.3 Is the potential prime acceptable?  	//  	if (!IsPrimeAcceptable (curVal' context))  		goto biNotPrime;  	//  	// STEP 2.4 Filter out all primes that pass this step with a primality test  	//  	if (PrimalityTest (curVal' Confidence))  		return curVal;  	//  	// STEP 2.4  	//  	biNotPrime:  	pMod1 += 2;  	if (pMod1 >= primeProd1)  		pMod1 -= primeProd1;  	curVal.Incr2 ();  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: if (pMod1 % 3 == 0)  	goto biNotPrime;  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: if (pMod1 % 5 == 0)  	goto biNotPrime;  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: if (pMod1 % 7 == 0)  	goto biNotPrime;  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: if (pMod1 % 11 == 0)  	goto biNotPrime;  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: if (pMod1 % 13 == 0)  	goto biNotPrime;  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: if (pMod1 % 17 == 0)  	goto biNotPrime;  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: if (pMod1 % 19 == 0)  	goto biNotPrime;  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: if (pMod1 % 23 == 0)  	goto biNotPrime;  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: if (pMod1 % 29 == 0)  	goto biNotPrime;  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  	if (curVal % SmallPrimes [p] == 0)  		goto biNotPrime;  }  
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: pMod1 += 2;  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,Decode,The following statement contains a magic number: if (pfx.Count > 2) {  	ASN1 macData = pfx [2];  	if (macData.Tag != 0x30)  		throw new ArgumentException ("invalid MAC");  	ASN1 mac = macData [0];  	if (mac.Tag != 0x30)  		throw new ArgumentException ("invalid MAC");  	ASN1 macAlgorithm = mac [0];  	string macOid = ASN1Convert.ToOid (macAlgorithm [0]);  	if (macOid != "1.3.14.3.2.26")  		throw new ArgumentException ("unsupported HMAC");  	byte[] macValue = mac [1].Value;  	ASN1 macSalt = macData [1];  	if (macSalt.Tag != 0x04)  		throw new ArgumentException ("missing MAC salt");  	_iterations = 1;  	// default value  	if (macData.Count > 2) {  		ASN1 iters = macData [2];  		if (iters.Tag != 0x02)  			throw new ArgumentException ("invalid MAC iteration");  		_iterations = ASN1Convert.ToInt32 (iters);  	}  	byte[] authSafeData = authSafe.Content [0].Value;  	byte[] calculatedMac = MAC (_password' macSalt.Value' _iterations' authSafeData);  	if (!Compare (macValue' calculatedMac))  		throw new CryptographicException ("Invalid MAC - file may have been tampered!");  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,Decode,The following statement contains a magic number: if (pfx.Count > 2) {  	ASN1 macData = pfx [2];  	if (macData.Tag != 0x30)  		throw new ArgumentException ("invalid MAC");  	ASN1 mac = macData [0];  	if (mac.Tag != 0x30)  		throw new ArgumentException ("invalid MAC");  	ASN1 macAlgorithm = mac [0];  	string macOid = ASN1Convert.ToOid (macAlgorithm [0]);  	if (macOid != "1.3.14.3.2.26")  		throw new ArgumentException ("unsupported HMAC");  	byte[] macValue = mac [1].Value;  	ASN1 macSalt = macData [1];  	if (macSalt.Tag != 0x04)  		throw new ArgumentException ("missing MAC salt");  	_iterations = 1;  	// default value  	if (macData.Count > 2) {  		ASN1 iters = macData [2];  		if (iters.Tag != 0x02)  			throw new ArgumentException ("invalid MAC iteration");  		_iterations = ASN1Convert.ToInt32 (iters);  	}  	byte[] authSafeData = authSafe.Content [0].Value;  	byte[] calculatedMac = MAC (_password' macSalt.Value' _iterations' authSafeData);  	if (!Compare (macValue' calculatedMac))  		throw new CryptographicException ("Invalid MAC - file may have been tampered!");  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,Decode,The following statement contains a magic number: if (pfx.Count > 2) {  	ASN1 macData = pfx [2];  	if (macData.Tag != 0x30)  		throw new ArgumentException ("invalid MAC");  	ASN1 mac = macData [0];  	if (mac.Tag != 0x30)  		throw new ArgumentException ("invalid MAC");  	ASN1 macAlgorithm = mac [0];  	string macOid = ASN1Convert.ToOid (macAlgorithm [0]);  	if (macOid != "1.3.14.3.2.26")  		throw new ArgumentException ("unsupported HMAC");  	byte[] macValue = mac [1].Value;  	ASN1 macSalt = macData [1];  	if (macSalt.Tag != 0x04)  		throw new ArgumentException ("missing MAC salt");  	_iterations = 1;  	// default value  	if (macData.Count > 2) {  		ASN1 iters = macData [2];  		if (iters.Tag != 0x02)  			throw new ArgumentException ("invalid MAC iteration");  		_iterations = ASN1Convert.ToInt32 (iters);  	}  	byte[] authSafeData = authSafe.Content [0].Value;  	byte[] calculatedMac = MAC (_password' macSalt.Value' _iterations' authSafeData);  	if (!Compare (macValue' calculatedMac))  		throw new CryptographicException ("Invalid MAC - file may have been tampered!");  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,Decode,The following statement contains a magic number: if (pfx.Count > 2) {  	ASN1 macData = pfx [2];  	if (macData.Tag != 0x30)  		throw new ArgumentException ("invalid MAC");  	ASN1 mac = macData [0];  	if (mac.Tag != 0x30)  		throw new ArgumentException ("invalid MAC");  	ASN1 macAlgorithm = mac [0];  	string macOid = ASN1Convert.ToOid (macAlgorithm [0]);  	if (macOid != "1.3.14.3.2.26")  		throw new ArgumentException ("unsupported HMAC");  	byte[] macValue = mac [1].Value;  	ASN1 macSalt = macData [1];  	if (macSalt.Tag != 0x04)  		throw new ArgumentException ("missing MAC salt");  	_iterations = 1;  	// default value  	if (macData.Count > 2) {  		ASN1 iters = macData [2];  		if (iters.Tag != 0x02)  			throw new ArgumentException ("invalid MAC iteration");  		_iterations = ASN1Convert.ToInt32 (iters);  	}  	byte[] authSafeData = authSafe.Content [0].Value;  	byte[] calculatedMac = MAC (_password' macSalt.Value' _iterations' authSafeData);  	if (!Compare (macValue' calculatedMac))  		throw new CryptographicException ("Invalid MAC - file may have been tampered!");  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,Decode,The following statement contains a magic number: if (macData.Count > 2) {  	ASN1 iters = macData [2];  	if (iters.Tag != 0x02)  		throw new ArgumentException ("invalid MAC iteration");  	_iterations = ASN1Convert.ToInt32 (iters);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,Decode,The following statement contains a magic number: if (macData.Count > 2) {  	ASN1 iters = macData [2];  	if (iters.Tag != 0x02)  		throw new ArgumentException ("invalid MAC iteration");  	_iterations = ASN1Convert.ToInt32 (iters);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: switch (algorithmOid) {  case PKCS5.pbeWithMD2AndDESCBC:  	// no unit test available  	pd.HashName = "MD2";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD5AndDESCBC:  	// no unit test available  	pd.HashName = "MD5";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD2AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD2";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithMD5AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD5";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithSHA1AndDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "DES";  	break;  case PKCS5.pbeWithSHA1AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS12.pbeWithSHAAnd128BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 16;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd40BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 5;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd3KeyTripleDESCBC:  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 24;  	break;  case PKCS12.pbeWithSHAAnd2KeyTripleDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd128BitRC2CBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd40BitRC2CBC:  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 5;  	break;  default:  	throw new NotSupportedException ("unknown oid " + algorithm);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: switch (algorithmOid) {  case PKCS5.pbeWithMD2AndDESCBC:  	// no unit test available  	pd.HashName = "MD2";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD5AndDESCBC:  	// no unit test available  	pd.HashName = "MD5";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD2AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD2";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithMD5AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD5";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithSHA1AndDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "DES";  	break;  case PKCS5.pbeWithSHA1AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS12.pbeWithSHAAnd128BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 16;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd40BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 5;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd3KeyTripleDESCBC:  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 24;  	break;  case PKCS12.pbeWithSHAAnd2KeyTripleDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd128BitRC2CBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd40BitRC2CBC:  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 5;  	break;  default:  	throw new NotSupportedException ("unknown oid " + algorithm);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: switch (algorithmOid) {  case PKCS5.pbeWithMD2AndDESCBC:  	// no unit test available  	pd.HashName = "MD2";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD5AndDESCBC:  	// no unit test available  	pd.HashName = "MD5";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD2AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD2";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithMD5AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD5";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithSHA1AndDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "DES";  	break;  case PKCS5.pbeWithSHA1AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS12.pbeWithSHAAnd128BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 16;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd40BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 5;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd3KeyTripleDESCBC:  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 24;  	break;  case PKCS12.pbeWithSHAAnd2KeyTripleDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd128BitRC2CBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd40BitRC2CBC:  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 5;  	break;  default:  	throw new NotSupportedException ("unknown oid " + algorithm);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: switch (algorithmOid) {  case PKCS5.pbeWithMD2AndDESCBC:  	// no unit test available  	pd.HashName = "MD2";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD5AndDESCBC:  	// no unit test available  	pd.HashName = "MD5";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD2AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD2";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithMD5AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD5";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithSHA1AndDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "DES";  	break;  case PKCS5.pbeWithSHA1AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS12.pbeWithSHAAnd128BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 16;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd40BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 5;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd3KeyTripleDESCBC:  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 24;  	break;  case PKCS12.pbeWithSHAAnd2KeyTripleDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd128BitRC2CBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd40BitRC2CBC:  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 5;  	break;  default:  	throw new NotSupportedException ("unknown oid " + algorithm);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: switch (algorithmOid) {  case PKCS5.pbeWithMD2AndDESCBC:  	// no unit test available  	pd.HashName = "MD2";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD5AndDESCBC:  	// no unit test available  	pd.HashName = "MD5";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD2AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD2";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithMD5AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD5";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithSHA1AndDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "DES";  	break;  case PKCS5.pbeWithSHA1AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS12.pbeWithSHAAnd128BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 16;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd40BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 5;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd3KeyTripleDESCBC:  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 24;  	break;  case PKCS12.pbeWithSHAAnd2KeyTripleDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd128BitRC2CBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd40BitRC2CBC:  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 5;  	break;  default:  	throw new NotSupportedException ("unknown oid " + algorithm);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: switch (algorithmOid) {  case PKCS5.pbeWithMD2AndDESCBC:  	// no unit test available  	pd.HashName = "MD2";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD5AndDESCBC:  	// no unit test available  	pd.HashName = "MD5";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD2AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD2";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithMD5AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD5";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithSHA1AndDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "DES";  	break;  case PKCS5.pbeWithSHA1AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS12.pbeWithSHAAnd128BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 16;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd40BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 5;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd3KeyTripleDESCBC:  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 24;  	break;  case PKCS12.pbeWithSHAAnd2KeyTripleDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd128BitRC2CBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd40BitRC2CBC:  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 5;  	break;  default:  	throw new NotSupportedException ("unknown oid " + algorithm);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: switch (algorithmOid) {  case PKCS5.pbeWithMD2AndDESCBC:  	// no unit test available  	pd.HashName = "MD2";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD5AndDESCBC:  	// no unit test available  	pd.HashName = "MD5";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD2AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD2";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithMD5AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD5";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithSHA1AndDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "DES";  	break;  case PKCS5.pbeWithSHA1AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS12.pbeWithSHAAnd128BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 16;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd40BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 5;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd3KeyTripleDESCBC:  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 24;  	break;  case PKCS12.pbeWithSHAAnd2KeyTripleDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd128BitRC2CBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd40BitRC2CBC:  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 5;  	break;  default:  	throw new NotSupportedException ("unknown oid " + algorithm);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: switch (algorithmOid) {  case PKCS5.pbeWithMD2AndDESCBC:  	// no unit test available  	pd.HashName = "MD2";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD5AndDESCBC:  	// no unit test available  	pd.HashName = "MD5";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD2AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD2";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithMD5AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD5";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithSHA1AndDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "DES";  	break;  case PKCS5.pbeWithSHA1AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS12.pbeWithSHAAnd128BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 16;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd40BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 5;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd3KeyTripleDESCBC:  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 24;  	break;  case PKCS12.pbeWithSHAAnd2KeyTripleDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd128BitRC2CBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd40BitRC2CBC:  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 5;  	break;  default:  	throw new NotSupportedException ("unknown oid " + algorithm);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: switch (algorithmOid) {  case PKCS5.pbeWithMD2AndDESCBC:  	// no unit test available  	pd.HashName = "MD2";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD5AndDESCBC:  	// no unit test available  	pd.HashName = "MD5";  	algorithm = "DES";  	break;  case PKCS5.pbeWithMD2AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD2";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithMD5AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "MD5";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS5.pbeWithSHA1AndDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "DES";  	break;  case PKCS5.pbeWithSHA1AndRC2CBC:  	// no unit test available  	// TODO - RC2-CBC-Parameter (PKCS5)  	// if missing default to 32 bits !!!  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 4;  	// default  	break;  case PKCS12.pbeWithSHAAnd128BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 16;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd40BitRC4:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC4";  	keyLength = 5;  	ivLength = 0;  	// N/A  	break;  case PKCS12.pbeWithSHAAnd3KeyTripleDESCBC:  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 24;  	break;  case PKCS12.pbeWithSHAAnd2KeyTripleDESCBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "TripleDES";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd128BitRC2CBC:  	// no unit test available  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 16;  	break;  case PKCS12.pbeWithSHAAnd40BitRC2CBC:  	pd.HashName = "SHA1";  	algorithm = "RC2";  	keyLength = 5;  	break;  default:  	throw new NotSupportedException ("unknown oid " + algorithm);  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: keyLength = 4;  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: keyLength = 4;  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: keyLength = 4;  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: keyLength = 16;  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: keyLength = 5;  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: keyLength = 24;  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: keyLength = 16;  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: keyLength = 16;  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSymmetricAlgorithm,The following statement contains a magic number: keyLength = 5;  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,ReadSafeBag,The following statement contains a magic number: if (safeBag.Count > 2) {  	ASN1 bagAttributes = safeBag [2];  	if (bagAttributes.Tag != 0x31)  		throw new ArgumentException ("invalid safeBag attributes id");  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		if (pkcs12Attribute.Tag != 0x30)  			throw new ArgumentException ("invalid PKCS12 attributes id");  		ASN1 attrId = pkcs12Attribute [0];  		if (attrId.Tag != 0x06)  			throw new ArgumentException ("invalid attribute id");  		string attrOid = ASN1Convert.ToOid (attrId);  		ASN1 attrValues = pkcs12Attribute [1];  		for (int j = 0; j < attrValues.Count; j++) {  			ASN1 attrValue = attrValues [j];  			switch (attrOid) {  			case PKCS9.friendlyName:  				if (attrValue.Tag != 0x1e)  					throw new ArgumentException ("invalid attribute value id");  				break;  			case PKCS9.localKeyId:  				if (attrValue.Tag != 0x04)  					throw new ArgumentException ("invalid attribute value id");  				break;  			default:  				// Unknown OID -- don't check Tag  				break;  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,ReadSafeBag,The following statement contains a magic number: if (safeBag.Count > 2) {  	ASN1 bagAttributes = safeBag [2];  	if (bagAttributes.Tag != 0x31)  		throw new ArgumentException ("invalid safeBag attributes id");  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		if (pkcs12Attribute.Tag != 0x30)  			throw new ArgumentException ("invalid PKCS12 attributes id");  		ASN1 attrId = pkcs12Attribute [0];  		if (attrId.Tag != 0x06)  			throw new ArgumentException ("invalid attribute id");  		string attrOid = ASN1Convert.ToOid (attrId);  		ASN1 attrValues = pkcs12Attribute [1];  		for (int j = 0; j < attrValues.Count; j++) {  			ASN1 attrValue = attrValues [j];  			switch (attrOid) {  			case PKCS9.friendlyName:  				if (attrValue.Tag != 0x1e)  					throw new ArgumentException ("invalid attribute value id");  				break;  			case PKCS9.localKeyId:  				if (attrValue.Tag != 0x04)  					throw new ArgumentException ("invalid attribute value id");  				break;  			default:  				// Unknown OID -- don't check Tag  				break;  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,MAC,The following statement contains a magic number: hmac.Key = pd.DeriveMAC (20);  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetBytes,The following statement contains a magic number: if (_password != null) {  	// only for password based encryption  	byte[] salt = new byte[20];  	RNG.GetBytes (salt);  	byte[] macValue = MAC (_password' salt' _iterations' authSafe.Content [0].Value);  	ASN1 oidSeq = new ASN1 (0x30);  	oidSeq.Add (ASN1Convert.FromOid ("1.3.14.3.2.26"));  	// SHA1  	oidSeq.Add (new ASN1 (0x05));  	ASN1 mac = new ASN1 (0x30);  	mac.Add (oidSeq);  	mac.Add (new ASN1 (0x04' macValue));  	macData.Add (mac);  	macData.Add (new ASN1 (0x04' salt));  	macData.Add (ASN1Convert.FromInt32 (_iterations));  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,The following statement contains a magic number: for (int i = 0; certIndex == -1 && i < _safeBags.Count; i++) {  	SafeBag sb = (SafeBag)_safeBags [i];  	if (sb.BagOID.Equals (certBag)) {  		ASN1 safeBag = sb.ASN1;  		ASN1 bagValue = safeBag [1];  		PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  		X509Certificate c = new X509Certificate (crt.Content [0].Value);  		if (Compare (cert.RawData' c.RawData)) {  			if (attrs != null) {  				if (safeBag.Count == 3) {  					ASN1 bagAttributes = safeBag [2];  					int bagAttributesFound = 0;  					for (int j = 0; j < bagAttributes.Count; j++) {  						ASN1 pkcs12Attribute = bagAttributes [j];  						ASN1 attrId = pkcs12Attribute [0];  						string ao = ASN1Convert.ToOid (attrId);  						ArrayList dattrValues = (ArrayList)attrs [ao];  						if (dattrValues != null) {  							ASN1 attrValues = pkcs12Attribute [1];  							if (dattrValues.Count == attrValues.Count) {  								int attrValuesFound = 0;  								for (int k = 0; k < attrValues.Count; k++) {  									ASN1 attrValue = attrValues [k];  									byte[] value = (byte[])dattrValues [k];  									if (Compare (value' attrValue.Value)) {  										attrValuesFound += 1;  									}  								}  								if (attrValuesFound == attrValues.Count) {  									bagAttributesFound += 1;  								}  							}  						}  					}  					if (bagAttributesFound == bagAttributes.Count) {  						certIndex = i;  					}  				}  			} else {  				certIndex = i;  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,The following statement contains a magic number: for (int i = 0; certIndex == -1 && i < _safeBags.Count; i++) {  	SafeBag sb = (SafeBag)_safeBags [i];  	if (sb.BagOID.Equals (certBag)) {  		ASN1 safeBag = sb.ASN1;  		ASN1 bagValue = safeBag [1];  		PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  		X509Certificate c = new X509Certificate (crt.Content [0].Value);  		if (Compare (cert.RawData' c.RawData)) {  			if (attrs != null) {  				if (safeBag.Count == 3) {  					ASN1 bagAttributes = safeBag [2];  					int bagAttributesFound = 0;  					for (int j = 0; j < bagAttributes.Count; j++) {  						ASN1 pkcs12Attribute = bagAttributes [j];  						ASN1 attrId = pkcs12Attribute [0];  						string ao = ASN1Convert.ToOid (attrId);  						ArrayList dattrValues = (ArrayList)attrs [ao];  						if (dattrValues != null) {  							ASN1 attrValues = pkcs12Attribute [1];  							if (dattrValues.Count == attrValues.Count) {  								int attrValuesFound = 0;  								for (int k = 0; k < attrValues.Count; k++) {  									ASN1 attrValue = attrValues [k];  									byte[] value = (byte[])dattrValues [k];  									if (Compare (value' attrValue.Value)) {  										attrValuesFound += 1;  									}  								}  								if (attrValuesFound == attrValues.Count) {  									bagAttributesFound += 1;  								}  							}  						}  					}  					if (bagAttributesFound == bagAttributes.Count) {  						certIndex = i;  					}  				}  			} else {  				certIndex = i;  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,The following statement contains a magic number: if (sb.BagOID.Equals (certBag)) {  	ASN1 safeBag = sb.ASN1;  	ASN1 bagValue = safeBag [1];  	PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  	X509Certificate c = new X509Certificate (crt.Content [0].Value);  	if (Compare (cert.RawData' c.RawData)) {  		if (attrs != null) {  			if (safeBag.Count == 3) {  				ASN1 bagAttributes = safeBag [2];  				int bagAttributesFound = 0;  				for (int j = 0; j < bagAttributes.Count; j++) {  					ASN1 pkcs12Attribute = bagAttributes [j];  					ASN1 attrId = pkcs12Attribute [0];  					string ao = ASN1Convert.ToOid (attrId);  					ArrayList dattrValues = (ArrayList)attrs [ao];  					if (dattrValues != null) {  						ASN1 attrValues = pkcs12Attribute [1];  						if (dattrValues.Count == attrValues.Count) {  							int attrValuesFound = 0;  							for (int k = 0; k < attrValues.Count; k++) {  								ASN1 attrValue = attrValues [k];  								byte[] value = (byte[])dattrValues [k];  								if (Compare (value' attrValue.Value)) {  									attrValuesFound += 1;  								}  							}  							if (attrValuesFound == attrValues.Count) {  								bagAttributesFound += 1;  							}  						}  					}  				}  				if (bagAttributesFound == bagAttributes.Count) {  					certIndex = i;  				}  			}  		} else {  			certIndex = i;  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,The following statement contains a magic number: if (sb.BagOID.Equals (certBag)) {  	ASN1 safeBag = sb.ASN1;  	ASN1 bagValue = safeBag [1];  	PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  	X509Certificate c = new X509Certificate (crt.Content [0].Value);  	if (Compare (cert.RawData' c.RawData)) {  		if (attrs != null) {  			if (safeBag.Count == 3) {  				ASN1 bagAttributes = safeBag [2];  				int bagAttributesFound = 0;  				for (int j = 0; j < bagAttributes.Count; j++) {  					ASN1 pkcs12Attribute = bagAttributes [j];  					ASN1 attrId = pkcs12Attribute [0];  					string ao = ASN1Convert.ToOid (attrId);  					ArrayList dattrValues = (ArrayList)attrs [ao];  					if (dattrValues != null) {  						ASN1 attrValues = pkcs12Attribute [1];  						if (dattrValues.Count == attrValues.Count) {  							int attrValuesFound = 0;  							for (int k = 0; k < attrValues.Count; k++) {  								ASN1 attrValue = attrValues [k];  								byte[] value = (byte[])dattrValues [k];  								if (Compare (value' attrValue.Value)) {  									attrValuesFound += 1;  								}  							}  							if (attrValuesFound == attrValues.Count) {  								bagAttributesFound += 1;  							}  						}  					}  				}  				if (bagAttributesFound == bagAttributes.Count) {  					certIndex = i;  				}  			}  		} else {  			certIndex = i;  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,The following statement contains a magic number: if (Compare (cert.RawData' c.RawData)) {  	if (attrs != null) {  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			int bagAttributesFound = 0;  			for (int j = 0; j < bagAttributes.Count; j++) {  				ASN1 pkcs12Attribute = bagAttributes [j];  				ASN1 attrId = pkcs12Attribute [0];  				string ao = ASN1Convert.ToOid (attrId);  				ArrayList dattrValues = (ArrayList)attrs [ao];  				if (dattrValues != null) {  					ASN1 attrValues = pkcs12Attribute [1];  					if (dattrValues.Count == attrValues.Count) {  						int attrValuesFound = 0;  						for (int k = 0; k < attrValues.Count; k++) {  							ASN1 attrValue = attrValues [k];  							byte[] value = (byte[])dattrValues [k];  							if (Compare (value' attrValue.Value)) {  								attrValuesFound += 1;  							}  						}  						if (attrValuesFound == attrValues.Count) {  							bagAttributesFound += 1;  						}  					}  				}  			}  			if (bagAttributesFound == bagAttributes.Count) {  				certIndex = i;  			}  		}  	} else {  		certIndex = i;  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,The following statement contains a magic number: if (Compare (cert.RawData' c.RawData)) {  	if (attrs != null) {  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			int bagAttributesFound = 0;  			for (int j = 0; j < bagAttributes.Count; j++) {  				ASN1 pkcs12Attribute = bagAttributes [j];  				ASN1 attrId = pkcs12Attribute [0];  				string ao = ASN1Convert.ToOid (attrId);  				ArrayList dattrValues = (ArrayList)attrs [ao];  				if (dattrValues != null) {  					ASN1 attrValues = pkcs12Attribute [1];  					if (dattrValues.Count == attrValues.Count) {  						int attrValuesFound = 0;  						for (int k = 0; k < attrValues.Count; k++) {  							ASN1 attrValue = attrValues [k];  							byte[] value = (byte[])dattrValues [k];  							if (Compare (value' attrValue.Value)) {  								attrValuesFound += 1;  							}  						}  						if (attrValuesFound == attrValues.Count) {  							bagAttributesFound += 1;  						}  					}  				}  			}  			if (bagAttributesFound == bagAttributes.Count) {  				certIndex = i;  			}  		}  	} else {  		certIndex = i;  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,The following statement contains a magic number: if (attrs != null) {  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		int bagAttributesFound = 0;  		for (int j = 0; j < bagAttributes.Count; j++) {  			ASN1 pkcs12Attribute = bagAttributes [j];  			ASN1 attrId = pkcs12Attribute [0];  			string ao = ASN1Convert.ToOid (attrId);  			ArrayList dattrValues = (ArrayList)attrs [ao];  			if (dattrValues != null) {  				ASN1 attrValues = pkcs12Attribute [1];  				if (dattrValues.Count == attrValues.Count) {  					int attrValuesFound = 0;  					for (int k = 0; k < attrValues.Count; k++) {  						ASN1 attrValue = attrValues [k];  						byte[] value = (byte[])dattrValues [k];  						if (Compare (value' attrValue.Value)) {  							attrValuesFound += 1;  						}  					}  					if (attrValuesFound == attrValues.Count) {  						bagAttributesFound += 1;  					}  				}  			}  		}  		if (bagAttributesFound == bagAttributes.Count) {  			certIndex = i;  		}  	}  } else {  	certIndex = i;  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,The following statement contains a magic number: if (attrs != null) {  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		int bagAttributesFound = 0;  		for (int j = 0; j < bagAttributes.Count; j++) {  			ASN1 pkcs12Attribute = bagAttributes [j];  			ASN1 attrId = pkcs12Attribute [0];  			string ao = ASN1Convert.ToOid (attrId);  			ArrayList dattrValues = (ArrayList)attrs [ao];  			if (dattrValues != null) {  				ASN1 attrValues = pkcs12Attribute [1];  				if (dattrValues.Count == attrValues.Count) {  					int attrValuesFound = 0;  					for (int k = 0; k < attrValues.Count; k++) {  						ASN1 attrValue = attrValues [k];  						byte[] value = (byte[])dattrValues [k];  						if (Compare (value' attrValue.Value)) {  							attrValuesFound += 1;  						}  					}  					if (attrValuesFound == attrValues.Count) {  						bagAttributesFound += 1;  					}  				}  			}  		}  		if (bagAttributesFound == bagAttributes.Count) {  			certIndex = i;  		}  	}  } else {  	certIndex = i;  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	int bagAttributesFound = 0;  	for (int j = 0; j < bagAttributes.Count; j++) {  		ASN1 pkcs12Attribute = bagAttributes [j];  		ASN1 attrId = pkcs12Attribute [0];  		string ao = ASN1Convert.ToOid (attrId);  		ArrayList dattrValues = (ArrayList)attrs [ao];  		if (dattrValues != null) {  			ASN1 attrValues = pkcs12Attribute [1];  			if (dattrValues.Count == attrValues.Count) {  				int attrValuesFound = 0;  				for (int k = 0; k < attrValues.Count; k++) {  					ASN1 attrValue = attrValues [k];  					byte[] value = (byte[])dattrValues [k];  					if (Compare (value' attrValue.Value)) {  						attrValuesFound += 1;  					}  				}  				if (attrValuesFound == attrValues.Count) {  					bagAttributesFound += 1;  				}  			}  		}  	}  	if (bagAttributesFound == bagAttributes.Count) {  		certIndex = i;  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,RemoveCertificate,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	int bagAttributesFound = 0;  	for (int j = 0; j < bagAttributes.Count; j++) {  		ASN1 pkcs12Attribute = bagAttributes [j];  		ASN1 attrId = pkcs12Attribute [0];  		string ao = ASN1Convert.ToOid (attrId);  		ArrayList dattrValues = (ArrayList)attrs [ao];  		if (dattrValues != null) {  			ASN1 attrValues = pkcs12Attribute [1];  			if (dattrValues.Count == attrValues.Count) {  				int attrValuesFound = 0;  				for (int k = 0; k < attrValues.Count; k++) {  					ASN1 attrValue = attrValues [k];  					byte[] value = (byte[])dattrValues [k];  					if (Compare (value' attrValue.Value)) {  						attrValuesFound += 1;  					}  				}  				if (attrValuesFound == attrValues.Count) {  					bagAttributesFound += 1;  				}  			}  		}  	}  	if (bagAttributesFound == bagAttributes.Count) {  		certIndex = i;  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAsymmetricAlgorithm,The following statement contains a magic number: foreach (SafeBag sb in _safeBags) {  	if (sb.BagOID.Equals (keyBag) || sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  		ASN1 safeBag = sb.ASN1;  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			int bagAttributesFound = 0;  			for (int i = 0; i < bagAttributes.Count; i++) {  				ASN1 pkcs12Attribute = bagAttributes [i];  				ASN1 attrId = pkcs12Attribute [0];  				string ao = ASN1Convert.ToOid (attrId);  				ArrayList dattrValues = (ArrayList)attrs [ao];  				if (dattrValues != null) {  					ASN1 attrValues = pkcs12Attribute [1];  					if (dattrValues.Count == attrValues.Count) {  						int attrValuesFound = 0;  						for (int j = 0; j < attrValues.Count; j++) {  							ASN1 attrValue = attrValues [j];  							byte[] value = (byte[])dattrValues [j];  							if (Compare (value' attrValue.Value)) {  								attrValuesFound += 1;  							}  						}  						if (attrValuesFound == attrValues.Count) {  							bagAttributesFound += 1;  						}  					}  				}  			}  			if (bagAttributesFound == bagAttributes.Count) {  				ASN1 bagValue = safeBag [1];  				AsymmetricAlgorithm aa = null;  				if (sb.BagOID.Equals (keyBag)) {  					PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (bagValue.Value);  					byte[] privateKey = pki.PrivateKey;  					switch (privateKey [0]) {  					case 0x02:  						DSAParameters p = new DSAParameters ();  						// FIXME  						aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  						break;  					case 0x30:  						aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  						break;  					default:  						break;  					}  					Array.Clear (privateKey' 0' privateKey.Length);  				} else if (sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  					PKCS8.EncryptedPrivateKeyInfo epki = new PKCS8.EncryptedPrivateKeyInfo (bagValue.Value);  					byte[] decrypted = Decrypt (epki.Algorithm' epki.Salt' epki.IterationCount' epki.EncryptedData);  					PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (decrypted);  					byte[] privateKey = pki.PrivateKey;  					switch (privateKey [0]) {  					case 0x02:  						DSAParameters p = new DSAParameters ();  						// FIXME  						aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  						break;  					case 0x30:  						aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  						break;  					default:  						break;  					}  					Array.Clear (privateKey' 0' privateKey.Length);  					Array.Clear (decrypted' 0' decrypted.Length);  				}  				return aa;  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAsymmetricAlgorithm,The following statement contains a magic number: foreach (SafeBag sb in _safeBags) {  	if (sb.BagOID.Equals (keyBag) || sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  		ASN1 safeBag = sb.ASN1;  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			int bagAttributesFound = 0;  			for (int i = 0; i < bagAttributes.Count; i++) {  				ASN1 pkcs12Attribute = bagAttributes [i];  				ASN1 attrId = pkcs12Attribute [0];  				string ao = ASN1Convert.ToOid (attrId);  				ArrayList dattrValues = (ArrayList)attrs [ao];  				if (dattrValues != null) {  					ASN1 attrValues = pkcs12Attribute [1];  					if (dattrValues.Count == attrValues.Count) {  						int attrValuesFound = 0;  						for (int j = 0; j < attrValues.Count; j++) {  							ASN1 attrValue = attrValues [j];  							byte[] value = (byte[])dattrValues [j];  							if (Compare (value' attrValue.Value)) {  								attrValuesFound += 1;  							}  						}  						if (attrValuesFound == attrValues.Count) {  							bagAttributesFound += 1;  						}  					}  				}  			}  			if (bagAttributesFound == bagAttributes.Count) {  				ASN1 bagValue = safeBag [1];  				AsymmetricAlgorithm aa = null;  				if (sb.BagOID.Equals (keyBag)) {  					PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (bagValue.Value);  					byte[] privateKey = pki.PrivateKey;  					switch (privateKey [0]) {  					case 0x02:  						DSAParameters p = new DSAParameters ();  						// FIXME  						aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  						break;  					case 0x30:  						aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  						break;  					default:  						break;  					}  					Array.Clear (privateKey' 0' privateKey.Length);  				} else if (sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  					PKCS8.EncryptedPrivateKeyInfo epki = new PKCS8.EncryptedPrivateKeyInfo (bagValue.Value);  					byte[] decrypted = Decrypt (epki.Algorithm' epki.Salt' epki.IterationCount' epki.EncryptedData);  					PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (decrypted);  					byte[] privateKey = pki.PrivateKey;  					switch (privateKey [0]) {  					case 0x02:  						DSAParameters p = new DSAParameters ();  						// FIXME  						aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  						break;  					case 0x30:  						aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  						break;  					default:  						break;  					}  					Array.Clear (privateKey' 0' privateKey.Length);  					Array.Clear (decrypted' 0' decrypted.Length);  				}  				return aa;  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAsymmetricAlgorithm,The following statement contains a magic number: if (sb.BagOID.Equals (keyBag) || sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  	ASN1 safeBag = sb.ASN1;  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		int bagAttributesFound = 0;  		for (int i = 0; i < bagAttributes.Count; i++) {  			ASN1 pkcs12Attribute = bagAttributes [i];  			ASN1 attrId = pkcs12Attribute [0];  			string ao = ASN1Convert.ToOid (attrId);  			ArrayList dattrValues = (ArrayList)attrs [ao];  			if (dattrValues != null) {  				ASN1 attrValues = pkcs12Attribute [1];  				if (dattrValues.Count == attrValues.Count) {  					int attrValuesFound = 0;  					for (int j = 0; j < attrValues.Count; j++) {  						ASN1 attrValue = attrValues [j];  						byte[] value = (byte[])dattrValues [j];  						if (Compare (value' attrValue.Value)) {  							attrValuesFound += 1;  						}  					}  					if (attrValuesFound == attrValues.Count) {  						bagAttributesFound += 1;  					}  				}  			}  		}  		if (bagAttributesFound == bagAttributes.Count) {  			ASN1 bagValue = safeBag [1];  			AsymmetricAlgorithm aa = null;  			if (sb.BagOID.Equals (keyBag)) {  				PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (bagValue.Value);  				byte[] privateKey = pki.PrivateKey;  				switch (privateKey [0]) {  				case 0x02:  					DSAParameters p = new DSAParameters ();  					// FIXME  					aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  					break;  				case 0x30:  					aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  					break;  				default:  					break;  				}  				Array.Clear (privateKey' 0' privateKey.Length);  			} else if (sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  				PKCS8.EncryptedPrivateKeyInfo epki = new PKCS8.EncryptedPrivateKeyInfo (bagValue.Value);  				byte[] decrypted = Decrypt (epki.Algorithm' epki.Salt' epki.IterationCount' epki.EncryptedData);  				PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (decrypted);  				byte[] privateKey = pki.PrivateKey;  				switch (privateKey [0]) {  				case 0x02:  					DSAParameters p = new DSAParameters ();  					// FIXME  					aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  					break;  				case 0x30:  					aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  					break;  				default:  					break;  				}  				Array.Clear (privateKey' 0' privateKey.Length);  				Array.Clear (decrypted' 0' decrypted.Length);  			}  			return aa;  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAsymmetricAlgorithm,The following statement contains a magic number: if (sb.BagOID.Equals (keyBag) || sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  	ASN1 safeBag = sb.ASN1;  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		int bagAttributesFound = 0;  		for (int i = 0; i < bagAttributes.Count; i++) {  			ASN1 pkcs12Attribute = bagAttributes [i];  			ASN1 attrId = pkcs12Attribute [0];  			string ao = ASN1Convert.ToOid (attrId);  			ArrayList dattrValues = (ArrayList)attrs [ao];  			if (dattrValues != null) {  				ASN1 attrValues = pkcs12Attribute [1];  				if (dattrValues.Count == attrValues.Count) {  					int attrValuesFound = 0;  					for (int j = 0; j < attrValues.Count; j++) {  						ASN1 attrValue = attrValues [j];  						byte[] value = (byte[])dattrValues [j];  						if (Compare (value' attrValue.Value)) {  							attrValuesFound += 1;  						}  					}  					if (attrValuesFound == attrValues.Count) {  						bagAttributesFound += 1;  					}  				}  			}  		}  		if (bagAttributesFound == bagAttributes.Count) {  			ASN1 bagValue = safeBag [1];  			AsymmetricAlgorithm aa = null;  			if (sb.BagOID.Equals (keyBag)) {  				PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (bagValue.Value);  				byte[] privateKey = pki.PrivateKey;  				switch (privateKey [0]) {  				case 0x02:  					DSAParameters p = new DSAParameters ();  					// FIXME  					aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  					break;  				case 0x30:  					aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  					break;  				default:  					break;  				}  				Array.Clear (privateKey' 0' privateKey.Length);  			} else if (sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  				PKCS8.EncryptedPrivateKeyInfo epki = new PKCS8.EncryptedPrivateKeyInfo (bagValue.Value);  				byte[] decrypted = Decrypt (epki.Algorithm' epki.Salt' epki.IterationCount' epki.EncryptedData);  				PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (decrypted);  				byte[] privateKey = pki.PrivateKey;  				switch (privateKey [0]) {  				case 0x02:  					DSAParameters p = new DSAParameters ();  					// FIXME  					aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  					break;  				case 0x30:  					aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  					break;  				default:  					break;  				}  				Array.Clear (privateKey' 0' privateKey.Length);  				Array.Clear (decrypted' 0' decrypted.Length);  			}  			return aa;  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAsymmetricAlgorithm,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	int bagAttributesFound = 0;  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		ASN1 attrId = pkcs12Attribute [0];  		string ao = ASN1Convert.ToOid (attrId);  		ArrayList dattrValues = (ArrayList)attrs [ao];  		if (dattrValues != null) {  			ASN1 attrValues = pkcs12Attribute [1];  			if (dattrValues.Count == attrValues.Count) {  				int attrValuesFound = 0;  				for (int j = 0; j < attrValues.Count; j++) {  					ASN1 attrValue = attrValues [j];  					byte[] value = (byte[])dattrValues [j];  					if (Compare (value' attrValue.Value)) {  						attrValuesFound += 1;  					}  				}  				if (attrValuesFound == attrValues.Count) {  					bagAttributesFound += 1;  				}  			}  		}  	}  	if (bagAttributesFound == bagAttributes.Count) {  		ASN1 bagValue = safeBag [1];  		AsymmetricAlgorithm aa = null;  		if (sb.BagOID.Equals (keyBag)) {  			PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (bagValue.Value);  			byte[] privateKey = pki.PrivateKey;  			switch (privateKey [0]) {  			case 0x02:  				DSAParameters p = new DSAParameters ();  				// FIXME  				aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  				break;  			case 0x30:  				aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  				break;  			default:  				break;  			}  			Array.Clear (privateKey' 0' privateKey.Length);  		} else if (sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  			PKCS8.EncryptedPrivateKeyInfo epki = new PKCS8.EncryptedPrivateKeyInfo (bagValue.Value);  			byte[] decrypted = Decrypt (epki.Algorithm' epki.Salt' epki.IterationCount' epki.EncryptedData);  			PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (decrypted);  			byte[] privateKey = pki.PrivateKey;  			switch (privateKey [0]) {  			case 0x02:  				DSAParameters p = new DSAParameters ();  				// FIXME  				aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  				break;  			case 0x30:  				aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  				break;  			default:  				break;  			}  			Array.Clear (privateKey' 0' privateKey.Length);  			Array.Clear (decrypted' 0' decrypted.Length);  		}  		return aa;  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAsymmetricAlgorithm,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	int bagAttributesFound = 0;  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		ASN1 attrId = pkcs12Attribute [0];  		string ao = ASN1Convert.ToOid (attrId);  		ArrayList dattrValues = (ArrayList)attrs [ao];  		if (dattrValues != null) {  			ASN1 attrValues = pkcs12Attribute [1];  			if (dattrValues.Count == attrValues.Count) {  				int attrValuesFound = 0;  				for (int j = 0; j < attrValues.Count; j++) {  					ASN1 attrValue = attrValues [j];  					byte[] value = (byte[])dattrValues [j];  					if (Compare (value' attrValue.Value)) {  						attrValuesFound += 1;  					}  				}  				if (attrValuesFound == attrValues.Count) {  					bagAttributesFound += 1;  				}  			}  		}  	}  	if (bagAttributesFound == bagAttributes.Count) {  		ASN1 bagValue = safeBag [1];  		AsymmetricAlgorithm aa = null;  		if (sb.BagOID.Equals (keyBag)) {  			PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (bagValue.Value);  			byte[] privateKey = pki.PrivateKey;  			switch (privateKey [0]) {  			case 0x02:  				DSAParameters p = new DSAParameters ();  				// FIXME  				aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  				break;  			case 0x30:  				aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  				break;  			default:  				break;  			}  			Array.Clear (privateKey' 0' privateKey.Length);  		} else if (sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  			PKCS8.EncryptedPrivateKeyInfo epki = new PKCS8.EncryptedPrivateKeyInfo (bagValue.Value);  			byte[] decrypted = Decrypt (epki.Algorithm' epki.Salt' epki.IterationCount' epki.EncryptedData);  			PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (decrypted);  			byte[] privateKey = pki.PrivateKey;  			switch (privateKey [0]) {  			case 0x02:  				DSAParameters p = new DSAParameters ();  				// FIXME  				aa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  				break;  			case 0x30:  				aa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  				break;  			default:  				break;  			}  			Array.Clear (privateKey' 0' privateKey.Length);  			Array.Clear (decrypted' 0' decrypted.Length);  		}  		return aa;  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSecret,The following statement contains a magic number: foreach (SafeBag sb in _safeBags) {  	if (sb.BagOID.Equals (secretBag)) {  		ASN1 safeBag = sb.ASN1;  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			int bagAttributesFound = 0;  			for (int i = 0; i < bagAttributes.Count; i++) {  				ASN1 pkcs12Attribute = bagAttributes [i];  				ASN1 attrId = pkcs12Attribute [0];  				string ao = ASN1Convert.ToOid (attrId);  				ArrayList dattrValues = (ArrayList)attrs [ao];  				if (dattrValues != null) {  					ASN1 attrValues = pkcs12Attribute [1];  					if (dattrValues.Count == attrValues.Count) {  						int attrValuesFound = 0;  						for (int j = 0; j < attrValues.Count; j++) {  							ASN1 attrValue = attrValues [j];  							byte[] value = (byte[])dattrValues [j];  							if (Compare (value' attrValue.Value)) {  								attrValuesFound += 1;  							}  						}  						if (attrValuesFound == attrValues.Count) {  							bagAttributesFound += 1;  						}  					}  				}  			}  			if (bagAttributesFound == bagAttributes.Count) {  				ASN1 bagValue = safeBag [1];  				return bagValue.Value;  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSecret,The following statement contains a magic number: foreach (SafeBag sb in _safeBags) {  	if (sb.BagOID.Equals (secretBag)) {  		ASN1 safeBag = sb.ASN1;  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			int bagAttributesFound = 0;  			for (int i = 0; i < bagAttributes.Count; i++) {  				ASN1 pkcs12Attribute = bagAttributes [i];  				ASN1 attrId = pkcs12Attribute [0];  				string ao = ASN1Convert.ToOid (attrId);  				ArrayList dattrValues = (ArrayList)attrs [ao];  				if (dattrValues != null) {  					ASN1 attrValues = pkcs12Attribute [1];  					if (dattrValues.Count == attrValues.Count) {  						int attrValuesFound = 0;  						for (int j = 0; j < attrValues.Count; j++) {  							ASN1 attrValue = attrValues [j];  							byte[] value = (byte[])dattrValues [j];  							if (Compare (value' attrValue.Value)) {  								attrValuesFound += 1;  							}  						}  						if (attrValuesFound == attrValues.Count) {  							bagAttributesFound += 1;  						}  					}  				}  			}  			if (bagAttributesFound == bagAttributes.Count) {  				ASN1 bagValue = safeBag [1];  				return bagValue.Value;  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSecret,The following statement contains a magic number: if (sb.BagOID.Equals (secretBag)) {  	ASN1 safeBag = sb.ASN1;  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		int bagAttributesFound = 0;  		for (int i = 0; i < bagAttributes.Count; i++) {  			ASN1 pkcs12Attribute = bagAttributes [i];  			ASN1 attrId = pkcs12Attribute [0];  			string ao = ASN1Convert.ToOid (attrId);  			ArrayList dattrValues = (ArrayList)attrs [ao];  			if (dattrValues != null) {  				ASN1 attrValues = pkcs12Attribute [1];  				if (dattrValues.Count == attrValues.Count) {  					int attrValuesFound = 0;  					for (int j = 0; j < attrValues.Count; j++) {  						ASN1 attrValue = attrValues [j];  						byte[] value = (byte[])dattrValues [j];  						if (Compare (value' attrValue.Value)) {  							attrValuesFound += 1;  						}  					}  					if (attrValuesFound == attrValues.Count) {  						bagAttributesFound += 1;  					}  				}  			}  		}  		if (bagAttributesFound == bagAttributes.Count) {  			ASN1 bagValue = safeBag [1];  			return bagValue.Value;  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSecret,The following statement contains a magic number: if (sb.BagOID.Equals (secretBag)) {  	ASN1 safeBag = sb.ASN1;  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		int bagAttributesFound = 0;  		for (int i = 0; i < bagAttributes.Count; i++) {  			ASN1 pkcs12Attribute = bagAttributes [i];  			ASN1 attrId = pkcs12Attribute [0];  			string ao = ASN1Convert.ToOid (attrId);  			ArrayList dattrValues = (ArrayList)attrs [ao];  			if (dattrValues != null) {  				ASN1 attrValues = pkcs12Attribute [1];  				if (dattrValues.Count == attrValues.Count) {  					int attrValuesFound = 0;  					for (int j = 0; j < attrValues.Count; j++) {  						ASN1 attrValue = attrValues [j];  						byte[] value = (byte[])dattrValues [j];  						if (Compare (value' attrValue.Value)) {  							attrValuesFound += 1;  						}  					}  					if (attrValuesFound == attrValues.Count) {  						bagAttributesFound += 1;  					}  				}  			}  		}  		if (bagAttributesFound == bagAttributes.Count) {  			ASN1 bagValue = safeBag [1];  			return bagValue.Value;  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSecret,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	int bagAttributesFound = 0;  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		ASN1 attrId = pkcs12Attribute [0];  		string ao = ASN1Convert.ToOid (attrId);  		ArrayList dattrValues = (ArrayList)attrs [ao];  		if (dattrValues != null) {  			ASN1 attrValues = pkcs12Attribute [1];  			if (dattrValues.Count == attrValues.Count) {  				int attrValuesFound = 0;  				for (int j = 0; j < attrValues.Count; j++) {  					ASN1 attrValue = attrValues [j];  					byte[] value = (byte[])dattrValues [j];  					if (Compare (value' attrValue.Value)) {  						attrValuesFound += 1;  					}  				}  				if (attrValuesFound == attrValues.Count) {  					bagAttributesFound += 1;  				}  			}  		}  	}  	if (bagAttributesFound == bagAttributes.Count) {  		ASN1 bagValue = safeBag [1];  		return bagValue.Value;  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetSecret,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	int bagAttributesFound = 0;  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		ASN1 attrId = pkcs12Attribute [0];  		string ao = ASN1Convert.ToOid (attrId);  		ArrayList dattrValues = (ArrayList)attrs [ao];  		if (dattrValues != null) {  			ASN1 attrValues = pkcs12Attribute [1];  			if (dattrValues.Count == attrValues.Count) {  				int attrValuesFound = 0;  				for (int j = 0; j < attrValues.Count; j++) {  					ASN1 attrValue = attrValues [j];  					byte[] value = (byte[])dattrValues [j];  					if (Compare (value' attrValue.Value)) {  						attrValuesFound += 1;  					}  				}  				if (attrValuesFound == attrValues.Count) {  					bagAttributesFound += 1;  				}  			}  		}  	}  	if (bagAttributesFound == bagAttributes.Count) {  		ASN1 bagValue = safeBag [1];  		return bagValue.Value;  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetCertificate,The following statement contains a magic number: foreach (SafeBag sb in _safeBags) {  	if (sb.BagOID.Equals (certBag)) {  		ASN1 safeBag = sb.ASN1;  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			int bagAttributesFound = 0;  			for (int i = 0; i < bagAttributes.Count; i++) {  				ASN1 pkcs12Attribute = bagAttributes [i];  				ASN1 attrId = pkcs12Attribute [0];  				string ao = ASN1Convert.ToOid (attrId);  				ArrayList dattrValues = (ArrayList)attrs [ao];  				if (dattrValues != null) {  					ASN1 attrValues = pkcs12Attribute [1];  					if (dattrValues.Count == attrValues.Count) {  						int attrValuesFound = 0;  						for (int j = 0; j < attrValues.Count; j++) {  							ASN1 attrValue = attrValues [j];  							byte[] value = (byte[])dattrValues [j];  							if (Compare (value' attrValue.Value)) {  								attrValuesFound += 1;  							}  						}  						if (attrValuesFound == attrValues.Count) {  							bagAttributesFound += 1;  						}  					}  				}  			}  			if (bagAttributesFound == bagAttributes.Count) {  				ASN1 bagValue = safeBag [1];  				PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  				return new X509Certificate (crt.Content [0].Value);  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetCertificate,The following statement contains a magic number: foreach (SafeBag sb in _safeBags) {  	if (sb.BagOID.Equals (certBag)) {  		ASN1 safeBag = sb.ASN1;  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			int bagAttributesFound = 0;  			for (int i = 0; i < bagAttributes.Count; i++) {  				ASN1 pkcs12Attribute = bagAttributes [i];  				ASN1 attrId = pkcs12Attribute [0];  				string ao = ASN1Convert.ToOid (attrId);  				ArrayList dattrValues = (ArrayList)attrs [ao];  				if (dattrValues != null) {  					ASN1 attrValues = pkcs12Attribute [1];  					if (dattrValues.Count == attrValues.Count) {  						int attrValuesFound = 0;  						for (int j = 0; j < attrValues.Count; j++) {  							ASN1 attrValue = attrValues [j];  							byte[] value = (byte[])dattrValues [j];  							if (Compare (value' attrValue.Value)) {  								attrValuesFound += 1;  							}  						}  						if (attrValuesFound == attrValues.Count) {  							bagAttributesFound += 1;  						}  					}  				}  			}  			if (bagAttributesFound == bagAttributes.Count) {  				ASN1 bagValue = safeBag [1];  				PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  				return new X509Certificate (crt.Content [0].Value);  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetCertificate,The following statement contains a magic number: if (sb.BagOID.Equals (certBag)) {  	ASN1 safeBag = sb.ASN1;  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		int bagAttributesFound = 0;  		for (int i = 0; i < bagAttributes.Count; i++) {  			ASN1 pkcs12Attribute = bagAttributes [i];  			ASN1 attrId = pkcs12Attribute [0];  			string ao = ASN1Convert.ToOid (attrId);  			ArrayList dattrValues = (ArrayList)attrs [ao];  			if (dattrValues != null) {  				ASN1 attrValues = pkcs12Attribute [1];  				if (dattrValues.Count == attrValues.Count) {  					int attrValuesFound = 0;  					for (int j = 0; j < attrValues.Count; j++) {  						ASN1 attrValue = attrValues [j];  						byte[] value = (byte[])dattrValues [j];  						if (Compare (value' attrValue.Value)) {  							attrValuesFound += 1;  						}  					}  					if (attrValuesFound == attrValues.Count) {  						bagAttributesFound += 1;  					}  				}  			}  		}  		if (bagAttributesFound == bagAttributes.Count) {  			ASN1 bagValue = safeBag [1];  			PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  			return new X509Certificate (crt.Content [0].Value);  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetCertificate,The following statement contains a magic number: if (sb.BagOID.Equals (certBag)) {  	ASN1 safeBag = sb.ASN1;  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		int bagAttributesFound = 0;  		for (int i = 0; i < bagAttributes.Count; i++) {  			ASN1 pkcs12Attribute = bagAttributes [i];  			ASN1 attrId = pkcs12Attribute [0];  			string ao = ASN1Convert.ToOid (attrId);  			ArrayList dattrValues = (ArrayList)attrs [ao];  			if (dattrValues != null) {  				ASN1 attrValues = pkcs12Attribute [1];  				if (dattrValues.Count == attrValues.Count) {  					int attrValuesFound = 0;  					for (int j = 0; j < attrValues.Count; j++) {  						ASN1 attrValue = attrValues [j];  						byte[] value = (byte[])dattrValues [j];  						if (Compare (value' attrValue.Value)) {  							attrValuesFound += 1;  						}  					}  					if (attrValuesFound == attrValues.Count) {  						bagAttributesFound += 1;  					}  				}  			}  		}  		if (bagAttributesFound == bagAttributes.Count) {  			ASN1 bagValue = safeBag [1];  			PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  			return new X509Certificate (crt.Content [0].Value);  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetCertificate,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	int bagAttributesFound = 0;  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		ASN1 attrId = pkcs12Attribute [0];  		string ao = ASN1Convert.ToOid (attrId);  		ArrayList dattrValues = (ArrayList)attrs [ao];  		if (dattrValues != null) {  			ASN1 attrValues = pkcs12Attribute [1];  			if (dattrValues.Count == attrValues.Count) {  				int attrValuesFound = 0;  				for (int j = 0; j < attrValues.Count; j++) {  					ASN1 attrValue = attrValues [j];  					byte[] value = (byte[])dattrValues [j];  					if (Compare (value' attrValue.Value)) {  						attrValuesFound += 1;  					}  				}  				if (attrValuesFound == attrValues.Count) {  					bagAttributesFound += 1;  				}  			}  		}  	}  	if (bagAttributesFound == bagAttributes.Count) {  		ASN1 bagValue = safeBag [1];  		PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  		return new X509Certificate (crt.Content [0].Value);  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetCertificate,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	int bagAttributesFound = 0;  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		ASN1 attrId = pkcs12Attribute [0];  		string ao = ASN1Convert.ToOid (attrId);  		ArrayList dattrValues = (ArrayList)attrs [ao];  		if (dattrValues != null) {  			ASN1 attrValues = pkcs12Attribute [1];  			if (dattrValues.Count == attrValues.Count) {  				int attrValuesFound = 0;  				for (int j = 0; j < attrValues.Count; j++) {  					ASN1 attrValue = attrValues [j];  					byte[] value = (byte[])dattrValues [j];  					if (Compare (value' attrValue.Value)) {  						attrValuesFound += 1;  					}  				}  				if (attrValuesFound == attrValues.Count) {  					bagAttributesFound += 1;  				}  			}  		}  	}  	if (bagAttributesFound == bagAttributes.Count) {  		ASN1 bagValue = safeBag [1];  		PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  		return new X509Certificate (crt.Content [0].Value);  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: foreach (SafeBag sb in _safeBags) {  	if (sb.BagOID.Equals (keyBag) || sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  		ASN1 safeBag = sb.ASN1;  		ASN1 bagValue = safeBag [1];  		AsymmetricAlgorithm saa = null;  		if (sb.BagOID.Equals (keyBag)) {  			PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (bagValue.Value);  			byte[] privateKey = pki.PrivateKey;  			switch (privateKey [0]) {  			case 0x02:  				DSAParameters p = new DSAParameters ();  				// FIXME  				saa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  				break;  			case 0x30:  				saa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  				break;  			default:  				break;  			}  			Array.Clear (privateKey' 0' privateKey.Length);  		} else if (sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  			PKCS8.EncryptedPrivateKeyInfo epki = new PKCS8.EncryptedPrivateKeyInfo (bagValue.Value);  			byte[] decrypted = Decrypt (epki.Algorithm' epki.Salt' epki.IterationCount' epki.EncryptedData);  			PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (decrypted);  			byte[] privateKey = pki.PrivateKey;  			switch (privateKey [0]) {  			case 0x02:  				DSAParameters p = new DSAParameters ();  				// FIXME  				saa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  				break;  			case 0x30:  				saa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  				break;  			default:  				break;  			}  			Array.Clear (privateKey' 0' privateKey.Length);  			Array.Clear (decrypted' 0' decrypted.Length);  		}  		if (saa != null && CompareAsymmetricAlgorithm (saa' aa)) {  			if (safeBag.Count == 3) {  				ASN1 bagAttributes = safeBag [2];  				for (int i = 0; i < bagAttributes.Count; i++) {  					ASN1 pkcs12Attribute = bagAttributes [i];  					ASN1 attrId = pkcs12Attribute [0];  					string aOid = ASN1Convert.ToOid (attrId);  					ArrayList aValues = new ArrayList ();  					ASN1 attrValues = pkcs12Attribute [1];  					for (int j = 0; j < attrValues.Count; j++) {  						ASN1 attrValue = attrValues [j];  						aValues.Add (attrValue.Value);  					}  					result.Add (aOid' aValues);  				}  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: foreach (SafeBag sb in _safeBags) {  	if (sb.BagOID.Equals (keyBag) || sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  		ASN1 safeBag = sb.ASN1;  		ASN1 bagValue = safeBag [1];  		AsymmetricAlgorithm saa = null;  		if (sb.BagOID.Equals (keyBag)) {  			PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (bagValue.Value);  			byte[] privateKey = pki.PrivateKey;  			switch (privateKey [0]) {  			case 0x02:  				DSAParameters p = new DSAParameters ();  				// FIXME  				saa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  				break;  			case 0x30:  				saa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  				break;  			default:  				break;  			}  			Array.Clear (privateKey' 0' privateKey.Length);  		} else if (sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  			PKCS8.EncryptedPrivateKeyInfo epki = new PKCS8.EncryptedPrivateKeyInfo (bagValue.Value);  			byte[] decrypted = Decrypt (epki.Algorithm' epki.Salt' epki.IterationCount' epki.EncryptedData);  			PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (decrypted);  			byte[] privateKey = pki.PrivateKey;  			switch (privateKey [0]) {  			case 0x02:  				DSAParameters p = new DSAParameters ();  				// FIXME  				saa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  				break;  			case 0x30:  				saa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  				break;  			default:  				break;  			}  			Array.Clear (privateKey' 0' privateKey.Length);  			Array.Clear (decrypted' 0' decrypted.Length);  		}  		if (saa != null && CompareAsymmetricAlgorithm (saa' aa)) {  			if (safeBag.Count == 3) {  				ASN1 bagAttributes = safeBag [2];  				for (int i = 0; i < bagAttributes.Count; i++) {  					ASN1 pkcs12Attribute = bagAttributes [i];  					ASN1 attrId = pkcs12Attribute [0];  					string aOid = ASN1Convert.ToOid (attrId);  					ArrayList aValues = new ArrayList ();  					ASN1 attrValues = pkcs12Attribute [1];  					for (int j = 0; j < attrValues.Count; j++) {  						ASN1 attrValue = attrValues [j];  						aValues.Add (attrValue.Value);  					}  					result.Add (aOid' aValues);  				}  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (sb.BagOID.Equals (keyBag) || sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  	ASN1 safeBag = sb.ASN1;  	ASN1 bagValue = safeBag [1];  	AsymmetricAlgorithm saa = null;  	if (sb.BagOID.Equals (keyBag)) {  		PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (bagValue.Value);  		byte[] privateKey = pki.PrivateKey;  		switch (privateKey [0]) {  		case 0x02:  			DSAParameters p = new DSAParameters ();  			// FIXME  			saa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  			break;  		case 0x30:  			saa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  			break;  		default:  			break;  		}  		Array.Clear (privateKey' 0' privateKey.Length);  	} else if (sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  		PKCS8.EncryptedPrivateKeyInfo epki = new PKCS8.EncryptedPrivateKeyInfo (bagValue.Value);  		byte[] decrypted = Decrypt (epki.Algorithm' epki.Salt' epki.IterationCount' epki.EncryptedData);  		PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (decrypted);  		byte[] privateKey = pki.PrivateKey;  		switch (privateKey [0]) {  		case 0x02:  			DSAParameters p = new DSAParameters ();  			// FIXME  			saa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  			break;  		case 0x30:  			saa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  			break;  		default:  			break;  		}  		Array.Clear (privateKey' 0' privateKey.Length);  		Array.Clear (decrypted' 0' decrypted.Length);  	}  	if (saa != null && CompareAsymmetricAlgorithm (saa' aa)) {  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			for (int i = 0; i < bagAttributes.Count; i++) {  				ASN1 pkcs12Attribute = bagAttributes [i];  				ASN1 attrId = pkcs12Attribute [0];  				string aOid = ASN1Convert.ToOid (attrId);  				ArrayList aValues = new ArrayList ();  				ASN1 attrValues = pkcs12Attribute [1];  				for (int j = 0; j < attrValues.Count; j++) {  					ASN1 attrValue = attrValues [j];  					aValues.Add (attrValue.Value);  				}  				result.Add (aOid' aValues);  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (sb.BagOID.Equals (keyBag) || sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  	ASN1 safeBag = sb.ASN1;  	ASN1 bagValue = safeBag [1];  	AsymmetricAlgorithm saa = null;  	if (sb.BagOID.Equals (keyBag)) {  		PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (bagValue.Value);  		byte[] privateKey = pki.PrivateKey;  		switch (privateKey [0]) {  		case 0x02:  			DSAParameters p = new DSAParameters ();  			// FIXME  			saa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  			break;  		case 0x30:  			saa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  			break;  		default:  			break;  		}  		Array.Clear (privateKey' 0' privateKey.Length);  	} else if (sb.BagOID.Equals (pkcs8ShroudedKeyBag)) {  		PKCS8.EncryptedPrivateKeyInfo epki = new PKCS8.EncryptedPrivateKeyInfo (bagValue.Value);  		byte[] decrypted = Decrypt (epki.Algorithm' epki.Salt' epki.IterationCount' epki.EncryptedData);  		PKCS8.PrivateKeyInfo pki = new PKCS8.PrivateKeyInfo (decrypted);  		byte[] privateKey = pki.PrivateKey;  		switch (privateKey [0]) {  		case 0x02:  			DSAParameters p = new DSAParameters ();  			// FIXME  			saa = PKCS8.PrivateKeyInfo.DecodeDSA (privateKey' p);  			break;  		case 0x30:  			saa = PKCS8.PrivateKeyInfo.DecodeRSA (privateKey);  			break;  		default:  			break;  		}  		Array.Clear (privateKey' 0' privateKey.Length);  		Array.Clear (decrypted' 0' decrypted.Length);  	}  	if (saa != null && CompareAsymmetricAlgorithm (saa' aa)) {  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			for (int i = 0; i < bagAttributes.Count; i++) {  				ASN1 pkcs12Attribute = bagAttributes [i];  				ASN1 attrId = pkcs12Attribute [0];  				string aOid = ASN1Convert.ToOid (attrId);  				ArrayList aValues = new ArrayList ();  				ASN1 attrValues = pkcs12Attribute [1];  				for (int j = 0; j < attrValues.Count; j++) {  					ASN1 attrValue = attrValues [j];  					aValues.Add (attrValue.Value);  				}  				result.Add (aOid' aValues);  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (saa != null && CompareAsymmetricAlgorithm (saa' aa)) {  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		for (int i = 0; i < bagAttributes.Count; i++) {  			ASN1 pkcs12Attribute = bagAttributes [i];  			ASN1 attrId = pkcs12Attribute [0];  			string aOid = ASN1Convert.ToOid (attrId);  			ArrayList aValues = new ArrayList ();  			ASN1 attrValues = pkcs12Attribute [1];  			for (int j = 0; j < attrValues.Count; j++) {  				ASN1 attrValue = attrValues [j];  				aValues.Add (attrValue.Value);  			}  			result.Add (aOid' aValues);  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (saa != null && CompareAsymmetricAlgorithm (saa' aa)) {  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		for (int i = 0; i < bagAttributes.Count; i++) {  			ASN1 pkcs12Attribute = bagAttributes [i];  			ASN1 attrId = pkcs12Attribute [0];  			string aOid = ASN1Convert.ToOid (attrId);  			ArrayList aValues = new ArrayList ();  			ASN1 attrValues = pkcs12Attribute [1];  			for (int j = 0; j < attrValues.Count; j++) {  				ASN1 attrValue = attrValues [j];  				aValues.Add (attrValue.Value);  			}  			result.Add (aOid' aValues);  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		ASN1 attrId = pkcs12Attribute [0];  		string aOid = ASN1Convert.ToOid (attrId);  		ArrayList aValues = new ArrayList ();  		ASN1 attrValues = pkcs12Attribute [1];  		for (int j = 0; j < attrValues.Count; j++) {  			ASN1 attrValue = attrValues [j];  			aValues.Add (attrValue.Value);  		}  		result.Add (aOid' aValues);  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		ASN1 attrId = pkcs12Attribute [0];  		string aOid = ASN1Convert.ToOid (attrId);  		ArrayList aValues = new ArrayList ();  		ASN1 attrValues = pkcs12Attribute [1];  		for (int j = 0; j < attrValues.Count; j++) {  			ASN1 attrValue = attrValues [j];  			aValues.Add (attrValue.Value);  		}  		result.Add (aOid' aValues);  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: foreach (SafeBag sb in _safeBags) {  	if (sb.BagOID.Equals (certBag)) {  		ASN1 safeBag = sb.ASN1;  		ASN1 bagValue = safeBag [1];  		PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  		X509Certificate xc = new X509Certificate (crt.Content [0].Value);  		if (Compare (cert.RawData' xc.RawData)) {  			if (safeBag.Count == 3) {  				ASN1 bagAttributes = safeBag [2];  				for (int i = 0; i < bagAttributes.Count; i++) {  					ASN1 pkcs12Attribute = bagAttributes [i];  					ASN1 attrId = pkcs12Attribute [0];  					string aOid = ASN1Convert.ToOid (attrId);  					ArrayList aValues = new ArrayList ();  					ASN1 attrValues = pkcs12Attribute [1];  					for (int j = 0; j < attrValues.Count; j++) {  						ASN1 attrValue = attrValues [j];  						aValues.Add (attrValue.Value);  					}  					result.Add (aOid' aValues);  				}  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: foreach (SafeBag sb in _safeBags) {  	if (sb.BagOID.Equals (certBag)) {  		ASN1 safeBag = sb.ASN1;  		ASN1 bagValue = safeBag [1];  		PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  		X509Certificate xc = new X509Certificate (crt.Content [0].Value);  		if (Compare (cert.RawData' xc.RawData)) {  			if (safeBag.Count == 3) {  				ASN1 bagAttributes = safeBag [2];  				for (int i = 0; i < bagAttributes.Count; i++) {  					ASN1 pkcs12Attribute = bagAttributes [i];  					ASN1 attrId = pkcs12Attribute [0];  					string aOid = ASN1Convert.ToOid (attrId);  					ArrayList aValues = new ArrayList ();  					ASN1 attrValues = pkcs12Attribute [1];  					for (int j = 0; j < attrValues.Count; j++) {  						ASN1 attrValue = attrValues [j];  						aValues.Add (attrValue.Value);  					}  					result.Add (aOid' aValues);  				}  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (sb.BagOID.Equals (certBag)) {  	ASN1 safeBag = sb.ASN1;  	ASN1 bagValue = safeBag [1];  	PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  	X509Certificate xc = new X509Certificate (crt.Content [0].Value);  	if (Compare (cert.RawData' xc.RawData)) {  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			for (int i = 0; i < bagAttributes.Count; i++) {  				ASN1 pkcs12Attribute = bagAttributes [i];  				ASN1 attrId = pkcs12Attribute [0];  				string aOid = ASN1Convert.ToOid (attrId);  				ArrayList aValues = new ArrayList ();  				ASN1 attrValues = pkcs12Attribute [1];  				for (int j = 0; j < attrValues.Count; j++) {  					ASN1 attrValue = attrValues [j];  					aValues.Add (attrValue.Value);  				}  				result.Add (aOid' aValues);  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (sb.BagOID.Equals (certBag)) {  	ASN1 safeBag = sb.ASN1;  	ASN1 bagValue = safeBag [1];  	PKCS7.ContentInfo crt = new PKCS7.ContentInfo (bagValue.Value);  	X509Certificate xc = new X509Certificate (crt.Content [0].Value);  	if (Compare (cert.RawData' xc.RawData)) {  		if (safeBag.Count == 3) {  			ASN1 bagAttributes = safeBag [2];  			for (int i = 0; i < bagAttributes.Count; i++) {  				ASN1 pkcs12Attribute = bagAttributes [i];  				ASN1 attrId = pkcs12Attribute [0];  				string aOid = ASN1Convert.ToOid (attrId);  				ArrayList aValues = new ArrayList ();  				ASN1 attrValues = pkcs12Attribute [1];  				for (int j = 0; j < attrValues.Count; j++) {  					ASN1 attrValue = attrValues [j];  					aValues.Add (attrValue.Value);  				}  				result.Add (aOid' aValues);  			}  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (Compare (cert.RawData' xc.RawData)) {  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		for (int i = 0; i < bagAttributes.Count; i++) {  			ASN1 pkcs12Attribute = bagAttributes [i];  			ASN1 attrId = pkcs12Attribute [0];  			string aOid = ASN1Convert.ToOid (attrId);  			ArrayList aValues = new ArrayList ();  			ASN1 attrValues = pkcs12Attribute [1];  			for (int j = 0; j < attrValues.Count; j++) {  				ASN1 attrValue = attrValues [j];  				aValues.Add (attrValue.Value);  			}  			result.Add (aOid' aValues);  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (Compare (cert.RawData' xc.RawData)) {  	if (safeBag.Count == 3) {  		ASN1 bagAttributes = safeBag [2];  		for (int i = 0; i < bagAttributes.Count; i++) {  			ASN1 pkcs12Attribute = bagAttributes [i];  			ASN1 attrId = pkcs12Attribute [0];  			string aOid = ASN1Convert.ToOid (attrId);  			ArrayList aValues = new ArrayList ();  			ASN1 attrValues = pkcs12Attribute [1];  			for (int j = 0; j < attrValues.Count; j++) {  				ASN1 attrValue = attrValues [j];  				aValues.Add (attrValue.Value);  			}  			result.Add (aOid' aValues);  		}  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		ASN1 attrId = pkcs12Attribute [0];  		string aOid = ASN1Convert.ToOid (attrId);  		ArrayList aValues = new ArrayList ();  		ASN1 attrValues = pkcs12Attribute [1];  		for (int j = 0; j < attrValues.Count; j++) {  			ASN1 attrValue = attrValues [j];  			aValues.Add (attrValue.Value);  		}  		result.Add (aOid' aValues);  	}  }  
Magic Number,Mono.Security.X509,PKCS12,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS12.cs,GetAttributes,The following statement contains a magic number: if (safeBag.Count == 3) {  	ASN1 bagAttributes = safeBag [2];  	for (int i = 0; i < bagAttributes.Count; i++) {  		ASN1 pkcs12Attribute = bagAttributes [i];  		ASN1 attrId = pkcs12Attribute [0];  		string aOid = ASN1Convert.ToOid (attrId);  		ArrayList aValues = new ArrayList ();  		ASN1 attrValues = pkcs12Attribute [1];  		for (int j = 0; j < attrValues.Count; j++) {  			ASN1 attrValue = attrValues [j];  			aValues.Add (attrValue.Value);  		}  		result.Add (aOid' aValues);  	}  }  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,AppendEntry,The following statement contains a magic number: for (int k = 0; k < entry.Count; k++) {  	ASN1 pair = entry [k];  	ASN1 s = pair [1];  	if (s == null)  		continue;  	ASN1 poid = pair [0];  	if (poid == null)  		continue;  	if (poid.CompareValue (countryName))  		sb.Append ("C=");  	else if (poid.CompareValue (organizationName))  		sb.Append ("O=");  	else if (poid.CompareValue (organizationalUnitName))  		sb.Append ("OU=");  	else if (poid.CompareValue (commonName))  		sb.Append ("CN=");  	else if (poid.CompareValue (localityName))  		sb.Append ("L=");  	else if (poid.CompareValue (stateOrProvinceName))  		sb.Append ("S=");  	// NOTE: RFC2253 uses ST=  	else if (poid.CompareValue (streetAddress))  		sb.Append ("STREET=");  	else if (poid.CompareValue (domainComponent))  		sb.Append ("DC=");  	else if (poid.CompareValue (userid))  		sb.Append ("UID=");  	else if (poid.CompareValue (email))  		sb.Append ("E=");  	// NOTE: Not part of RFC2253  	else if (poid.CompareValue (dnQualifier))  		sb.Append ("dnQualifier=");  	else if (poid.CompareValue (title))  		sb.Append ("T=");  	else if (poid.CompareValue (surname))  		sb.Append ("SN=");  	else if (poid.CompareValue (givenName))  		sb.Append ("G=");  	else if (poid.CompareValue (initial))  		sb.Append ("I=");  	else {  		// unknown OID  		sb.Append ("OID.");  		// NOTE: Not present as RFC2253  		sb.Append (ASN1Convert.ToOid (poid));  		sb.Append ("=");  	}  	string sValue = null;  	// 16bits or 8bits string ? TODO not complete (+special chars!)  	if (s.Tag == 0x1E) {  		// BMPSTRING  		StringBuilder sb2 = new StringBuilder ();  		for (int j = 1; j < s.Value.Length; j += 2)  			sb2.Append ((char)s.Value [j]);  		sValue = sb2.ToString ();  	} else {  		if (s.Tag == 0x14)  			sValue = Encoding.UTF7.GetString (s.Value);  		else  			sValue = Encoding.UTF8.GetString (s.Value);  		// in some cases we must quote (") the value  		// Note: this doesn't seems to conform to RFC2253  		char[] specials =  {  			''''  			'+''  			'"''  			'\\''  			'<''  			'>''  			';'  		};  		if (quotes) {  			if ((sValue.IndexOfAny (specials' 0' sValue.Length) > 0) || sValue.StartsWith (" ") || (sValue.EndsWith (" ")))  				sValue = "\"" + sValue + "\"";  		}  	}  	sb.Append (sValue);  	// separator (not on last iteration)  	if (k < entry.Count - 1)  		sb.Append ("' ");  }  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,AppendEntry,The following statement contains a magic number: if (s.Tag == 0x1E) {  	// BMPSTRING  	StringBuilder sb2 = new StringBuilder ();  	for (int j = 1; j < s.Value.Length; j += 2)  		sb2.Append ((char)s.Value [j]);  	sValue = sb2.ToString ();  } else {  	if (s.Tag == 0x14)  		sValue = Encoding.UTF7.GetString (s.Value);  	else  		sValue = Encoding.UTF8.GetString (s.Value);  	// in some cases we must quote (") the value  	// Note: this doesn't seems to conform to RFC2253  	char[] specials =  {  		''''  		'+''  		'"''  		'\\''  		'<''  		'>''  		';'  	};  	if (quotes) {  		if ((sValue.IndexOfAny (specials' 0' sValue.Length) > 0) || sValue.StartsWith (" ") || (sValue.EndsWith (" ")))  			sValue = "\"" + sValue + "\"";  	}  }  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,AppendEntry,The following statement contains a magic number: for (int j = 1; j < s.Value.Length; j += 2)  	sb2.Append ((char)s.Value [j]);  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,AppendEntry,The following statement contains a magic number: j += 2
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,GetAttributeFromOid,The following statement contains a magic number: switch (s) {  case "C":  	return new X520.CountryName ();  case "O":  	return new X520.OrganizationName ();  case "OU":  	return new X520.OrganizationalUnitName ();  case "CN":  	return new X520.CommonName ();  case "L":  	return new X520.LocalityName ();  case "S":  // Microsoft  case "ST":  	// RFC2253  	return new X520.StateOrProvinceName ();  case "E":  	// NOTE: Not part of RFC2253  	return new X520.EmailAddress ();  case "DC":  	// RFC2247  	return new X520.DomainComponent ();  case "UID":  	// RFC1274  	return new X520.UserId ();  case "DNQUALIFIER":  	return new X520.DnQualifier ();  case "T":  	return new X520.Title ();  case "SN":  	return new X520.Surname ();  case "G":  	return new X520.GivenName ();  case "I":  	return new X520.Initial ();  default:  	if (s.StartsWith ("OID.")) {  		// MUST support it but it OID may be without it  		return new X520.Oid (s.Substring (4));  	} else {  		if (IsOid (s))  			return new X520.Oid (s);  		else  			return null;  	}  }  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,GetAttributeFromOid,The following statement contains a magic number: if (s.StartsWith ("OID.")) {  	// MUST support it but it OID may be without it  	return new X520.Oid (s.Substring (4));  } else {  	if (IsOid (s))  		return new X520.Oid (s);  	else  		return null;  }  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,GetAttributeFromOid,The following statement contains a magic number: return new X520.Oid (s.Substring (4));  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,ReadHex,The following statement contains a magic number: if ((pos < value.Length - 4) && (value [pos + 1] == '\\') && IsHex (value [pos + 2])) {  	pos += 2;  	// pass last char and skip \  	sb.Append (value [pos++]);  	sb.Append (value [pos]);  }  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,ReadHex,The following statement contains a magic number: if ((pos < value.Length - 4) && (value [pos + 1] == '\\') && IsHex (value [pos + 2])) {  	pos += 2;  	// pass last char and skip \  	sb.Append (value [pos++]);  	sb.Append (value [pos]);  }  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,ReadHex,The following statement contains a magic number: if ((pos < value.Length - 4) && (value [pos + 1] == '\\') && IsHex (value [pos + 2])) {  	pos += 2;  	// pass last char and skip \  	sb.Append (value [pos++]);  	sb.Append (value [pos]);  }  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,ReadHex,The following statement contains a magic number: pos += 2;  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,ReadEscaped,The following statement contains a magic number: switch (value [pos]) {  case '\\':  case '"':  case '=':  case ';':  case '<':  case '>':  case '+':  case '#':  case ''':  	sb.Append (value [pos]);  	return pos;  default:  	if (pos >= value.Length - 2) {  		string msg = Locale.GetText ("Malformed escaped value '{0}'.");  		throw new FormatException (string.Format (msg' value.Substring (pos)));  	}  	// it's either a 8 bits or 16 bits char  	sb.Append (ReadHex (value' ref pos));  	return pos;  }  
Magic Number,Mono.Security.X509,X501,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X501Name.cs,ReadEscaped,The following statement contains a magic number: if (pos >= value.Length - 2) {  	string msg = Locale.GetText ("Malformed escaped value '{0}'.");  	throw new FormatException (string.Format (msg' value.Substring (pos)));  }  
Magic Number,Mono.Security.X509,X509Builder,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Builder.cs,Sign,The following statement contains a magic number: Buffer.BlockCopy (rs' 0' r' 0' 20);  
Magic Number,Mono.Security.X509,X509Builder,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Builder.cs,Sign,The following statement contains a magic number: Buffer.BlockCopy (rs' 20' s' 0' 20);  
Magic Number,Mono.Security.X509,X509Builder,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Builder.cs,Sign,The following statement contains a magic number: Buffer.BlockCopy (rs' 20' s' 0' 20);  
Magic Number,Mono.Security.X509,X509Certificate,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Certificate.cs,Parse,The following statement contains a magic number: try {  	decoder = new ASN1 (data);  	// Certificate   	if (decoder.Tag != 0x30)  		throw new CryptographicException (encoding_error);  	// Certificate / TBSCertificate  	if (decoder [0].Tag != 0x30)  		throw new CryptographicException (encoding_error);  	ASN1 tbsCertificate = decoder [0];  	int tbs = 0;  	// Certificate / TBSCertificate / Version  	ASN1 v = decoder [0] [tbs];  	version = 1;  	// DEFAULT v1  	if ((v.Tag == 0xA0) && (v.Count > 0)) {  		// version (optional) is present only in v2+ certs  		version += v [0].Value [0];  		// zero based  		tbs++;  	}  	// Certificate / TBSCertificate / CertificateSerialNumber  	ASN1 sn = decoder [0] [tbs++];  	if (sn.Tag != 0x02)  		throw new CryptographicException (encoding_error);  	serialnumber = sn.Value;  	Array.Reverse (serialnumber' 0' serialnumber.Length);  	// Certificate / TBSCertificate / AlgorithmIdentifier  	tbs++;  	// ASN1 signatureAlgo = tbsCertificate.Element (tbs++' 0x30);   	issuer = tbsCertificate.Element (tbs++' 0x30);  	m_issuername = X501.ToString (issuer);  	ASN1 validity = tbsCertificate.Element (tbs++' 0x30);  	ASN1 notBefore = validity [0];  	m_from = ASN1Convert.ToDateTime (notBefore);  	ASN1 notAfter = validity [1];  	m_until = ASN1Convert.ToDateTime (notAfter);  	subject = tbsCertificate.Element (tbs++' 0x30);  	m_subject = X501.ToString (subject);  	ASN1 subjectPublicKeyInfo = tbsCertificate.Element (tbs++' 0x30);  	ASN1 algorithm = subjectPublicKeyInfo.Element (0' 0x30);  	ASN1 algo = algorithm.Element (0' 0x06);  	m_keyalgo = ASN1Convert.ToOid (algo);  	// parameters ANY DEFINED BY algorithm OPTIONAL  	// so we dont ask for a specific (Element) type and return DER  	ASN1 parameters = algorithm [1];  	m_keyalgoparams = ((algorithm.Count > 1) ? parameters.GetBytes () : null);  	ASN1 subjectPublicKey = subjectPublicKeyInfo.Element (1' 0x03);  	// we must drop th first byte (which is the number of unused bits  	// in the BITSTRING)  	int n = subjectPublicKey.Length - 1;  	m_publickey = new byte[n];  	Buffer.BlockCopy (subjectPublicKey.Value' 1' m_publickey' 0' n);  	// signature processing  	byte[] bitstring = decoder [2].Value;  	// first byte contains unused bits in first byte  	signature = new byte[bitstring.Length - 1];  	Buffer.BlockCopy (bitstring' 1' signature' 0' signature.Length);  	algorithm = decoder [1];  	algo = algorithm.Element (0' 0x06);  	m_signaturealgo = ASN1Convert.ToOid (algo);  	parameters = algorithm [1];  	if (parameters != null)  		m_signaturealgoparams = parameters.GetBytes ();  	else  		m_signaturealgoparams = null;  	// Certificate / TBSCertificate / issuerUniqueID  	ASN1 issuerUID = tbsCertificate.Element (tbs' 0x81);  	if (issuerUID != null) {  		tbs++;  		issuerUniqueID = issuerUID.Value;  	}  	// Certificate / TBSCertificate / subjectUniqueID  	ASN1 subjectUID = tbsCertificate.Element (tbs' 0x82);  	if (subjectUID != null) {  		tbs++;  		subjectUniqueID = subjectUID.Value;  	}  	// Certificate / TBSCertificate / Extensions  	ASN1 extns = tbsCertificate.Element (tbs' 0xA3);  	if ((extns != null) && (extns.Count == 1))  		extensions = new X509ExtensionCollection (extns [0]);  	else  		extensions = new X509ExtensionCollection (null);  	// keep a copy of the original data  	m_encodedcert = (byte[])data.Clone ();  } catch (Exception ex) {  	throw new CryptographicException (encoding_error' ex);  }  
Magic Number,Mono.Security.X509,X509CertificateBuilder,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509CertificateBuilder.cs,X509CertificateBuilder,The following statement contains a magic number: if (version > 3)  	throw new ArgumentException ("Invalid certificate version");  
Magic Number,Mono.Security.X509,X509CertificateBuilder,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509CertificateBuilder.cs,ToBeSigned,The following statement contains a magic number: if (version > 1) {  	// TBSCertificate / [1]  IMPLICIT UniqueIdentifier OPTIONAL  	if (issuerUniqueID != null)  		tbsCert.Add (new ASN1 (0xA1' UniqueIdentifier (issuerUniqueID)));  	// TBSCertificate / [2]  IMPLICIT UniqueIdentifier OPTIONAL  	if (subjectUniqueID != null)  		tbsCert.Add (new ASN1 (0xA1' UniqueIdentifier (subjectUniqueID)));  	// TBSCertificate / [3]  Extensions OPTIONAL  	if ((version > 2) && (extensions.Count > 0))  		tbsCert.Add (new ASN1 (0xA3' extensions.GetBytes ()));  }  
Magic Number,Mono.Security.X509,X509CertificateBuilder,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509CertificateBuilder.cs,ToBeSigned,The following statement contains a magic number: if ((version > 2) && (extensions.Count > 0))  	tbsCert.Add (new ASN1 (0xA3' extensions.GetBytes ()));  
Magic Number,Mono.Security.X509,X509Extension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Extension.cs,X509Extension,The following statement contains a magic number: if ((asn1.Tag != 0x30) || (asn1.Count < 2))  	throw new ArgumentException (Locale.GetText ("Invalid X.509 extension."));  
Magic Number,Mono.Security.X509,X509Extension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Extension.cs,WriteLine,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	if (j < n) {  		sb.Append (value [p++].ToString ("X2"' CultureInfo.InvariantCulture));  		sb.Append (" ");  	} else  		sb.Append ("   ");  }  
Magic Number,Mono.Security.X509,X509Extension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Extension.cs,ToString,The following statement contains a magic number: for (int i = 0; i < div; i++) {  	WriteLine (sb' 8' x);  	x += 8;  }  
Magic Number,Mono.Security.X509,X509Extension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Extension.cs,ToString,The following statement contains a magic number: for (int i = 0; i < div; i++) {  	WriteLine (sb' 8' x);  	x += 8;  }  
Magic Number,Mono.Security.X509,X509Extension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Extension.cs,ToString,The following statement contains a magic number: WriteLine (sb' 8' x);  
Magic Number,Mono.Security.X509,X509Extension,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\X509Extension.cs,ToString,The following statement contains a magic number: x += 8;  
Magic Number,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,GetConfiguration,The following statement contains a magic number: return PerformLogicWithDatabase (context' true' db => {  	int numDocs = db.GetDocumentCount ();  	long updateSequence = db.GetLastSequenceNumber ();  	if (numDocs < 0 || updateSequence < 0) {  		return context.CreateResponse (StatusCode.DbError);  	}  	var response = context.CreateResponse ();  	response.JsonBody = new Body (new Dictionary<string' object> {  		{  			"db_name"'  			db.Name  		}'  		{  			"db_uuid"'  			db.PublicUUID ()  		}'  		{  			"doc_count"'  			numDocs  		}'  		{  			"update_seq"'  			updateSequence  		}'  		{  			"committed_update_seq"'  			updateSequence  		}'  		{  			"purge_seq"'  			0  		}'  		//TODO: Implement  		{  			"disk_size"'  			db.GetTotalDataSize ()  		}'  		{  			"start_time"'  			db.StartTime * 1000  		}'  		{  			"revs_limit"'  			db.GetMaxRevTreeDepth ()  		}  	});  	return response;  }).AsDefaultState ();  
Magic Number,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,GetConfiguration,The following statement contains a magic number: response.JsonBody = new Body (new Dictionary<string' object> {  	{  		"db_name"'  		db.Name  	}'  	{  		"db_uuid"'  		db.PublicUUID ()  	}'  	{  		"doc_count"'  		numDocs  	}'  	{  		"update_seq"'  		updateSequence  	}'  	{  		"committed_update_seq"'  		updateSequence  	}'  	{  		"purge_seq"'  		0  	}'  	//TODO: Implement  	{  		"disk_size"'  		db.GetTotalDataSize ()  	}'  	{  		"start_time"'  		db.StartTime * 1000  	}'  	{  		"revs_limit"'  		db.GetMaxRevTreeDepth ()  	}  });  
Magic Number,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,ProcessDocumentChangeOperations,The following statement contains a magic number: return PerformLogicWithDatabase (context' true' db => {  	var postBody = context.BodyAs<Dictionary<string' object>> ();  	if (postBody == null) {  		return context.CreateResponse (StatusCode.BadJson);  	}  	if (!postBody.ContainsKey ("docs")) {  		return context.CreateResponse (StatusCode.BadParam);  	}  	var docs = postBody ["docs"].AsList<IDictionary<string' object>> ();  	bool allOrNothing;  	postBody.TryGetValue<bool> ("all_or_nothing"' out allOrNothing);  	var newEdits = postBody.GetCast<bool> ("new_edits"' true);  	var response = context.CreateResponse ();  	StatusCode status = StatusCode.Ok;  	bool success = db.RunInTransaction (() => {  		List<IDictionary<string' object>> results = new List<IDictionary<string' object>> (docs.Count);  		var castContext = context as ICouchbaseListenerContext2;  		var source = castContext != null && !castContext.IsLoopbackRequest ? castContext.Sender : null;  		foreach (var doc in docs) {  			string docId = doc.CblID ();  			RevisionInternal rev = null;  			Body body = new Body (doc);  			if (!newEdits) {  				if (!RevisionInternal.IsValid (body)) {  					status = StatusCode.BadParam;  				} else {  					rev = new RevisionInternal (body);  					var history = Database.ParseCouchDBRevisionHistory (doc);  					try {  						Log.To.Router.I (TAG' "Inserting revision {0} from _bulk_docs"' rev);  						Log.To.Router.V (TAG' "With history {0}"' new LogJsonString (history));  						db.ForceInsert (rev' history' source);  					} catch (CouchbaseLiteException e) {  						status = e.Code;  					}  				}  			} else {  				status = DocumentMethods.UpdateDocument (context' db' docId' body' false' allOrNothing' out rev);  			}  			IDictionary<string' object> result = null;  			if ((int)status < 300) {  				Debug.Assert (rev != null && rev.RevID != null);  				if (newEdits) {  					result = new Dictionary<string' object> {  						{  							"id"'  							rev.DocID  						}'  						{  							"rev"'  							rev.RevID  						}'  						{  							"status"'  							(int)status  						}  					};  				}  			} else if ((int)status >= 500) {  				return false;  				// abort the whole thing if something goes badly wrong  			} else if (allOrNothing) {  				return false;  				// all_or_nothing backs out if there's any error  			} else {  				var info = Status.ToHttpStatus (status);  				result = new Dictionary<string' object> {  					{  						"id"'  						docId  					}'  					{  						"error"'  						info.Item2  					}'  					{  						"status"'  						info.Item1  					}  				};  			}  			if (result != null) {  				results.Add (result);  			}  		}  		response.JsonBody = new Body (results.Cast<object> ().ToList ());  		return true;  	});  	if (!success) {  		response.InternalStatus = status;  	}  	return response;  }).AsDefaultState ();  
Magic Number,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,ProcessDocumentChangeOperations,The following statement contains a magic number: return PerformLogicWithDatabase (context' true' db => {  	var postBody = context.BodyAs<Dictionary<string' object>> ();  	if (postBody == null) {  		return context.CreateResponse (StatusCode.BadJson);  	}  	if (!postBody.ContainsKey ("docs")) {  		return context.CreateResponse (StatusCode.BadParam);  	}  	var docs = postBody ["docs"].AsList<IDictionary<string' object>> ();  	bool allOrNothing;  	postBody.TryGetValue<bool> ("all_or_nothing"' out allOrNothing);  	var newEdits = postBody.GetCast<bool> ("new_edits"' true);  	var response = context.CreateResponse ();  	StatusCode status = StatusCode.Ok;  	bool success = db.RunInTransaction (() => {  		List<IDictionary<string' object>> results = new List<IDictionary<string' object>> (docs.Count);  		var castContext = context as ICouchbaseListenerContext2;  		var source = castContext != null && !castContext.IsLoopbackRequest ? castContext.Sender : null;  		foreach (var doc in docs) {  			string docId = doc.CblID ();  			RevisionInternal rev = null;  			Body body = new Body (doc);  			if (!newEdits) {  				if (!RevisionInternal.IsValid (body)) {  					status = StatusCode.BadParam;  				} else {  					rev = new RevisionInternal (body);  					var history = Database.ParseCouchDBRevisionHistory (doc);  					try {  						Log.To.Router.I (TAG' "Inserting revision {0} from _bulk_docs"' rev);  						Log.To.Router.V (TAG' "With history {0}"' new LogJsonString (history));  						db.ForceInsert (rev' history' source);  					} catch (CouchbaseLiteException e) {  						status = e.Code;  					}  				}  			} else {  				status = DocumentMethods.UpdateDocument (context' db' docId' body' false' allOrNothing' out rev);  			}  			IDictionary<string' object> result = null;  			if ((int)status < 300) {  				Debug.Assert (rev != null && rev.RevID != null);  				if (newEdits) {  					result = new Dictionary<string' object> {  						{  							"id"'  							rev.DocID  						}'  						{  							"rev"'  							rev.RevID  						}'  						{  							"status"'  							(int)status  						}  					};  				}  			} else if ((int)status >= 500) {  				return false;  				// abort the whole thing if something goes badly wrong  			} else if (allOrNothing) {  				return false;  				// all_or_nothing backs out if there's any error  			} else {  				var info = Status.ToHttpStatus (status);  				result = new Dictionary<string' object> {  					{  						"id"'  						docId  					}'  					{  						"error"'  						info.Item2  					}'  					{  						"status"'  						info.Item1  					}  				};  			}  			if (result != null) {  				results.Add (result);  			}  		}  		response.JsonBody = new Body (results.Cast<object> ().ToList ());  		return true;  	});  	if (!success) {  		response.InternalStatus = status;  	}  	return response;  }).AsDefaultState ();  
Magic Number,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,ProcessDocumentChangeOperations,The following statement contains a magic number: foreach (var doc in docs) {  	string docId = doc.CblID ();  	RevisionInternal rev = null;  	Body body = new Body (doc);  	if (!newEdits) {  		if (!RevisionInternal.IsValid (body)) {  			status = StatusCode.BadParam;  		} else {  			rev = new RevisionInternal (body);  			var history = Database.ParseCouchDBRevisionHistory (doc);  			try {  				Log.To.Router.I (TAG' "Inserting revision {0} from _bulk_docs"' rev);  				Log.To.Router.V (TAG' "With history {0}"' new LogJsonString (history));  				db.ForceInsert (rev' history' source);  			} catch (CouchbaseLiteException e) {  				status = e.Code;  			}  		}  	} else {  		status = DocumentMethods.UpdateDocument (context' db' docId' body' false' allOrNothing' out rev);  	}  	IDictionary<string' object> result = null;  	if ((int)status < 300) {  		Debug.Assert (rev != null && rev.RevID != null);  		if (newEdits) {  			result = new Dictionary<string' object> {  				{  					"id"'  					rev.DocID  				}'  				{  					"rev"'  					rev.RevID  				}'  				{  					"status"'  					(int)status  				}  			};  		}  	} else if ((int)status >= 500) {  		return false;  		// abort the whole thing if something goes badly wrong  	} else if (allOrNothing) {  		return false;  		// all_or_nothing backs out if there's any error  	} else {  		var info = Status.ToHttpStatus (status);  		result = new Dictionary<string' object> {  			{  				"id"'  				docId  			}'  			{  				"error"'  				info.Item2  			}'  			{  				"status"'  				info.Item1  			}  		};  	}  	if (result != null) {  		results.Add (result);  	}  }  
Magic Number,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,ProcessDocumentChangeOperations,The following statement contains a magic number: foreach (var doc in docs) {  	string docId = doc.CblID ();  	RevisionInternal rev = null;  	Body body = new Body (doc);  	if (!newEdits) {  		if (!RevisionInternal.IsValid (body)) {  			status = StatusCode.BadParam;  		} else {  			rev = new RevisionInternal (body);  			var history = Database.ParseCouchDBRevisionHistory (doc);  			try {  				Log.To.Router.I (TAG' "Inserting revision {0} from _bulk_docs"' rev);  				Log.To.Router.V (TAG' "With history {0}"' new LogJsonString (history));  				db.ForceInsert (rev' history' source);  			} catch (CouchbaseLiteException e) {  				status = e.Code;  			}  		}  	} else {  		status = DocumentMethods.UpdateDocument (context' db' docId' body' false' allOrNothing' out rev);  	}  	IDictionary<string' object> result = null;  	if ((int)status < 300) {  		Debug.Assert (rev != null && rev.RevID != null);  		if (newEdits) {  			result = new Dictionary<string' object> {  				{  					"id"'  					rev.DocID  				}'  				{  					"rev"'  					rev.RevID  				}'  				{  					"status"'  					(int)status  				}  			};  		}  	} else if ((int)status >= 500) {  		return false;  		// abort the whole thing if something goes badly wrong  	} else if (allOrNothing) {  		return false;  		// all_or_nothing backs out if there's any error  	} else {  		var info = Status.ToHttpStatus (status);  		result = new Dictionary<string' object> {  			{  				"id"'  				docId  			}'  			{  				"error"'  				info.Item2  			}'  			{  				"status"'  				info.Item1  			}  		};  	}  	if (result != null) {  		results.Add (result);  	}  }  
Magic Number,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,ProcessDocumentChangeOperations,The following statement contains a magic number: if ((int)status < 300) {  	Debug.Assert (rev != null && rev.RevID != null);  	if (newEdits) {  		result = new Dictionary<string' object> {  			{  				"id"'  				rev.DocID  			}'  			{  				"rev"'  				rev.RevID  			}'  			{  				"status"'  				(int)status  			}  		};  	}  } else if ((int)status >= 500) {  	return false;  	// abort the whole thing if something goes badly wrong  } else if (allOrNothing) {  	return false;  	// all_or_nothing backs out if there's any error  } else {  	var info = Status.ToHttpStatus (status);  	result = new Dictionary<string' object> {  		{  			"id"'  			docId  		}'  		{  			"error"'  			info.Item2  		}'  		{  			"status"'  			info.Item1  		}  	};  }  
Magic Number,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,ProcessDocumentChangeOperations,The following statement contains a magic number: if ((int)status < 300) {  	Debug.Assert (rev != null && rev.RevID != null);  	if (newEdits) {  		result = new Dictionary<string' object> {  			{  				"id"'  				rev.DocID  			}'  			{  				"rev"'  				rev.RevID  			}'  			{  				"status"'  				(int)status  			}  		};  	}  } else if ((int)status >= 500) {  	return false;  	// abort the whole thing if something goes badly wrong  } else if (allOrNothing) {  	return false;  	// all_or_nothing backs out if there's any error  } else {  	var info = Status.ToHttpStatus (status);  	result = new Dictionary<string' object> {  		{  			"id"'  			docId  		}'  		{  			"error"'  			info.Item2  		}'  		{  			"status"'  			info.Item1  		}  	};  }  
Magic Number,Couchbase.Lite.Listener,DatabaseMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DatabaseMethods.cs,ProcessDocumentChangeOperations,The following statement contains a magic number: if ((int)status >= 500) {  	return false;  	// abort the whole thing if something goes badly wrong  } else if (allOrNothing) {  	return false;  	// all_or_nothing backs out if there's any error  } else {  	var info = Status.ToHttpStatus (status);  	result = new Dictionary<string' object> {  		{  			"id"'  			docId  		}'  		{  			"error"'  			info.Item2  		}'  		{  			"status"'  			info.Item1  		}  	};  }  
Magic Number,Couchbase.Lite.Listener,DocumentMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\DocumentMethods.cs,UpdateDb,The following statement contains a magic number: if ((int)status < 300) {  	context.CacheWithEtag (rev.RevID.ToString ());  	// set ETag  	if (!deleting) {  		var url = context.RequestUrl;  		if (docId != null) {  			response ["Location"] = url.AbsoluteUri;  		}  	}  	response.JsonBody = new Body (new Dictionary<string' object> {  		{  			"ok"'  			true  		}'  		{  			"id"'  			rev.DocID  		}'  		{  			"rev"'  			rev.RevID  		}  	});  }  
Magic Number,Couchbase.Lite.Listener,ServerMethods,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\ServerMethods.cs,GetUUIDs,The following statement contains a magic number: if (count > 1000) {  	return context.CreateResponse (StatusCode.Forbidden).AsDefaultState ();  }  
Magic Number,Couchbase.Lite.Listener,CouchbaseListenerContext,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseListenerContext.cs,IfMatch,The following statement contains a magic number: if (ifMatch.Length > 2 && ifMatch.StartsWith ("\"") && ifMatch.EndsWith ("\"")) {  	return ifMatch.Trim ('"');  }  
Magic Number,Couchbase.Lite.Listener,CouchbaseListenerContext,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseListenerContext.cs,UrlComponentAt,The following statement contains a magic number: if (_urlComponents == null) {  	var tmp = RequestUrl.AbsolutePath.Split ('?') [0];  	_urlComponents = tmp.Split (new[] {  		'/'  	}' StringSplitOptions.RemoveEmptyEntries);  	if (_urlComponents.Length >= 3) {  		var secondComponent = _urlComponents [1];  		if (secondComponent.Equals ("_local") || secondComponent.Equals ("_design")) {  			_viewPrefix = secondComponent + "/";  		}  	}  }  
Magic Number,Couchbase.Lite.Listener,CouchbaseListenerContext,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseListenerContext.cs,UrlComponentAt,The following statement contains a magic number: if (_urlComponents.Length >= 3) {  	var secondComponent = _urlComponents [1];  	if (secondComponent.Equals ("_local") || secondComponent.Equals ("_design")) {  		_viewPrefix = secondComponent + "/";  	}  }  
Magic Number,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,ProcessRequestRanges,The following statement contains a magic number: if (_responseWriter.StatusCode != 200 || (_requestMethod != "GET" && _requestMethod != "HEAD") || _binaryBody == null) {  	return;  }  
Magic Number,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,ProcessRequestRanges,The following statement contains a magic number: if (end >= bodyLength || end < start) {  	Status = 416;  	// Requested Range Not Satisfiable  	var contentRangeStr = String.Format ("bytes */{0}"' bodyLength);  	Headers ["Content-Range"] = contentRangeStr;  	_binaryBody = null;  	return;  }  
Magic Number,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,ProcessRequestRanges,The following statement contains a magic number: Status = 416;  
Magic Number,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,ProcessRequestRanges,The following statement contains a magic number: Status = 206;  
Magic Number,Couchbase.Lite.Listener,CouchbaseLiteResponse,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\CouchbaseLiteResponse.cs,WriteHeaders,The following statement contains a magic number: if (this.Status == 200 && _requestMethod.Equals ("GET") || _requestMethod.Equals ("HEAD")) {  	if (!Headers.ContainsKey ("Cache-Control")) {  		this ["Cache-Control"] = "must-revalidate";  	}  }  
Magic Number,Couchbase.Lite.Security,X509Manager,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\X509\X509Manager.cs,GetExistingPersistentCertificate,The following statement contains a magic number: if (File.Exists (filePath)) {  	var retVal = new X509Certificate2 (filePath' password);  	var cn = "CN=" + certificateName;  	if (retVal.Subject != cn) {  		Log.To.Listener.E (Tag' "Certificate name doesn't match for {0}' " + "expecting {1} but found {2}' throwing..."' filePath' certificateName' retVal.Subject.Substring (3));  		throw new InvalidDataException (String.Format ("Certificate name doesn't match for {0}' " + "expecting {1} but found {2}"' filePath' certificateName' retVal.Subject.Substring (3)));  	}  	return retVal;  }  
Magic Number,Couchbase.Lite.Security,X509Manager,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\X509\X509Manager.cs,GetExistingPersistentCertificate,The following statement contains a magic number: if (File.Exists (filePath)) {  	var retVal = new X509Certificate2 (filePath' password);  	var cn = "CN=" + certificateName;  	if (retVal.Subject != cn) {  		Log.To.Listener.E (Tag' "Certificate name doesn't match for {0}' " + "expecting {1} but found {2}' throwing..."' filePath' certificateName' retVal.Subject.Substring (3));  		throw new InvalidDataException (String.Format ("Certificate name doesn't match for {0}' " + "expecting {1} but found {2}"' filePath' certificateName' retVal.Subject.Substring (3)));  	}  	return retVal;  }  
Magic Number,Couchbase.Lite.Security,X509Manager,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\X509\X509Manager.cs,GetExistingPersistentCertificate,The following statement contains a magic number: if (retVal.Subject != cn) {  	Log.To.Listener.E (Tag' "Certificate name doesn't match for {0}' " + "expecting {1} but found {2}' throwing..."' filePath' certificateName' retVal.Subject.Substring (3));  	throw new InvalidDataException (String.Format ("Certificate name doesn't match for {0}' " + "expecting {1} but found {2}"' filePath' certificateName' retVal.Subject.Substring (3)));  }  
Magic Number,Couchbase.Lite.Security,X509Manager,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\X509\X509Manager.cs,GetExistingPersistentCertificate,The following statement contains a magic number: if (retVal.Subject != cn) {  	Log.To.Listener.E (Tag' "Certificate name doesn't match for {0}' " + "expecting {1} but found {2}' throwing..."' filePath' certificateName' retVal.Subject.Substring (3));  	throw new InvalidDataException (String.Format ("Certificate name doesn't match for {0}' " + "expecting {1} but found {2}"' filePath' certificateName' retVal.Subject.Substring (3)));  }  
Magic Number,Couchbase.Lite.Security,X509Manager,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\X509\X509Manager.cs,GetExistingPersistentCertificate,The following statement contains a magic number: Log.To.Listener.E (Tag' "Certificate name doesn't match for {0}' " + "expecting {1} but found {2}' throwing..."' filePath' certificateName' retVal.Subject.Substring (3));  
Magic Number,Couchbase.Lite.Security,X509Manager,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\X509\X509Manager.cs,GetExistingPersistentCertificate,The following statement contains a magic number: throw new InvalidDataException (String.Format ("Certificate name doesn't match for {0}' " + "expecting {1} but found {2}"' filePath' certificateName' retVal.Subject.Substring (3)));  
Magic Number,Couchbase.Lite.Security,X509Manager,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\X509\X509Manager.cs,CreateRawCert,The following statement contains a magic number: Log.To.Listener.I (Tag' "Finished generating X509 certificate; took {0} sec"' sw.ElapsedMilliseconds / 1000.0);  
Magic Number,Couchbase.Lite.Security,X509Manager,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\X509\X509Manager.cs,GetAttributes,The following statement contains a magic number: list.Add (new byte[4] {  	1'  	0'  	0'  	0  });  
Missing Default,Mono.Security,ASN1Convert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\ASN1Convert.cs,ToDateTime,The following switch statement is missing a default case: switch (t.Length) {  case 11:  	// illegal format' still it's supported for compatibility  	mask = "yyMMddHHmmZ";  	break;  case 13:  	// RFC3280: 4.1.2.5.1  UTCTime  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	// Where YY is greater than or equal to 50' the   	// year SHALL be interpreted as 19YY; and   	// Where YY is less than 50' the year SHALL be   	// interpreted as 20YY.  	if (year >= 50)  		t = "19" + t;  	else  		t = "20" + t;  	mask = "yyyyMMddHHmmssZ";  	break;  case 15:  	mask = "yyyyMMddHHmmssZ";  	// GeneralizedTime  	break;  case 17:  	// another illegal format (990630000000+1000)' again supported for compatibility  	year = Convert.ToInt16 (t.Substring (0' 2)' CultureInfo.InvariantCulture);  	string century = (year >= 50) ? "19" : "20";  	// ASN.1 (see ITU X.680 section 43.3) deals with offset differently than .NET  	char sign = (t [12] == '+') ? '-' : '+';  	t = String.Format ("{0}{1}{2}{3}{4}:{5}{6}"' century' t.Substring (0' 12)' sign' t [13]' t [14]' t [15]' t [16]);  	mask = "yyyyMMddHHmmsszzz";  	break;  }  
Missing Default,Mono.Math,BigInteger,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\BigInteger.cs,BigInteger,The following switch statement is missing a default case: switch (leftOver) {  case 1:  	data [length - 1] = (uint)inData [0];  	break;  case 2:  	data [length - 1] = (uint)((inData [0] << 8) | inData [1]);  	break;  case 3:  	data [length - 1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]);  	break;  }  
Missing Default,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiKeyBlob,The following switch statement is missing a default case: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
Missing Default,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\CryptoConvert.cs,FromCapiKeyBlobDSA,The following switch statement is missing a default case: switch (blob [offset]) {  case 0x06:  	return FromCapiPublicKeyBlobDSA (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlobDSA (blob' offset);  }  
Missing Default,Mono.Security.Cryptography,PKCS8,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\Mono.Security.X509\PKCS8.cs,GetType,The following switch statement is missing a default case: switch (firstLevel.Tag) {  case 0x02:  	ki = KeyInfo.PrivateKey;  	break;  case 0x30:  	ki = KeyInfo.EncryptedPrivateKey;  	break;  }  
Missing Default,Couchbase.Lite.Listener.Tcp,CouchbaseLiteTcpListener,F:\newReposMay17\couchbase_couchbase-lite-net\src\ListenerComponent\Couchbase.Lite.Listener.Shared\PeerToPeer\TCP\CouchbaseLiteTcpListener.cs,CouchbaseLiteTcpListener,The following switch statement is missing a default case: switch (data.Level) {  case WebSocketSharp.LogLevel.Fatal:  	Log.To.Listener.E ("HttpServer"' data.Message);  	break;  case WebSocketSharp.LogLevel.Error:  case WebSocketSharp.LogLevel.Warn:  	Log.To.Listener.W ("HttpServer"' data.Message);  	break;  case WebSocketSharp.LogLevel.Info:  	Log.To.Listener.I ("HttpServer"' data.Message);  	break;  case WebSocketSharp.LogLevel.Trace:  case WebSocketSharp.LogLevel.Debug:  	Log.To.Listener.V ("HttpServer"' data.Message);  	break;  }  
