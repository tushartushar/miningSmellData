Implementation smell,Namespace,Class,File,Method,Description
Long Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The method has 146 lines of code.
Long Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The method has 183 lines of code.
Long Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ForceInsert,The method has 173 lines of code.
Long Method,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunQuery,The method has 110 lines of code.
Long Method,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The method has 276 lines of code.
Long Method,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The method has 144 lines of code.
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,RunStatements,Cyclomatic complexity of the method is 8
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,Cyclomatic complexity of the method is 14
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,Cyclomatic complexity of the method is 8
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,Cyclomatic complexity of the method is 25
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,Cyclomatic complexity of the method is 12
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutLocalRevision,Cyclomatic complexity of the method is 11
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunQuery,Cyclomatic complexity of the method is 13
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,Cyclomatic complexity of the method is 8
Complex Method,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ValueTypeOf,Cyclomatic complexity of the method is 22
Complex Method,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,Cyclomatic complexity of the method is 31
Complex Method,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,Cyclomatic complexity of the method is 19
Complex Method,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,CompareStringsAscii,Cyclomatic complexity of the method is 10
Complex Method,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,Cyclomatic complexity of the method is 50
Long Parameter List,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocumentProperties,The method has 5 parameters.
Long Parameter List,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetRevision,The method has 5 parameters.
Long Parameter List,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,RevisionWithDocID,The method has 5 parameters.
Long Parameter List,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,InsertRevision,The method has 7 parameters.
Long Parameter List,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The method has 7 parameters.
Long Parameter List,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,CompareStringsAscii,The method has 6 parameters.
Long Parameter List,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,CompareStringsUnicode,The method has 6 parameters.
Long Parameter List,SQLitePCL,authorizer_hook_info,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\util.cs,call,The method has 5 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_exec,The method has 5 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_table_column_metadata,The method has 9 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_db_status,The method has 5 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_blob_open,The method has 7 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_blob_read,The method has 5 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_blob_write,The method has 5 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The method has 5 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The method has 6 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,collation_hook_bridge_impl,The method has 5 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,update_hook_bridge_impl,The method has 5 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,authorizer_hook_bridge_impl,The method has 6 parameters.
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_wal_checkpoint_v2,The method has 5 parameters.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,RunStatements,The length of the statement  "				Log.To.Database.E (TAG' "Error running statement '{0}'' rethrowing"' new SecureLogString (statement' LogMessageSensitivity.PotentiallyInsecure)); " is 145.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,RunStatements,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error running statement '{0}'"' new SecureLogString (statement' LogMessageSensitivity.PotentiallyInsecure)); " is 168.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocumentProperties,The length of the statement  "			Log.To.Database.W (TAG' "Unparseable JSON for doc={0}' rev={1}: {2}' returning skeleton set"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId' new SecureLogString (realizedJson' LogMessageSensitivity.PotentiallyInsecure)); " is 252.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PruneDocument,The length of the statement  "	const string sql = "DELETE FROM revs WHERE doc_id=? AND revid < ? AND current=0 AND" + "sequence NOT IN (SELECT parent FROM revs WHERE doc_id=? AND current=1)"; " is 160.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PruneDocument,The length of the statement  "		Log.To.Database.W (TAG' "SQLite error {0} pruning generations < {1} of doc {2}"' StorageEngine.LastErrorCode' minGenToKeep' docNumericID); " is 138.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Unable to create a SQLite storage engine"); " is 120.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The length of the statement  "			throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion); " is 160.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The length of the statement  "			throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion); " is 151.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The length of the statement  "			const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102"; " is 218.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,SequenceHasAttachments,The length of the statement  "	return QueryOrDefault<bool> (c => c.GetInt (0) != 0' false' "SELECT no_attachments=0 FROM revs WHERE sequence=?"' sequence); " is 124.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetSequenceOfDocument,The length of the statement  "	var sql = String.Format ("SELECT sequence FROM revs WHERE doc_id=? AND revid=? {0} LIMIT 1"' (onlyCurrent ? "AND current=1" : "")); " is 131.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,LosingSequences,The length of the statement  "	var sql = "SELECT sequence' revs.doc_id' docid' revid' deleted FROM revs' docs " + "WHERE sequence > ? AND current=1 " + "AND revs.doc_id = docs.doc_id " + "ORDER BY revs.doc_id' deleted' revid DESC"; " is 200.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetWinner,The length of the statement  "	}' "SELECT revid' deleted FROM revs WHERE doc_id=? and current=1 ORDER BY deleted asc' revid desc LIMIT ?"' docNumericId' (!outConflict.IsNull ? 2 : 1)); " is 153.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,SetInfo,The length of the statement  "		Log.To.Database.E (TAG' "Failed to set info ({0} -> {1})' rethrowing..."' new SecureLogString (key' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (info' LogMessageSensitivity.PotentiallyInsecure)); " is 215.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,SetInfo,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error setting info ({0} -> {1})"' new SecureLogString (key' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (info' LogMessageSensitivity.PotentiallyInsecure)); " is 235.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,LoadRevisionBody,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.NotFound' TAG' "Cannot load body of {0} because it doesn't exist"' rev); " is 134.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetRevisionSequence,The length of the statement  "	return QueryOrDefault<long> (c => c.GetLong (0)' 0L' "SELECT sequence FROM revs WHERE doc_id=? AND revid=? LIMIT 1"' docNumericId' rev.RevID.ToString ()); " is 154.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,NextDocumentExpiry,The length of the statement  "	var result = QueryOrDefault<long?> (c => c.GetLong (0)' null' "SELECT expiry_timestamp FROM " + "docs WHERE expiry_timestamp IS NOT NULL ORDER BY expiry_timestamp ASC LIMIT 1"); " is 177.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocumentExpiration,The length of the statement  "	var result = QueryOrDefault<long?> (c => c.GetLong (0)' null' "SELECT expiry_timestamp FROM docs WHERE doc_id=? AND expiry_timestamp IS NOT NULL"' docNumericId); " is 161.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,SetDocumentExpiration,The length of the statement  "		var msg = String.Format ("Unable to find document {0} in SetRevisionExpiration"' new SecureLogString (documentId' LogMessageSensitivity.PotentiallyInsecure)); " is 158.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetParentRevision,The length of the statement  "		seq = QueryOrDefault<long> (c => c.GetLong (0)' 0L' "SELECT parent FROM revs WHERE doc_id=? and revid=?"' docNumericId' rev.RevID.ToString ()); " is 143.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetPossibleAncestors,The length of the statement  "	const string sql = "SELECT revid' json is not null FROM revs " + "WHERE doc_id=? AND current=? AND revid < ? " + "ORDER BY revid DESC LIMIT ?"; " is 143.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,FindCommonAncestor,The length of the statement  "	var sql = String.Format ("SELECT revid FROM revs " + "WHERE doc_id=? and revid in ({0}) and revid <= ? " + "ORDER BY revid DESC LIMIT 1"' Utility.JoinQuoted (revIds.Select (x => x.ToString ()))); " is 195.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,FindMissingRevisions,The length of the statement  "	var sql = String.Format ("SELECT docid' revid FROM revs' docs " + "WHERE revid in ({0}) AND docid IN ({1}) " + "AND revs.doc_id == docs.doc_id"' Utility.JoinQuoted (revs.GetAllRevIds ().Select (x => x.ToString ()))' Utility.JoinQuoted (revs.GetAllDocIds ())); " is 259.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The length of the statement  "		sql.AppendFormat (" revs.doc_id IN (SELECT doc_id FROM docs WHERE docid IN ({0})) AND"' JoinQuotedObjects (options.Keys)); " is 122.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The length of the statement  "	sql.AppendFormat (" ORDER BY docid {0}' {1} revid DESC LIMIT ? OFFSET ?"' (options.Descending ? "DESC" : "ASC")' (includeDeletedDocs ? "deleted ASC'" : string.Empty)); " is 167.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The length of the statement  "	var sql = String.Format ("SELECT sequence' revs.doc_id' docid' revid' deleted {0} FROM revs " + "JOIN docs ON docs.doc_id = revs.doc_id " + "WHERE sequence > ? AND +current=1 " + "ORDER BY +revs.doc_id' +deleted' revid DESC"' (includeDocs ? @"' json" : @"")); " is 259.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The length of the statement  "	var orderby = options.SortBySequence ? options.Descending ? "sequence DESC" : "sequence" : "+revs.doc_id' +deleted' revid DESC"; " is 128.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The length of the statement  "	var sql = String.Format ("SELECT sequence' revs.doc_id' docid' revid' deleted {0} FROM revs " + "JOIN docs ON docs.doc_id = revs.doc_id " + "WHERE sequence > ? AND +current=1 " + "ORDER BY {1} "' (includeDocs ? @"' json" : @"")' orderby); " is 238.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Unable to create sequence number for document"); " is 125.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.NotFound' TAG' "Previous revision specified for a new document"); " is 127.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "					throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.Conflict' TAG' "Conflict attempted in PutRevision without allowConflict == true"); " is 144.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.NotFound' TAG' "Unable to find previous revision (ID={0} REV={1})"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' prevRevId); " is 213.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' status' TAG' "Delete operation attempted without specifying revision ID for {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 205.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "					throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Couldn't write new document {0} to database"' docId); " is 130.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "			throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadId' TAG' "Invalid rev ID {0} for document {1}"' prevRevId' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 196.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' LastDbError.Code' TAG' "Failed to insert revision {0} ({1})"' newRev' lastCode); " is 131.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "			Log.To.Database.I (TAG' "Duplicate rev insertion {0} / {1}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' newRevId); " is 143.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "				Log.To.Database.E (TAG' "Failed to update document {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 144.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error updating document {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 162.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The length of the statement  "				Log.To.Database.V (TAG' "Pruned {0} old revisions of doc '{1}'"' pruned' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 145.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ForceInsert,The length of the statement  "			throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Error inserting document {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 180.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ForceInsert,The length of the statement  "					Log.To.Database.E (TAG' "Failed to look up winner for {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 147.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ForceInsert,The length of the statement  "					throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error looking up winner for {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 166.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ForceInsert,The length of the statement  "					Log.To.Database.E (TAG' "Error getting document revisions for {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 155.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ForceInsert,The length of the statement  "				Log.To.Database.E (TAG' "Failed to update {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 135.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ForceInsert,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error updating {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 153.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ForceInsert,The length of the statement  "					Log.To.Database.V (TAG' "Pruned {0} old revisions of '{1}'"' pruned' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 141.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadParam' TAG' "Illegal null revIds for {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 180.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The length of the statement  "					Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 148.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The length of the statement  "					throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 166.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The length of the statement  "				Log.To.Database.I (TAG' "Purging doc '{0}' revs ({1}); asked for ({2})"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' new LogJsonString (revsToPurge.ToStringArray ())' new LogJsonString (revIDs)); " is 223.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The length of the statement  "						Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 148.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The length of the statement  "						throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 166.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutLocalRevision,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadId' TAG' "Local revision doesn't start with '_local/'"); " is 121.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,OpenSqliteConnection,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Failed to open SQLite storage engine at path {0} ({1})"' Path' LastErrorCode); " is 155.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,OpenSqliteConnection,The length of the statement  "	Log.To.Database.I (TAG' "Open {0} (flags={1}{2})"' Path' flags' (_encryptionKey != null ? "' encryption key given" : "")); " is 122.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,SetVersion,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.Forbidden' TAG' "Attempting to write to a readonly database"); " is 124.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,SetVersion,The length of the statement  "			throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Unable to set version to {0} ({1})"' version' LastErrorCode); " is 138.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,SetVersion,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Unable to set version to {0} ({1})"' version' LastErrorCode); " is 138.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,BeginTransaction,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.Forbidden' TAG' "Transactions not allowed on a readonly database"); " is 129.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,BeginTransaction,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadRequest' TAG' "BeginTransaction called on closed database"); " is 125.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,EndTransaction,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.Forbidden' TAG' "Transactions not allowed on a readonly database"); " is 129.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,EndTransaction,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadRequest' TAG' "EndTransaction called on closed database"); " is 123.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,RawQuery,The length of the statement  "		Log.To.Database.V (TAG' "RawQuery sql ({2}): {0} ({1})"' sql' String.Join ("' "' paramArgs.ToStringArray ())' IsOnDBThread ? "read uncommit" : "read commit"); " is 158.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,RawQuery,The length of the statement  "		Log.To.Database.E (TAG' String.Format ("Error executing raw query '{0}' with values '{1}'' rethrowing..."' sql' paramArgs == null ? (object)String.Empty : new SecureLogJsonString (args' LogMessageSensitivity.PotentiallyInsecure))' e); " is 234.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,InsertWithOnConflict,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.Forbidden' TAG' "Attempting to write to a readonly database"); " is 124.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,InsertWithOnConflict,The length of the statement  "					throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Error inserting {0} using {1}"' initialValues' command); " is 133.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,InsertWithOnConflict,The length of the statement  "			throw Misc.CreateExceptionAndLog (Log.To.Database' ex' StatusCode.DbError' TAG' "Error inserting into table {0}"' table); " is 121.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Update,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.Forbidden' TAG' "Attempting to write to a readonly database"); " is 124.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Update,The length of the statement  "			throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Error updating {0} with command '{1}'"' values' command); " is 134.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Delete,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.Forbidden' TAG' "Attempting to write to a readonly database"); " is 124.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Delete,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Error deleting from table {0} ({1})"' table' result); " is 130.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Delete,The length of the statement  "			Log.To.Database.E (TAG' String.Format ("Error {0} when deleting from table {1}' rethrowing..."' _writeConnection.extended_errcode ()' table)' ex); " is 146.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,BuildCommand,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadRequest' TAG' "BuildCommand called on closed database"); " is 121.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,BuildCommand,The length of the statement  "		Log.To.Database.E (TAG' "Error when building sql '{0}' with params {1}' rethrowing..."' sql' new SecureLogJsonString (paramArgs' LogMessageSensitivity.PotentiallyInsecure)); " is 173.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,BuildCommand,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error when building sql '{0}' with params {1}"' sql' new SecureLogJsonString (paramArgs' LogMessageSensitivity.PotentiallyInsecure)); " is 193.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,GetUpdateCommand,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadRequest' TAG' "GetUpdateCommand called on closed database"); " is 125.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,GetInsertCommand,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadRequest' TAG' "GetInsertCommand called on closed database"); " is 125.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,GetInsertCommand,The length of the statement  "		Log.To.Database.V (TAG' "Preparing statement: '{0}' with values: {1}"' sql' new SecureLogJsonString (args' LogMessageSensitivity.PotentiallyInsecure)); " is 151.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,GetDeleteCommand,The length of the statement  "		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadRequest' TAG' "GetDeleteCommand called on closed database"); " is 125.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,ExecSQL,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "SQLite error in ExecSQL: {0}"' raw.sqlite3_errmsg (db)); " is 133.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,ExecSQL,The length of the statement  "			Log.To.Database.E (TAG' String.Format ("Error {0}' {1} ({2}) executing sql '{3}'"' e.errcode' db.extended_errcode ()' raw.sqlite3_errmsg (db)' sql)' e); " is 152.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,ExecSQL,The length of the statement  "			throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Error {0}' {1} ({2}) executing sql '{3}'"' e.errcode' db.extended_errcode ()' raw.sqlite3_errmsg (db)' sql); " is 185.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunStatements,The length of the statement  "			Log.To.Database.E (Tag' "Failed to run statments ({0})' rethrowing..."' new SecureLogString (sqlStatements' LogMessageSensitivity.PotentiallyInsecure)); " is 152.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunStatements,The length of the statement  "			throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Exception running sql statements ({0})' "' new SecureLogString (sqlStatements' LogMessageSensitivity.PotentiallyInsecure)); " is 179.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,CreateIndex,The length of the statement  "	const string sql = "CREATE TABLE IF NOT EXISTS 'maps_#' (" + "sequence INTEGER NOT NULL REFERENCES revs(sequence) ON DELETE CASCADE'" + "key TEXT NOT NULL COLLATE JSON'" + "value TEXT'" + "fulltext_id INTEGER' " + "bbox_id INTEGER' " + "geokey BLOB)"; " is 251.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,Emit,The length of the statement  "		Log.To.Query.V (Tag' "    emit({0}' {1}"' new SecureLogString (keyJSON' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (valueJSON' LogMessageSensitivity.PotentiallyInsecure)); " is 192.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,Emit,The length of the statement  "		_emitSql = QueryString ("INSERT INTO 'maps_#' (sequence' key' value' " + "fulltext_id' bbox_id' geokey) VALUES (?' ?' ?' ?' ?' ?)"); " is 132.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,FinishCreatingIndex,The length of the statement  "	const string sql = "CREATE INDEX IF NOT EXISTS 'maps_#_keys' on 'maps_#'(key COLLATE JSON);" + "CREATE INDEX IF NOT EXISTS 'maps_#_sequence' ON 'maps_#'(sequence)"; " is 164.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,CreateRTreeSchema,The length of the statement  "	const string sql = "CREATE VIRTUAL TABLE IF NOT EXISTS bboxes USING rtree(rowid' x0' x1' y0' y1);" + "CREATE TRIGGER IF NOT EXISTS 'del_maps_#_bbox' " + "DELETE ON 'maps_#' WHEN old.bbox_id not null BEGIN " + "DELETE FROM bboxes WHERE rowid=old.bbox_id| END"; " is 259.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,GroupTogether,The length of the statement  "	return JsonCollator.Compare (JsonCollationMode.Unicode' Encoding.UTF8.GetString (key1)' Encoding.UTF8.GetString (key2)' groupLevel) == 0; " is 137.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,CallReduce,The length of the statement  "		Log.To.Query.E (Tag' String.Format ("Failed to reduce query (keys={0} vals={1})' returning null..."' new SecureLogJsonString (keysToReduce' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogJsonString (valuesToReduce' LogMessageSensitivity.PotentiallyInsecure))' e); " is 273.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,ToJSONString,The length of the statement  "		Log.To.View.W (Tag' String.Format ("Exception serializing object to json: {0}' returning null..."' new SecureLogJsonString (obj' LogMessageSensitivity.PotentiallyInsecure))' e); " is 177.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,FromJSON,The length of the statement  "		Log.To.View.W (Tag' String.Format ("Exception parsing json ({0})' returning null..."' new SecureLogString (json.ToArray ()' LogMessageSensitivity.PotentiallyInsecure))' e); " is 172.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunQuery,The length of the statement  "            }*/sql.AppendFormat (" AND revs.sequence = 'maps_{0}'.sequence AND docs.doc_id = revs.doc_id " + "ORDER BY"' MapTableName); " is 123.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunQuery,The length of the statement  "	Log.To.Query.I (Tag' "Query {0}: {1}\n\tArguments: {2}"' Name' sql' new SecureLogJsonString (args' LogMessageSensitivity.PotentiallyInsecure)); " is 143.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The length of the statement  "				throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Invalid last sequence indexed ({0}) received from {1}"' last' view); " is 141.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The length of the statement  "						changes = db.StorageEngine.ExecSQL (view.QueryString ("DELETE FROM 'maps_#' WHERE sequence IN (" + "SELECT parent FROM revs WHERE sequence>?" + "AND +parent>0 AND +parent<=?)")' last' last); " is 190.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The length of the statement  "					throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Error deleting obsolete map results before index update"); " is 131.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The length of the statement  "		Log.To.View.I (Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."' ViewNames (views)' minLastSequence' dbMaxSequence); " is 122.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The length of the statement  "					using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) { " is 192.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The length of the statement  "					Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId); " is 155.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The length of the statement  "							Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x); " is 120.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The length of the statement  "		Log.To.View.I (Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"' ViewNames (views)' dbMaxSequence' deletedCount' insertedCount); " is 149.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The length of the statement  "		Log.To.Query.V (Tag' "Query {0}: Found row with key={1}' value={2}' id={3}"' Name' new SecureLogString (keyData.Value' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (valueData.Value' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)); " is 317.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,ReducedQuery,The length of the statement  "			Log.To.Query.W (Tag' "Cannot use reduce option in view {0} which has no reduce block defined' " + "returning null"' Name); " is 122.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,ReducedQuery,The length of the statement  "		Log.To.Query.V (Tag' "Query {0}: Will reduce row with key={1}' value={2}"' Name' new SecureLogString (keyData.Value' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (valueData.Value' LogMessageSensitivity.PotentiallyInsecure)); " is 243.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,ReducedQuery,The length of the statement  "		Log.To.Query.V (Tag' "Query {0}: Reduced to key={1}' value={2}"' Name' new SecureLogJsonString (key' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogJsonString (reduced' LogMessageSensitivity.PotentiallyInsecure)); " is 223.
Long Statement,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The length of the statement  "			int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3])); " is 159.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_table_column_metadata,The length of the statement  "	int rc = NativeMethods.sqlite3_table_column_metadata (db' util.to_utf8 (dbName)' util.to_utf8 (tblName)' util.to_utf8 (colName)' out datatype_ptr' out collseq_ptr' out notNull' out primaryKey' out autoInc); " is 206.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_blob_open,The length of the statement  "	return NativeMethods.sqlite3_blob_open (db' util.to_utf8 (sdb)' util.to_utf8 (table)' util.to_utf8 (col)' rowid' flags' out blob); " is 130.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The length of the statement  "		int rc = NativeMethods.sqlite3_create_function_v2 (db' util.to_utf8 (name)' nargs' 1' hi.ptr' scalar_function_hook_bridge' null' null' null); " is 141.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The length of the statement  "		return NativeMethods.sqlite3_create_function_v2 (db' util.to_utf8 (name)' nargs' 1' IntPtr.Zero' null' null' null' null); " is 121.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The length of the statement  "		int rc = NativeMethods.sqlite3_create_function_v2 (db' util.to_utf8 (name)' nargs' 1' hi.ptr' null' agg_function_hook_bridge_step' agg_function_hook_bridge_final' null); " is 169.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The length of the statement  "		return NativeMethods.sqlite3_create_function_v2 (db' util.to_utf8 (name)' nargs' 1' IntPtr.Zero' null' null' null' null); " is 121.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\storage.customsqlite.net45\..\SQLite3Provider_cbsqlite.cs,authorizer_hook_bridge_impl,The length of the statement  "	return hi.call (action_code' util.from_utf8 (param0)' util.from_utf8 (param1)' util.from_utf8 (dbName)' util.from_utf8 (inner_most_trigger_or_view)); " is 149.
Complex Conditional,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetLocalDocument,The conditional expression  "json == null || !json.Any () || (json.Length == 2 && json [0] == (byte)'{' && json [1] == '}')"  is complex.
Complex Conditional,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,BuildCommand,The conditional expression  "paramArgs != null && paramArgs.Length > 0 && command != null && LastErrorCode != raw.SQLITE_ERROR"  is complex.
Complex Conditional,Couchbase.Lite,RevIdCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\RevIdCollator.cs,Compare,The conditional expression  "(dash1 == 1 && dash2 == 1) || dash1 > 8 || dash2 > 8 || dash1 == -1 || dash2 == -1"  is complex.
Magic Number,Couchbase.Lite.Storage.CustomSQLite,ContentValues,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\ContentValues.cs,ContentValues,The following statement contains a magic number: mValues = new Dictionary<string' object> (8);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,SqliteCouchStore,The following statement contains a magic number: Debug.Assert (_SqliteVersion >= 3007000' String.Format ("SQLite library is too old ({0}); needs to be at least 3.7"' raw.sqlite3_libversion ()));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,OptimizeSQLIndexes,The following statement contains a magic number: if (currentSequence > 0) {  	long lastOptimized = long.Parse (GetInfo ("last_optimized") ?? "0");  	if (lastOptimized <= currentSequence / 10) {  		RunInTransaction (() => {  			Log.To.Database.I (TAG' "Optimizing SQL indexes (curSeq={0}' last run at {1})"' currentSequence' lastOptimized);  			StorageEngine.ExecSQL ("ANALYZE");  			StorageEngine.ExecSQL ("ANALYZE sqlite_master");  			SetInfo ("last_optimized"' currentSequence.ToString ());  			return true;  		});  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,OptimizeSQLIndexes,The following statement contains a magic number: if (lastOptimized <= currentSequence / 10) {  	RunInTransaction (() => {  		Log.To.Database.I (TAG' "Optimizing SQL indexes (curSeq={0}' last run at {1})"' currentSequence' lastOptimized);  		StorageEngine.ExecSQL ("ANALYZE");  		StorageEngine.ExecSQL ("ANALYZE sqlite_master");  		SetInfo ("last_optimized"' currentSequence.ToString ());  		return true;  	});  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,RunStatements,The following statement contains a magic number: foreach (var quotedStatement in sqlStatements.Split (';')) {  	var statement = quotedStatement.Replace ('|'' ';');  	if (_SqliteVersion < 3008000) {  		// No partial index support before SQLite 3.8  		if (statement.Contains ("CREATE INDEX")) {  			var where = statement.IndexOf ("WHERE");  			if (where >= 0) {  				statement = statement.Substring (0' where);  			}  		}  	}  	if (!StringEx.IsNullOrWhiteSpace (statement)) {  		try {  			StorageEngine.ExecSQL (statement);  		} catch (CouchbaseLiteException) {  			Log.To.Database.E (TAG' "Error running statement '{0}'' rethrowing"' new SecureLogString (statement' LogMessageSensitivity.PotentiallyInsecure));  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error running statement '{0}'"' new SecureLogString (statement' LogMessageSensitivity.PotentiallyInsecure));  		}  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,RunStatements,The following statement contains a magic number: if (_SqliteVersion < 3008000) {  	// No partial index support before SQLite 3.8  	if (statement.Contains ("CREATE INDEX")) {  		var where = statement.IndexOf ("WHERE");  		if (where >= 0) {  			statement = statement.Substring (0' where);  		}  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocumentProperties,The following statement contains a magic number: if (realizedJson.Length == 0 || (realizedJson.Length == 2 && Encoding.UTF8.GetString (realizedJson) == "{}")) {  	docProperties = new Dictionary<string' object> ();  } else {  	try {  		docProperties = Manager.GetObjectMapper ().ReadValue<IDictionary<string' object>> (realizedJson);  	} catch (CouchbaseLiteException) {  		Log.To.Database.W (TAG' "Unparseable JSON for doc={0}' rev={1}: {2}' returning skeleton set"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId' new SecureLogString (realizedJson' LogMessageSensitivity.PotentiallyInsecure));  		docProperties = new Dictionary<string' object> ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: TryQuery (c => {  	var revId = c.GetString (0).AsRevID ();  	bool deleted = c.GetInt (1) != 0;  	result = new RevisionInternal (docId' revId' deleted);  	result.Sequence = sequence;  	result.SetBody (new Body (c.GetBlob (2)));  	return false;  }' "SELECT revid' deleted' json FROM revs WHERE sequence=?"' sequence);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: result.SetBody (new Body (c.GetBlob (2)));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {  	RunStatements ("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");  	// Check the user_version number we last stored in the sqliteDb:  	var dbVersion = StorageEngine.GetVersion ();  	bool isNew = dbVersion == 17;  	if (isNew) {  		RunStatements ("BEGIN TRANSACTION");  	}  	// Incompatible version changes increment the hundreds' place:  	if (dbVersion >= 200) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);  	}  	if (dbVersion < 17) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion);  	}  	if (dbVersion < 18) {  		const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  		RunStatements (upgradeSql);  		dbVersion = 18;  	}  	if (dbVersion < 101) {  		const string upgradeSql = "PRAGMA user_version = 101";  		RunStatements (upgradeSql);  		dbVersion = 101;  	}  	if (dbVersion < 102) {  		const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  		RunStatements (upgradeSql);  		dbVersion = 102;  	}  	if (isNew) {  		RunStatements ("END TRANSACTION");  		SetInfo ("pruned"' "true");  		// See Compact for explanation  	}  	if (!isNew && !_readOnly) {  		OptimizeSQLIndexes ();  	}  } catch (CouchbaseLiteException) {  	Log.To.Database.E (TAG' "Error initializing the SQLite storage engine' rethrowing...");  	StorageEngine.Close ();  	throw;  } catch (Exception e) {  	StorageEngine.Close ();  	throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error initializing SQLite storage engine");  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {  	RunStatements ("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");  	// Check the user_version number we last stored in the sqliteDb:  	var dbVersion = StorageEngine.GetVersion ();  	bool isNew = dbVersion == 17;  	if (isNew) {  		RunStatements ("BEGIN TRANSACTION");  	}  	// Incompatible version changes increment the hundreds' place:  	if (dbVersion >= 200) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);  	}  	if (dbVersion < 17) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion);  	}  	if (dbVersion < 18) {  		const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  		RunStatements (upgradeSql);  		dbVersion = 18;  	}  	if (dbVersion < 101) {  		const string upgradeSql = "PRAGMA user_version = 101";  		RunStatements (upgradeSql);  		dbVersion = 101;  	}  	if (dbVersion < 102) {  		const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  		RunStatements (upgradeSql);  		dbVersion = 102;  	}  	if (isNew) {  		RunStatements ("END TRANSACTION");  		SetInfo ("pruned"' "true");  		// See Compact for explanation  	}  	if (!isNew && !_readOnly) {  		OptimizeSQLIndexes ();  	}  } catch (CouchbaseLiteException) {  	Log.To.Database.E (TAG' "Error initializing the SQLite storage engine' rethrowing...");  	StorageEngine.Close ();  	throw;  } catch (Exception e) {  	StorageEngine.Close ();  	throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error initializing SQLite storage engine");  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {  	RunStatements ("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");  	// Check the user_version number we last stored in the sqliteDb:  	var dbVersion = StorageEngine.GetVersion ();  	bool isNew = dbVersion == 17;  	if (isNew) {  		RunStatements ("BEGIN TRANSACTION");  	}  	// Incompatible version changes increment the hundreds' place:  	if (dbVersion >= 200) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);  	}  	if (dbVersion < 17) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion);  	}  	if (dbVersion < 18) {  		const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  		RunStatements (upgradeSql);  		dbVersion = 18;  	}  	if (dbVersion < 101) {  		const string upgradeSql = "PRAGMA user_version = 101";  		RunStatements (upgradeSql);  		dbVersion = 101;  	}  	if (dbVersion < 102) {  		const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  		RunStatements (upgradeSql);  		dbVersion = 102;  	}  	if (isNew) {  		RunStatements ("END TRANSACTION");  		SetInfo ("pruned"' "true");  		// See Compact for explanation  	}  	if (!isNew && !_readOnly) {  		OptimizeSQLIndexes ();  	}  } catch (CouchbaseLiteException) {  	Log.To.Database.E (TAG' "Error initializing the SQLite storage engine' rethrowing...");  	StorageEngine.Close ();  	throw;  } catch (Exception e) {  	StorageEngine.Close ();  	throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error initializing SQLite storage engine");  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {  	RunStatements ("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");  	// Check the user_version number we last stored in the sqliteDb:  	var dbVersion = StorageEngine.GetVersion ();  	bool isNew = dbVersion == 17;  	if (isNew) {  		RunStatements ("BEGIN TRANSACTION");  	}  	// Incompatible version changes increment the hundreds' place:  	if (dbVersion >= 200) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);  	}  	if (dbVersion < 17) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion);  	}  	if (dbVersion < 18) {  		const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  		RunStatements (upgradeSql);  		dbVersion = 18;  	}  	if (dbVersion < 101) {  		const string upgradeSql = "PRAGMA user_version = 101";  		RunStatements (upgradeSql);  		dbVersion = 101;  	}  	if (dbVersion < 102) {  		const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  		RunStatements (upgradeSql);  		dbVersion = 102;  	}  	if (isNew) {  		RunStatements ("END TRANSACTION");  		SetInfo ("pruned"' "true");  		// See Compact for explanation  	}  	if (!isNew && !_readOnly) {  		OptimizeSQLIndexes ();  	}  } catch (CouchbaseLiteException) {  	Log.To.Database.E (TAG' "Error initializing the SQLite storage engine' rethrowing...");  	StorageEngine.Close ();  	throw;  } catch (Exception e) {  	StorageEngine.Close ();  	throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error initializing SQLite storage engine");  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {  	RunStatements ("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");  	// Check the user_version number we last stored in the sqliteDb:  	var dbVersion = StorageEngine.GetVersion ();  	bool isNew = dbVersion == 17;  	if (isNew) {  		RunStatements ("BEGIN TRANSACTION");  	}  	// Incompatible version changes increment the hundreds' place:  	if (dbVersion >= 200) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);  	}  	if (dbVersion < 17) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion);  	}  	if (dbVersion < 18) {  		const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  		RunStatements (upgradeSql);  		dbVersion = 18;  	}  	if (dbVersion < 101) {  		const string upgradeSql = "PRAGMA user_version = 101";  		RunStatements (upgradeSql);  		dbVersion = 101;  	}  	if (dbVersion < 102) {  		const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  		RunStatements (upgradeSql);  		dbVersion = 102;  	}  	if (isNew) {  		RunStatements ("END TRANSACTION");  		SetInfo ("pruned"' "true");  		// See Compact for explanation  	}  	if (!isNew && !_readOnly) {  		OptimizeSQLIndexes ();  	}  } catch (CouchbaseLiteException) {  	Log.To.Database.E (TAG' "Error initializing the SQLite storage engine' rethrowing...");  	StorageEngine.Close ();  	throw;  } catch (Exception e) {  	StorageEngine.Close ();  	throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error initializing SQLite storage engine");  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {  	RunStatements ("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");  	// Check the user_version number we last stored in the sqliteDb:  	var dbVersion = StorageEngine.GetVersion ();  	bool isNew = dbVersion == 17;  	if (isNew) {  		RunStatements ("BEGIN TRANSACTION");  	}  	// Incompatible version changes increment the hundreds' place:  	if (dbVersion >= 200) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);  	}  	if (dbVersion < 17) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion);  	}  	if (dbVersion < 18) {  		const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  		RunStatements (upgradeSql);  		dbVersion = 18;  	}  	if (dbVersion < 101) {  		const string upgradeSql = "PRAGMA user_version = 101";  		RunStatements (upgradeSql);  		dbVersion = 101;  	}  	if (dbVersion < 102) {  		const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  		RunStatements (upgradeSql);  		dbVersion = 102;  	}  	if (isNew) {  		RunStatements ("END TRANSACTION");  		SetInfo ("pruned"' "true");  		// See Compact for explanation  	}  	if (!isNew && !_readOnly) {  		OptimizeSQLIndexes ();  	}  } catch (CouchbaseLiteException) {  	Log.To.Database.E (TAG' "Error initializing the SQLite storage engine' rethrowing...");  	StorageEngine.Close ();  	throw;  } catch (Exception e) {  	StorageEngine.Close ();  	throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error initializing SQLite storage engine");  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {  	RunStatements ("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");  	// Check the user_version number we last stored in the sqliteDb:  	var dbVersion = StorageEngine.GetVersion ();  	bool isNew = dbVersion == 17;  	if (isNew) {  		RunStatements ("BEGIN TRANSACTION");  	}  	// Incompatible version changes increment the hundreds' place:  	if (dbVersion >= 200) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);  	}  	if (dbVersion < 17) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion);  	}  	if (dbVersion < 18) {  		const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  		RunStatements (upgradeSql);  		dbVersion = 18;  	}  	if (dbVersion < 101) {  		const string upgradeSql = "PRAGMA user_version = 101";  		RunStatements (upgradeSql);  		dbVersion = 101;  	}  	if (dbVersion < 102) {  		const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  		RunStatements (upgradeSql);  		dbVersion = 102;  	}  	if (isNew) {  		RunStatements ("END TRANSACTION");  		SetInfo ("pruned"' "true");  		// See Compact for explanation  	}  	if (!isNew && !_readOnly) {  		OptimizeSQLIndexes ();  	}  } catch (CouchbaseLiteException) {  	Log.To.Database.E (TAG' "Error initializing the SQLite storage engine' rethrowing...");  	StorageEngine.Close ();  	throw;  } catch (Exception e) {  	StorageEngine.Close ();  	throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error initializing SQLite storage engine");  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {  	RunStatements ("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");  	// Check the user_version number we last stored in the sqliteDb:  	var dbVersion = StorageEngine.GetVersion ();  	bool isNew = dbVersion == 17;  	if (isNew) {  		RunStatements ("BEGIN TRANSACTION");  	}  	// Incompatible version changes increment the hundreds' place:  	if (dbVersion >= 200) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);  	}  	if (dbVersion < 17) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion);  	}  	if (dbVersion < 18) {  		const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  		RunStatements (upgradeSql);  		dbVersion = 18;  	}  	if (dbVersion < 101) {  		const string upgradeSql = "PRAGMA user_version = 101";  		RunStatements (upgradeSql);  		dbVersion = 101;  	}  	if (dbVersion < 102) {  		const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  		RunStatements (upgradeSql);  		dbVersion = 102;  	}  	if (isNew) {  		RunStatements ("END TRANSACTION");  		SetInfo ("pruned"' "true");  		// See Compact for explanation  	}  	if (!isNew && !_readOnly) {  		OptimizeSQLIndexes ();  	}  } catch (CouchbaseLiteException) {  	Log.To.Database.E (TAG' "Error initializing the SQLite storage engine' rethrowing...");  	StorageEngine.Close ();  	throw;  } catch (Exception e) {  	StorageEngine.Close ();  	throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error initializing SQLite storage engine");  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {  	RunStatements ("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");  	// Check the user_version number we last stored in the sqliteDb:  	var dbVersion = StorageEngine.GetVersion ();  	bool isNew = dbVersion == 17;  	if (isNew) {  		RunStatements ("BEGIN TRANSACTION");  	}  	// Incompatible version changes increment the hundreds' place:  	if (dbVersion >= 200) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);  	}  	if (dbVersion < 17) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion);  	}  	if (dbVersion < 18) {  		const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  		RunStatements (upgradeSql);  		dbVersion = 18;  	}  	if (dbVersion < 101) {  		const string upgradeSql = "PRAGMA user_version = 101";  		RunStatements (upgradeSql);  		dbVersion = 101;  	}  	if (dbVersion < 102) {  		const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  		RunStatements (upgradeSql);  		dbVersion = 102;  	}  	if (isNew) {  		RunStatements ("END TRANSACTION");  		SetInfo ("pruned"' "true");  		// See Compact for explanation  	}  	if (!isNew && !_readOnly) {  		OptimizeSQLIndexes ();  	}  } catch (CouchbaseLiteException) {  	Log.To.Database.E (TAG' "Error initializing the SQLite storage engine' rethrowing...");  	StorageEngine.Close ();  	throw;  } catch (Exception e) {  	StorageEngine.Close ();  	throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error initializing SQLite storage engine");  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: if (dbVersion >= 200) {  	throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: if (dbVersion < 17) {  	throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.DbError' TAG' "Database version ({0}) is older than I know how to work with"' dbVersion);  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: if (dbVersion < 18) {  	const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  	RunStatements (upgradeSql);  	dbVersion = 18;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: if (dbVersion < 18) {  	const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" + "PRAGMA user_version = 18";  	RunStatements (upgradeSql);  	dbVersion = 18;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: dbVersion = 18;  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: if (dbVersion < 101) {  	const string upgradeSql = "PRAGMA user_version = 101";  	RunStatements (upgradeSql);  	dbVersion = 101;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: if (dbVersion < 101) {  	const string upgradeSql = "PRAGMA user_version = 101";  	RunStatements (upgradeSql);  	dbVersion = 101;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: dbVersion = 101;  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: if (dbVersion < 102) {  	const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  	RunStatements (upgradeSql);  	dbVersion = 102;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: if (dbVersion < 102) {  	const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" + "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" + "WHERE expiry_timestamp not null;" + "PRAGMA user_version = 102";  	RunStatements (upgradeSql);  	dbVersion = 102;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: dbVersion = 102;  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PruneRevsToMaxDepth,The following statement contains a magic number: try {  	cursor = StorageEngine.RawQuery (sql);  	while (cursor.MoveToNext ()) {  		docNumericID = cursor.GetLong (0);  		var minGenRevId = cursor.GetString (1).AsRevID ();  		var maxGenRevId = cursor.GetString (2).AsRevID ();  		minGen = minGenRevId.Generation;  		maxGen = maxGenRevId.Generation;  		if ((maxGen - minGen + 1) > maxDepth) {  			toPrune [docNumericID] = (maxGen - minGen);  		}  	}  	if (toPrune.Count == 0) {  		return 0;  	}  	RunInTransaction (() => {  		foreach (var pair in toPrune) {  			outPruned += PruneDocument (pair.Key' pair.Value);  		}  		return true;  	});  } catch (Exception e) {  	throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error pruning database");  } finally {  	if (cursor != null) {  		cursor.Close ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PruneRevsToMaxDepth,The following statement contains a magic number: while (cursor.MoveToNext ()) {  	docNumericID = cursor.GetLong (0);  	var minGenRevId = cursor.GetString (1).AsRevID ();  	var maxGenRevId = cursor.GetString (2).AsRevID ();  	minGen = minGenRevId.Generation;  	maxGen = maxGenRevId.Generation;  	if ((maxGen - minGen + 1) > maxDepth) {  		toPrune [docNumericID] = (maxGen - minGen);  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetWinner,The following statement contains a magic number: TryQuery (c => {  	revId = c.GetString (0).AsRevID ();  	outDeleted.Value = c.GetInt (1) != 0;  	// The document is in conflict if there are two+ result rows that are not deletions.  	outConflict.Value = !outDeleted && c.MoveToNext () && c.GetInt (1) == 0;  	return false;  }' "SELECT revid' deleted FROM revs WHERE doc_id=? and current=1 ORDER BY deleted asc' revid desc LIMIT ?"' docNumericId' (!outConflict.IsNull ? 2 : 1));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: result.Sequence = c.GetLong (2);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: if (withBody) {  	result.SetJson (c.GetBlob (3));  } else {  	result.Missing = c.GetInt (3) == 0;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: if (withBody) {  	result.SetJson (c.GetBlob (3));  } else {  	result.Missing = c.GetInt (3) == 0;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: result.SetJson (c.GetBlob (3));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: result.Missing = c.GetInt (3) == 0;  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetRevisionHistory,The following statement contains a magic number: if (lastSequence == 0) {  	matches = revId == c.GetString (2).AsRevID ();  } else {  	matches = lastSequence == sequence;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetRevisionHistory,The following statement contains a magic number: matches = revId == c.GetString (2).AsRevID ();  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetRevisionHistory,The following statement contains a magic number: if (matches) {  	var nextRevId = c.GetString (2).AsRevID ();  	history.Add (nextRevId);  	lastSequence = c.GetLong (1);  	if (lastSequence == 0) {  		return false;  	}  	if (ancestorRevIds != null && ancestorRevIds.Contains (revId)) {  		return false;  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {  	c = StorageEngine.RawQuery (sql.ToString ()' args.ToArray ());  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		long docNumericId = c.GetLong (0);  		string docId = c.GetString (1);  		var revId = c.GetString (2);  		long sequence = c.GetLong (3);  		bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  		RevisionInternal docRevision = null;  		if (includeDocs) {  			// Fill in the document contents:  			docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  			Debug.Assert (docRevision != null);  		}  		// Iterate over following rows with the same doc_id -- these are conflicts.  		// Skip them' but collect their revIDs if the 'conflicts' option is set:  		List<string> conflicts = null;  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  			if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  				if (conflicts == null) {  					conflicts = new List<string> ();  					conflicts.Add (revId.ToString ());  				}  				conflicts.Add (c.GetString (2));  			}  		}  		if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  			continue;  		}  		var value = new NonNullDictionary<string' object> {  			{  				"rev"'  				revId  			}'  			{  				"deleted"'  				deleted ? (object)true : null  			}'  			{  				"_conflicts"'  				conflicts  			}  		// (not found in CouchDB)  		};  		var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  		if (options.Keys != null) {  			docs [docId] = row;  		} else if (options.Filter == null || options.Filter (row)) {  			rows.Add (row);  		}  	}  } catch (Exception e) {  	Log.To.Database.W (TAG' "Error in all docs query' returning null..."' e);  	return null;  } finally {  	if (c != null) {  		c.Close ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {  	c = StorageEngine.RawQuery (sql.ToString ()' args.ToArray ());  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		long docNumericId = c.GetLong (0);  		string docId = c.GetString (1);  		var revId = c.GetString (2);  		long sequence = c.GetLong (3);  		bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  		RevisionInternal docRevision = null;  		if (includeDocs) {  			// Fill in the document contents:  			docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  			Debug.Assert (docRevision != null);  		}  		// Iterate over following rows with the same doc_id -- these are conflicts.  		// Skip them' but collect their revIDs if the 'conflicts' option is set:  		List<string> conflicts = null;  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  			if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  				if (conflicts == null) {  					conflicts = new List<string> ();  					conflicts.Add (revId.ToString ());  				}  				conflicts.Add (c.GetString (2));  			}  		}  		if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  			continue;  		}  		var value = new NonNullDictionary<string' object> {  			{  				"rev"'  				revId  			}'  			{  				"deleted"'  				deleted ? (object)true : null  			}'  			{  				"_conflicts"'  				conflicts  			}  		// (not found in CouchDB)  		};  		var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  		if (options.Keys != null) {  			docs [docId] = row;  		} else if (options.Filter == null || options.Filter (row)) {  			rows.Add (row);  		}  	}  } catch (Exception e) {  	Log.To.Database.W (TAG' "Error in all docs query' returning null..."' e);  	return null;  } finally {  	if (c != null) {  		c.Close ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {  	c = StorageEngine.RawQuery (sql.ToString ()' args.ToArray ());  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		long docNumericId = c.GetLong (0);  		string docId = c.GetString (1);  		var revId = c.GetString (2);  		long sequence = c.GetLong (3);  		bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  		RevisionInternal docRevision = null;  		if (includeDocs) {  			// Fill in the document contents:  			docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  			Debug.Assert (docRevision != null);  		}  		// Iterate over following rows with the same doc_id -- these are conflicts.  		// Skip them' but collect their revIDs if the 'conflicts' option is set:  		List<string> conflicts = null;  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  			if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  				if (conflicts == null) {  					conflicts = new List<string> ();  					conflicts.Add (revId.ToString ());  				}  				conflicts.Add (c.GetString (2));  			}  		}  		if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  			continue;  		}  		var value = new NonNullDictionary<string' object> {  			{  				"rev"'  				revId  			}'  			{  				"deleted"'  				deleted ? (object)true : null  			}'  			{  				"_conflicts"'  				conflicts  			}  		// (not found in CouchDB)  		};  		var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  		if (options.Keys != null) {  			docs [docId] = row;  		} else if (options.Filter == null || options.Filter (row)) {  			rows.Add (row);  		}  	}  } catch (Exception e) {  	Log.To.Database.W (TAG' "Error in all docs query' returning null..."' e);  	return null;  } finally {  	if (c != null) {  		c.Close ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {  	c = StorageEngine.RawQuery (sql.ToString ()' args.ToArray ());  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		long docNumericId = c.GetLong (0);  		string docId = c.GetString (1);  		var revId = c.GetString (2);  		long sequence = c.GetLong (3);  		bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  		RevisionInternal docRevision = null;  		if (includeDocs) {  			// Fill in the document contents:  			docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  			Debug.Assert (docRevision != null);  		}  		// Iterate over following rows with the same doc_id -- these are conflicts.  		// Skip them' but collect their revIDs if the 'conflicts' option is set:  		List<string> conflicts = null;  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  			if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  				if (conflicts == null) {  					conflicts = new List<string> ();  					conflicts.Add (revId.ToString ());  				}  				conflicts.Add (c.GetString (2));  			}  		}  		if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  			continue;  		}  		var value = new NonNullDictionary<string' object> {  			{  				"rev"'  				revId  			}'  			{  				"deleted"'  				deleted ? (object)true : null  			}'  			{  				"_conflicts"'  				conflicts  			}  		// (not found in CouchDB)  		};  		var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  		if (options.Keys != null) {  			docs [docId] = row;  		} else if (options.Filter == null || options.Filter (row)) {  			rows.Add (row);  		}  	}  } catch (Exception e) {  	Log.To.Database.W (TAG' "Error in all docs query' returning null..."' e);  	return null;  } finally {  	if (c != null) {  		c.Close ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {  	c = StorageEngine.RawQuery (sql.ToString ()' args.ToArray ());  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		long docNumericId = c.GetLong (0);  		string docId = c.GetString (1);  		var revId = c.GetString (2);  		long sequence = c.GetLong (3);  		bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  		RevisionInternal docRevision = null;  		if (includeDocs) {  			// Fill in the document contents:  			docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  			Debug.Assert (docRevision != null);  		}  		// Iterate over following rows with the same doc_id -- these are conflicts.  		// Skip them' but collect their revIDs if the 'conflicts' option is set:  		List<string> conflicts = null;  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  			if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  				if (conflicts == null) {  					conflicts = new List<string> ();  					conflicts.Add (revId.ToString ());  				}  				conflicts.Add (c.GetString (2));  			}  		}  		if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  			continue;  		}  		var value = new NonNullDictionary<string' object> {  			{  				"rev"'  				revId  			}'  			{  				"deleted"'  				deleted ? (object)true : null  			}'  			{  				"_conflicts"'  				conflicts  			}  		// (not found in CouchDB)  		};  		var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  		if (options.Keys != null) {  			docs [docId] = row;  		} else if (options.Filter == null || options.Filter (row)) {  			rows.Add (row);  		}  	}  } catch (Exception e) {  	Log.To.Database.W (TAG' "Error in all docs query' returning null..."' e);  	return null;  } finally {  	if (c != null) {  		c.Close ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {  	c = StorageEngine.RawQuery (sql.ToString ()' args.ToArray ());  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		long docNumericId = c.GetLong (0);  		string docId = c.GetString (1);  		var revId = c.GetString (2);  		long sequence = c.GetLong (3);  		bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  		RevisionInternal docRevision = null;  		if (includeDocs) {  			// Fill in the document contents:  			docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  			Debug.Assert (docRevision != null);  		}  		// Iterate over following rows with the same doc_id -- these are conflicts.  		// Skip them' but collect their revIDs if the 'conflicts' option is set:  		List<string> conflicts = null;  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  			if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  				if (conflicts == null) {  					conflicts = new List<string> ();  					conflicts.Add (revId.ToString ());  				}  				conflicts.Add (c.GetString (2));  			}  		}  		if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  			continue;  		}  		var value = new NonNullDictionary<string' object> {  			{  				"rev"'  				revId  			}'  			{  				"deleted"'  				deleted ? (object)true : null  			}'  			{  				"_conflicts"'  				conflicts  			}  		// (not found in CouchDB)  		};  		var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  		if (options.Keys != null) {  			docs [docId] = row;  		} else if (options.Filter == null || options.Filter (row)) {  			rows.Add (row);  		}  	}  } catch (Exception e) {  	Log.To.Database.W (TAG' "Error in all docs query' returning null..."' e);  	return null;  } finally {  	if (c != null) {  		c.Close ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: while (keepGoing) {  	long docNumericId = c.GetLong (0);  	string docId = c.GetString (1);  	var revId = c.GetString (2);  	long sequence = c.GetLong (3);  	bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  	RevisionInternal docRevision = null;  	if (includeDocs) {  		// Fill in the document contents:  		docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  		Debug.Assert (docRevision != null);  	}  	// Iterate over following rows with the same doc_id -- these are conflicts.  	// Skip them' but collect their revIDs if the 'conflicts' option is set:  	List<string> conflicts = null;  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  		if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  			if (conflicts == null) {  				conflicts = new List<string> ();  				conflicts.Add (revId.ToString ());  			}  			conflicts.Add (c.GetString (2));  		}  	}  	if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  		continue;  	}  	var value = new NonNullDictionary<string' object> {  		{  			"rev"'  			revId  		}'  		{  			"deleted"'  			deleted ? (object)true : null  		}'  		{  			"_conflicts"'  			conflicts  		}  	// (not found in CouchDB)  	};  	var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  	if (options.Keys != null) {  		docs [docId] = row;  	} else if (options.Filter == null || options.Filter (row)) {  		rows.Add (row);  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: while (keepGoing) {  	long docNumericId = c.GetLong (0);  	string docId = c.GetString (1);  	var revId = c.GetString (2);  	long sequence = c.GetLong (3);  	bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  	RevisionInternal docRevision = null;  	if (includeDocs) {  		// Fill in the document contents:  		docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  		Debug.Assert (docRevision != null);  	}  	// Iterate over following rows with the same doc_id -- these are conflicts.  	// Skip them' but collect their revIDs if the 'conflicts' option is set:  	List<string> conflicts = null;  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  		if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  			if (conflicts == null) {  				conflicts = new List<string> ();  				conflicts.Add (revId.ToString ());  			}  			conflicts.Add (c.GetString (2));  		}  	}  	if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  		continue;  	}  	var value = new NonNullDictionary<string' object> {  		{  			"rev"'  			revId  		}'  		{  			"deleted"'  			deleted ? (object)true : null  		}'  		{  			"_conflicts"'  			conflicts  		}  	// (not found in CouchDB)  	};  	var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  	if (options.Keys != null) {  		docs [docId] = row;  	} else if (options.Filter == null || options.Filter (row)) {  		rows.Add (row);  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: while (keepGoing) {  	long docNumericId = c.GetLong (0);  	string docId = c.GetString (1);  	var revId = c.GetString (2);  	long sequence = c.GetLong (3);  	bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  	RevisionInternal docRevision = null;  	if (includeDocs) {  		// Fill in the document contents:  		docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  		Debug.Assert (docRevision != null);  	}  	// Iterate over following rows with the same doc_id -- these are conflicts.  	// Skip them' but collect their revIDs if the 'conflicts' option is set:  	List<string> conflicts = null;  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  		if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  			if (conflicts == null) {  				conflicts = new List<string> ();  				conflicts.Add (revId.ToString ());  			}  			conflicts.Add (c.GetString (2));  		}  	}  	if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  		continue;  	}  	var value = new NonNullDictionary<string' object> {  		{  			"rev"'  			revId  		}'  		{  			"deleted"'  			deleted ? (object)true : null  		}'  		{  			"_conflicts"'  			conflicts  		}  	// (not found in CouchDB)  	};  	var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  	if (options.Keys != null) {  		docs [docId] = row;  	} else if (options.Filter == null || options.Filter (row)) {  		rows.Add (row);  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: while (keepGoing) {  	long docNumericId = c.GetLong (0);  	string docId = c.GetString (1);  	var revId = c.GetString (2);  	long sequence = c.GetLong (3);  	bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  	RevisionInternal docRevision = null;  	if (includeDocs) {  		// Fill in the document contents:  		docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  		Debug.Assert (docRevision != null);  	}  	// Iterate over following rows with the same doc_id -- these are conflicts.  	// Skip them' but collect their revIDs if the 'conflicts' option is set:  	List<string> conflicts = null;  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  		if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  			if (conflicts == null) {  				conflicts = new List<string> ();  				conflicts.Add (revId.ToString ());  			}  			conflicts.Add (c.GetString (2));  		}  	}  	if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  		continue;  	}  	var value = new NonNullDictionary<string' object> {  		{  			"rev"'  			revId  		}'  		{  			"deleted"'  			deleted ? (object)true : null  		}'  		{  			"_conflicts"'  			conflicts  		}  	// (not found in CouchDB)  	};  	var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  	if (options.Keys != null) {  		docs [docId] = row;  	} else if (options.Filter == null || options.Filter (row)) {  		rows.Add (row);  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: while (keepGoing) {  	long docNumericId = c.GetLong (0);  	string docId = c.GetString (1);  	var revId = c.GetString (2);  	long sequence = c.GetLong (3);  	bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  	RevisionInternal docRevision = null;  	if (includeDocs) {  		// Fill in the document contents:  		docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  		Debug.Assert (docRevision != null);  	}  	// Iterate over following rows with the same doc_id -- these are conflicts.  	// Skip them' but collect their revIDs if the 'conflicts' option is set:  	List<string> conflicts = null;  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  		if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  			if (conflicts == null) {  				conflicts = new List<string> ();  				conflicts.Add (revId.ToString ());  			}  			conflicts.Add (c.GetString (2));  		}  	}  	if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  		continue;  	}  	var value = new NonNullDictionary<string' object> {  		{  			"rev"'  			revId  		}'  		{  			"deleted"'  			deleted ? (object)true : null  		}'  		{  			"_conflicts"'  			conflicts  		}  	// (not found in CouchDB)  	};  	var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  	if (options.Keys != null) {  		docs [docId] = row;  	} else if (options.Filter == null || options.Filter (row)) {  		rows.Add (row);  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: while (keepGoing) {  	long docNumericId = c.GetLong (0);  	string docId = c.GetString (1);  	var revId = c.GetString (2);  	long sequence = c.GetLong (3);  	bool deleted = includeDeletedDocs && c.GetInt (includeDocs ? 6 : 4) != 0;  	RevisionInternal docRevision = null;  	if (includeDocs) {  		// Fill in the document contents:  		docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  		Debug.Assert (docRevision != null);  	}  	// Iterate over following rows with the same doc_id -- these are conflicts.  	// Skip them' but collect their revIDs if the 'conflicts' option is set:  	List<string> conflicts = null;  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  		if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  			if (conflicts == null) {  				conflicts = new List<string> ();  				conflicts.Add (revId.ToString ());  			}  			conflicts.Add (c.GetString (2));  		}  	}  	if (options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {  		continue;  	}  	var value = new NonNullDictionary<string' object> {  		{  			"rev"'  			revId  		}'  		{  			"deleted"'  			deleted ? (object)true : null  		}'  		{  			"_conflicts"'  			conflicts  		}  	// (not found in CouchDB)  	};  	var row = new QueryRow (docId' sequence' docId' value' docRevision' null);  	if (options.Keys != null) {  		docs [docId] = row;  	} else if (options.Filter == null || options.Filter (row)) {  		rows.Add (row);  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: if (includeDocs) {  	// Fill in the document contents:  	docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  	Debug.Assert (docRevision != null);  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: docRevision = RevisionWithDocID (docId' revId.AsRevID ()' deleted' sequence' c.GetBlob (4));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == docNumericId) {  	if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  		if (conflicts == null) {  			conflicts = new List<string> ();  			conflicts.Add (revId.ToString ());  		}  		conflicts.Add (c.GetString (2));  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: if (options.AllDocsMode >= AllDocsMode.ShowConflicts) {  	if (conflicts == null) {  		conflicts = new List<string> ();  		conflicts.Add (revId.ToString ());  	}  	conflicts.Add (c.GetString (2));  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: conflicts.Add (c.GetString (2));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The following statement contains a magic number: TryQuery (c => {  	if (!options.IncludeConflicts) {  		// Only count the first rev for a given doc (the rest will be losing conflicts):  		var docNumericId = c.GetLong (1);  		if (docNumericId == lastDocId) {  			return true;  		}  		lastDocId = docNumericId;  	}  	string docId = c.GetString (2);  	var revId = c.GetString (3).AsRevID ();  	bool deleted = c.GetInt (4) != 0;  	var rev = new RevisionInternal (docId' revId' deleted);  	rev.Sequence = c.GetLong (0);  	if (includeDocs) {  		rev.SetJson (c.GetBlob (5));  	}  	if ((filter == null || filter (rev)) && returned++ < options.Limit) {  		changes.Add (rev);  	}  	if (returned >= options.Limit) {  		return false;  	}  	return true;  }' sql' lastSequence);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The following statement contains a magic number: TryQuery (c => {  	if (!options.IncludeConflicts) {  		// Only count the first rev for a given doc (the rest will be losing conflicts):  		var docNumericId = c.GetLong (1);  		if (docNumericId == lastDocId) {  			return true;  		}  		lastDocId = docNumericId;  	}  	string docId = c.GetString (2);  	var revId = c.GetString (3).AsRevID ();  	bool deleted = c.GetInt (4) != 0;  	var rev = new RevisionInternal (docId' revId' deleted);  	rev.Sequence = c.GetLong (0);  	if (includeDocs) {  		rev.SetJson (c.GetBlob (5));  	}  	if ((filter == null || filter (rev)) && returned++ < options.Limit) {  		changes.Add (rev);  	}  	if (returned >= options.Limit) {  		return false;  	}  	return true;  }' sql' lastSequence);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The following statement contains a magic number: TryQuery (c => {  	if (!options.IncludeConflicts) {  		// Only count the first rev for a given doc (the rest will be losing conflicts):  		var docNumericId = c.GetLong (1);  		if (docNumericId == lastDocId) {  			return true;  		}  		lastDocId = docNumericId;  	}  	string docId = c.GetString (2);  	var revId = c.GetString (3).AsRevID ();  	bool deleted = c.GetInt (4) != 0;  	var rev = new RevisionInternal (docId' revId' deleted);  	rev.Sequence = c.GetLong (0);  	if (includeDocs) {  		rev.SetJson (c.GetBlob (5));  	}  	if ((filter == null || filter (rev)) && returned++ < options.Limit) {  		changes.Add (rev);  	}  	if (returned >= options.Limit) {  		return false;  	}  	return true;  }' sql' lastSequence);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The following statement contains a magic number: TryQuery (c => {  	if (!options.IncludeConflicts) {  		// Only count the first rev for a given doc (the rest will be losing conflicts):  		var docNumericId = c.GetLong (1);  		if (docNumericId == lastDocId) {  			return true;  		}  		lastDocId = docNumericId;  	}  	string docId = c.GetString (2);  	var revId = c.GetString (3).AsRevID ();  	bool deleted = c.GetInt (4) != 0;  	var rev = new RevisionInternal (docId' revId' deleted);  	rev.Sequence = c.GetLong (0);  	if (includeDocs) {  		rev.SetJson (c.GetBlob (5));  	}  	if ((filter == null || filter (rev)) && returned++ < options.Limit) {  		changes.Add (rev);  	}  	if (returned >= options.Limit) {  		return false;  	}  	return true;  }' sql' lastSequence);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The following statement contains a magic number: if (includeDocs) {  	rev.SetJson (c.GetBlob (5));  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The following statement contains a magic number: rev.SetJson (c.GetBlob (5));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: using (var c = StorageEngine.RawQuery (sql' lastSequence)) {  	while (c.MoveToNext ()) {  		if (options.SortBySequence) {  			if (losingSequences.Contains (c.GetLong (0)) == true) {  				continue;  			}  		} else if (!options.IncludeConflicts) {  			// Only count the first rev for a given doc (the rest will be losing conflicts):  			var docNumericId = c.GetLong (1);  			if (docNumericId == lastDocId) {  				continue;  			}  			lastDocId = docNumericId;  		}  		string docId = c.GetString (2);  		var revId = c.GetString (3).AsRevID ();  		bool deleted = c.GetInt (4) != 0;  		var rev = new RevisionInternal (docId' revId' deleted);  		rev.Sequence = c.GetLong (0);  		if (includeDocs) {  			rev.SetJson (c.GetBlob (5));  		}  		if (filter == null || filter (rev) && returned++ < options.Limit) {  			yield return rev;  		}  		if (returned >= options.Limit) {  			break;  		}  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: using (var c = StorageEngine.RawQuery (sql' lastSequence)) {  	while (c.MoveToNext ()) {  		if (options.SortBySequence) {  			if (losingSequences.Contains (c.GetLong (0)) == true) {  				continue;  			}  		} else if (!options.IncludeConflicts) {  			// Only count the first rev for a given doc (the rest will be losing conflicts):  			var docNumericId = c.GetLong (1);  			if (docNumericId == lastDocId) {  				continue;  			}  			lastDocId = docNumericId;  		}  		string docId = c.GetString (2);  		var revId = c.GetString (3).AsRevID ();  		bool deleted = c.GetInt (4) != 0;  		var rev = new RevisionInternal (docId' revId' deleted);  		rev.Sequence = c.GetLong (0);  		if (includeDocs) {  			rev.SetJson (c.GetBlob (5));  		}  		if (filter == null || filter (rev) && returned++ < options.Limit) {  			yield return rev;  		}  		if (returned >= options.Limit) {  			break;  		}  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: using (var c = StorageEngine.RawQuery (sql' lastSequence)) {  	while (c.MoveToNext ()) {  		if (options.SortBySequence) {  			if (losingSequences.Contains (c.GetLong (0)) == true) {  				continue;  			}  		} else if (!options.IncludeConflicts) {  			// Only count the first rev for a given doc (the rest will be losing conflicts):  			var docNumericId = c.GetLong (1);  			if (docNumericId == lastDocId) {  				continue;  			}  			lastDocId = docNumericId;  		}  		string docId = c.GetString (2);  		var revId = c.GetString (3).AsRevID ();  		bool deleted = c.GetInt (4) != 0;  		var rev = new RevisionInternal (docId' revId' deleted);  		rev.Sequence = c.GetLong (0);  		if (includeDocs) {  			rev.SetJson (c.GetBlob (5));  		}  		if (filter == null || filter (rev) && returned++ < options.Limit) {  			yield return rev;  		}  		if (returned >= options.Limit) {  			break;  		}  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: using (var c = StorageEngine.RawQuery (sql' lastSequence)) {  	while (c.MoveToNext ()) {  		if (options.SortBySequence) {  			if (losingSequences.Contains (c.GetLong (0)) == true) {  				continue;  			}  		} else if (!options.IncludeConflicts) {  			// Only count the first rev for a given doc (the rest will be losing conflicts):  			var docNumericId = c.GetLong (1);  			if (docNumericId == lastDocId) {  				continue;  			}  			lastDocId = docNumericId;  		}  		string docId = c.GetString (2);  		var revId = c.GetString (3).AsRevID ();  		bool deleted = c.GetInt (4) != 0;  		var rev = new RevisionInternal (docId' revId' deleted);  		rev.Sequence = c.GetLong (0);  		if (includeDocs) {  			rev.SetJson (c.GetBlob (5));  		}  		if (filter == null || filter (rev) && returned++ < options.Limit) {  			yield return rev;  		}  		if (returned >= options.Limit) {  			break;  		}  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: while (c.MoveToNext ()) {  	if (options.SortBySequence) {  		if (losingSequences.Contains (c.GetLong (0)) == true) {  			continue;  		}  	} else if (!options.IncludeConflicts) {  		// Only count the first rev for a given doc (the rest will be losing conflicts):  		var docNumericId = c.GetLong (1);  		if (docNumericId == lastDocId) {  			continue;  		}  		lastDocId = docNumericId;  	}  	string docId = c.GetString (2);  	var revId = c.GetString (3).AsRevID ();  	bool deleted = c.GetInt (4) != 0;  	var rev = new RevisionInternal (docId' revId' deleted);  	rev.Sequence = c.GetLong (0);  	if (includeDocs) {  		rev.SetJson (c.GetBlob (5));  	}  	if (filter == null || filter (rev) && returned++ < options.Limit) {  		yield return rev;  	}  	if (returned >= options.Limit) {  		break;  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: while (c.MoveToNext ()) {  	if (options.SortBySequence) {  		if (losingSequences.Contains (c.GetLong (0)) == true) {  			continue;  		}  	} else if (!options.IncludeConflicts) {  		// Only count the first rev for a given doc (the rest will be losing conflicts):  		var docNumericId = c.GetLong (1);  		if (docNumericId == lastDocId) {  			continue;  		}  		lastDocId = docNumericId;  	}  	string docId = c.GetString (2);  	var revId = c.GetString (3).AsRevID ();  	bool deleted = c.GetInt (4) != 0;  	var rev = new RevisionInternal (docId' revId' deleted);  	rev.Sequence = c.GetLong (0);  	if (includeDocs) {  		rev.SetJson (c.GetBlob (5));  	}  	if (filter == null || filter (rev) && returned++ < options.Limit) {  		yield return rev;  	}  	if (returned >= options.Limit) {  		break;  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: while (c.MoveToNext ()) {  	if (options.SortBySequence) {  		if (losingSequences.Contains (c.GetLong (0)) == true) {  			continue;  		}  	} else if (!options.IncludeConflicts) {  		// Only count the first rev for a given doc (the rest will be losing conflicts):  		var docNumericId = c.GetLong (1);  		if (docNumericId == lastDocId) {  			continue;  		}  		lastDocId = docNumericId;  	}  	string docId = c.GetString (2);  	var revId = c.GetString (3).AsRevID ();  	bool deleted = c.GetInt (4) != 0;  	var rev = new RevisionInternal (docId' revId' deleted);  	rev.Sequence = c.GetLong (0);  	if (includeDocs) {  		rev.SetJson (c.GetBlob (5));  	}  	if (filter == null || filter (rev) && returned++ < options.Limit) {  		yield return rev;  	}  	if (returned >= options.Limit) {  		break;  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: while (c.MoveToNext ()) {  	if (options.SortBySequence) {  		if (losingSequences.Contains (c.GetLong (0)) == true) {  			continue;  		}  	} else if (!options.IncludeConflicts) {  		// Only count the first rev for a given doc (the rest will be losing conflicts):  		var docNumericId = c.GetLong (1);  		if (docNumericId == lastDocId) {  			continue;  		}  		lastDocId = docNumericId;  	}  	string docId = c.GetString (2);  	var revId = c.GetString (3).AsRevID ();  	bool deleted = c.GetInt (4) != 0;  	var rev = new RevisionInternal (docId' revId' deleted);  	rev.Sequence = c.GetLong (0);  	if (includeDocs) {  		rev.SetJson (c.GetBlob (5));  	}  	if (filter == null || filter (rev) && returned++ < options.Limit) {  		yield return rev;  	}  	if (returned >= options.Limit) {  		break;  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: if (includeDocs) {  	rev.SetJson (c.GetBlob (5));  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: rev.SetJson (c.GetBlob (5));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The following statement contains a magic number: RunInTransaction (() => {  	foreach (var docId in docsToRev.Keys) {  		var docNumericId = GetDocNumericID (docId);  		if (docNumericId == 0) {  			// no such document; skip it  			continue;  		}  		IEnumerable<string> revsPurged = null;  		var revIDs = docsToRev [docId];  		if (revIDs == null) {  			throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadParam' TAG' "Illegal null revIds for {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  		} else if (revIDs.Count == 0) {  			revsPurged = new List<string> ();  		} else if (revIDs.Contains ("*")) {  			// Delete all revisions if magic "*" revision ID is given.  Deleting the 'docs'  			// row will delete all 'revs' rows due to cascading.  			try {  				StorageEngine.Delete ("docs"' "doc_id=?"' docNumericId.ToString ());  			} catch (CouchbaseLiteException) {  				Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  				throw;  			} catch (Exception e) {  				throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  			}  			InvalidateDocNumericID (docId);  			NotifyPurgedDocument (docId);  			revsPurged = new List<string> {  				"*"  			};  		} else {  			// Iterate over all the revisions of the doc' in reverse sequence order.  			// Keep track of all the sequences to delete' i.e. the given revs and ancestors'  			// but not any non-given leaf revs or their ancestors.  			const string sql = "SELECT revid' sequence' parent FROM revs WHERE doc_id=? ORDER BY sequence DESC";  			HashSet<long> seqsToPurge = new HashSet<long> ();  			HashSet<long> seqsToKeep = new HashSet<long> ();  			HashSet<string> revsToPurge = new HashSet<string> ();  			TryQuery (c => {  				string revId = c.GetString (0);  				long sequence = c.GetLong (1);  				long parent = c.GetLong (2);  				if (seqsToPurge.Contains (sequence) || revIDs.Contains (revId) && !seqsToKeep.Contains (sequence)) {  					// Purge it and maybe its parent:  					seqsToPurge.Add (sequence);  					revsToPurge.Add (revId);  					if (parent > 0) {  						seqsToPurge.Add (parent);  					}  				} else {  					// Keep it and its parent:  					seqsToPurge.Remove (sequence);  					revsToPurge.Remove (revId);  					seqsToKeep.Add (parent);  				}  				return true;  			}' sql' docNumericId);  			seqsToPurge.ExceptWith (seqsToKeep);  			Log.To.Database.I (TAG' "Purging doc '{0}' revs ({1}); asked for ({2})"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' new LogJsonString (revsToPurge.ToStringArray ())' new LogJsonString (revIDs));  			if (seqsToPurge.Any ()) {  				// Now delete the sequences to be purged.  				var deleteSql = String.Format ("sequence in ({0})"' String.Join ("' "' seqsToPurge.ToStringArray ()));  				int count = 0;  				try {  					count = StorageEngine.Delete ("revs"' deleteSql);  				} catch (CouchbaseLiteException) {  					Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  					throw;  				} catch (Exception e) {  					throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  				}  				if (count != seqsToPurge.Count) {  					Log.To.Database.W (TAG' "Only {0} revisions deleted of {1}"' count' String.Join ("' "' seqsToPurge.ToStringArray ()));  				}  			}  			revsPurged = revsToPurge;  		}  		result ["docID"] = revIDs.Where (x => revsPurged.Contains (x));  	}  	return true;  });  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The following statement contains a magic number: foreach (var docId in docsToRev.Keys) {  	var docNumericId = GetDocNumericID (docId);  	if (docNumericId == 0) {  		// no such document; skip it  		continue;  	}  	IEnumerable<string> revsPurged = null;  	var revIDs = docsToRev [docId];  	if (revIDs == null) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadParam' TAG' "Illegal null revIds for {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  	} else if (revIDs.Count == 0) {  		revsPurged = new List<string> ();  	} else if (revIDs.Contains ("*")) {  		// Delete all revisions if magic "*" revision ID is given.  Deleting the 'docs'  		// row will delete all 'revs' rows due to cascading.  		try {  			StorageEngine.Delete ("docs"' "doc_id=?"' docNumericId.ToString ());  		} catch (CouchbaseLiteException) {  			Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  		}  		InvalidateDocNumericID (docId);  		NotifyPurgedDocument (docId);  		revsPurged = new List<string> {  			"*"  		};  	} else {  		// Iterate over all the revisions of the doc' in reverse sequence order.  		// Keep track of all the sequences to delete' i.e. the given revs and ancestors'  		// but not any non-given leaf revs or their ancestors.  		const string sql = "SELECT revid' sequence' parent FROM revs WHERE doc_id=? ORDER BY sequence DESC";  		HashSet<long> seqsToPurge = new HashSet<long> ();  		HashSet<long> seqsToKeep = new HashSet<long> ();  		HashSet<string> revsToPurge = new HashSet<string> ();  		TryQuery (c => {  			string revId = c.GetString (0);  			long sequence = c.GetLong (1);  			long parent = c.GetLong (2);  			if (seqsToPurge.Contains (sequence) || revIDs.Contains (revId) && !seqsToKeep.Contains (sequence)) {  				// Purge it and maybe its parent:  				seqsToPurge.Add (sequence);  				revsToPurge.Add (revId);  				if (parent > 0) {  					seqsToPurge.Add (parent);  				}  			} else {  				// Keep it and its parent:  				seqsToPurge.Remove (sequence);  				revsToPurge.Remove (revId);  				seqsToKeep.Add (parent);  			}  			return true;  		}' sql' docNumericId);  		seqsToPurge.ExceptWith (seqsToKeep);  		Log.To.Database.I (TAG' "Purging doc '{0}' revs ({1}); asked for ({2})"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' new LogJsonString (revsToPurge.ToStringArray ())' new LogJsonString (revIDs));  		if (seqsToPurge.Any ()) {  			// Now delete the sequences to be purged.  			var deleteSql = String.Format ("sequence in ({0})"' String.Join ("' "' seqsToPurge.ToStringArray ()));  			int count = 0;  			try {  				count = StorageEngine.Delete ("revs"' deleteSql);  			} catch (CouchbaseLiteException) {  				Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  				throw;  			} catch (Exception e) {  				throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  			}  			if (count != seqsToPurge.Count) {  				Log.To.Database.W (TAG' "Only {0} revisions deleted of {1}"' count' String.Join ("' "' seqsToPurge.ToStringArray ()));  			}  		}  		revsPurged = revsToPurge;  	}  	result ["docID"] = revIDs.Where (x => revsPurged.Contains (x));  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The following statement contains a magic number: if (revIDs == null) {  	throw Misc.CreateExceptionAndLog (Log.To.Database' StatusCode.BadParam' TAG' "Illegal null revIds for {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  } else if (revIDs.Count == 0) {  	revsPurged = new List<string> ();  } else if (revIDs.Contains ("*")) {  	// Delete all revisions if magic "*" revision ID is given.  Deleting the 'docs'  	// row will delete all 'revs' rows due to cascading.  	try {  		StorageEngine.Delete ("docs"' "doc_id=?"' docNumericId.ToString ());  	} catch (CouchbaseLiteException) {  		Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  		throw;  	} catch (Exception e) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  	}  	InvalidateDocNumericID (docId);  	NotifyPurgedDocument (docId);  	revsPurged = new List<string> {  		"*"  	};  } else {  	// Iterate over all the revisions of the doc' in reverse sequence order.  	// Keep track of all the sequences to delete' i.e. the given revs and ancestors'  	// but not any non-given leaf revs or their ancestors.  	const string sql = "SELECT revid' sequence' parent FROM revs WHERE doc_id=? ORDER BY sequence DESC";  	HashSet<long> seqsToPurge = new HashSet<long> ();  	HashSet<long> seqsToKeep = new HashSet<long> ();  	HashSet<string> revsToPurge = new HashSet<string> ();  	TryQuery (c => {  		string revId = c.GetString (0);  		long sequence = c.GetLong (1);  		long parent = c.GetLong (2);  		if (seqsToPurge.Contains (sequence) || revIDs.Contains (revId) && !seqsToKeep.Contains (sequence)) {  			// Purge it and maybe its parent:  			seqsToPurge.Add (sequence);  			revsToPurge.Add (revId);  			if (parent > 0) {  				seqsToPurge.Add (parent);  			}  		} else {  			// Keep it and its parent:  			seqsToPurge.Remove (sequence);  			revsToPurge.Remove (revId);  			seqsToKeep.Add (parent);  		}  		return true;  	}' sql' docNumericId);  	seqsToPurge.ExceptWith (seqsToKeep);  	Log.To.Database.I (TAG' "Purging doc '{0}' revs ({1}); asked for ({2})"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' new LogJsonString (revsToPurge.ToStringArray ())' new LogJsonString (revIDs));  	if (seqsToPurge.Any ()) {  		// Now delete the sequences to be purged.  		var deleteSql = String.Format ("sequence in ({0})"' String.Join ("' "' seqsToPurge.ToStringArray ()));  		int count = 0;  		try {  			count = StorageEngine.Delete ("revs"' deleteSql);  		} catch (CouchbaseLiteException) {  			Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  		}  		if (count != seqsToPurge.Count) {  			Log.To.Database.W (TAG' "Only {0} revisions deleted of {1}"' count' String.Join ("' "' seqsToPurge.ToStringArray ()));  		}  	}  	revsPurged = revsToPurge;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The following statement contains a magic number: if (revIDs.Count == 0) {  	revsPurged = new List<string> ();  } else if (revIDs.Contains ("*")) {  	// Delete all revisions if magic "*" revision ID is given.  Deleting the 'docs'  	// row will delete all 'revs' rows due to cascading.  	try {  		StorageEngine.Delete ("docs"' "doc_id=?"' docNumericId.ToString ());  	} catch (CouchbaseLiteException) {  		Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  		throw;  	} catch (Exception e) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  	}  	InvalidateDocNumericID (docId);  	NotifyPurgedDocument (docId);  	revsPurged = new List<string> {  		"*"  	};  } else {  	// Iterate over all the revisions of the doc' in reverse sequence order.  	// Keep track of all the sequences to delete' i.e. the given revs and ancestors'  	// but not any non-given leaf revs or their ancestors.  	const string sql = "SELECT revid' sequence' parent FROM revs WHERE doc_id=? ORDER BY sequence DESC";  	HashSet<long> seqsToPurge = new HashSet<long> ();  	HashSet<long> seqsToKeep = new HashSet<long> ();  	HashSet<string> revsToPurge = new HashSet<string> ();  	TryQuery (c => {  		string revId = c.GetString (0);  		long sequence = c.GetLong (1);  		long parent = c.GetLong (2);  		if (seqsToPurge.Contains (sequence) || revIDs.Contains (revId) && !seqsToKeep.Contains (sequence)) {  			// Purge it and maybe its parent:  			seqsToPurge.Add (sequence);  			revsToPurge.Add (revId);  			if (parent > 0) {  				seqsToPurge.Add (parent);  			}  		} else {  			// Keep it and its parent:  			seqsToPurge.Remove (sequence);  			revsToPurge.Remove (revId);  			seqsToKeep.Add (parent);  		}  		return true;  	}' sql' docNumericId);  	seqsToPurge.ExceptWith (seqsToKeep);  	Log.To.Database.I (TAG' "Purging doc '{0}' revs ({1}); asked for ({2})"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' new LogJsonString (revsToPurge.ToStringArray ())' new LogJsonString (revIDs));  	if (seqsToPurge.Any ()) {  		// Now delete the sequences to be purged.  		var deleteSql = String.Format ("sequence in ({0})"' String.Join ("' "' seqsToPurge.ToStringArray ()));  		int count = 0;  		try {  			count = StorageEngine.Delete ("revs"' deleteSql);  		} catch (CouchbaseLiteException) {  			Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  		}  		if (count != seqsToPurge.Count) {  			Log.To.Database.W (TAG' "Only {0} revisions deleted of {1}"' count' String.Join ("' "' seqsToPurge.ToStringArray ()));  		}  	}  	revsPurged = revsToPurge;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The following statement contains a magic number: if (revIDs.Contains ("*")) {  	// Delete all revisions if magic "*" revision ID is given.  Deleting the 'docs'  	// row will delete all 'revs' rows due to cascading.  	try {  		StorageEngine.Delete ("docs"' "doc_id=?"' docNumericId.ToString ());  	} catch (CouchbaseLiteException) {  		Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  		throw;  	} catch (Exception e) {  		throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  	}  	InvalidateDocNumericID (docId);  	NotifyPurgedDocument (docId);  	revsPurged = new List<string> {  		"*"  	};  } else {  	// Iterate over all the revisions of the doc' in reverse sequence order.  	// Keep track of all the sequences to delete' i.e. the given revs and ancestors'  	// but not any non-given leaf revs or their ancestors.  	const string sql = "SELECT revid' sequence' parent FROM revs WHERE doc_id=? ORDER BY sequence DESC";  	HashSet<long> seqsToPurge = new HashSet<long> ();  	HashSet<long> seqsToKeep = new HashSet<long> ();  	HashSet<string> revsToPurge = new HashSet<string> ();  	TryQuery (c => {  		string revId = c.GetString (0);  		long sequence = c.GetLong (1);  		long parent = c.GetLong (2);  		if (seqsToPurge.Contains (sequence) || revIDs.Contains (revId) && !seqsToKeep.Contains (sequence)) {  			// Purge it and maybe its parent:  			seqsToPurge.Add (sequence);  			revsToPurge.Add (revId);  			if (parent > 0) {  				seqsToPurge.Add (parent);  			}  		} else {  			// Keep it and its parent:  			seqsToPurge.Remove (sequence);  			revsToPurge.Remove (revId);  			seqsToKeep.Add (parent);  		}  		return true;  	}' sql' docNumericId);  	seqsToPurge.ExceptWith (seqsToKeep);  	Log.To.Database.I (TAG' "Purging doc '{0}' revs ({1}); asked for ({2})"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' new LogJsonString (revsToPurge.ToStringArray ())' new LogJsonString (revIDs));  	if (seqsToPurge.Any ()) {  		// Now delete the sequences to be purged.  		var deleteSql = String.Format ("sequence in ({0})"' String.Join ("' "' seqsToPurge.ToStringArray ()));  		int count = 0;  		try {  			count = StorageEngine.Delete ("revs"' deleteSql);  		} catch (CouchbaseLiteException) {  			Log.To.Database.E (TAG' "Failed to delete revisions of {0}' rethrowing..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.Database' e' TAG' "Error deleting revisions of {0}"' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  		}  		if (count != seqsToPurge.Count) {  			Log.To.Database.W (TAG' "Only {0} revisions deleted of {1}"' count' String.Join ("' "' seqsToPurge.ToStringArray ()));  		}  	}  	revsPurged = revsToPurge;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The following statement contains a magic number: TryQuery (c => {  	string revId = c.GetString (0);  	long sequence = c.GetLong (1);  	long parent = c.GetLong (2);  	if (seqsToPurge.Contains (sequence) || revIDs.Contains (revId) && !seqsToKeep.Contains (sequence)) {  		// Purge it and maybe its parent:  		seqsToPurge.Add (sequence);  		revsToPurge.Add (revId);  		if (parent > 0) {  			seqsToPurge.Add (parent);  		}  	} else {  		// Keep it and its parent:  		seqsToPurge.Remove (sequence);  		revsToPurge.Remove (revId);  		seqsToKeep.Add (parent);  	}  	return true;  }' sql' docNumericId);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetLocalDocument,The following statement contains a magic number: TryQuery (c => {  	var gotRevId = c.GetString (0).AsRevID ();  	if (revId != null && revId != gotRevId) {  		return false;  	}  	var json = c.GetBlob (1);  	IDictionary<string' object> properties;  	if (json == null || !json.Any () || (json.Length == 2 && json [0] == (byte)'{' && json [1] == '}')) {  		properties = new Dictionary<string' object> ();  	} else {  		try {  			properties = Manager.GetObjectMapper ().ReadValue<IDictionary<string' object>> (json);  		} catch (Exception) {  			return false;  		}  	}  	properties.SetDocRevID (docId' gotRevId);  	result = new RevisionInternal (docId' gotRevId' false);  	result.SetProperties (properties);  	return false;  }' "SELECT revid' json FROM localdocs WHERE docid=?"' docId);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetLocalDocument,The following statement contains a magic number: if (json == null || !json.Any () || (json.Length == 2 && json [0] == (byte)'{' && json [1] == '}')) {  	properties = new Dictionary<string' object> ();  } else {  	try {  		properties = Manager.GetObjectMapper ().ReadValue<IDictionary<string' object>> (json);  	} catch (Exception) {  		return false;  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Open,The following statement contains a magic number: try {  	OpenRWConnection (_readOnly);  	if (schema != null && GetVersion () == 0) {  		foreach (var statement in schema.Split (';')) {  			ExecSQL (statement);  		}  	}  	_readerConnections = new ConnectionPool (3' OpenROConnection' Close);  } catch (CouchbaseLiteException) {  	Log.To.Database.W (TAG' "Error opening SQLite storage engine' rethrowing...");  	throw;  } catch (Exception ex) {  	throw Misc.CreateExceptionAndLog (Log.To.Database' ex' TAG' "Failed to open SQLite storage engine");  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Open,The following statement contains a magic number: _readerConnections = new ConnectionPool (3' OpenROConnection' Close);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Close,The following statement contains a magic number: try {  	// Close any open statements' otherwise the  	// sqlite connection won't actually close.  	sqlite3_stmt next = null;  	while ((next = dbCopy.next_stmt (next)) != null) {  		next.Dispose ();  	}  	dbCopy.close ();  } catch (KeyNotFoundException ex) {  	// Appears to be a bug in sqlite3.find_stmt. Concurrency issue in static dictionary?  	// Assuming we're done.  	Log.To.Database.W (TAG' "Abandoning database close."' ex);  } catch (ugly.sqlite3_exception ex) {  	Log.To.Database.I (TAG' "Retrying database close due to exception."' ex);  	// Assuming a basic retry fixes this.  	Thread.Sleep (5000);  	dbCopy.close ();  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Close,The following statement contains a magic number: Thread.Sleep (5000);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunQuery,The following statement contains a magic number: dbStorage.TryQuery (c => {  	var docId = c.GetString (2);  	status = action (new Lazy<byte[]> (() => c.GetBlob (0))' new Lazy<byte[]> (() => c.GetBlob (1))' docId' c);  	if (status.IsError || status.Code == StatusCode.Reserved) {  		return false;  	} else if ((int)status.Code <= 0) {  		status.Code = StatusCode.Ok;  	}  	return true;  }' sql.ToString ()' args.ToArray ());  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction (() => {  	long dbMaxSequence = db.LastSequence;  	long forViewLastSequence = LastSequenceIndexed;  	// Check whether we need to update at all'  	// and remove obsolete emitted results from the 'maps' table:  	long minLastSequence = dbMaxSequence;  	long[] viewLastSequence = new long[inputViews.Count ()];  	int deletedCount = 0;  	int i = 0;  	HashSet<string> docTypes = new HashSet<string> ();  	IDictionary<string' string> viewDocTypes = null;  	bool allDocTypes = false;  	IDictionary<int' int> viewTotalRows = new Dictionary<int' int> ();  	List<SqliteViewStore> views = new List<SqliteViewStore> (inputViews.Count ());  	List<MapDelegate> mapBlocks = new List<MapDelegate> ();  	foreach (var view in inputViews.Cast<SqliteViewStore> ()) {  		var viewDelegate = view.Delegate;  		var mapBlock = viewDelegate == null ? null : viewDelegate.Map;  		if (mapBlock == null) {  			Debug.Assert (view != this' String.Format ("Cannot index view {0}: no map block registered"' view.Name));  			Log.To.View.V (Tag' "    {0} has no map block; skipping it"' view.Name);  			continue;  		}  		long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;  		if (last >= dbMaxSequence) {  			Log.To.View.V (Tag' "{0} is already up to date' skipping..."' view.Name);  			continue;  		}  		views.Add (view);  		mapBlocks.Add (mapBlock);  		int viewId = view.ViewID;  		Debug.Assert (viewId > 0' String.Format ("View '{0}' not found in database"' view.Name));  		int totalRows = view.TotalRows;  		viewTotalRows [viewId] = totalRows;  		viewLastSequence [i++] = last;  		if (last < 0) {  			throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Invalid last sequence indexed ({0}) received from {1}"' last' view);  		}  		if (last < dbMaxSequence) {  			minLastSequence = Math.Min (minLastSequence' last);  			Log.To.View.V (Tag' "    {0} last indexed at #{1}"' view.Name' last);  			string docType = viewDelegate.DocumentType;  			if (docType != null) {  				docTypes.Add (docType);  				if (viewDocTypes == null) {  					viewDocTypes = new Dictionary<string' string> ();  				}  				viewDocTypes [view.Name] = docType;  			} else {  				// can't filter by doc_type  				allDocTypes = true;  			}  			bool ok = true;  			int changes = 0;  			if (last == 0) {  				try {  					// If the lastSequence has been reset to 0' make sure to remove all map results:  					using (var changesCursor = db.StorageEngine.RawQuery (view.QueryString ("SELECT COUNT(*) FROM maps_#"))) {  						changes = changesCursor.GetInt (0);  					}  					view.DeleteIndex ();  					view.CreateIndex ();  				} catch (SQLitePCL.Ugly.ugly.sqlite3_exception e) {  					if (e.errcode == raw.SQLITE_MISUSE) {  						// Somehow' the maps table does not exist  						Log.To.View.I (Tag' "Maps table for view does not exist' trying to recover by creating it...");  						view.CreateIndex ();  					} else {  						ok = false;  					}  				} catch (Exception) {  					ok = false;  				}  			} else {  				db.OptimizeSQLIndexes ();  				// ensures query will use the right indexes  				// Delete all obsolete map results (ones from since-replaced revisions):  				try {  					changes = db.StorageEngine.ExecSQL (view.QueryString ("DELETE FROM 'maps_#' WHERE sequence IN (" + "SELECT parent FROM revs WHERE sequence>?" + "AND +parent>0 AND +parent<=?)")' last' last);  				} catch (Exception) {  					ok = false;  				}  			}  			if (!ok) {  				throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Error deleting obsolete map results before index update");  			}  			// Update #deleted rows  			deletedCount += changes;  			// Only count these deletes as changes if this isn't a view reset to 0  			if (last != 0) {  				viewTotalRows [viewId] -= changes;  			}  		}  	}  	if (minLastSequence == dbMaxSequence) {  		return true;  	}  	Log.To.View.I (Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."' ViewNames (views)' minLastSequence' dbMaxSequence);  	// This is the emit() block' which gets called from within the user-defined map() block  	// that's called down below.  	SqliteViewStore currentView = null;  	IDictionary<string' object> currentDoc = null;  	long sequence = minLastSequence;  	Status emitStatus = new Status (StatusCode.Ok);  	int insertedCount = 0;  	EmitDelegate emit = (key' value) => {  		if (key == null) {  			Log.To.View.W (Tag' "Emit function called with a null key; ignoring");  			return;  		}  		StatusCode s = currentView.Emit (key' value' value == currentDoc' sequence);  		if (s != StatusCode.Ok) {  			emitStatus.Code = s;  		} else {  			viewTotalRows [currentView.ViewID] += 1;  			insertedCount++;  		}  	};  	// Now scan every revision added since the last time the views were indexed:  	bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);  	var sql = new StringBuilder ("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");  	if (checkDocTypes) {  		sql.Append ("' doc_type ");  	}  	sql.Append ("FROM revs " + "JOIN docs ON docs.doc_id = revs.doc_id " + "WHERE sequence>? AND +current>0 ");  	if (minLastSequence == 0) {  		sql.Append ("AND +deleted=0 ");  	}  	if (!allDocTypes && docTypes.Count > 0) {  		sql.AppendFormat ("AND doc_type IN ({0}) "' Utility.JoinQuoted (docTypes));  	}  	sql.Append ("ORDER BY +revs.doc_id' +deleted' +revid DESC");  	Cursor c = null;  	Cursor c2 = null;  	try {  		c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  		bool keepGoing = c.MoveToNext ();  		while (keepGoing) {  			// Get row values now' before the code below advances 'c':  			long doc_id = c.GetLong (0);  			sequence = c.GetLong (1);  			string docId = c.GetString (2);  			if (docId.StartsWith ("_design/")) {  				// design documents don't get indexed  				keepGoing = c.MoveToNext ();  				continue;  			}  			var revId = c.GetString (3).AsRevID ();  			var json = c.GetBlob (4);  			bool deleted = c.GetInt (5) != 0;  			string docType = checkDocTypes ? c.GetString (6) : null;  			// Skip rows with the same doc_id -- these are losing conflicts.  			var conflicts = default(List<string>);  			while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  				if (conflicts == null) {  					conflicts = new List<string> ();  				}  				conflicts.Add (c.GetString (3));  			}  			long realSequence = sequence;  			// because sequence may be changed' below  			if (minLastSequence > 0) {  				// Find conflicts with documents from previous indexings.  				using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  					if (c2.MoveToNext ()) {  						var oldRevId = c2.GetString (0).AsRevID ();  						// This is the revision that used to be the 'winner'.  						// Remove its emitted rows:  						long oldSequence = c2.GetLong (1);  						foreach (var view in views) {  							int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  							deletedCount += changes;  							viewTotalRows [view.ViewID] -= changes;  						}  						if (deleted || oldRevId.CompareTo (revId) > 0) {  							// It still 'wins' the conflict' so it's the one that  							// should be mapped [again]' not the current revision!  							revId = oldRevId;  							deleted = false;  							sequence = oldSequence;  							json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  						}  						if (!deleted) {  							// Conflict revisions:  							if (conflicts == null) {  								conflicts = new List<string> ();  							}  							conflicts.Add (oldRevId.ToString ());  							while (c2.MoveToNext ()) {  								conflicts.Add (c2.GetString (0));  							}  						}  					}  				}  			}  			if (deleted) {  				continue;  			}  			// Get the document properties' to pass to the map function:  			currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  			if (currentDoc == null) {  				Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  				continue;  			}  			currentDoc ["_local_seq"] = sequence;  			if (conflicts != null) {  				currentDoc ["_conflicts"] = conflicts;  			}  			// Call the user-defined map() to emit new key/value pairs from this revision:  			int viewIndex = -1;  			var e = views.GetEnumerator ();  			while (e.MoveNext ()) {  				currentView = e.Current;  				++viewIndex;  				if (viewLastSequence [viewIndex] < realSequence) {  					if (checkDocTypes) {  						var viewDocType = viewDocTypes [currentView.Name];  						if (viewDocType != null && viewDocType != docType) {  							// skip; view's documentType doesn't match this doc  							continue;  						}  					}  					Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  					try {  						mapBlocks [viewIndex] (currentDoc' emit);  					} catch (Exception x) {  						Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  						emitStatus.Code = StatusCode.Exception;  					}  					if (emitStatus.IsError) {  						c.Dispose ();  						return false;  					}  				}  			}  			currentView = null;  		}  	} catch (CouchbaseLiteException) {  		Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  		throw;  	} catch (Exception e) {  		throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  	} finally {  		if (c != null) {  			c.Dispose ();  		}  	}  	// Finally' record the last revision sequence number that was indexed and update #rows:  	foreach (var view in views) {  		view.FinishCreatingIndex ();  		int newTotalRows = viewTotalRows [view.ViewID];  		Debug.Assert (newTotalRows >= 0);  		var args = new ContentValues ();  		args ["lastSequence"] = dbMaxSequence;  		args ["total_docs"] = newTotalRows;  		try {  			db.StorageEngine.Update ("views"' args' "view_id=?"' view.ViewID.ToString ());  		} catch (CouchbaseLiteException) {  			Log.To.View.E (Tag' "Failed to update view {0}' rethrowing..."' view.Name);  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating view {0}"' view.Name);  		}  	}  	Log.To.View.I (Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"' ViewNames (views)' dbMaxSequence' deletedCount' insertedCount);  	return true;  });  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction (() => {  	long dbMaxSequence = db.LastSequence;  	long forViewLastSequence = LastSequenceIndexed;  	// Check whether we need to update at all'  	// and remove obsolete emitted results from the 'maps' table:  	long minLastSequence = dbMaxSequence;  	long[] viewLastSequence = new long[inputViews.Count ()];  	int deletedCount = 0;  	int i = 0;  	HashSet<string> docTypes = new HashSet<string> ();  	IDictionary<string' string> viewDocTypes = null;  	bool allDocTypes = false;  	IDictionary<int' int> viewTotalRows = new Dictionary<int' int> ();  	List<SqliteViewStore> views = new List<SqliteViewStore> (inputViews.Count ());  	List<MapDelegate> mapBlocks = new List<MapDelegate> ();  	foreach (var view in inputViews.Cast<SqliteViewStore> ()) {  		var viewDelegate = view.Delegate;  		var mapBlock = viewDelegate == null ? null : viewDelegate.Map;  		if (mapBlock == null) {  			Debug.Assert (view != this' String.Format ("Cannot index view {0}: no map block registered"' view.Name));  			Log.To.View.V (Tag' "    {0} has no map block; skipping it"' view.Name);  			continue;  		}  		long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;  		if (last >= dbMaxSequence) {  			Log.To.View.V (Tag' "{0} is already up to date' skipping..."' view.Name);  			continue;  		}  		views.Add (view);  		mapBlocks.Add (mapBlock);  		int viewId = view.ViewID;  		Debug.Assert (viewId > 0' String.Format ("View '{0}' not found in database"' view.Name));  		int totalRows = view.TotalRows;  		viewTotalRows [viewId] = totalRows;  		viewLastSequence [i++] = last;  		if (last < 0) {  			throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Invalid last sequence indexed ({0}) received from {1}"' last' view);  		}  		if (last < dbMaxSequence) {  			minLastSequence = Math.Min (minLastSequence' last);  			Log.To.View.V (Tag' "    {0} last indexed at #{1}"' view.Name' last);  			string docType = viewDelegate.DocumentType;  			if (docType != null) {  				docTypes.Add (docType);  				if (viewDocTypes == null) {  					viewDocTypes = new Dictionary<string' string> ();  				}  				viewDocTypes [view.Name] = docType;  			} else {  				// can't filter by doc_type  				allDocTypes = true;  			}  			bool ok = true;  			int changes = 0;  			if (last == 0) {  				try {  					// If the lastSequence has been reset to 0' make sure to remove all map results:  					using (var changesCursor = db.StorageEngine.RawQuery (view.QueryString ("SELECT COUNT(*) FROM maps_#"))) {  						changes = changesCursor.GetInt (0);  					}  					view.DeleteIndex ();  					view.CreateIndex ();  				} catch (SQLitePCL.Ugly.ugly.sqlite3_exception e) {  					if (e.errcode == raw.SQLITE_MISUSE) {  						// Somehow' the maps table does not exist  						Log.To.View.I (Tag' "Maps table for view does not exist' trying to recover by creating it...");  						view.CreateIndex ();  					} else {  						ok = false;  					}  				} catch (Exception) {  					ok = false;  				}  			} else {  				db.OptimizeSQLIndexes ();  				// ensures query will use the right indexes  				// Delete all obsolete map results (ones from since-replaced revisions):  				try {  					changes = db.StorageEngine.ExecSQL (view.QueryString ("DELETE FROM 'maps_#' WHERE sequence IN (" + "SELECT parent FROM revs WHERE sequence>?" + "AND +parent>0 AND +parent<=?)")' last' last);  				} catch (Exception) {  					ok = false;  				}  			}  			if (!ok) {  				throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Error deleting obsolete map results before index update");  			}  			// Update #deleted rows  			deletedCount += changes;  			// Only count these deletes as changes if this isn't a view reset to 0  			if (last != 0) {  				viewTotalRows [viewId] -= changes;  			}  		}  	}  	if (minLastSequence == dbMaxSequence) {  		return true;  	}  	Log.To.View.I (Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."' ViewNames (views)' minLastSequence' dbMaxSequence);  	// This is the emit() block' which gets called from within the user-defined map() block  	// that's called down below.  	SqliteViewStore currentView = null;  	IDictionary<string' object> currentDoc = null;  	long sequence = minLastSequence;  	Status emitStatus = new Status (StatusCode.Ok);  	int insertedCount = 0;  	EmitDelegate emit = (key' value) => {  		if (key == null) {  			Log.To.View.W (Tag' "Emit function called with a null key; ignoring");  			return;  		}  		StatusCode s = currentView.Emit (key' value' value == currentDoc' sequence);  		if (s != StatusCode.Ok) {  			emitStatus.Code = s;  		} else {  			viewTotalRows [currentView.ViewID] += 1;  			insertedCount++;  		}  	};  	// Now scan every revision added since the last time the views were indexed:  	bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);  	var sql = new StringBuilder ("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");  	if (checkDocTypes) {  		sql.Append ("' doc_type ");  	}  	sql.Append ("FROM revs " + "JOIN docs ON docs.doc_id = revs.doc_id " + "WHERE sequence>? AND +current>0 ");  	if (minLastSequence == 0) {  		sql.Append ("AND +deleted=0 ");  	}  	if (!allDocTypes && docTypes.Count > 0) {  		sql.AppendFormat ("AND doc_type IN ({0}) "' Utility.JoinQuoted (docTypes));  	}  	sql.Append ("ORDER BY +revs.doc_id' +deleted' +revid DESC");  	Cursor c = null;  	Cursor c2 = null;  	try {  		c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  		bool keepGoing = c.MoveToNext ();  		while (keepGoing) {  			// Get row values now' before the code below advances 'c':  			long doc_id = c.GetLong (0);  			sequence = c.GetLong (1);  			string docId = c.GetString (2);  			if (docId.StartsWith ("_design/")) {  				// design documents don't get indexed  				keepGoing = c.MoveToNext ();  				continue;  			}  			var revId = c.GetString (3).AsRevID ();  			var json = c.GetBlob (4);  			bool deleted = c.GetInt (5) != 0;  			string docType = checkDocTypes ? c.GetString (6) : null;  			// Skip rows with the same doc_id -- these are losing conflicts.  			var conflicts = default(List<string>);  			while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  				if (conflicts == null) {  					conflicts = new List<string> ();  				}  				conflicts.Add (c.GetString (3));  			}  			long realSequence = sequence;  			// because sequence may be changed' below  			if (minLastSequence > 0) {  				// Find conflicts with documents from previous indexings.  				using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  					if (c2.MoveToNext ()) {  						var oldRevId = c2.GetString (0).AsRevID ();  						// This is the revision that used to be the 'winner'.  						// Remove its emitted rows:  						long oldSequence = c2.GetLong (1);  						foreach (var view in views) {  							int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  							deletedCount += changes;  							viewTotalRows [view.ViewID] -= changes;  						}  						if (deleted || oldRevId.CompareTo (revId) > 0) {  							// It still 'wins' the conflict' so it's the one that  							// should be mapped [again]' not the current revision!  							revId = oldRevId;  							deleted = false;  							sequence = oldSequence;  							json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  						}  						if (!deleted) {  							// Conflict revisions:  							if (conflicts == null) {  								conflicts = new List<string> ();  							}  							conflicts.Add (oldRevId.ToString ());  							while (c2.MoveToNext ()) {  								conflicts.Add (c2.GetString (0));  							}  						}  					}  				}  			}  			if (deleted) {  				continue;  			}  			// Get the document properties' to pass to the map function:  			currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  			if (currentDoc == null) {  				Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  				continue;  			}  			currentDoc ["_local_seq"] = sequence;  			if (conflicts != null) {  				currentDoc ["_conflicts"] = conflicts;  			}  			// Call the user-defined map() to emit new key/value pairs from this revision:  			int viewIndex = -1;  			var e = views.GetEnumerator ();  			while (e.MoveNext ()) {  				currentView = e.Current;  				++viewIndex;  				if (viewLastSequence [viewIndex] < realSequence) {  					if (checkDocTypes) {  						var viewDocType = viewDocTypes [currentView.Name];  						if (viewDocType != null && viewDocType != docType) {  							// skip; view's documentType doesn't match this doc  							continue;  						}  					}  					Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  					try {  						mapBlocks [viewIndex] (currentDoc' emit);  					} catch (Exception x) {  						Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  						emitStatus.Code = StatusCode.Exception;  					}  					if (emitStatus.IsError) {  						c.Dispose ();  						return false;  					}  				}  			}  			currentView = null;  		}  	} catch (CouchbaseLiteException) {  		Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  		throw;  	} catch (Exception e) {  		throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  	} finally {  		if (c != null) {  			c.Dispose ();  		}  	}  	// Finally' record the last revision sequence number that was indexed and update #rows:  	foreach (var view in views) {  		view.FinishCreatingIndex ();  		int newTotalRows = viewTotalRows [view.ViewID];  		Debug.Assert (newTotalRows >= 0);  		var args = new ContentValues ();  		args ["lastSequence"] = dbMaxSequence;  		args ["total_docs"] = newTotalRows;  		try {  			db.StorageEngine.Update ("views"' args' "view_id=?"' view.ViewID.ToString ());  		} catch (CouchbaseLiteException) {  			Log.To.View.E (Tag' "Failed to update view {0}' rethrowing..."' view.Name);  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating view {0}"' view.Name);  		}  	}  	Log.To.View.I (Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"' ViewNames (views)' dbMaxSequence' deletedCount' insertedCount);  	return true;  });  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction (() => {  	long dbMaxSequence = db.LastSequence;  	long forViewLastSequence = LastSequenceIndexed;  	// Check whether we need to update at all'  	// and remove obsolete emitted results from the 'maps' table:  	long minLastSequence = dbMaxSequence;  	long[] viewLastSequence = new long[inputViews.Count ()];  	int deletedCount = 0;  	int i = 0;  	HashSet<string> docTypes = new HashSet<string> ();  	IDictionary<string' string> viewDocTypes = null;  	bool allDocTypes = false;  	IDictionary<int' int> viewTotalRows = new Dictionary<int' int> ();  	List<SqliteViewStore> views = new List<SqliteViewStore> (inputViews.Count ());  	List<MapDelegate> mapBlocks = new List<MapDelegate> ();  	foreach (var view in inputViews.Cast<SqliteViewStore> ()) {  		var viewDelegate = view.Delegate;  		var mapBlock = viewDelegate == null ? null : viewDelegate.Map;  		if (mapBlock == null) {  			Debug.Assert (view != this' String.Format ("Cannot index view {0}: no map block registered"' view.Name));  			Log.To.View.V (Tag' "    {0} has no map block; skipping it"' view.Name);  			continue;  		}  		long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;  		if (last >= dbMaxSequence) {  			Log.To.View.V (Tag' "{0} is already up to date' skipping..."' view.Name);  			continue;  		}  		views.Add (view);  		mapBlocks.Add (mapBlock);  		int viewId = view.ViewID;  		Debug.Assert (viewId > 0' String.Format ("View '{0}' not found in database"' view.Name));  		int totalRows = view.TotalRows;  		viewTotalRows [viewId] = totalRows;  		viewLastSequence [i++] = last;  		if (last < 0) {  			throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Invalid last sequence indexed ({0}) received from {1}"' last' view);  		}  		if (last < dbMaxSequence) {  			minLastSequence = Math.Min (minLastSequence' last);  			Log.To.View.V (Tag' "    {0} last indexed at #{1}"' view.Name' last);  			string docType = viewDelegate.DocumentType;  			if (docType != null) {  				docTypes.Add (docType);  				if (viewDocTypes == null) {  					viewDocTypes = new Dictionary<string' string> ();  				}  				viewDocTypes [view.Name] = docType;  			} else {  				// can't filter by doc_type  				allDocTypes = true;  			}  			bool ok = true;  			int changes = 0;  			if (last == 0) {  				try {  					// If the lastSequence has been reset to 0' make sure to remove all map results:  					using (var changesCursor = db.StorageEngine.RawQuery (view.QueryString ("SELECT COUNT(*) FROM maps_#"))) {  						changes = changesCursor.GetInt (0);  					}  					view.DeleteIndex ();  					view.CreateIndex ();  				} catch (SQLitePCL.Ugly.ugly.sqlite3_exception e) {  					if (e.errcode == raw.SQLITE_MISUSE) {  						// Somehow' the maps table does not exist  						Log.To.View.I (Tag' "Maps table for view does not exist' trying to recover by creating it...");  						view.CreateIndex ();  					} else {  						ok = false;  					}  				} catch (Exception) {  					ok = false;  				}  			} else {  				db.OptimizeSQLIndexes ();  				// ensures query will use the right indexes  				// Delete all obsolete map results (ones from since-replaced revisions):  				try {  					changes = db.StorageEngine.ExecSQL (view.QueryString ("DELETE FROM 'maps_#' WHERE sequence IN (" + "SELECT parent FROM revs WHERE sequence>?" + "AND +parent>0 AND +parent<=?)")' last' last);  				} catch (Exception) {  					ok = false;  				}  			}  			if (!ok) {  				throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Error deleting obsolete map results before index update");  			}  			// Update #deleted rows  			deletedCount += changes;  			// Only count these deletes as changes if this isn't a view reset to 0  			if (last != 0) {  				viewTotalRows [viewId] -= changes;  			}  		}  	}  	if (minLastSequence == dbMaxSequence) {  		return true;  	}  	Log.To.View.I (Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."' ViewNames (views)' minLastSequence' dbMaxSequence);  	// This is the emit() block' which gets called from within the user-defined map() block  	// that's called down below.  	SqliteViewStore currentView = null;  	IDictionary<string' object> currentDoc = null;  	long sequence = minLastSequence;  	Status emitStatus = new Status (StatusCode.Ok);  	int insertedCount = 0;  	EmitDelegate emit = (key' value) => {  		if (key == null) {  			Log.To.View.W (Tag' "Emit function called with a null key; ignoring");  			return;  		}  		StatusCode s = currentView.Emit (key' value' value == currentDoc' sequence);  		if (s != StatusCode.Ok) {  			emitStatus.Code = s;  		} else {  			viewTotalRows [currentView.ViewID] += 1;  			insertedCount++;  		}  	};  	// Now scan every revision added since the last time the views were indexed:  	bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);  	var sql = new StringBuilder ("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");  	if (checkDocTypes) {  		sql.Append ("' doc_type ");  	}  	sql.Append ("FROM revs " + "JOIN docs ON docs.doc_id = revs.doc_id " + "WHERE sequence>? AND +current>0 ");  	if (minLastSequence == 0) {  		sql.Append ("AND +deleted=0 ");  	}  	if (!allDocTypes && docTypes.Count > 0) {  		sql.AppendFormat ("AND doc_type IN ({0}) "' Utility.JoinQuoted (docTypes));  	}  	sql.Append ("ORDER BY +revs.doc_id' +deleted' +revid DESC");  	Cursor c = null;  	Cursor c2 = null;  	try {  		c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  		bool keepGoing = c.MoveToNext ();  		while (keepGoing) {  			// Get row values now' before the code below advances 'c':  			long doc_id = c.GetLong (0);  			sequence = c.GetLong (1);  			string docId = c.GetString (2);  			if (docId.StartsWith ("_design/")) {  				// design documents don't get indexed  				keepGoing = c.MoveToNext ();  				continue;  			}  			var revId = c.GetString (3).AsRevID ();  			var json = c.GetBlob (4);  			bool deleted = c.GetInt (5) != 0;  			string docType = checkDocTypes ? c.GetString (6) : null;  			// Skip rows with the same doc_id -- these are losing conflicts.  			var conflicts = default(List<string>);  			while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  				if (conflicts == null) {  					conflicts = new List<string> ();  				}  				conflicts.Add (c.GetString (3));  			}  			long realSequence = sequence;  			// because sequence may be changed' below  			if (minLastSequence > 0) {  				// Find conflicts with documents from previous indexings.  				using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  					if (c2.MoveToNext ()) {  						var oldRevId = c2.GetString (0).AsRevID ();  						// This is the revision that used to be the 'winner'.  						// Remove its emitted rows:  						long oldSequence = c2.GetLong (1);  						foreach (var view in views) {  							int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  							deletedCount += changes;  							viewTotalRows [view.ViewID] -= changes;  						}  						if (deleted || oldRevId.CompareTo (revId) > 0) {  							// It still 'wins' the conflict' so it's the one that  							// should be mapped [again]' not the current revision!  							revId = oldRevId;  							deleted = false;  							sequence = oldSequence;  							json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  						}  						if (!deleted) {  							// Conflict revisions:  							if (conflicts == null) {  								conflicts = new List<string> ();  							}  							conflicts.Add (oldRevId.ToString ());  							while (c2.MoveToNext ()) {  								conflicts.Add (c2.GetString (0));  							}  						}  					}  				}  			}  			if (deleted) {  				continue;  			}  			// Get the document properties' to pass to the map function:  			currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  			if (currentDoc == null) {  				Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  				continue;  			}  			currentDoc ["_local_seq"] = sequence;  			if (conflicts != null) {  				currentDoc ["_conflicts"] = conflicts;  			}  			// Call the user-defined map() to emit new key/value pairs from this revision:  			int viewIndex = -1;  			var e = views.GetEnumerator ();  			while (e.MoveNext ()) {  				currentView = e.Current;  				++viewIndex;  				if (viewLastSequence [viewIndex] < realSequence) {  					if (checkDocTypes) {  						var viewDocType = viewDocTypes [currentView.Name];  						if (viewDocType != null && viewDocType != docType) {  							// skip; view's documentType doesn't match this doc  							continue;  						}  					}  					Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  					try {  						mapBlocks [viewIndex] (currentDoc' emit);  					} catch (Exception x) {  						Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  						emitStatus.Code = StatusCode.Exception;  					}  					if (emitStatus.IsError) {  						c.Dispose ();  						return false;  					}  				}  			}  			currentView = null;  		}  	} catch (CouchbaseLiteException) {  		Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  		throw;  	} catch (Exception e) {  		throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  	} finally {  		if (c != null) {  			c.Dispose ();  		}  	}  	// Finally' record the last revision sequence number that was indexed and update #rows:  	foreach (var view in views) {  		view.FinishCreatingIndex ();  		int newTotalRows = viewTotalRows [view.ViewID];  		Debug.Assert (newTotalRows >= 0);  		var args = new ContentValues ();  		args ["lastSequence"] = dbMaxSequence;  		args ["total_docs"] = newTotalRows;  		try {  			db.StorageEngine.Update ("views"' args' "view_id=?"' view.ViewID.ToString ());  		} catch (CouchbaseLiteException) {  			Log.To.View.E (Tag' "Failed to update view {0}' rethrowing..."' view.Name);  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating view {0}"' view.Name);  		}  	}  	Log.To.View.I (Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"' ViewNames (views)' dbMaxSequence' deletedCount' insertedCount);  	return true;  });  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction (() => {  	long dbMaxSequence = db.LastSequence;  	long forViewLastSequence = LastSequenceIndexed;  	// Check whether we need to update at all'  	// and remove obsolete emitted results from the 'maps' table:  	long minLastSequence = dbMaxSequence;  	long[] viewLastSequence = new long[inputViews.Count ()];  	int deletedCount = 0;  	int i = 0;  	HashSet<string> docTypes = new HashSet<string> ();  	IDictionary<string' string> viewDocTypes = null;  	bool allDocTypes = false;  	IDictionary<int' int> viewTotalRows = new Dictionary<int' int> ();  	List<SqliteViewStore> views = new List<SqliteViewStore> (inputViews.Count ());  	List<MapDelegate> mapBlocks = new List<MapDelegate> ();  	foreach (var view in inputViews.Cast<SqliteViewStore> ()) {  		var viewDelegate = view.Delegate;  		var mapBlock = viewDelegate == null ? null : viewDelegate.Map;  		if (mapBlock == null) {  			Debug.Assert (view != this' String.Format ("Cannot index view {0}: no map block registered"' view.Name));  			Log.To.View.V (Tag' "    {0} has no map block; skipping it"' view.Name);  			continue;  		}  		long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;  		if (last >= dbMaxSequence) {  			Log.To.View.V (Tag' "{0} is already up to date' skipping..."' view.Name);  			continue;  		}  		views.Add (view);  		mapBlocks.Add (mapBlock);  		int viewId = view.ViewID;  		Debug.Assert (viewId > 0' String.Format ("View '{0}' not found in database"' view.Name));  		int totalRows = view.TotalRows;  		viewTotalRows [viewId] = totalRows;  		viewLastSequence [i++] = last;  		if (last < 0) {  			throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Invalid last sequence indexed ({0}) received from {1}"' last' view);  		}  		if (last < dbMaxSequence) {  			minLastSequence = Math.Min (minLastSequence' last);  			Log.To.View.V (Tag' "    {0} last indexed at #{1}"' view.Name' last);  			string docType = viewDelegate.DocumentType;  			if (docType != null) {  				docTypes.Add (docType);  				if (viewDocTypes == null) {  					viewDocTypes = new Dictionary<string' string> ();  				}  				viewDocTypes [view.Name] = docType;  			} else {  				// can't filter by doc_type  				allDocTypes = true;  			}  			bool ok = true;  			int changes = 0;  			if (last == 0) {  				try {  					// If the lastSequence has been reset to 0' make sure to remove all map results:  					using (var changesCursor = db.StorageEngine.RawQuery (view.QueryString ("SELECT COUNT(*) FROM maps_#"))) {  						changes = changesCursor.GetInt (0);  					}  					view.DeleteIndex ();  					view.CreateIndex ();  				} catch (SQLitePCL.Ugly.ugly.sqlite3_exception e) {  					if (e.errcode == raw.SQLITE_MISUSE) {  						// Somehow' the maps table does not exist  						Log.To.View.I (Tag' "Maps table for view does not exist' trying to recover by creating it...");  						view.CreateIndex ();  					} else {  						ok = false;  					}  				} catch (Exception) {  					ok = false;  				}  			} else {  				db.OptimizeSQLIndexes ();  				// ensures query will use the right indexes  				// Delete all obsolete map results (ones from since-replaced revisions):  				try {  					changes = db.StorageEngine.ExecSQL (view.QueryString ("DELETE FROM 'maps_#' WHERE sequence IN (" + "SELECT parent FROM revs WHERE sequence>?" + "AND +parent>0 AND +parent<=?)")' last' last);  				} catch (Exception) {  					ok = false;  				}  			}  			if (!ok) {  				throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Error deleting obsolete map results before index update");  			}  			// Update #deleted rows  			deletedCount += changes;  			// Only count these deletes as changes if this isn't a view reset to 0  			if (last != 0) {  				viewTotalRows [viewId] -= changes;  			}  		}  	}  	if (minLastSequence == dbMaxSequence) {  		return true;  	}  	Log.To.View.I (Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."' ViewNames (views)' minLastSequence' dbMaxSequence);  	// This is the emit() block' which gets called from within the user-defined map() block  	// that's called down below.  	SqliteViewStore currentView = null;  	IDictionary<string' object> currentDoc = null;  	long sequence = minLastSequence;  	Status emitStatus = new Status (StatusCode.Ok);  	int insertedCount = 0;  	EmitDelegate emit = (key' value) => {  		if (key == null) {  			Log.To.View.W (Tag' "Emit function called with a null key; ignoring");  			return;  		}  		StatusCode s = currentView.Emit (key' value' value == currentDoc' sequence);  		if (s != StatusCode.Ok) {  			emitStatus.Code = s;  		} else {  			viewTotalRows [currentView.ViewID] += 1;  			insertedCount++;  		}  	};  	// Now scan every revision added since the last time the views were indexed:  	bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);  	var sql = new StringBuilder ("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");  	if (checkDocTypes) {  		sql.Append ("' doc_type ");  	}  	sql.Append ("FROM revs " + "JOIN docs ON docs.doc_id = revs.doc_id " + "WHERE sequence>? AND +current>0 ");  	if (minLastSequence == 0) {  		sql.Append ("AND +deleted=0 ");  	}  	if (!allDocTypes && docTypes.Count > 0) {  		sql.AppendFormat ("AND doc_type IN ({0}) "' Utility.JoinQuoted (docTypes));  	}  	sql.Append ("ORDER BY +revs.doc_id' +deleted' +revid DESC");  	Cursor c = null;  	Cursor c2 = null;  	try {  		c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  		bool keepGoing = c.MoveToNext ();  		while (keepGoing) {  			// Get row values now' before the code below advances 'c':  			long doc_id = c.GetLong (0);  			sequence = c.GetLong (1);  			string docId = c.GetString (2);  			if (docId.StartsWith ("_design/")) {  				// design documents don't get indexed  				keepGoing = c.MoveToNext ();  				continue;  			}  			var revId = c.GetString (3).AsRevID ();  			var json = c.GetBlob (4);  			bool deleted = c.GetInt (5) != 0;  			string docType = checkDocTypes ? c.GetString (6) : null;  			// Skip rows with the same doc_id -- these are losing conflicts.  			var conflicts = default(List<string>);  			while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  				if (conflicts == null) {  					conflicts = new List<string> ();  				}  				conflicts.Add (c.GetString (3));  			}  			long realSequence = sequence;  			// because sequence may be changed' below  			if (minLastSequence > 0) {  				// Find conflicts with documents from previous indexings.  				using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  					if (c2.MoveToNext ()) {  						var oldRevId = c2.GetString (0).AsRevID ();  						// This is the revision that used to be the 'winner'.  						// Remove its emitted rows:  						long oldSequence = c2.GetLong (1);  						foreach (var view in views) {  							int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  							deletedCount += changes;  							viewTotalRows [view.ViewID] -= changes;  						}  						if (deleted || oldRevId.CompareTo (revId) > 0) {  							// It still 'wins' the conflict' so it's the one that  							// should be mapped [again]' not the current revision!  							revId = oldRevId;  							deleted = false;  							sequence = oldSequence;  							json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  						}  						if (!deleted) {  							// Conflict revisions:  							if (conflicts == null) {  								conflicts = new List<string> ();  							}  							conflicts.Add (oldRevId.ToString ());  							while (c2.MoveToNext ()) {  								conflicts.Add (c2.GetString (0));  							}  						}  					}  				}  			}  			if (deleted) {  				continue;  			}  			// Get the document properties' to pass to the map function:  			currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  			if (currentDoc == null) {  				Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  				continue;  			}  			currentDoc ["_local_seq"] = sequence;  			if (conflicts != null) {  				currentDoc ["_conflicts"] = conflicts;  			}  			// Call the user-defined map() to emit new key/value pairs from this revision:  			int viewIndex = -1;  			var e = views.GetEnumerator ();  			while (e.MoveNext ()) {  				currentView = e.Current;  				++viewIndex;  				if (viewLastSequence [viewIndex] < realSequence) {  					if (checkDocTypes) {  						var viewDocType = viewDocTypes [currentView.Name];  						if (viewDocType != null && viewDocType != docType) {  							// skip; view's documentType doesn't match this doc  							continue;  						}  					}  					Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  					try {  						mapBlocks [viewIndex] (currentDoc' emit);  					} catch (Exception x) {  						Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  						emitStatus.Code = StatusCode.Exception;  					}  					if (emitStatus.IsError) {  						c.Dispose ();  						return false;  					}  				}  			}  			currentView = null;  		}  	} catch (CouchbaseLiteException) {  		Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  		throw;  	} catch (Exception e) {  		throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  	} finally {  		if (c != null) {  			c.Dispose ();  		}  	}  	// Finally' record the last revision sequence number that was indexed and update #rows:  	foreach (var view in views) {  		view.FinishCreatingIndex ();  		int newTotalRows = viewTotalRows [view.ViewID];  		Debug.Assert (newTotalRows >= 0);  		var args = new ContentValues ();  		args ["lastSequence"] = dbMaxSequence;  		args ["total_docs"] = newTotalRows;  		try {  			db.StorageEngine.Update ("views"' args' "view_id=?"' view.ViewID.ToString ());  		} catch (CouchbaseLiteException) {  			Log.To.View.E (Tag' "Failed to update view {0}' rethrowing..."' view.Name);  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating view {0}"' view.Name);  		}  	}  	Log.To.View.I (Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"' ViewNames (views)' dbMaxSequence' deletedCount' insertedCount);  	return true;  });  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction (() => {  	long dbMaxSequence = db.LastSequence;  	long forViewLastSequence = LastSequenceIndexed;  	// Check whether we need to update at all'  	// and remove obsolete emitted results from the 'maps' table:  	long minLastSequence = dbMaxSequence;  	long[] viewLastSequence = new long[inputViews.Count ()];  	int deletedCount = 0;  	int i = 0;  	HashSet<string> docTypes = new HashSet<string> ();  	IDictionary<string' string> viewDocTypes = null;  	bool allDocTypes = false;  	IDictionary<int' int> viewTotalRows = new Dictionary<int' int> ();  	List<SqliteViewStore> views = new List<SqliteViewStore> (inputViews.Count ());  	List<MapDelegate> mapBlocks = new List<MapDelegate> ();  	foreach (var view in inputViews.Cast<SqliteViewStore> ()) {  		var viewDelegate = view.Delegate;  		var mapBlock = viewDelegate == null ? null : viewDelegate.Map;  		if (mapBlock == null) {  			Debug.Assert (view != this' String.Format ("Cannot index view {0}: no map block registered"' view.Name));  			Log.To.View.V (Tag' "    {0} has no map block; skipping it"' view.Name);  			continue;  		}  		long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;  		if (last >= dbMaxSequence) {  			Log.To.View.V (Tag' "{0} is already up to date' skipping..."' view.Name);  			continue;  		}  		views.Add (view);  		mapBlocks.Add (mapBlock);  		int viewId = view.ViewID;  		Debug.Assert (viewId > 0' String.Format ("View '{0}' not found in database"' view.Name));  		int totalRows = view.TotalRows;  		viewTotalRows [viewId] = totalRows;  		viewLastSequence [i++] = last;  		if (last < 0) {  			throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Invalid last sequence indexed ({0}) received from {1}"' last' view);  		}  		if (last < dbMaxSequence) {  			minLastSequence = Math.Min (minLastSequence' last);  			Log.To.View.V (Tag' "    {0} last indexed at #{1}"' view.Name' last);  			string docType = viewDelegate.DocumentType;  			if (docType != null) {  				docTypes.Add (docType);  				if (viewDocTypes == null) {  					viewDocTypes = new Dictionary<string' string> ();  				}  				viewDocTypes [view.Name] = docType;  			} else {  				// can't filter by doc_type  				allDocTypes = true;  			}  			bool ok = true;  			int changes = 0;  			if (last == 0) {  				try {  					// If the lastSequence has been reset to 0' make sure to remove all map results:  					using (var changesCursor = db.StorageEngine.RawQuery (view.QueryString ("SELECT COUNT(*) FROM maps_#"))) {  						changes = changesCursor.GetInt (0);  					}  					view.DeleteIndex ();  					view.CreateIndex ();  				} catch (SQLitePCL.Ugly.ugly.sqlite3_exception e) {  					if (e.errcode == raw.SQLITE_MISUSE) {  						// Somehow' the maps table does not exist  						Log.To.View.I (Tag' "Maps table for view does not exist' trying to recover by creating it...");  						view.CreateIndex ();  					} else {  						ok = false;  					}  				} catch (Exception) {  					ok = false;  				}  			} else {  				db.OptimizeSQLIndexes ();  				// ensures query will use the right indexes  				// Delete all obsolete map results (ones from since-replaced revisions):  				try {  					changes = db.StorageEngine.ExecSQL (view.QueryString ("DELETE FROM 'maps_#' WHERE sequence IN (" + "SELECT parent FROM revs WHERE sequence>?" + "AND +parent>0 AND +parent<=?)")' last' last);  				} catch (Exception) {  					ok = false;  				}  			}  			if (!ok) {  				throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Error deleting obsolete map results before index update");  			}  			// Update #deleted rows  			deletedCount += changes;  			// Only count these deletes as changes if this isn't a view reset to 0  			if (last != 0) {  				viewTotalRows [viewId] -= changes;  			}  		}  	}  	if (minLastSequence == dbMaxSequence) {  		return true;  	}  	Log.To.View.I (Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."' ViewNames (views)' minLastSequence' dbMaxSequence);  	// This is the emit() block' which gets called from within the user-defined map() block  	// that's called down below.  	SqliteViewStore currentView = null;  	IDictionary<string' object> currentDoc = null;  	long sequence = minLastSequence;  	Status emitStatus = new Status (StatusCode.Ok);  	int insertedCount = 0;  	EmitDelegate emit = (key' value) => {  		if (key == null) {  			Log.To.View.W (Tag' "Emit function called with a null key; ignoring");  			return;  		}  		StatusCode s = currentView.Emit (key' value' value == currentDoc' sequence);  		if (s != StatusCode.Ok) {  			emitStatus.Code = s;  		} else {  			viewTotalRows [currentView.ViewID] += 1;  			insertedCount++;  		}  	};  	// Now scan every revision added since the last time the views were indexed:  	bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);  	var sql = new StringBuilder ("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");  	if (checkDocTypes) {  		sql.Append ("' doc_type ");  	}  	sql.Append ("FROM revs " + "JOIN docs ON docs.doc_id = revs.doc_id " + "WHERE sequence>? AND +current>0 ");  	if (minLastSequence == 0) {  		sql.Append ("AND +deleted=0 ");  	}  	if (!allDocTypes && docTypes.Count > 0) {  		sql.AppendFormat ("AND doc_type IN ({0}) "' Utility.JoinQuoted (docTypes));  	}  	sql.Append ("ORDER BY +revs.doc_id' +deleted' +revid DESC");  	Cursor c = null;  	Cursor c2 = null;  	try {  		c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  		bool keepGoing = c.MoveToNext ();  		while (keepGoing) {  			// Get row values now' before the code below advances 'c':  			long doc_id = c.GetLong (0);  			sequence = c.GetLong (1);  			string docId = c.GetString (2);  			if (docId.StartsWith ("_design/")) {  				// design documents don't get indexed  				keepGoing = c.MoveToNext ();  				continue;  			}  			var revId = c.GetString (3).AsRevID ();  			var json = c.GetBlob (4);  			bool deleted = c.GetInt (5) != 0;  			string docType = checkDocTypes ? c.GetString (6) : null;  			// Skip rows with the same doc_id -- these are losing conflicts.  			var conflicts = default(List<string>);  			while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  				if (conflicts == null) {  					conflicts = new List<string> ();  				}  				conflicts.Add (c.GetString (3));  			}  			long realSequence = sequence;  			// because sequence may be changed' below  			if (minLastSequence > 0) {  				// Find conflicts with documents from previous indexings.  				using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  					if (c2.MoveToNext ()) {  						var oldRevId = c2.GetString (0).AsRevID ();  						// This is the revision that used to be the 'winner'.  						// Remove its emitted rows:  						long oldSequence = c2.GetLong (1);  						foreach (var view in views) {  							int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  							deletedCount += changes;  							viewTotalRows [view.ViewID] -= changes;  						}  						if (deleted || oldRevId.CompareTo (revId) > 0) {  							// It still 'wins' the conflict' so it's the one that  							// should be mapped [again]' not the current revision!  							revId = oldRevId;  							deleted = false;  							sequence = oldSequence;  							json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  						}  						if (!deleted) {  							// Conflict revisions:  							if (conflicts == null) {  								conflicts = new List<string> ();  							}  							conflicts.Add (oldRevId.ToString ());  							while (c2.MoveToNext ()) {  								conflicts.Add (c2.GetString (0));  							}  						}  					}  				}  			}  			if (deleted) {  				continue;  			}  			// Get the document properties' to pass to the map function:  			currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  			if (currentDoc == null) {  				Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  				continue;  			}  			currentDoc ["_local_seq"] = sequence;  			if (conflicts != null) {  				currentDoc ["_conflicts"] = conflicts;  			}  			// Call the user-defined map() to emit new key/value pairs from this revision:  			int viewIndex = -1;  			var e = views.GetEnumerator ();  			while (e.MoveNext ()) {  				currentView = e.Current;  				++viewIndex;  				if (viewLastSequence [viewIndex] < realSequence) {  					if (checkDocTypes) {  						var viewDocType = viewDocTypes [currentView.Name];  						if (viewDocType != null && viewDocType != docType) {  							// skip; view's documentType doesn't match this doc  							continue;  						}  					}  					Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  					try {  						mapBlocks [viewIndex] (currentDoc' emit);  					} catch (Exception x) {  						Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  						emitStatus.Code = StatusCode.Exception;  					}  					if (emitStatus.IsError) {  						c.Dispose ();  						return false;  					}  				}  			}  			currentView = null;  		}  	} catch (CouchbaseLiteException) {  		Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  		throw;  	} catch (Exception e) {  		throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  	} finally {  		if (c != null) {  			c.Dispose ();  		}  	}  	// Finally' record the last revision sequence number that was indexed and update #rows:  	foreach (var view in views) {  		view.FinishCreatingIndex ();  		int newTotalRows = viewTotalRows [view.ViewID];  		Debug.Assert (newTotalRows >= 0);  		var args = new ContentValues ();  		args ["lastSequence"] = dbMaxSequence;  		args ["total_docs"] = newTotalRows;  		try {  			db.StorageEngine.Update ("views"' args' "view_id=?"' view.ViewID.ToString ());  		} catch (CouchbaseLiteException) {  			Log.To.View.E (Tag' "Failed to update view {0}' rethrowing..."' view.Name);  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating view {0}"' view.Name);  		}  	}  	Log.To.View.I (Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"' ViewNames (views)' dbMaxSequence' deletedCount' insertedCount);  	return true;  });  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction (() => {  	long dbMaxSequence = db.LastSequence;  	long forViewLastSequence = LastSequenceIndexed;  	// Check whether we need to update at all'  	// and remove obsolete emitted results from the 'maps' table:  	long minLastSequence = dbMaxSequence;  	long[] viewLastSequence = new long[inputViews.Count ()];  	int deletedCount = 0;  	int i = 0;  	HashSet<string> docTypes = new HashSet<string> ();  	IDictionary<string' string> viewDocTypes = null;  	bool allDocTypes = false;  	IDictionary<int' int> viewTotalRows = new Dictionary<int' int> ();  	List<SqliteViewStore> views = new List<SqliteViewStore> (inputViews.Count ());  	List<MapDelegate> mapBlocks = new List<MapDelegate> ();  	foreach (var view in inputViews.Cast<SqliteViewStore> ()) {  		var viewDelegate = view.Delegate;  		var mapBlock = viewDelegate == null ? null : viewDelegate.Map;  		if (mapBlock == null) {  			Debug.Assert (view != this' String.Format ("Cannot index view {0}: no map block registered"' view.Name));  			Log.To.View.V (Tag' "    {0} has no map block; skipping it"' view.Name);  			continue;  		}  		long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;  		if (last >= dbMaxSequence) {  			Log.To.View.V (Tag' "{0} is already up to date' skipping..."' view.Name);  			continue;  		}  		views.Add (view);  		mapBlocks.Add (mapBlock);  		int viewId = view.ViewID;  		Debug.Assert (viewId > 0' String.Format ("View '{0}' not found in database"' view.Name));  		int totalRows = view.TotalRows;  		viewTotalRows [viewId] = totalRows;  		viewLastSequence [i++] = last;  		if (last < 0) {  			throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Invalid last sequence indexed ({0}) received from {1}"' last' view);  		}  		if (last < dbMaxSequence) {  			minLastSequence = Math.Min (minLastSequence' last);  			Log.To.View.V (Tag' "    {0} last indexed at #{1}"' view.Name' last);  			string docType = viewDelegate.DocumentType;  			if (docType != null) {  				docTypes.Add (docType);  				if (viewDocTypes == null) {  					viewDocTypes = new Dictionary<string' string> ();  				}  				viewDocTypes [view.Name] = docType;  			} else {  				// can't filter by doc_type  				allDocTypes = true;  			}  			bool ok = true;  			int changes = 0;  			if (last == 0) {  				try {  					// If the lastSequence has been reset to 0' make sure to remove all map results:  					using (var changesCursor = db.StorageEngine.RawQuery (view.QueryString ("SELECT COUNT(*) FROM maps_#"))) {  						changes = changesCursor.GetInt (0);  					}  					view.DeleteIndex ();  					view.CreateIndex ();  				} catch (SQLitePCL.Ugly.ugly.sqlite3_exception e) {  					if (e.errcode == raw.SQLITE_MISUSE) {  						// Somehow' the maps table does not exist  						Log.To.View.I (Tag' "Maps table for view does not exist' trying to recover by creating it...");  						view.CreateIndex ();  					} else {  						ok = false;  					}  				} catch (Exception) {  					ok = false;  				}  			} else {  				db.OptimizeSQLIndexes ();  				// ensures query will use the right indexes  				// Delete all obsolete map results (ones from since-replaced revisions):  				try {  					changes = db.StorageEngine.ExecSQL (view.QueryString ("DELETE FROM 'maps_#' WHERE sequence IN (" + "SELECT parent FROM revs WHERE sequence>?" + "AND +parent>0 AND +parent<=?)")' last' last);  				} catch (Exception) {  					ok = false;  				}  			}  			if (!ok) {  				throw Misc.CreateExceptionAndLog (Log.To.View' StatusCode.DbError' Tag' "Error deleting obsolete map results before index update");  			}  			// Update #deleted rows  			deletedCount += changes;  			// Only count these deletes as changes if this isn't a view reset to 0  			if (last != 0) {  				viewTotalRows [viewId] -= changes;  			}  		}  	}  	if (minLastSequence == dbMaxSequence) {  		return true;  	}  	Log.To.View.I (Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."' ViewNames (views)' minLastSequence' dbMaxSequence);  	// This is the emit() block' which gets called from within the user-defined map() block  	// that's called down below.  	SqliteViewStore currentView = null;  	IDictionary<string' object> currentDoc = null;  	long sequence = minLastSequence;  	Status emitStatus = new Status (StatusCode.Ok);  	int insertedCount = 0;  	EmitDelegate emit = (key' value) => {  		if (key == null) {  			Log.To.View.W (Tag' "Emit function called with a null key; ignoring");  			return;  		}  		StatusCode s = currentView.Emit (key' value' value == currentDoc' sequence);  		if (s != StatusCode.Ok) {  			emitStatus.Code = s;  		} else {  			viewTotalRows [currentView.ViewID] += 1;  			insertedCount++;  		}  	};  	// Now scan every revision added since the last time the views were indexed:  	bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);  	var sql = new StringBuilder ("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");  	if (checkDocTypes) {  		sql.Append ("' doc_type ");  	}  	sql.Append ("FROM revs " + "JOIN docs ON docs.doc_id = revs.doc_id " + "WHERE sequence>? AND +current>0 ");  	if (minLastSequence == 0) {  		sql.Append ("AND +deleted=0 ");  	}  	if (!allDocTypes && docTypes.Count > 0) {  		sql.AppendFormat ("AND doc_type IN ({0}) "' Utility.JoinQuoted (docTypes));  	}  	sql.Append ("ORDER BY +revs.doc_id' +deleted' +revid DESC");  	Cursor c = null;  	Cursor c2 = null;  	try {  		c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  		bool keepGoing = c.MoveToNext ();  		while (keepGoing) {  			// Get row values now' before the code below advances 'c':  			long doc_id = c.GetLong (0);  			sequence = c.GetLong (1);  			string docId = c.GetString (2);  			if (docId.StartsWith ("_design/")) {  				// design documents don't get indexed  				keepGoing = c.MoveToNext ();  				continue;  			}  			var revId = c.GetString (3).AsRevID ();  			var json = c.GetBlob (4);  			bool deleted = c.GetInt (5) != 0;  			string docType = checkDocTypes ? c.GetString (6) : null;  			// Skip rows with the same doc_id -- these are losing conflicts.  			var conflicts = default(List<string>);  			while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  				if (conflicts == null) {  					conflicts = new List<string> ();  				}  				conflicts.Add (c.GetString (3));  			}  			long realSequence = sequence;  			// because sequence may be changed' below  			if (minLastSequence > 0) {  				// Find conflicts with documents from previous indexings.  				using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  					if (c2.MoveToNext ()) {  						var oldRevId = c2.GetString (0).AsRevID ();  						// This is the revision that used to be the 'winner'.  						// Remove its emitted rows:  						long oldSequence = c2.GetLong (1);  						foreach (var view in views) {  							int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  							deletedCount += changes;  							viewTotalRows [view.ViewID] -= changes;  						}  						if (deleted || oldRevId.CompareTo (revId) > 0) {  							// It still 'wins' the conflict' so it's the one that  							// should be mapped [again]' not the current revision!  							revId = oldRevId;  							deleted = false;  							sequence = oldSequence;  							json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  						}  						if (!deleted) {  							// Conflict revisions:  							if (conflicts == null) {  								conflicts = new List<string> ();  							}  							conflicts.Add (oldRevId.ToString ());  							while (c2.MoveToNext ()) {  								conflicts.Add (c2.GetString (0));  							}  						}  					}  				}  			}  			if (deleted) {  				continue;  			}  			// Get the document properties' to pass to the map function:  			currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  			if (currentDoc == null) {  				Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  				continue;  			}  			currentDoc ["_local_seq"] = sequence;  			if (conflicts != null) {  				currentDoc ["_conflicts"] = conflicts;  			}  			// Call the user-defined map() to emit new key/value pairs from this revision:  			int viewIndex = -1;  			var e = views.GetEnumerator ();  			while (e.MoveNext ()) {  				currentView = e.Current;  				++viewIndex;  				if (viewLastSequence [viewIndex] < realSequence) {  					if (checkDocTypes) {  						var viewDocType = viewDocTypes [currentView.Name];  						if (viewDocType != null && viewDocType != docType) {  							// skip; view's documentType doesn't match this doc  							continue;  						}  					}  					Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  					try {  						mapBlocks [viewIndex] (currentDoc' emit);  					} catch (Exception x) {  						Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  						emitStatus.Code = StatusCode.Exception;  					}  					if (emitStatus.IsError) {  						c.Dispose ();  						return false;  					}  				}  			}  			currentView = null;  		}  	} catch (CouchbaseLiteException) {  		Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  		throw;  	} catch (Exception e) {  		throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  	} finally {  		if (c != null) {  			c.Dispose ();  		}  	}  	// Finally' record the last revision sequence number that was indexed and update #rows:  	foreach (var view in views) {  		view.FinishCreatingIndex ();  		int newTotalRows = viewTotalRows [view.ViewID];  		Debug.Assert (newTotalRows >= 0);  		var args = new ContentValues ();  		args ["lastSequence"] = dbMaxSequence;  		args ["total_docs"] = newTotalRows;  		try {  			db.StorageEngine.Update ("views"' args' "view_id=?"' view.ViewID.ToString ());  		} catch (CouchbaseLiteException) {  			Log.To.View.E (Tag' "Failed to update view {0}' rethrowing..."' view.Name);  			throw;  		} catch (Exception e) {  			throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating view {0}"' view.Name);  		}  	}  	Log.To.View.I (Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"' ViewNames (views)' dbMaxSequence' deletedCount' insertedCount);  	return true;  });  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: try {  	c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		// Get row values now' before the code below advances 'c':  		long doc_id = c.GetLong (0);  		sequence = c.GetLong (1);  		string docId = c.GetString (2);  		if (docId.StartsWith ("_design/")) {  			// design documents don't get indexed  			keepGoing = c.MoveToNext ();  			continue;  		}  		var revId = c.GetString (3).AsRevID ();  		var json = c.GetBlob (4);  		bool deleted = c.GetInt (5) != 0;  		string docType = checkDocTypes ? c.GetString (6) : null;  		// Skip rows with the same doc_id -- these are losing conflicts.  		var conflicts = default(List<string>);  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  			if (conflicts == null) {  				conflicts = new List<string> ();  			}  			conflicts.Add (c.GetString (3));  		}  		long realSequence = sequence;  		// because sequence may be changed' below  		if (minLastSequence > 0) {  			// Find conflicts with documents from previous indexings.  			using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  				if (c2.MoveToNext ()) {  					var oldRevId = c2.GetString (0).AsRevID ();  					// This is the revision that used to be the 'winner'.  					// Remove its emitted rows:  					long oldSequence = c2.GetLong (1);  					foreach (var view in views) {  						int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  						deletedCount += changes;  						viewTotalRows [view.ViewID] -= changes;  					}  					if (deleted || oldRevId.CompareTo (revId) > 0) {  						// It still 'wins' the conflict' so it's the one that  						// should be mapped [again]' not the current revision!  						revId = oldRevId;  						deleted = false;  						sequence = oldSequence;  						json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  					}  					if (!deleted) {  						// Conflict revisions:  						if (conflicts == null) {  							conflicts = new List<string> ();  						}  						conflicts.Add (oldRevId.ToString ());  						while (c2.MoveToNext ()) {  							conflicts.Add (c2.GetString (0));  						}  					}  				}  			}  		}  		if (deleted) {  			continue;  		}  		// Get the document properties' to pass to the map function:  		currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  		if (currentDoc == null) {  			Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  			continue;  		}  		currentDoc ["_local_seq"] = sequence;  		if (conflicts != null) {  			currentDoc ["_conflicts"] = conflicts;  		}  		// Call the user-defined map() to emit new key/value pairs from this revision:  		int viewIndex = -1;  		var e = views.GetEnumerator ();  		while (e.MoveNext ()) {  			currentView = e.Current;  			++viewIndex;  			if (viewLastSequence [viewIndex] < realSequence) {  				if (checkDocTypes) {  					var viewDocType = viewDocTypes [currentView.Name];  					if (viewDocType != null && viewDocType != docType) {  						// skip; view's documentType doesn't match this doc  						continue;  					}  				}  				Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  				try {  					mapBlocks [viewIndex] (currentDoc' emit);  				} catch (Exception x) {  					Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  					emitStatus.Code = StatusCode.Exception;  				}  				if (emitStatus.IsError) {  					c.Dispose ();  					return false;  				}  			}  		}  		currentView = null;  	}  } catch (CouchbaseLiteException) {  	Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  	throw;  } catch (Exception e) {  	throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  } finally {  	if (c != null) {  		c.Dispose ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: try {  	c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		// Get row values now' before the code below advances 'c':  		long doc_id = c.GetLong (0);  		sequence = c.GetLong (1);  		string docId = c.GetString (2);  		if (docId.StartsWith ("_design/")) {  			// design documents don't get indexed  			keepGoing = c.MoveToNext ();  			continue;  		}  		var revId = c.GetString (3).AsRevID ();  		var json = c.GetBlob (4);  		bool deleted = c.GetInt (5) != 0;  		string docType = checkDocTypes ? c.GetString (6) : null;  		// Skip rows with the same doc_id -- these are losing conflicts.  		var conflicts = default(List<string>);  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  			if (conflicts == null) {  				conflicts = new List<string> ();  			}  			conflicts.Add (c.GetString (3));  		}  		long realSequence = sequence;  		// because sequence may be changed' below  		if (minLastSequence > 0) {  			// Find conflicts with documents from previous indexings.  			using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  				if (c2.MoveToNext ()) {  					var oldRevId = c2.GetString (0).AsRevID ();  					// This is the revision that used to be the 'winner'.  					// Remove its emitted rows:  					long oldSequence = c2.GetLong (1);  					foreach (var view in views) {  						int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  						deletedCount += changes;  						viewTotalRows [view.ViewID] -= changes;  					}  					if (deleted || oldRevId.CompareTo (revId) > 0) {  						// It still 'wins' the conflict' so it's the one that  						// should be mapped [again]' not the current revision!  						revId = oldRevId;  						deleted = false;  						sequence = oldSequence;  						json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  					}  					if (!deleted) {  						// Conflict revisions:  						if (conflicts == null) {  							conflicts = new List<string> ();  						}  						conflicts.Add (oldRevId.ToString ());  						while (c2.MoveToNext ()) {  							conflicts.Add (c2.GetString (0));  						}  					}  				}  			}  		}  		if (deleted) {  			continue;  		}  		// Get the document properties' to pass to the map function:  		currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  		if (currentDoc == null) {  			Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  			continue;  		}  		currentDoc ["_local_seq"] = sequence;  		if (conflicts != null) {  			currentDoc ["_conflicts"] = conflicts;  		}  		// Call the user-defined map() to emit new key/value pairs from this revision:  		int viewIndex = -1;  		var e = views.GetEnumerator ();  		while (e.MoveNext ()) {  			currentView = e.Current;  			++viewIndex;  			if (viewLastSequence [viewIndex] < realSequence) {  				if (checkDocTypes) {  					var viewDocType = viewDocTypes [currentView.Name];  					if (viewDocType != null && viewDocType != docType) {  						// skip; view's documentType doesn't match this doc  						continue;  					}  				}  				Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  				try {  					mapBlocks [viewIndex] (currentDoc' emit);  				} catch (Exception x) {  					Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  					emitStatus.Code = StatusCode.Exception;  				}  				if (emitStatus.IsError) {  					c.Dispose ();  					return false;  				}  			}  		}  		currentView = null;  	}  } catch (CouchbaseLiteException) {  	Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  	throw;  } catch (Exception e) {  	throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  } finally {  	if (c != null) {  		c.Dispose ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: try {  	c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		// Get row values now' before the code below advances 'c':  		long doc_id = c.GetLong (0);  		sequence = c.GetLong (1);  		string docId = c.GetString (2);  		if (docId.StartsWith ("_design/")) {  			// design documents don't get indexed  			keepGoing = c.MoveToNext ();  			continue;  		}  		var revId = c.GetString (3).AsRevID ();  		var json = c.GetBlob (4);  		bool deleted = c.GetInt (5) != 0;  		string docType = checkDocTypes ? c.GetString (6) : null;  		// Skip rows with the same doc_id -- these are losing conflicts.  		var conflicts = default(List<string>);  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  			if (conflicts == null) {  				conflicts = new List<string> ();  			}  			conflicts.Add (c.GetString (3));  		}  		long realSequence = sequence;  		// because sequence may be changed' below  		if (minLastSequence > 0) {  			// Find conflicts with documents from previous indexings.  			using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  				if (c2.MoveToNext ()) {  					var oldRevId = c2.GetString (0).AsRevID ();  					// This is the revision that used to be the 'winner'.  					// Remove its emitted rows:  					long oldSequence = c2.GetLong (1);  					foreach (var view in views) {  						int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  						deletedCount += changes;  						viewTotalRows [view.ViewID] -= changes;  					}  					if (deleted || oldRevId.CompareTo (revId) > 0) {  						// It still 'wins' the conflict' so it's the one that  						// should be mapped [again]' not the current revision!  						revId = oldRevId;  						deleted = false;  						sequence = oldSequence;  						json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  					}  					if (!deleted) {  						// Conflict revisions:  						if (conflicts == null) {  							conflicts = new List<string> ();  						}  						conflicts.Add (oldRevId.ToString ());  						while (c2.MoveToNext ()) {  							conflicts.Add (c2.GetString (0));  						}  					}  				}  			}  		}  		if (deleted) {  			continue;  		}  		// Get the document properties' to pass to the map function:  		currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  		if (currentDoc == null) {  			Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  			continue;  		}  		currentDoc ["_local_seq"] = sequence;  		if (conflicts != null) {  			currentDoc ["_conflicts"] = conflicts;  		}  		// Call the user-defined map() to emit new key/value pairs from this revision:  		int viewIndex = -1;  		var e = views.GetEnumerator ();  		while (e.MoveNext ()) {  			currentView = e.Current;  			++viewIndex;  			if (viewLastSequence [viewIndex] < realSequence) {  				if (checkDocTypes) {  					var viewDocType = viewDocTypes [currentView.Name];  					if (viewDocType != null && viewDocType != docType) {  						// skip; view's documentType doesn't match this doc  						continue;  					}  				}  				Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  				try {  					mapBlocks [viewIndex] (currentDoc' emit);  				} catch (Exception x) {  					Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  					emitStatus.Code = StatusCode.Exception;  				}  				if (emitStatus.IsError) {  					c.Dispose ();  					return false;  				}  			}  		}  		currentView = null;  	}  } catch (CouchbaseLiteException) {  	Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  	throw;  } catch (Exception e) {  	throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  } finally {  	if (c != null) {  		c.Dispose ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: try {  	c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		// Get row values now' before the code below advances 'c':  		long doc_id = c.GetLong (0);  		sequence = c.GetLong (1);  		string docId = c.GetString (2);  		if (docId.StartsWith ("_design/")) {  			// design documents don't get indexed  			keepGoing = c.MoveToNext ();  			continue;  		}  		var revId = c.GetString (3).AsRevID ();  		var json = c.GetBlob (4);  		bool deleted = c.GetInt (5) != 0;  		string docType = checkDocTypes ? c.GetString (6) : null;  		// Skip rows with the same doc_id -- these are losing conflicts.  		var conflicts = default(List<string>);  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  			if (conflicts == null) {  				conflicts = new List<string> ();  			}  			conflicts.Add (c.GetString (3));  		}  		long realSequence = sequence;  		// because sequence may be changed' below  		if (minLastSequence > 0) {  			// Find conflicts with documents from previous indexings.  			using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  				if (c2.MoveToNext ()) {  					var oldRevId = c2.GetString (0).AsRevID ();  					// This is the revision that used to be the 'winner'.  					// Remove its emitted rows:  					long oldSequence = c2.GetLong (1);  					foreach (var view in views) {  						int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  						deletedCount += changes;  						viewTotalRows [view.ViewID] -= changes;  					}  					if (deleted || oldRevId.CompareTo (revId) > 0) {  						// It still 'wins' the conflict' so it's the one that  						// should be mapped [again]' not the current revision!  						revId = oldRevId;  						deleted = false;  						sequence = oldSequence;  						json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  					}  					if (!deleted) {  						// Conflict revisions:  						if (conflicts == null) {  							conflicts = new List<string> ();  						}  						conflicts.Add (oldRevId.ToString ());  						while (c2.MoveToNext ()) {  							conflicts.Add (c2.GetString (0));  						}  					}  				}  			}  		}  		if (deleted) {  			continue;  		}  		// Get the document properties' to pass to the map function:  		currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  		if (currentDoc == null) {  			Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  			continue;  		}  		currentDoc ["_local_seq"] = sequence;  		if (conflicts != null) {  			currentDoc ["_conflicts"] = conflicts;  		}  		// Call the user-defined map() to emit new key/value pairs from this revision:  		int viewIndex = -1;  		var e = views.GetEnumerator ();  		while (e.MoveNext ()) {  			currentView = e.Current;  			++viewIndex;  			if (viewLastSequence [viewIndex] < realSequence) {  				if (checkDocTypes) {  					var viewDocType = viewDocTypes [currentView.Name];  					if (viewDocType != null && viewDocType != docType) {  						// skip; view's documentType doesn't match this doc  						continue;  					}  				}  				Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  				try {  					mapBlocks [viewIndex] (currentDoc' emit);  				} catch (Exception x) {  					Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  					emitStatus.Code = StatusCode.Exception;  				}  				if (emitStatus.IsError) {  					c.Dispose ();  					return false;  				}  			}  		}  		currentView = null;  	}  } catch (CouchbaseLiteException) {  	Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  	throw;  } catch (Exception e) {  	throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  } finally {  	if (c != null) {  		c.Dispose ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: try {  	c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		// Get row values now' before the code below advances 'c':  		long doc_id = c.GetLong (0);  		sequence = c.GetLong (1);  		string docId = c.GetString (2);  		if (docId.StartsWith ("_design/")) {  			// design documents don't get indexed  			keepGoing = c.MoveToNext ();  			continue;  		}  		var revId = c.GetString (3).AsRevID ();  		var json = c.GetBlob (4);  		bool deleted = c.GetInt (5) != 0;  		string docType = checkDocTypes ? c.GetString (6) : null;  		// Skip rows with the same doc_id -- these are losing conflicts.  		var conflicts = default(List<string>);  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  			if (conflicts == null) {  				conflicts = new List<string> ();  			}  			conflicts.Add (c.GetString (3));  		}  		long realSequence = sequence;  		// because sequence may be changed' below  		if (minLastSequence > 0) {  			// Find conflicts with documents from previous indexings.  			using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  				if (c2.MoveToNext ()) {  					var oldRevId = c2.GetString (0).AsRevID ();  					// This is the revision that used to be the 'winner'.  					// Remove its emitted rows:  					long oldSequence = c2.GetLong (1);  					foreach (var view in views) {  						int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  						deletedCount += changes;  						viewTotalRows [view.ViewID] -= changes;  					}  					if (deleted || oldRevId.CompareTo (revId) > 0) {  						// It still 'wins' the conflict' so it's the one that  						// should be mapped [again]' not the current revision!  						revId = oldRevId;  						deleted = false;  						sequence = oldSequence;  						json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  					}  					if (!deleted) {  						// Conflict revisions:  						if (conflicts == null) {  							conflicts = new List<string> ();  						}  						conflicts.Add (oldRevId.ToString ());  						while (c2.MoveToNext ()) {  							conflicts.Add (c2.GetString (0));  						}  					}  				}  			}  		}  		if (deleted) {  			continue;  		}  		// Get the document properties' to pass to the map function:  		currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  		if (currentDoc == null) {  			Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  			continue;  		}  		currentDoc ["_local_seq"] = sequence;  		if (conflicts != null) {  			currentDoc ["_conflicts"] = conflicts;  		}  		// Call the user-defined map() to emit new key/value pairs from this revision:  		int viewIndex = -1;  		var e = views.GetEnumerator ();  		while (e.MoveNext ()) {  			currentView = e.Current;  			++viewIndex;  			if (viewLastSequence [viewIndex] < realSequence) {  				if (checkDocTypes) {  					var viewDocType = viewDocTypes [currentView.Name];  					if (viewDocType != null && viewDocType != docType) {  						// skip; view's documentType doesn't match this doc  						continue;  					}  				}  				Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  				try {  					mapBlocks [viewIndex] (currentDoc' emit);  				} catch (Exception x) {  					Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  					emitStatus.Code = StatusCode.Exception;  				}  				if (emitStatus.IsError) {  					c.Dispose ();  					return false;  				}  			}  		}  		currentView = null;  	}  } catch (CouchbaseLiteException) {  	Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  	throw;  } catch (Exception e) {  	throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  } finally {  	if (c != null) {  		c.Dispose ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: try {  	c = db.StorageEngine.RawQuery (sql.ToString ()' minLastSequence' dbMaxSequence);  	bool keepGoing = c.MoveToNext ();  	while (keepGoing) {  		// Get row values now' before the code below advances 'c':  		long doc_id = c.GetLong (0);  		sequence = c.GetLong (1);  		string docId = c.GetString (2);  		if (docId.StartsWith ("_design/")) {  			// design documents don't get indexed  			keepGoing = c.MoveToNext ();  			continue;  		}  		var revId = c.GetString (3).AsRevID ();  		var json = c.GetBlob (4);  		bool deleted = c.GetInt (5) != 0;  		string docType = checkDocTypes ? c.GetString (6) : null;  		// Skip rows with the same doc_id -- these are losing conflicts.  		var conflicts = default(List<string>);  		while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  			if (conflicts == null) {  				conflicts = new List<string> ();  			}  			conflicts.Add (c.GetString (3));  		}  		long realSequence = sequence;  		// because sequence may be changed' below  		if (minLastSequence > 0) {  			// Find conflicts with documents from previous indexings.  			using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  				if (c2.MoveToNext ()) {  					var oldRevId = c2.GetString (0).AsRevID ();  					// This is the revision that used to be the 'winner'.  					// Remove its emitted rows:  					long oldSequence = c2.GetLong (1);  					foreach (var view in views) {  						int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  						deletedCount += changes;  						viewTotalRows [view.ViewID] -= changes;  					}  					if (deleted || oldRevId.CompareTo (revId) > 0) {  						// It still 'wins' the conflict' so it's the one that  						// should be mapped [again]' not the current revision!  						revId = oldRevId;  						deleted = false;  						sequence = oldSequence;  						json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  					}  					if (!deleted) {  						// Conflict revisions:  						if (conflicts == null) {  							conflicts = new List<string> ();  						}  						conflicts.Add (oldRevId.ToString ());  						while (c2.MoveToNext ()) {  							conflicts.Add (c2.GetString (0));  						}  					}  				}  			}  		}  		if (deleted) {  			continue;  		}  		// Get the document properties' to pass to the map function:  		currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  		if (currentDoc == null) {  			Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  			continue;  		}  		currentDoc ["_local_seq"] = sequence;  		if (conflicts != null) {  			currentDoc ["_conflicts"] = conflicts;  		}  		// Call the user-defined map() to emit new key/value pairs from this revision:  		int viewIndex = -1;  		var e = views.GetEnumerator ();  		while (e.MoveNext ()) {  			currentView = e.Current;  			++viewIndex;  			if (viewLastSequence [viewIndex] < realSequence) {  				if (checkDocTypes) {  					var viewDocType = viewDocTypes [currentView.Name];  					if (viewDocType != null && viewDocType != docType) {  						// skip; view's documentType doesn't match this doc  						continue;  					}  				}  				Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  				try {  					mapBlocks [viewIndex] (currentDoc' emit);  				} catch (Exception x) {  					Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  					emitStatus.Code = StatusCode.Exception;  				}  				if (emitStatus.IsError) {  					c.Dispose ();  					return false;  				}  			}  		}  		currentView = null;  	}  } catch (CouchbaseLiteException) {  	Log.To.View.E (Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);  	throw;  } catch (Exception e) {  	throw Misc.CreateExceptionAndLog (Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);  } finally {  	if (c != null) {  		c.Dispose ();  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: while (keepGoing) {  	// Get row values now' before the code below advances 'c':  	long doc_id = c.GetLong (0);  	sequence = c.GetLong (1);  	string docId = c.GetString (2);  	if (docId.StartsWith ("_design/")) {  		// design documents don't get indexed  		keepGoing = c.MoveToNext ();  		continue;  	}  	var revId = c.GetString (3).AsRevID ();  	var json = c.GetBlob (4);  	bool deleted = c.GetInt (5) != 0;  	string docType = checkDocTypes ? c.GetString (6) : null;  	// Skip rows with the same doc_id -- these are losing conflicts.  	var conflicts = default(List<string>);  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  		if (conflicts == null) {  			conflicts = new List<string> ();  		}  		conflicts.Add (c.GetString (3));  	}  	long realSequence = sequence;  	// because sequence may be changed' below  	if (minLastSequence > 0) {  		// Find conflicts with documents from previous indexings.  		using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  			if (c2.MoveToNext ()) {  				var oldRevId = c2.GetString (0).AsRevID ();  				// This is the revision that used to be the 'winner'.  				// Remove its emitted rows:  				long oldSequence = c2.GetLong (1);  				foreach (var view in views) {  					int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  					deletedCount += changes;  					viewTotalRows [view.ViewID] -= changes;  				}  				if (deleted || oldRevId.CompareTo (revId) > 0) {  					// It still 'wins' the conflict' so it's the one that  					// should be mapped [again]' not the current revision!  					revId = oldRevId;  					deleted = false;  					sequence = oldSequence;  					json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  				}  				if (!deleted) {  					// Conflict revisions:  					if (conflicts == null) {  						conflicts = new List<string> ();  					}  					conflicts.Add (oldRevId.ToString ());  					while (c2.MoveToNext ()) {  						conflicts.Add (c2.GetString (0));  					}  				}  			}  		}  	}  	if (deleted) {  		continue;  	}  	// Get the document properties' to pass to the map function:  	currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  	if (currentDoc == null) {  		Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  		continue;  	}  	currentDoc ["_local_seq"] = sequence;  	if (conflicts != null) {  		currentDoc ["_conflicts"] = conflicts;  	}  	// Call the user-defined map() to emit new key/value pairs from this revision:  	int viewIndex = -1;  	var e = views.GetEnumerator ();  	while (e.MoveNext ()) {  		currentView = e.Current;  		++viewIndex;  		if (viewLastSequence [viewIndex] < realSequence) {  			if (checkDocTypes) {  				var viewDocType = viewDocTypes [currentView.Name];  				if (viewDocType != null && viewDocType != docType) {  					// skip; view's documentType doesn't match this doc  					continue;  				}  			}  			Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  			try {  				mapBlocks [viewIndex] (currentDoc' emit);  			} catch (Exception x) {  				Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  				emitStatus.Code = StatusCode.Exception;  			}  			if (emitStatus.IsError) {  				c.Dispose ();  				return false;  			}  		}  	}  	currentView = null;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: while (keepGoing) {  	// Get row values now' before the code below advances 'c':  	long doc_id = c.GetLong (0);  	sequence = c.GetLong (1);  	string docId = c.GetString (2);  	if (docId.StartsWith ("_design/")) {  		// design documents don't get indexed  		keepGoing = c.MoveToNext ();  		continue;  	}  	var revId = c.GetString (3).AsRevID ();  	var json = c.GetBlob (4);  	bool deleted = c.GetInt (5) != 0;  	string docType = checkDocTypes ? c.GetString (6) : null;  	// Skip rows with the same doc_id -- these are losing conflicts.  	var conflicts = default(List<string>);  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  		if (conflicts == null) {  			conflicts = new List<string> ();  		}  		conflicts.Add (c.GetString (3));  	}  	long realSequence = sequence;  	// because sequence may be changed' below  	if (minLastSequence > 0) {  		// Find conflicts with documents from previous indexings.  		using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  			if (c2.MoveToNext ()) {  				var oldRevId = c2.GetString (0).AsRevID ();  				// This is the revision that used to be the 'winner'.  				// Remove its emitted rows:  				long oldSequence = c2.GetLong (1);  				foreach (var view in views) {  					int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  					deletedCount += changes;  					viewTotalRows [view.ViewID] -= changes;  				}  				if (deleted || oldRevId.CompareTo (revId) > 0) {  					// It still 'wins' the conflict' so it's the one that  					// should be mapped [again]' not the current revision!  					revId = oldRevId;  					deleted = false;  					sequence = oldSequence;  					json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  				}  				if (!deleted) {  					// Conflict revisions:  					if (conflicts == null) {  						conflicts = new List<string> ();  					}  					conflicts.Add (oldRevId.ToString ());  					while (c2.MoveToNext ()) {  						conflicts.Add (c2.GetString (0));  					}  				}  			}  		}  	}  	if (deleted) {  		continue;  	}  	// Get the document properties' to pass to the map function:  	currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  	if (currentDoc == null) {  		Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  		continue;  	}  	currentDoc ["_local_seq"] = sequence;  	if (conflicts != null) {  		currentDoc ["_conflicts"] = conflicts;  	}  	// Call the user-defined map() to emit new key/value pairs from this revision:  	int viewIndex = -1;  	var e = views.GetEnumerator ();  	while (e.MoveNext ()) {  		currentView = e.Current;  		++viewIndex;  		if (viewLastSequence [viewIndex] < realSequence) {  			if (checkDocTypes) {  				var viewDocType = viewDocTypes [currentView.Name];  				if (viewDocType != null && viewDocType != docType) {  					// skip; view's documentType doesn't match this doc  					continue;  				}  			}  			Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  			try {  				mapBlocks [viewIndex] (currentDoc' emit);  			} catch (Exception x) {  				Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  				emitStatus.Code = StatusCode.Exception;  			}  			if (emitStatus.IsError) {  				c.Dispose ();  				return false;  			}  		}  	}  	currentView = null;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: while (keepGoing) {  	// Get row values now' before the code below advances 'c':  	long doc_id = c.GetLong (0);  	sequence = c.GetLong (1);  	string docId = c.GetString (2);  	if (docId.StartsWith ("_design/")) {  		// design documents don't get indexed  		keepGoing = c.MoveToNext ();  		continue;  	}  	var revId = c.GetString (3).AsRevID ();  	var json = c.GetBlob (4);  	bool deleted = c.GetInt (5) != 0;  	string docType = checkDocTypes ? c.GetString (6) : null;  	// Skip rows with the same doc_id -- these are losing conflicts.  	var conflicts = default(List<string>);  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  		if (conflicts == null) {  			conflicts = new List<string> ();  		}  		conflicts.Add (c.GetString (3));  	}  	long realSequence = sequence;  	// because sequence may be changed' below  	if (minLastSequence > 0) {  		// Find conflicts with documents from previous indexings.  		using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  			if (c2.MoveToNext ()) {  				var oldRevId = c2.GetString (0).AsRevID ();  				// This is the revision that used to be the 'winner'.  				// Remove its emitted rows:  				long oldSequence = c2.GetLong (1);  				foreach (var view in views) {  					int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  					deletedCount += changes;  					viewTotalRows [view.ViewID] -= changes;  				}  				if (deleted || oldRevId.CompareTo (revId) > 0) {  					// It still 'wins' the conflict' so it's the one that  					// should be mapped [again]' not the current revision!  					revId = oldRevId;  					deleted = false;  					sequence = oldSequence;  					json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  				}  				if (!deleted) {  					// Conflict revisions:  					if (conflicts == null) {  						conflicts = new List<string> ();  					}  					conflicts.Add (oldRevId.ToString ());  					while (c2.MoveToNext ()) {  						conflicts.Add (c2.GetString (0));  					}  				}  			}  		}  	}  	if (deleted) {  		continue;  	}  	// Get the document properties' to pass to the map function:  	currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  	if (currentDoc == null) {  		Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  		continue;  	}  	currentDoc ["_local_seq"] = sequence;  	if (conflicts != null) {  		currentDoc ["_conflicts"] = conflicts;  	}  	// Call the user-defined map() to emit new key/value pairs from this revision:  	int viewIndex = -1;  	var e = views.GetEnumerator ();  	while (e.MoveNext ()) {  		currentView = e.Current;  		++viewIndex;  		if (viewLastSequence [viewIndex] < realSequence) {  			if (checkDocTypes) {  				var viewDocType = viewDocTypes [currentView.Name];  				if (viewDocType != null && viewDocType != docType) {  					// skip; view's documentType doesn't match this doc  					continue;  				}  			}  			Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  			try {  				mapBlocks [viewIndex] (currentDoc' emit);  			} catch (Exception x) {  				Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  				emitStatus.Code = StatusCode.Exception;  			}  			if (emitStatus.IsError) {  				c.Dispose ();  				return false;  			}  		}  	}  	currentView = null;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: while (keepGoing) {  	// Get row values now' before the code below advances 'c':  	long doc_id = c.GetLong (0);  	sequence = c.GetLong (1);  	string docId = c.GetString (2);  	if (docId.StartsWith ("_design/")) {  		// design documents don't get indexed  		keepGoing = c.MoveToNext ();  		continue;  	}  	var revId = c.GetString (3).AsRevID ();  	var json = c.GetBlob (4);  	bool deleted = c.GetInt (5) != 0;  	string docType = checkDocTypes ? c.GetString (6) : null;  	// Skip rows with the same doc_id -- these are losing conflicts.  	var conflicts = default(List<string>);  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  		if (conflicts == null) {  			conflicts = new List<string> ();  		}  		conflicts.Add (c.GetString (3));  	}  	long realSequence = sequence;  	// because sequence may be changed' below  	if (minLastSequence > 0) {  		// Find conflicts with documents from previous indexings.  		using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  			if (c2.MoveToNext ()) {  				var oldRevId = c2.GetString (0).AsRevID ();  				// This is the revision that used to be the 'winner'.  				// Remove its emitted rows:  				long oldSequence = c2.GetLong (1);  				foreach (var view in views) {  					int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  					deletedCount += changes;  					viewTotalRows [view.ViewID] -= changes;  				}  				if (deleted || oldRevId.CompareTo (revId) > 0) {  					// It still 'wins' the conflict' so it's the one that  					// should be mapped [again]' not the current revision!  					revId = oldRevId;  					deleted = false;  					sequence = oldSequence;  					json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  				}  				if (!deleted) {  					// Conflict revisions:  					if (conflicts == null) {  						conflicts = new List<string> ();  					}  					conflicts.Add (oldRevId.ToString ());  					while (c2.MoveToNext ()) {  						conflicts.Add (c2.GetString (0));  					}  				}  			}  		}  	}  	if (deleted) {  		continue;  	}  	// Get the document properties' to pass to the map function:  	currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  	if (currentDoc == null) {  		Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  		continue;  	}  	currentDoc ["_local_seq"] = sequence;  	if (conflicts != null) {  		currentDoc ["_conflicts"] = conflicts;  	}  	// Call the user-defined map() to emit new key/value pairs from this revision:  	int viewIndex = -1;  	var e = views.GetEnumerator ();  	while (e.MoveNext ()) {  		currentView = e.Current;  		++viewIndex;  		if (viewLastSequence [viewIndex] < realSequence) {  			if (checkDocTypes) {  				var viewDocType = viewDocTypes [currentView.Name];  				if (viewDocType != null && viewDocType != docType) {  					// skip; view's documentType doesn't match this doc  					continue;  				}  			}  			Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  			try {  				mapBlocks [viewIndex] (currentDoc' emit);  			} catch (Exception x) {  				Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  				emitStatus.Code = StatusCode.Exception;  			}  			if (emitStatus.IsError) {  				c.Dispose ();  				return false;  			}  		}  	}  	currentView = null;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: while (keepGoing) {  	// Get row values now' before the code below advances 'c':  	long doc_id = c.GetLong (0);  	sequence = c.GetLong (1);  	string docId = c.GetString (2);  	if (docId.StartsWith ("_design/")) {  		// design documents don't get indexed  		keepGoing = c.MoveToNext ();  		continue;  	}  	var revId = c.GetString (3).AsRevID ();  	var json = c.GetBlob (4);  	bool deleted = c.GetInt (5) != 0;  	string docType = checkDocTypes ? c.GetString (6) : null;  	// Skip rows with the same doc_id -- these are losing conflicts.  	var conflicts = default(List<string>);  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  		if (conflicts == null) {  			conflicts = new List<string> ();  		}  		conflicts.Add (c.GetString (3));  	}  	long realSequence = sequence;  	// because sequence may be changed' below  	if (minLastSequence > 0) {  		// Find conflicts with documents from previous indexings.  		using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  			if (c2.MoveToNext ()) {  				var oldRevId = c2.GetString (0).AsRevID ();  				// This is the revision that used to be the 'winner'.  				// Remove its emitted rows:  				long oldSequence = c2.GetLong (1);  				foreach (var view in views) {  					int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  					deletedCount += changes;  					viewTotalRows [view.ViewID] -= changes;  				}  				if (deleted || oldRevId.CompareTo (revId) > 0) {  					// It still 'wins' the conflict' so it's the one that  					// should be mapped [again]' not the current revision!  					revId = oldRevId;  					deleted = false;  					sequence = oldSequence;  					json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  				}  				if (!deleted) {  					// Conflict revisions:  					if (conflicts == null) {  						conflicts = new List<string> ();  					}  					conflicts.Add (oldRevId.ToString ());  					while (c2.MoveToNext ()) {  						conflicts.Add (c2.GetString (0));  					}  				}  			}  		}  	}  	if (deleted) {  		continue;  	}  	// Get the document properties' to pass to the map function:  	currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  	if (currentDoc == null) {  		Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  		continue;  	}  	currentDoc ["_local_seq"] = sequence;  	if (conflicts != null) {  		currentDoc ["_conflicts"] = conflicts;  	}  	// Call the user-defined map() to emit new key/value pairs from this revision:  	int viewIndex = -1;  	var e = views.GetEnumerator ();  	while (e.MoveNext ()) {  		currentView = e.Current;  		++viewIndex;  		if (viewLastSequence [viewIndex] < realSequence) {  			if (checkDocTypes) {  				var viewDocType = viewDocTypes [currentView.Name];  				if (viewDocType != null && viewDocType != docType) {  					// skip; view's documentType doesn't match this doc  					continue;  				}  			}  			Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  			try {  				mapBlocks [viewIndex] (currentDoc' emit);  			} catch (Exception x) {  				Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  				emitStatus.Code = StatusCode.Exception;  			}  			if (emitStatus.IsError) {  				c.Dispose ();  				return false;  			}  		}  	}  	currentView = null;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: while (keepGoing) {  	// Get row values now' before the code below advances 'c':  	long doc_id = c.GetLong (0);  	sequence = c.GetLong (1);  	string docId = c.GetString (2);  	if (docId.StartsWith ("_design/")) {  		// design documents don't get indexed  		keepGoing = c.MoveToNext ();  		continue;  	}  	var revId = c.GetString (3).AsRevID ();  	var json = c.GetBlob (4);  	bool deleted = c.GetInt (5) != 0;  	string docType = checkDocTypes ? c.GetString (6) : null;  	// Skip rows with the same doc_id -- these are losing conflicts.  	var conflicts = default(List<string>);  	while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  		if (conflicts == null) {  			conflicts = new List<string> ();  		}  		conflicts.Add (c.GetString (3));  	}  	long realSequence = sequence;  	// because sequence may be changed' below  	if (minLastSequence > 0) {  		// Find conflicts with documents from previous indexings.  		using (c2 = db.StorageEngine.RawQuery ("SELECT revid' sequence FROM revs " + "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " + "ORDER BY revID DESC "' doc_id' minLastSequence)) {  			if (c2.MoveToNext ()) {  				var oldRevId = c2.GetString (0).AsRevID ();  				// This is the revision that used to be the 'winner'.  				// Remove its emitted rows:  				long oldSequence = c2.GetLong (1);  				foreach (var view in views) {  					int changes = db.StorageEngine.ExecSQL (QueryString ("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);  					deletedCount += changes;  					viewTotalRows [view.ViewID] -= changes;  				}  				if (deleted || oldRevId.CompareTo (revId) > 0) {  					// It still 'wins' the conflict' so it's the one that  					// should be mapped [again]' not the current revision!  					revId = oldRevId;  					deleted = false;  					sequence = oldSequence;  					json = db.QueryOrDefault<byte[]> (x => x.GetBlob (0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);  				}  				if (!deleted) {  					// Conflict revisions:  					if (conflicts == null) {  						conflicts = new List<string> ();  					}  					conflicts.Add (oldRevId.ToString ());  					while (c2.MoveToNext ()) {  						conflicts.Add (c2.GetString (0));  					}  				}  			}  		}  	}  	if (deleted) {  		continue;  	}  	// Get the document properties' to pass to the map function:  	currentDoc = db.GetDocumentProperties (json' docId' revId' deleted' sequence);  	if (currentDoc == null) {  		Log.To.View.W (Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure)' revId);  		continue;  	}  	currentDoc ["_local_seq"] = sequence;  	if (conflicts != null) {  		currentDoc ["_conflicts"] = conflicts;  	}  	// Call the user-defined map() to emit new key/value pairs from this revision:  	int viewIndex = -1;  	var e = views.GetEnumerator ();  	while (e.MoveNext ()) {  		currentView = e.Current;  		++viewIndex;  		if (viewLastSequence [viewIndex] < realSequence) {  			if (checkDocTypes) {  				var viewDocType = viewDocTypes [currentView.Name];  				if (viewDocType != null && viewDocType != docType) {  					// skip; view's documentType doesn't match this doc  					continue;  				}  			}  			Log.To.View.V (Tag' "    #{0}: map \"{1}\" for view {2}..."' sequence' docId' e.Current.Name);  			try {  				mapBlocks [viewIndex] (currentDoc' emit);  			} catch (Exception x) {  				Log.To.View.E (Tag' String.Format ("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);  				emitStatus.Code = StatusCode.Exception;  			}  			if (emitStatus.IsError) {  				c.Dispose ();  				return false;  			}  		}  	}  	currentView = null;  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: while ((keepGoing = c.MoveToNext ()) && c.GetLong (0) == doc_id) {  	if (conflicts == null) {  		conflicts = new List<string> ();  	}  	conflicts.Add (c.GetString (3));  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: conflicts.Add (c.GetString (3));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: RunQuery (options' (keyData' valueData' docId' cursor) => {  	long sequence = cursor.GetLong (3);  	RevisionInternal docRevision = null;  	if (options.IncludeDocs) {  		IDictionary<string' object> value = null;  		if (valueData != null && !RowValueIsEntireDoc (valueData.Value)) {  			value = valueData.Value.AsDictionary<string' object> ();  		}  		string linkedId = value.CblID ();  		if (linkedId != null) {  			// Linked document: http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Linked_documents  			var linkedRev = value.CblRev ();  			//usually null  			docRevision = db.GetDocument (linkedId' linkedRev' true);  			sequence = docRevision == null ? 0 : docRevision.Sequence;  		} else {  			docRevision = db.GetRevision (docId' cursor.GetString (4).AsRevID ()' false' sequence' cursor.GetBlob (5));  		}  	}  	Log.To.Query.V (Tag' "Query {0}: Found row with key={1}' value={2}' id={3}"' Name' new SecureLogString (keyData.Value' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (valueData.Value' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  	QueryRow row = null;  	if (false) {  		//TODO: bbox  	} else {  		row = new QueryRow (docId' sequence' keyData.Value' valueData.Value' docRevision' this);  	}  	if (filter != null) {  		if (!filter (row)) {  			return new Status (StatusCode.Ok);  		}  		if (skip > 0) {  			--skip;  			return new Status (StatusCode.Ok);  		}  	}  	if (limit-- == 0) {  		return new Status (StatusCode.Reserved);  	}  	rows.Add (row);  	return new Status (StatusCode.Ok);  });  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: RunQuery (options' (keyData' valueData' docId' cursor) => {  	long sequence = cursor.GetLong (3);  	RevisionInternal docRevision = null;  	if (options.IncludeDocs) {  		IDictionary<string' object> value = null;  		if (valueData != null && !RowValueIsEntireDoc (valueData.Value)) {  			value = valueData.Value.AsDictionary<string' object> ();  		}  		string linkedId = value.CblID ();  		if (linkedId != null) {  			// Linked document: http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Linked_documents  			var linkedRev = value.CblRev ();  			//usually null  			docRevision = db.GetDocument (linkedId' linkedRev' true);  			sequence = docRevision == null ? 0 : docRevision.Sequence;  		} else {  			docRevision = db.GetRevision (docId' cursor.GetString (4).AsRevID ()' false' sequence' cursor.GetBlob (5));  		}  	}  	Log.To.Query.V (Tag' "Query {0}: Found row with key={1}' value={2}' id={3}"' Name' new SecureLogString (keyData.Value' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (valueData.Value' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  	QueryRow row = null;  	if (false) {  		//TODO: bbox  	} else {  		row = new QueryRow (docId' sequence' keyData.Value' valueData.Value' docRevision' this);  	}  	if (filter != null) {  		if (!filter (row)) {  			return new Status (StatusCode.Ok);  		}  		if (skip > 0) {  			--skip;  			return new Status (StatusCode.Ok);  		}  	}  	if (limit-- == 0) {  		return new Status (StatusCode.Reserved);  	}  	rows.Add (row);  	return new Status (StatusCode.Ok);  });  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: RunQuery (options' (keyData' valueData' docId' cursor) => {  	long sequence = cursor.GetLong (3);  	RevisionInternal docRevision = null;  	if (options.IncludeDocs) {  		IDictionary<string' object> value = null;  		if (valueData != null && !RowValueIsEntireDoc (valueData.Value)) {  			value = valueData.Value.AsDictionary<string' object> ();  		}  		string linkedId = value.CblID ();  		if (linkedId != null) {  			// Linked document: http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Linked_documents  			var linkedRev = value.CblRev ();  			//usually null  			docRevision = db.GetDocument (linkedId' linkedRev' true);  			sequence = docRevision == null ? 0 : docRevision.Sequence;  		} else {  			docRevision = db.GetRevision (docId' cursor.GetString (4).AsRevID ()' false' sequence' cursor.GetBlob (5));  		}  	}  	Log.To.Query.V (Tag' "Query {0}: Found row with key={1}' value={2}' id={3}"' Name' new SecureLogString (keyData.Value' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (valueData.Value' LogMessageSensitivity.PotentiallyInsecure)' new SecureLogString (docId' LogMessageSensitivity.PotentiallyInsecure));  	QueryRow row = null;  	if (false) {  		//TODO: bbox  	} else {  		row = new QueryRow (docId' sequence' keyData.Value' valueData.Value' docRevision' this);  	}  	if (filter != null) {  		if (!filter (row)) {  			return new Status (StatusCode.Ok);  		}  		if (skip > 0) {  			--skip;  			return new Status (StatusCode.Ok);  		}  	}  	if (limit-- == 0) {  		return new Status (StatusCode.Reserved);  	}  	rows.Add (row);  	return new Status (StatusCode.Ok);  });  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: if (options.IncludeDocs) {  	IDictionary<string' object> value = null;  	if (valueData != null && !RowValueIsEntireDoc (valueData.Value)) {  		value = valueData.Value.AsDictionary<string' object> ();  	}  	string linkedId = value.CblID ();  	if (linkedId != null) {  		// Linked document: http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Linked_documents  		var linkedRev = value.CblRev ();  		//usually null  		docRevision = db.GetDocument (linkedId' linkedRev' true);  		sequence = docRevision == null ? 0 : docRevision.Sequence;  	} else {  		docRevision = db.GetRevision (docId' cursor.GetString (4).AsRevID ()' false' sequence' cursor.GetBlob (5));  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: if (options.IncludeDocs) {  	IDictionary<string' object> value = null;  	if (valueData != null && !RowValueIsEntireDoc (valueData.Value)) {  		value = valueData.Value.AsDictionary<string' object> ();  	}  	string linkedId = value.CblID ();  	if (linkedId != null) {  		// Linked document: http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Linked_documents  		var linkedRev = value.CblRev ();  		//usually null  		docRevision = db.GetDocument (linkedId' linkedRev' true);  		sequence = docRevision == null ? 0 : docRevision.Sequence;  	} else {  		docRevision = db.GetRevision (docId' cursor.GetString (4).AsRevID ()' false' sequence' cursor.GetBlob (5));  	}  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: if (linkedId != null) {  	// Linked document: http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Linked_documents  	var linkedRev = value.CblRev ();  	//usually null  	docRevision = db.GetDocument (linkedId' linkedRev' true);  	sequence = docRevision == null ? 0 : docRevision.Sequence;  } else {  	docRevision = db.GetRevision (docId' cursor.GetString (4).AsRevID ()' false' sequence' cursor.GetBlob (5));  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: if (linkedId != null) {  	// Linked document: http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Linked_documents  	var linkedRev = value.CblRev ();  	//usually null  	docRevision = db.GetDocument (linkedId' linkedRev' true);  	sequence = docRevision == null ? 0 : docRevision.Sequence;  } else {  	docRevision = db.GetRevision (docId' cursor.GetString (4).AsRevID ()' false' sequence' cursor.GetBlob (5));  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: docRevision = db.GetRevision (docId' cursor.GetString (4).AsRevID ()' false' sequence' cursor.GetBlob (5));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: docRevision = db.GetRevision (docId' cursor.GetString (4).AsRevID ()' false' sequence' cursor.GetBlob (5));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,ReducedQuery,The following statement contains a magic number: if (reduce != null) {  	keysToReduce = new List<object> (100);  	valuesToReduce = new List<object> (100);  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,ReducedQuery,The following statement contains a magic number: if (reduce != null) {  	keysToReduce = new List<object> (100);  	valuesToReduce = new List<object> (100);  }  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,ReducedQuery,The following statement contains a magic number: keysToReduce = new List<object> (100);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,ReducedQuery,The following statement contains a magic number: valuesToReduce = new List<object> (100);  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,Dump,The following statement contains a magic number: _dbStorage.TryQuery (c => {  	retVal.Add (new Dictionary<string' object> () {  		{  			"seq"'  			c.GetLong (0)  		}'  		{  			"key"'  			c.GetString (1)  		}'  		{  			"val"'  			c.GetString (2)  		}  	});  	return true;  }' QueryString ("SELECT sequence' key' value FROM 'maps_#' ORDER BY key"));  
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,Dump,The following statement contains a magic number: retVal.Add (new Dictionary<string' object> () {  	{  		"seq"'  		c.GetLong (0)  	}'  	{  		"key"'  		c.GetString (1)  	}'  	{  		"val"'  		c.GetString (2)  	}  });  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: if (d < 10)  	return d;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: if (d < 6)  	return d + 10;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: if (d < 6)  	return d + 10;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: return d + 10;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: if (d < 6)  	return d + 10;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: if (d < 6)  	return d + 10;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: return d + 10;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (mantSize == 0) {  	fraction = 0.0;  	p = 0;  	goto Done;  } else {  	int frac1 = 0;  	for (; mantSize > 9; --mantSize) {  		c = str [p];  		++p;  		if (c == '.') {  			c = str [p];  			++p;  		}  		frac1 = 10 * frac1 + (c - '0');  	}  	int frac2 = 0;  	for (; mantSize > 0; --mantSize) {  		c = str [p];  		++p;  		if (c == '.') {  			c = str [p];  			++p;  		}  		frac2 = 10 * frac2 + (c - '0');  	}  	fraction = (double)((1.0e9 * frac1) + frac2);  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (mantSize == 0) {  	fraction = 0.0;  	p = 0;  	goto Done;  } else {  	int frac1 = 0;  	for (; mantSize > 9; --mantSize) {  		c = str [p];  		++p;  		if (c == '.') {  			c = str [p];  			++p;  		}  		frac1 = 10 * frac1 + (c - '0');  	}  	int frac2 = 0;  	for (; mantSize > 0; --mantSize) {  		c = str [p];  		++p;  		if (c == '.') {  			c = str [p];  			++p;  		}  		frac2 = 10 * frac2 + (c - '0');  	}  	fraction = (double)((1.0e9 * frac1) + frac2);  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (mantSize == 0) {  	fraction = 0.0;  	p = 0;  	goto Done;  } else {  	int frac1 = 0;  	for (; mantSize > 9; --mantSize) {  		c = str [p];  		++p;  		if (c == '.') {  			c = str [p];  			++p;  		}  		frac1 = 10 * frac1 + (c - '0');  	}  	int frac2 = 0;  	for (; mantSize > 0; --mantSize) {  		c = str [p];  		++p;  		if (c == '.') {  			c = str [p];  			++p;  		}  		frac2 = 10 * frac2 + (c - '0');  	}  	fraction = (double)((1.0e9 * frac1) + frac2);  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (mantSize == 0) {  	fraction = 0.0;  	p = 0;  	goto Done;  } else {  	int frac1 = 0;  	for (; mantSize > 9; --mantSize) {  		c = str [p];  		++p;  		if (c == '.') {  			c = str [p];  			++p;  		}  		frac1 = 10 * frac1 + (c - '0');  	}  	int frac2 = 0;  	for (; mantSize > 0; --mantSize) {  		c = str [p];  		++p;  		if (c == '.') {  			c = str [p];  			++p;  		}  		frac2 = 10 * frac2 + (c - '0');  	}  	fraction = (double)((1.0e9 * frac1) + frac2);  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: for (; mantSize > 9; --mantSize) {  	c = str [p];  	++p;  	if (c == '.') {  		c = str [p];  		++p;  	}  	frac1 = 10 * frac1 + (c - '0');  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: for (; mantSize > 9; --mantSize) {  	c = str [p];  	++p;  	if (c == '.') {  		c = str [p];  		++p;  	}  	frac1 = 10 * frac1 + (c - '0');  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: frac1 = 10 * frac1 + (c - '0');  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: for (; mantSize > 0; --mantSize) {  	c = str [p];  	++p;  	if (c == '.') {  		c = str [p];  		++p;  	}  	frac2 = 10 * frac2 + (c - '0');  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: frac2 = 10 * frac2 + (c - '0');  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: fraction = (double)((1.0e9 * frac1) + frac2);  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (p < str.Length && (str [p] == 'E' || str [p] == 'e')) {  	++p;  	if (p < length) {  		if (str [p] == '-') {  			expSign = 1;  			++p;  		} else if (str [p] == '+')  			++p;  		if (!Char.IsDigit (str [p])) {  			p = pExp;  			goto Done;  		}  		while (p < length && Char.IsDigit (str [p])) {  			exp = exp * 10 + (str [p] - '0');  			++p;  		}  	}  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (p < length) {  	if (str [p] == '-') {  		expSign = 1;  		++p;  	} else if (str [p] == '+')  		++p;  	if (!Char.IsDigit (str [p])) {  		p = pExp;  		goto Done;  	}  	while (p < length && Char.IsDigit (str [p])) {  		exp = exp * 10 + (str [p] - '0');  		++p;  	}  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: while (p < length && Char.IsDigit (str [p])) {  	exp = exp * 10 + (str [p] - '0');  	++p;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: exp = exp * 10 + (str [p] - '0');  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {  case 'u':  	// \u is a Unicode escape; 4 hex digits follow.  	int uIndex = index + 1;  	// TODO: Check Valid Digit  	if (uIndex + 3 < str.Length) {  		int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  		if (uc > 127) {  			// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  		}  		endPos = uIndex + 3;  		return (char)uc;  	}  	break;  case 'b':  	c = '\b';  	break;  case 'n':  	c = '\n';  	break;  case 'r':  	c = '\r';  	break;  case 't':  	c = '\t';  	break;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {  case 'u':  	// \u is a Unicode escape; 4 hex digits follow.  	int uIndex = index + 1;  	// TODO: Check Valid Digit  	if (uIndex + 3 < str.Length) {  		int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  		if (uc > 127) {  			// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  		}  		endPos = uIndex + 3;  		return (char)uc;  	}  	break;  case 'b':  	c = '\b';  	break;  case 'n':  	c = '\n';  	break;  case 'r':  	c = '\r';  	break;  case 't':  	c = '\t';  	break;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {  case 'u':  	// \u is a Unicode escape; 4 hex digits follow.  	int uIndex = index + 1;  	// TODO: Check Valid Digit  	if (uIndex + 3 < str.Length) {  		int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  		if (uc > 127) {  			// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  		}  		endPos = uIndex + 3;  		return (char)uc;  	}  	break;  case 'b':  	c = '\b';  	break;  case 'n':  	c = '\n';  	break;  case 'r':  	c = '\r';  	break;  case 't':  	c = '\t';  	break;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {  case 'u':  	// \u is a Unicode escape; 4 hex digits follow.  	int uIndex = index + 1;  	// TODO: Check Valid Digit  	if (uIndex + 3 < str.Length) {  		int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  		if (uc > 127) {  			// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  		}  		endPos = uIndex + 3;  		return (char)uc;  	}  	break;  case 'b':  	c = '\b';  	break;  case 'n':  	c = '\n';  	break;  case 'r':  	c = '\r';  	break;  case 't':  	c = '\t';  	break;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {  case 'u':  	// \u is a Unicode escape; 4 hex digits follow.  	int uIndex = index + 1;  	// TODO: Check Valid Digit  	if (uIndex + 3 < str.Length) {  		int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  		if (uc > 127) {  			// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  		}  		endPos = uIndex + 3;  		return (char)uc;  	}  	break;  case 'b':  	c = '\b';  	break;  case 'n':  	c = '\n';  	break;  case 'r':  	c = '\r';  	break;  case 't':  	c = '\t';  	break;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {  case 'u':  	// \u is a Unicode escape; 4 hex digits follow.  	int uIndex = index + 1;  	// TODO: Check Valid Digit  	if (uIndex + 3 < str.Length) {  		int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  		if (uc > 127) {  			// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  		}  		endPos = uIndex + 3;  		return (char)uc;  	}  	break;  case 'b':  	c = '\b';  	break;  case 'n':  	c = '\n';  	break;  case 'r':  	c = '\r';  	break;  case 't':  	c = '\t';  	break;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {  case 'u':  	// \u is a Unicode escape; 4 hex digits follow.  	int uIndex = index + 1;  	// TODO: Check Valid Digit  	if (uIndex + 3 < str.Length) {  		int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  		if (uc > 127) {  			// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  		}  		endPos = uIndex + 3;  		return (char)uc;  	}  	break;  case 'b':  	c = '\b';  	break;  case 'n':  	c = '\n';  	break;  case 'r':  	c = '\r';  	break;  case 't':  	c = '\t';  	break;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {  case 'u':  	// \u is a Unicode escape; 4 hex digits follow.  	int uIndex = index + 1;  	// TODO: Check Valid Digit  	if (uIndex + 3 < str.Length) {  		int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  		if (uc > 127) {  			// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  		}  		endPos = uIndex + 3;  		return (char)uc;  	}  	break;  case 'b':  	c = '\b';  	break;  case 'n':  	c = '\n';  	break;  case 'r':  	c = '\r';  	break;  case 't':  	c = '\t';  	break;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: if (uIndex + 3 < str.Length) {  	int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  	if (uc > 127) {  		// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  	}  	endPos = uIndex + 3;  	return (char)uc;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: if (uIndex + 3 < str.Length) {  	int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  	if (uc > 127) {  		// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  	}  	endPos = uIndex + 3;  	return (char)uc;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: if (uIndex + 3 < str.Length) {  	int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  	if (uc > 127) {  		// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  	}  	endPos = uIndex + 3;  	return (char)uc;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: if (uIndex + 3 < str.Length) {  	int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  	if (uc > 127) {  		// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  	}  	endPos = uIndex + 3;  	return (char)uc;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: if (uIndex + 3 < str.Length) {  	int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  	if (uc > 127) {  		// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  	}  	endPos = uIndex + 3;  	return (char)uc;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: if (uIndex + 3 < str.Length) {  	int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  	if (uc > 127) {  		// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  	}  	endPos = uIndex + 3;  	return (char)uc;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: if (uIndex + 3 < str.Length) {  	int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  	if (uc > 127) {  		// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  	}  	endPos = uIndex + 3;  	return (char)uc;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: if (uIndex + 3 < str.Length) {  	int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  	if (uc > 127) {  		// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  	}  	endPos = uIndex + 3;  	return (char)uc;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: if (uc > 127) {  	// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: endPos = uIndex + 3;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: do {  	var type1 = ValueTypeOf (index1 < param1.Length ? param1 [index1] : '\0');  	var type2 = ValueTypeOf (index2 < param2.Length ? param2 [index2] : '\0');  	if (type1 != type2) {  		if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma)) {  			if (++arrayIndex >= arrayLimit)  				return 0;  		}  		if (mode != JsonCollationMode.Raw)  			return Cmp ((int)type1' (int)type2);  		else  			return Cmp (RawOrderOfValueType (type1)' RawOrderOfValueType (type2));  	} else {  		switch (type1) {  		case ValueType.Null:  		case ValueType.True:  			index1 += 4;  			index2 += 4;  			break;  		case ValueType.False:  			index1 += 5;  			index2 += 5;  			break;  		case ValueType.Number:  			int next1;  			int next2;  			diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  			if (diff != 0)  				return diff;  			index1 = next1;  			index2 = next2;  			break;  		case ValueType.String:  			int endPos1;  			int endPos2;  			if (mode == JsonCollationMode.Unicode)  				diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  			else  				diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  			if (diff != 0)  				return diff;  			index1 = endPos1 + 1;  			index2 = endPos2 + 1;  			break;  		case ValueType.Array:  		case ValueType.Object:  			++index1;  			++index2;  			++depth;  			break;  		case ValueType.EndArray:  		case ValueType.EndObject:  			++index1;  			++index2;  			--depth;  			break;  		case ValueType.Comma:  			if (depth == 1 && (++arrayIndex >= arrayLimit))  				return 0;  			++index1;  			++index2;  			break;  		case ValueType.Colon:  			++index1;  			++index2;  			break;  		case ValueType.Illegal:  			return 0;  		}  	}  } while (depth > 0);  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: do {  	var type1 = ValueTypeOf (index1 < param1.Length ? param1 [index1] : '\0');  	var type2 = ValueTypeOf (index2 < param2.Length ? param2 [index2] : '\0');  	if (type1 != type2) {  		if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma)) {  			if (++arrayIndex >= arrayLimit)  				return 0;  		}  		if (mode != JsonCollationMode.Raw)  			return Cmp ((int)type1' (int)type2);  		else  			return Cmp (RawOrderOfValueType (type1)' RawOrderOfValueType (type2));  	} else {  		switch (type1) {  		case ValueType.Null:  		case ValueType.True:  			index1 += 4;  			index2 += 4;  			break;  		case ValueType.False:  			index1 += 5;  			index2 += 5;  			break;  		case ValueType.Number:  			int next1;  			int next2;  			diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  			if (diff != 0)  				return diff;  			index1 = next1;  			index2 = next2;  			break;  		case ValueType.String:  			int endPos1;  			int endPos2;  			if (mode == JsonCollationMode.Unicode)  				diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  			else  				diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  			if (diff != 0)  				return diff;  			index1 = endPos1 + 1;  			index2 = endPos2 + 1;  			break;  		case ValueType.Array:  		case ValueType.Object:  			++index1;  			++index2;  			++depth;  			break;  		case ValueType.EndArray:  		case ValueType.EndObject:  			++index1;  			++index2;  			--depth;  			break;  		case ValueType.Comma:  			if (depth == 1 && (++arrayIndex >= arrayLimit))  				return 0;  			++index1;  			++index2;  			break;  		case ValueType.Colon:  			++index1;  			++index2;  			break;  		case ValueType.Illegal:  			return 0;  		}  	}  } while (depth > 0);  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: do {  	var type1 = ValueTypeOf (index1 < param1.Length ? param1 [index1] : '\0');  	var type2 = ValueTypeOf (index2 < param2.Length ? param2 [index2] : '\0');  	if (type1 != type2) {  		if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma)) {  			if (++arrayIndex >= arrayLimit)  				return 0;  		}  		if (mode != JsonCollationMode.Raw)  			return Cmp ((int)type1' (int)type2);  		else  			return Cmp (RawOrderOfValueType (type1)' RawOrderOfValueType (type2));  	} else {  		switch (type1) {  		case ValueType.Null:  		case ValueType.True:  			index1 += 4;  			index2 += 4;  			break;  		case ValueType.False:  			index1 += 5;  			index2 += 5;  			break;  		case ValueType.Number:  			int next1;  			int next2;  			diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  			if (diff != 0)  				return diff;  			index1 = next1;  			index2 = next2;  			break;  		case ValueType.String:  			int endPos1;  			int endPos2;  			if (mode == JsonCollationMode.Unicode)  				diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  			else  				diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  			if (diff != 0)  				return diff;  			index1 = endPos1 + 1;  			index2 = endPos2 + 1;  			break;  		case ValueType.Array:  		case ValueType.Object:  			++index1;  			++index2;  			++depth;  			break;  		case ValueType.EndArray:  		case ValueType.EndObject:  			++index1;  			++index2;  			--depth;  			break;  		case ValueType.Comma:  			if (depth == 1 && (++arrayIndex >= arrayLimit))  				return 0;  			++index1;  			++index2;  			break;  		case ValueType.Colon:  			++index1;  			++index2;  			break;  		case ValueType.Illegal:  			return 0;  		}  	}  } while (depth > 0);  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: do {  	var type1 = ValueTypeOf (index1 < param1.Length ? param1 [index1] : '\0');  	var type2 = ValueTypeOf (index2 < param2.Length ? param2 [index2] : '\0');  	if (type1 != type2) {  		if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma)) {  			if (++arrayIndex >= arrayLimit)  				return 0;  		}  		if (mode != JsonCollationMode.Raw)  			return Cmp ((int)type1' (int)type2);  		else  			return Cmp (RawOrderOfValueType (type1)' RawOrderOfValueType (type2));  	} else {  		switch (type1) {  		case ValueType.Null:  		case ValueType.True:  			index1 += 4;  			index2 += 4;  			break;  		case ValueType.False:  			index1 += 5;  			index2 += 5;  			break;  		case ValueType.Number:  			int next1;  			int next2;  			diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  			if (diff != 0)  				return diff;  			index1 = next1;  			index2 = next2;  			break;  		case ValueType.String:  			int endPos1;  			int endPos2;  			if (mode == JsonCollationMode.Unicode)  				diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  			else  				diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  			if (diff != 0)  				return diff;  			index1 = endPos1 + 1;  			index2 = endPos2 + 1;  			break;  		case ValueType.Array:  		case ValueType.Object:  			++index1;  			++index2;  			++depth;  			break;  		case ValueType.EndArray:  		case ValueType.EndObject:  			++index1;  			++index2;  			--depth;  			break;  		case ValueType.Comma:  			if (depth == 1 && (++arrayIndex >= arrayLimit))  				return 0;  			++index1;  			++index2;  			break;  		case ValueType.Colon:  			++index1;  			++index2;  			break;  		case ValueType.Illegal:  			return 0;  		}  	}  } while (depth > 0);  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: if (type1 != type2) {  	if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma)) {  		if (++arrayIndex >= arrayLimit)  			return 0;  	}  	if (mode != JsonCollationMode.Raw)  		return Cmp ((int)type1' (int)type2);  	else  		return Cmp (RawOrderOfValueType (type1)' RawOrderOfValueType (type2));  } else {  	switch (type1) {  	case ValueType.Null:  	case ValueType.True:  		index1 += 4;  		index2 += 4;  		break;  	case ValueType.False:  		index1 += 5;  		index2 += 5;  		break;  	case ValueType.Number:  		int next1;  		int next2;  		diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  		if (diff != 0)  			return diff;  		index1 = next1;  		index2 = next2;  		break;  	case ValueType.String:  		int endPos1;  		int endPos2;  		if (mode == JsonCollationMode.Unicode)  			diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  		else  			diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  		if (diff != 0)  			return diff;  		index1 = endPos1 + 1;  		index2 = endPos2 + 1;  		break;  	case ValueType.Array:  	case ValueType.Object:  		++index1;  		++index2;  		++depth;  		break;  	case ValueType.EndArray:  	case ValueType.EndObject:  		++index1;  		++index2;  		--depth;  		break;  	case ValueType.Comma:  		if (depth == 1 && (++arrayIndex >= arrayLimit))  			return 0;  		++index1;  		++index2;  		break;  	case ValueType.Colon:  		++index1;  		++index2;  		break;  	case ValueType.Illegal:  		return 0;  	}  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: if (type1 != type2) {  	if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma)) {  		if (++arrayIndex >= arrayLimit)  			return 0;  	}  	if (mode != JsonCollationMode.Raw)  		return Cmp ((int)type1' (int)type2);  	else  		return Cmp (RawOrderOfValueType (type1)' RawOrderOfValueType (type2));  } else {  	switch (type1) {  	case ValueType.Null:  	case ValueType.True:  		index1 += 4;  		index2 += 4;  		break;  	case ValueType.False:  		index1 += 5;  		index2 += 5;  		break;  	case ValueType.Number:  		int next1;  		int next2;  		diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  		if (diff != 0)  			return diff;  		index1 = next1;  		index2 = next2;  		break;  	case ValueType.String:  		int endPos1;  		int endPos2;  		if (mode == JsonCollationMode.Unicode)  			diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  		else  			diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  		if (diff != 0)  			return diff;  		index1 = endPos1 + 1;  		index2 = endPos2 + 1;  		break;  	case ValueType.Array:  	case ValueType.Object:  		++index1;  		++index2;  		++depth;  		break;  	case ValueType.EndArray:  	case ValueType.EndObject:  		++index1;  		++index2;  		--depth;  		break;  	case ValueType.Comma:  		if (depth == 1 && (++arrayIndex >= arrayLimit))  			return 0;  		++index1;  		++index2;  		break;  	case ValueType.Colon:  		++index1;  		++index2;  		break;  	case ValueType.Illegal:  		return 0;  	}  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: if (type1 != type2) {  	if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma)) {  		if (++arrayIndex >= arrayLimit)  			return 0;  	}  	if (mode != JsonCollationMode.Raw)  		return Cmp ((int)type1' (int)type2);  	else  		return Cmp (RawOrderOfValueType (type1)' RawOrderOfValueType (type2));  } else {  	switch (type1) {  	case ValueType.Null:  	case ValueType.True:  		index1 += 4;  		index2 += 4;  		break;  	case ValueType.False:  		index1 += 5;  		index2 += 5;  		break;  	case ValueType.Number:  		int next1;  		int next2;  		diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  		if (diff != 0)  			return diff;  		index1 = next1;  		index2 = next2;  		break;  	case ValueType.String:  		int endPos1;  		int endPos2;  		if (mode == JsonCollationMode.Unicode)  			diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  		else  			diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  		if (diff != 0)  			return diff;  		index1 = endPos1 + 1;  		index2 = endPos2 + 1;  		break;  	case ValueType.Array:  	case ValueType.Object:  		++index1;  		++index2;  		++depth;  		break;  	case ValueType.EndArray:  	case ValueType.EndObject:  		++index1;  		++index2;  		--depth;  		break;  	case ValueType.Comma:  		if (depth == 1 && (++arrayIndex >= arrayLimit))  			return 0;  		++index1;  		++index2;  		break;  	case ValueType.Colon:  		++index1;  		++index2;  		break;  	case ValueType.Illegal:  		return 0;  	}  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: if (type1 != type2) {  	if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma)) {  		if (++arrayIndex >= arrayLimit)  			return 0;  	}  	if (mode != JsonCollationMode.Raw)  		return Cmp ((int)type1' (int)type2);  	else  		return Cmp (RawOrderOfValueType (type1)' RawOrderOfValueType (type2));  } else {  	switch (type1) {  	case ValueType.Null:  	case ValueType.True:  		index1 += 4;  		index2 += 4;  		break;  	case ValueType.False:  		index1 += 5;  		index2 += 5;  		break;  	case ValueType.Number:  		int next1;  		int next2;  		diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  		if (diff != 0)  			return diff;  		index1 = next1;  		index2 = next2;  		break;  	case ValueType.String:  		int endPos1;  		int endPos2;  		if (mode == JsonCollationMode.Unicode)  			diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  		else  			diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  		if (diff != 0)  			return diff;  		index1 = endPos1 + 1;  		index2 = endPos2 + 1;  		break;  	case ValueType.Array:  	case ValueType.Object:  		++index1;  		++index2;  		++depth;  		break;  	case ValueType.EndArray:  	case ValueType.EndObject:  		++index1;  		++index2;  		--depth;  		break;  	case ValueType.Comma:  		if (depth == 1 && (++arrayIndex >= arrayLimit))  			return 0;  		++index1;  		++index2;  		break;  	case ValueType.Colon:  		++index1;  		++index2;  		break;  	case ValueType.Illegal:  		return 0;  	}  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: switch (type1) {  case ValueType.Null:  case ValueType.True:  	index1 += 4;  	index2 += 4;  	break;  case ValueType.False:  	index1 += 5;  	index2 += 5;  	break;  case ValueType.Number:  	int next1;  	int next2;  	diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  	if (diff != 0)  		return diff;  	index1 = next1;  	index2 = next2;  	break;  case ValueType.String:  	int endPos1;  	int endPos2;  	if (mode == JsonCollationMode.Unicode)  		diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  	else  		diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  	if (diff != 0)  		return diff;  	index1 = endPos1 + 1;  	index2 = endPos2 + 1;  	break;  case ValueType.Array:  case ValueType.Object:  	++index1;  	++index2;  	++depth;  	break;  case ValueType.EndArray:  case ValueType.EndObject:  	++index1;  	++index2;  	--depth;  	break;  case ValueType.Comma:  	if (depth == 1 && (++arrayIndex >= arrayLimit))  		return 0;  	++index1;  	++index2;  	break;  case ValueType.Colon:  	++index1;  	++index2;  	break;  case ValueType.Illegal:  	return 0;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: switch (type1) {  case ValueType.Null:  case ValueType.True:  	index1 += 4;  	index2 += 4;  	break;  case ValueType.False:  	index1 += 5;  	index2 += 5;  	break;  case ValueType.Number:  	int next1;  	int next2;  	diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  	if (diff != 0)  		return diff;  	index1 = next1;  	index2 = next2;  	break;  case ValueType.String:  	int endPos1;  	int endPos2;  	if (mode == JsonCollationMode.Unicode)  		diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  	else  		diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  	if (diff != 0)  		return diff;  	index1 = endPos1 + 1;  	index2 = endPos2 + 1;  	break;  case ValueType.Array:  case ValueType.Object:  	++index1;  	++index2;  	++depth;  	break;  case ValueType.EndArray:  case ValueType.EndObject:  	++index1;  	++index2;  	--depth;  	break;  case ValueType.Comma:  	if (depth == 1 && (++arrayIndex >= arrayLimit))  		return 0;  	++index1;  	++index2;  	break;  case ValueType.Colon:  	++index1;  	++index2;  	break;  case ValueType.Illegal:  	return 0;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: switch (type1) {  case ValueType.Null:  case ValueType.True:  	index1 += 4;  	index2 += 4;  	break;  case ValueType.False:  	index1 += 5;  	index2 += 5;  	break;  case ValueType.Number:  	int next1;  	int next2;  	diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  	if (diff != 0)  		return diff;  	index1 = next1;  	index2 = next2;  	break;  case ValueType.String:  	int endPos1;  	int endPos2;  	if (mode == JsonCollationMode.Unicode)  		diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  	else  		diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  	if (diff != 0)  		return diff;  	index1 = endPos1 + 1;  	index2 = endPos2 + 1;  	break;  case ValueType.Array:  case ValueType.Object:  	++index1;  	++index2;  	++depth;  	break;  case ValueType.EndArray:  case ValueType.EndObject:  	++index1;  	++index2;  	--depth;  	break;  case ValueType.Comma:  	if (depth == 1 && (++arrayIndex >= arrayLimit))  		return 0;  	++index1;  	++index2;  	break;  case ValueType.Colon:  	++index1;  	++index2;  	break;  case ValueType.Illegal:  	return 0;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: switch (type1) {  case ValueType.Null:  case ValueType.True:  	index1 += 4;  	index2 += 4;  	break;  case ValueType.False:  	index1 += 5;  	index2 += 5;  	break;  case ValueType.Number:  	int next1;  	int next2;  	diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  	if (diff != 0)  		return diff;  	index1 = next1;  	index2 = next2;  	break;  case ValueType.String:  	int endPos1;  	int endPos2;  	if (mode == JsonCollationMode.Unicode)  		diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  	else  		diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  	if (diff != 0)  		return diff;  	index1 = endPos1 + 1;  	index2 = endPos2 + 1;  	break;  case ValueType.Array:  case ValueType.Object:  	++index1;  	++index2;  	++depth;  	break;  case ValueType.EndArray:  case ValueType.EndObject:  	++index1;  	++index2;  	--depth;  	break;  case ValueType.Comma:  	if (depth == 1 && (++arrayIndex >= arrayLimit))  		return 0;  	++index1;  	++index2;  	break;  case ValueType.Colon:  	++index1;  	++index2;  	break;  case ValueType.Illegal:  	return 0;  }  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: index1 += 4;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: index2 += 4;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: index1 += 5;  
Magic Number,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: index2 += 5;  
Magic Number,Couchbase.Lite,RevIdCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\RevIdCollator.cs,ParseDigits,The following statement contains a magic number: for (var i = 0; i < endPos; i++) {  	var ch = rev [i];  	if (!Char.IsDigit (ch)) {  		return 0;  	}  	result = (10 * result) + (ch - '0');  }  
Magic Number,Couchbase.Lite,RevIdCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\RevIdCollator.cs,ParseDigits,The following statement contains a magic number: result = (10 * result) + (ch - '0');  
Magic Number,Couchbase.Lite,RevIdCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\RevIdCollator.cs,Compare,The following statement contains a magic number: if ((dash1 == 1 && dash2 == 1) || dash1 > 8 || dash2 > 8 || dash1 == -1 || dash2 == -1) {  	// Single-digit generation #s' or improper rev IDs; just compare as plain text:  	return DefaultCollate (rev1' rev2);  }  
Magic Number,Couchbase.Lite,RevIdCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\RevIdCollator.cs,Compare,The following statement contains a magic number: if ((dash1 == 1 && dash2 == 1) || dash1 > 8 || dash2 > 8 || dash1 == -1 || dash2 == -1) {  	// Single-digit generation #s' or improper rev IDs; just compare as plain text:  	return DefaultCollate (rev1' rev2);  }  
Missing Default,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following switch statement is missing a default case: switch (c) {  case 'u':  	// \u is a Unicode escape; 4 hex digits follow.  	int uIndex = index + 1;  	// TODO: Check Valid Digit  	if (uIndex + 3 < str.Length) {  		int uc = (DigitToInt (str [uIndex + 0]) << 12) | (DigitToInt (str [uIndex + 1]) << 8) | (DigitToInt (str [uIndex + 2]) << 4) | (DigitToInt (str [uIndex + 3]));  		if (uc > 127) {  			// TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);  		}  		endPos = uIndex + 3;  		return (char)uc;  	}  	break;  case 'b':  	c = '\b';  	break;  case 'n':  	c = '\n';  	break;  case 'r':  	c = '\r';  	break;  case 't':  	c = '\t';  	break;  }  
Missing Default,Couchbase.Lite,JsonCollator,F:\newReposMay17\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following switch statement is missing a default case: switch (type1) {  case ValueType.Null:  case ValueType.True:  	index1 += 4;  	index2 += 4;  	break;  case ValueType.False:  	index1 += 5;  	index2 += 5;  	break;  case ValueType.Number:  	int next1;  	int next2;  	diff = DCmp (ReadNumber (param1' index1' out next1)' ReadNumber (param2' index2' out next2));  	if (diff != 0)  		return diff;  	index1 = next1;  	index2 = next2;  	break;  case ValueType.String:  	int endPos1;  	int endPos2;  	if (mode == JsonCollationMode.Unicode)  		diff = CompareStringsUnicode (param1' index1' out endPos1' param2' index2' out endPos2);  	else  		diff = CompareStringsAscii (param1' index1' out endPos1' param2' index2' out endPos2);  	if (diff != 0)  		return diff;  	index1 = endPos1 + 1;  	index2 = endPos2 + 1;  	break;  case ValueType.Array:  case ValueType.Object:  	++index1;  	++index2;  	++depth;  	break;  case ValueType.EndArray:  case ValueType.EndObject:  	++index1;  	++index2;  	--depth;  	break;  case ValueType.Comma:  	if (depth == 1 && (++arrayIndex >= arrayLimit))  		return 0;  	++index1;  	++index2;  	break;  case ValueType.Colon:  	++index1;  	++index2;  	break;  case ValueType.Illegal:  	return 0;  }  
