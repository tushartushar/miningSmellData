Implementation smell,Namespace,Class,File,Method,Description
Long Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The method has 132 lines of code.
Long Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The method has 203 lines of code.
Long Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ForceInsert,The method has 181 lines of code.
Long Method,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunQuery,The method has 115 lines of code.
Long Method,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The method has 290 lines of code.
Long Method,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,Import,The method has 155 lines of code.
Long Method,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The method has 169 lines of code.
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,Cyclomatic complexity of the method is 12
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,Cyclomatic complexity of the method is 23
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutLocalRevision,Cyclomatic complexity of the method is 8
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunQuery,Cyclomatic complexity of the method is 12
Complex Method,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,Cyclomatic complexity of the method is 8
Complex Method,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,Import,Cyclomatic complexity of the method is 10
Complex Method,Couchbase.Lite.Storage.CustomSQLite,v12_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportDoc,Cyclomatic complexity of the method is 8
Complex Method,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,Cyclomatic complexity of the method is 24
Complex Method,SQLitePCL,info,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\util.cs,free,Cyclomatic complexity of the method is 11
Long Parameter List,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocumentProperties,The method has 5 parameters. Parameters: json' docId' revId' deleted' sequence
Long Parameter List,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetRevision,The method has 5 parameters. Parameters: docId' revId' deleted' sequence' json
Long Parameter List,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,RevisionWithDocID,The method has 5 parameters. Parameters: docId' revId' deleted' sequence' json
Long Parameter List,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,InsertRevision,The method has 7 parameters. Parameters: rev' docNumericId' parentSequence' current' hasAttachments' json' docType
Long Parameter List,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutRevision,The method has 7 parameters. Parameters: inDocId' inPrevRevId' properties' deleting' allowConflict' source' validationBlock
Long Parameter List,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,CompareStringsAscii,The method has 6 parameters. Parameters: str1' start1' endPos1' str2' start2' endPos2
Long Parameter List,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,CompareStringsUnicode,The method has 6 parameters. Parameters: str1' start1' endPos1' str2' start2' endPos2
Long Parameter List,SQLitePCL,authorizer_hook_info,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\util.cs,call,The method has 5 parameters. Parameters: action_code' param0' param1' dbName' inner_most_trigger_or_view
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_exec,The method has 5 parameters. Parameters: db' sql' func' user_data' errMsg
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_table_column_metadata,The method has 9 parameters. Parameters: db' dbName' tblName' colName' dataType' collSeq' notNull' primaryKey' autoInc
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_db_status,The method has 5 parameters. Parameters: db' op' current' highest' resetFlg
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_blob_open,The method has 7 parameters. Parameters: db' sdb' table' col' rowid' flags' blob
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_blob_read,The method has 5 parameters. Parameters: blob' b' bOffset' n' offset
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_blob_write,The method has 5 parameters. Parameters: blob' b' bOffset' n' offset
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The method has 5 parameters. Parameters: db' name' nargs' v' func
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The method has 6 parameters. Parameters: db' name' nargs' v' func_step' func_final
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,collation_hook_bridge_impl,The method has 5 parameters. Parameters: p' len1' pv1' len2' pv2
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,update_hook_bridge_impl,The method has 5 parameters. Parameters: p' typ' db' tbl' rowid
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,authorizer_hook_bridge_impl,The method has 6 parameters. Parameters: p' action_code' param0' param1' dbName' inner_most_trigger_or_view
Long Parameter List,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_wal_checkpoint_v2,The method has 5 parameters. Parameters: db' dbName' eMode' logSize' framesCheckPointed
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_prepare,The method has 5 parameters. Parameters: db' pSql' nBytes' stmt' ptrRemain
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_prepare_v2,The method has 5 parameters. Parameters: db' pSql' nBytes' stmt' ptrRemain
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_db_status,The method has 5 parameters. Parameters: db' op' current' highest' resetFlg
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_table_column_metadata,The method has 9 parameters. Parameters: db' dbName' tblName' colName' ptrDataType' ptrCollSeq' notNull' primaryKey' autoInc
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_bind_blob,The method has 5 parameters. Parameters: stmt' index' val' nSize' nTransient
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_bind_text,The method has 5 parameters. Parameters: stmt' index' val' nlen' pvReserved
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_bind_text16,The method has 5 parameters. Parameters: stmt' index' val' nlen' pvReserved
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_create_function_v2,The method has 9 parameters. Parameters: db' strName' nArgs' nType' pvUser' func' fstep' ffinal' fdestroy
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_create_collation,The method has 5 parameters. Parameters: db' strName' nType' pvUser' func
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_exec,The method has 5 parameters. Parameters: db' strSql' cb' pvParam' errMsg
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_blob_open,The method has 7 parameters. Parameters: db' sdb' table' col' rowid' flags' blob
Long Parameter List,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_wal_checkpoint_v2,The method has 5 parameters. Parameters: db' dbName' eMode' logSize' framesCheckPointed
Long Identifier,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,,The length of the parameter SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN is 45.
Long Identifier,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,,The length of the parameter agg_function_hook_bridge_final is 30.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetRevisionSequence,The length of the statement  "            return QueryOrDefault<long>(c => c.GetLong(0)' 0L' "SELECT sequence FROM revs WHERE doc_id=? AND revid=? LIMIT 1"' docNumericId' rev.RevID.ToString()); " is 151.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocumentExpiration,The length of the statement  "            var result = QueryOrDefault<long?>(c => c.GetLong(0)' null' "SELECT expiry_timestamp FROM docs WHERE doc_id=? AND expiry_timestamp IS NOT NULL"' docNumericId); " is 159.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetParentRevision,The length of the statement  "                seq = QueryOrDefault<long>(c => c.GetLong(0)' 0L' "SELECT parent FROM revs WHERE doc_id=? and revid=?"' docNumericId' rev.RevID.ToString()); " is 140.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,FindMissingRevisions,The length of the statement  "                "AND revs.doc_id == docs.doc_id"' Utility.JoinQuoted(revs.GetAllRevIds().Select(x => x.ToString()))' Utility.JoinQuoted(revs.GetAllDocIds())); " is 142.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The length of the statement  "                sql.AppendFormat(" revs.doc_id IN (SELECT doc_id FROM docs WHERE docid IN ({0})) AND"' JoinQuotedObjects(options.Keys)); " is 120.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The length of the statement  "            var orderby = options.SortBySequence ? options.Descending ? "sequence DESC" : "sequence" : "+revs.doc_id' +deleted' revid DESC"; " is 128.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PutLocalRevision,The length of the statement  "                throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.BadId' TAG' "Local revision doesn't start with '_local/'"); " is 120.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,OpenSqliteConnection,The length of the statement  "            Log.To.Database.I(TAG' "Open {0} (flags={1}{2})"' Path' flags' (_encryptionKey != null ? "' encryption key given" : "")); " is 121.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,RawQuery,The length of the statement  "                    Log.To.Database.V (TAG' "RawQuery sql ({2}): {0} ({1})"' sql' String.Join ("' "' paramArgs.ToStringArray ())' IsOnDBThread ? "read uncommit" : "read commit"); " is 158.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Delete,The length of the statement  "                    Log.To.Database.E(TAG' String.Format("Error {0} when deleting from table {1}' rethrowing..."' _writeConnection.extended_errcode()' table)' ex); " is 143.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,GetInsertCommand,The length of the statement  "                Log.To.Database.V(TAG' "Preparing statement: '{0}' with values: {1}"' sql' new SecureLogJsonString(args' LogMessageSensitivity.PotentiallyInsecure)); " is 149.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,ExecSQL,The length of the statement  "                    Log.To.Database.E(TAG' String.Format("Error {0}' {1} ({2}) executing sql '{3}'"' e.errcode' db.extended_errcode()' raw.sqlite3_errmsg(db)' sql)' e); " is 148.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,GroupTogether,The length of the statement  "            return JsonCollator.Compare(JsonCollationMode.Unicode' Encoding.UTF8.GetString(key1)' Encoding.UTF8.GetString(key2)' groupLevel) == 0; " is 134.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunQuery,The length of the statement  "            Log.To.Query.I(Tag' "Query {0}: {1}\n\tArguments: {2}"' Name' sql' new SecureLogJsonString(args' LogMessageSensitivity.PotentiallyInsecure)); " is 141.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,AddAttachmentsToSequence,The length of the statement  "                    var attJson = Manager.GetObjectMapper().WriteValueAsBytes(new Dictionary<string' object> { { "_attachments"' attachments } }); " is 126.
Long Statement,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,MoveAttachmentsDir,The length of the statement  "                    Log.To.Upgrade.I(TAG' "Skip moving the attachments folder as no path change ('{0}' vs '{1}')."' _oldAttachmentsPath' newAttachmentsPath); " is 137.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_blob_open,The length of the statement  "            return NativeMethods.sqlite3_blob_open (db' util.to_utf8 (sdb)' util.to_utf8 (table)' util.to_utf8 (col)' rowid' flags' out blob); " is 130.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The length of the statement  "                int rc = NativeMethods.sqlite3_create_function_v2 (db' util.to_utf8 (name)' nargs' 1' hi.ptr' scalar_function_hook_bridge' null' null' null); " is 141.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The length of the statement  "                return NativeMethods.sqlite3_create_function_v2 (db' util.to_utf8 (name)' nargs' 1' IntPtr.Zero' null' null' null' null); " is 121.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The length of the statement  "                int rc = NativeMethods.sqlite3_create_function_v2 (db' util.to_utf8 (name)' nargs' 1' hi.ptr' null' agg_function_hook_bridge_step' agg_function_hook_bridge_final' null); " is 169.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,sqlite3_create_function,The length of the statement  "                return NativeMethods.sqlite3_create_function_v2 (db' util.to_utf8 (name)' nargs' 1' IntPtr.Zero' null' null' null' null); " is 121.
Long Statement,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,authorizer_hook_bridge_impl,The length of the statement  "            return hi.call (action_code' util.from_utf8 (param0)' util.from_utf8 (param1)' util.from_utf8 (dbName)' util.from_utf8 (inner_most_trigger_or_view)); " is 149.
Complex Conditional,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetLocalDocument,The conditional expression  "json == null || !json.Any() || (json.Length == 2 && json[0] == (byte)'{' && json[1] == '}')"  is complex.
Complex Conditional,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,BuildCommand,The conditional expression  "paramArgs != null && paramArgs.Length > 0 && command != null && LastErrorCode != raw.SQLITE_ERROR"  is complex.
Complex Conditional,Couchbase.Lite,RevIdCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\RevIdCollator.cs,Compare,The conditional expression  "(dash1 == 1 && dash2 == 1)                   || dash1 > 8 || dash2 > 8                  || dash1 == -1 || dash2 == -1"  is complex.
Empty Catch Block,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportLocalDocs,The method has an empty catch block.
Magic Number,Couchbase.Lite.Storage.CustomSQLite,ContentValues,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\ContentValues.cs,ContentValues,The following statement contains a magic number: mValues = new Dictionary<string' object>(8);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,SqliteCouchStore,The following statement contains a magic number: Debug.Assert(_SqliteVersion >= 3007000' String.Format("SQLite library is too old ({0}); needs to be at least 3.7"' raw.sqlite3_libversion()));
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,OptimizeSQLIndexes,The following statement contains a magic number: if (currentSequence > 0) {                  long lastOptimized = long.Parse(GetInfo("last_optimized") ?? "0");                  if (lastOptimized <= currentSequence / 10) {                      RunInTransaction(() =>                      {                          Log.To.Database.I(TAG' "Optimizing SQL indexes (curSeq={0}' last run at {1})"' currentSequence' lastOptimized);                          StorageEngine.ExecSQL("ANALYZE");                          StorageEngine.ExecSQL("ANALYZE sqlite_master");                          SetInfo("last_optimized"' currentSequence.ToString());                          return true;                      });                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,RunStatements,The following statement contains a magic number: foreach (var quotedStatement in sqlStatements.Split(';')) {                  var statement = quotedStatement.Replace('|'' ';');                    if (_SqliteVersion < 3008000) {                      // No partial index support before SQLite 3.8                      if (statement.Contains("CREATE INDEX")) {                          var where = statement.IndexOf("WHERE");                          if (where >= 0) {                              statement = statement.Substring(0' where);                          }                      }                  }                    if (!StringEx.IsNullOrWhiteSpace(statement)) {                      try {                          StorageEngine.ExecSQL(statement);                      } catch(CouchbaseLiteException) {                          Log.To.Database.E(TAG' "Error running statement '{0}'' rethrowing"'                               new SecureLogString(statement' LogMessageSensitivity.PotentiallyInsecure));                          throw;                      } catch(Exception e) {                          throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                              "Error running statement '{0}'"'                               new SecureLogString(statement' LogMessageSensitivity.PotentiallyInsecure));                      }                    }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocumentProperties,The following statement contains a magic number: if (realizedJson.Length == 0 || (realizedJson.Length == 2 && Encoding.UTF8.GetString(realizedJson) == "{}")) {                  docProperties = new Dictionary<string' object>();              } else {                  try {                      docProperties = Manager.GetObjectMapper().ReadValue<IDictionary<string' object>>(realizedJson);                  } catch(CouchbaseLiteException) {                      Log.To.Database.W(TAG' "Unparseable JSON for doc={0}' rev={1}: {2}' returning skeleton set"'                           new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure)'                          revId'                           new SecureLogString(realizedJson' LogMessageSensitivity.PotentiallyInsecure));                      docProperties = new Dictionary<string' object>();                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: TryQuery(c =>              {                  var revId = c.GetString(0).AsRevID();                  bool deleted = c.GetInt(1) != 0;                  result = new RevisionInternal(docId' revId' deleted);                  result.Sequence = sequence;                  result.SetBody(new Body(c.GetBlob(2)));                    return false;              }' "SELECT revid' deleted' json FROM revs WHERE sequence=?"' sequence);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {                  RunStatements("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");                    // Check the user_version number we last stored in the sqliteDb:                  var dbVersion = StorageEngine.GetVersion();                  bool isNew = dbVersion == 17;                  if (isNew) {                      RunStatements("BEGIN TRANSACTION");                  }                    // Incompatible version changes increment the hundreds' place:                  if (dbVersion >= 200) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);                  }                    if (dbVersion < 17) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is older than I know how to work with"' dbVersion);                  }                    if (dbVersion < 18) {                      const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" +                          "PRAGMA user_version = 18";                        RunStatements(upgradeSql);                      dbVersion = 18;                  }                    if (dbVersion < 101) {                      const string upgradeSql = "PRAGMA user_version = 101";                      RunStatements(upgradeSql);                      dbVersion = 101;                  }                    if(dbVersion < 102) {                      const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" +                          "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" +                          "WHERE expiry_timestamp not null;" +                          "PRAGMA user_version = 102";                      RunStatements(upgradeSql);                      dbVersion = 102;                  }                    if (isNew) {                      RunStatements("END TRANSACTION");                      SetInfo("pruned"' "true"); // See Compact for explanation                  }                    if (!isNew && !_readOnly) {                      OptimizeSQLIndexes();                  }              } catch(CouchbaseLiteException) {                  Log.To.Database.E(TAG' "Error initializing the SQLite storage engine' rethrowing...");                  StorageEngine.Close();                  throw;              } catch(Exception e) {                  StorageEngine.Close();                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                      "Error initializing SQLite storage engine");              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {                  RunStatements("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");                    // Check the user_version number we last stored in the sqliteDb:                  var dbVersion = StorageEngine.GetVersion();                  bool isNew = dbVersion == 17;                  if (isNew) {                      RunStatements("BEGIN TRANSACTION");                  }                    // Incompatible version changes increment the hundreds' place:                  if (dbVersion >= 200) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);                  }                    if (dbVersion < 17) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is older than I know how to work with"' dbVersion);                  }                    if (dbVersion < 18) {                      const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" +                          "PRAGMA user_version = 18";                        RunStatements(upgradeSql);                      dbVersion = 18;                  }                    if (dbVersion < 101) {                      const string upgradeSql = "PRAGMA user_version = 101";                      RunStatements(upgradeSql);                      dbVersion = 101;                  }                    if(dbVersion < 102) {                      const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" +                          "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" +                          "WHERE expiry_timestamp not null;" +                          "PRAGMA user_version = 102";                      RunStatements(upgradeSql);                      dbVersion = 102;                  }                    if (isNew) {                      RunStatements("END TRANSACTION");                      SetInfo("pruned"' "true"); // See Compact for explanation                  }                    if (!isNew && !_readOnly) {                      OptimizeSQLIndexes();                  }              } catch(CouchbaseLiteException) {                  Log.To.Database.E(TAG' "Error initializing the SQLite storage engine' rethrowing...");                  StorageEngine.Close();                  throw;              } catch(Exception e) {                  StorageEngine.Close();                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                      "Error initializing SQLite storage engine");              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {                  RunStatements("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");                    // Check the user_version number we last stored in the sqliteDb:                  var dbVersion = StorageEngine.GetVersion();                  bool isNew = dbVersion == 17;                  if (isNew) {                      RunStatements("BEGIN TRANSACTION");                  }                    // Incompatible version changes increment the hundreds' place:                  if (dbVersion >= 200) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);                  }                    if (dbVersion < 17) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is older than I know how to work with"' dbVersion);                  }                    if (dbVersion < 18) {                      const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" +                          "PRAGMA user_version = 18";                        RunStatements(upgradeSql);                      dbVersion = 18;                  }                    if (dbVersion < 101) {                      const string upgradeSql = "PRAGMA user_version = 101";                      RunStatements(upgradeSql);                      dbVersion = 101;                  }                    if(dbVersion < 102) {                      const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" +                          "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" +                          "WHERE expiry_timestamp not null;" +                          "PRAGMA user_version = 102";                      RunStatements(upgradeSql);                      dbVersion = 102;                  }                    if (isNew) {                      RunStatements("END TRANSACTION");                      SetInfo("pruned"' "true"); // See Compact for explanation                  }                    if (!isNew && !_readOnly) {                      OptimizeSQLIndexes();                  }              } catch(CouchbaseLiteException) {                  Log.To.Database.E(TAG' "Error initializing the SQLite storage engine' rethrowing...");                  StorageEngine.Close();                  throw;              } catch(Exception e) {                  StorageEngine.Close();                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                      "Error initializing SQLite storage engine");              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {                  RunStatements("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");                    // Check the user_version number we last stored in the sqliteDb:                  var dbVersion = StorageEngine.GetVersion();                  bool isNew = dbVersion == 17;                  if (isNew) {                      RunStatements("BEGIN TRANSACTION");                  }                    // Incompatible version changes increment the hundreds' place:                  if (dbVersion >= 200) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);                  }                    if (dbVersion < 17) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is older than I know how to work with"' dbVersion);                  }                    if (dbVersion < 18) {                      const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" +                          "PRAGMA user_version = 18";                        RunStatements(upgradeSql);                      dbVersion = 18;                  }                    if (dbVersion < 101) {                      const string upgradeSql = "PRAGMA user_version = 101";                      RunStatements(upgradeSql);                      dbVersion = 101;                  }                    if(dbVersion < 102) {                      const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" +                          "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" +                          "WHERE expiry_timestamp not null;" +                          "PRAGMA user_version = 102";                      RunStatements(upgradeSql);                      dbVersion = 102;                  }                    if (isNew) {                      RunStatements("END TRANSACTION");                      SetInfo("pruned"' "true"); // See Compact for explanation                  }                    if (!isNew && !_readOnly) {                      OptimizeSQLIndexes();                  }              } catch(CouchbaseLiteException) {                  Log.To.Database.E(TAG' "Error initializing the SQLite storage engine' rethrowing...");                  StorageEngine.Close();                  throw;              } catch(Exception e) {                  StorageEngine.Close();                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                      "Error initializing SQLite storage engine");              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {                  RunStatements("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");                    // Check the user_version number we last stored in the sqliteDb:                  var dbVersion = StorageEngine.GetVersion();                  bool isNew = dbVersion == 17;                  if (isNew) {                      RunStatements("BEGIN TRANSACTION");                  }                    // Incompatible version changes increment the hundreds' place:                  if (dbVersion >= 200) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);                  }                    if (dbVersion < 17) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is older than I know how to work with"' dbVersion);                  }                    if (dbVersion < 18) {                      const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" +                          "PRAGMA user_version = 18";                        RunStatements(upgradeSql);                      dbVersion = 18;                  }                    if (dbVersion < 101) {                      const string upgradeSql = "PRAGMA user_version = 101";                      RunStatements(upgradeSql);                      dbVersion = 101;                  }                    if(dbVersion < 102) {                      const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" +                          "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" +                          "WHERE expiry_timestamp not null;" +                          "PRAGMA user_version = 102";                      RunStatements(upgradeSql);                      dbVersion = 102;                  }                    if (isNew) {                      RunStatements("END TRANSACTION");                      SetInfo("pruned"' "true"); // See Compact for explanation                  }                    if (!isNew && !_readOnly) {                      OptimizeSQLIndexes();                  }              } catch(CouchbaseLiteException) {                  Log.To.Database.E(TAG' "Error initializing the SQLite storage engine' rethrowing...");                  StorageEngine.Close();                  throw;              } catch(Exception e) {                  StorageEngine.Close();                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                      "Error initializing SQLite storage engine");              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {                  RunStatements("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");                    // Check the user_version number we last stored in the sqliteDb:                  var dbVersion = StorageEngine.GetVersion();                  bool isNew = dbVersion == 17;                  if (isNew) {                      RunStatements("BEGIN TRANSACTION");                  }                    // Incompatible version changes increment the hundreds' place:                  if (dbVersion >= 200) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);                  }                    if (dbVersion < 17) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is older than I know how to work with"' dbVersion);                  }                    if (dbVersion < 18) {                      const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" +                          "PRAGMA user_version = 18";                        RunStatements(upgradeSql);                      dbVersion = 18;                  }                    if (dbVersion < 101) {                      const string upgradeSql = "PRAGMA user_version = 101";                      RunStatements(upgradeSql);                      dbVersion = 101;                  }                    if(dbVersion < 102) {                      const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" +                          "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" +                          "WHERE expiry_timestamp not null;" +                          "PRAGMA user_version = 102";                      RunStatements(upgradeSql);                      dbVersion = 102;                  }                    if (isNew) {                      RunStatements("END TRANSACTION");                      SetInfo("pruned"' "true"); // See Compact for explanation                  }                    if (!isNew && !_readOnly) {                      OptimizeSQLIndexes();                  }              } catch(CouchbaseLiteException) {                  Log.To.Database.E(TAG' "Error initializing the SQLite storage engine' rethrowing...");                  StorageEngine.Close();                  throw;              } catch(Exception e) {                  StorageEngine.Close();                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                      "Error initializing SQLite storage engine");              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {                  RunStatements("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");                    // Check the user_version number we last stored in the sqliteDb:                  var dbVersion = StorageEngine.GetVersion();                  bool isNew = dbVersion == 17;                  if (isNew) {                      RunStatements("BEGIN TRANSACTION");                  }                    // Incompatible version changes increment the hundreds' place:                  if (dbVersion >= 200) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);                  }                    if (dbVersion < 17) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is older than I know how to work with"' dbVersion);                  }                    if (dbVersion < 18) {                      const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" +                          "PRAGMA user_version = 18";                        RunStatements(upgradeSql);                      dbVersion = 18;                  }                    if (dbVersion < 101) {                      const string upgradeSql = "PRAGMA user_version = 101";                      RunStatements(upgradeSql);                      dbVersion = 101;                  }                    if(dbVersion < 102) {                      const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" +                          "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" +                          "WHERE expiry_timestamp not null;" +                          "PRAGMA user_version = 102";                      RunStatements(upgradeSql);                      dbVersion = 102;                  }                    if (isNew) {                      RunStatements("END TRANSACTION");                      SetInfo("pruned"' "true"); // See Compact for explanation                  }                    if (!isNew && !_readOnly) {                      OptimizeSQLIndexes();                  }              } catch(CouchbaseLiteException) {                  Log.To.Database.E(TAG' "Error initializing the SQLite storage engine' rethrowing...");                  StorageEngine.Close();                  throw;              } catch(Exception e) {                  StorageEngine.Close();                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                      "Error initializing SQLite storage engine");              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {                  RunStatements("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");                    // Check the user_version number we last stored in the sqliteDb:                  var dbVersion = StorageEngine.GetVersion();                  bool isNew = dbVersion == 17;                  if (isNew) {                      RunStatements("BEGIN TRANSACTION");                  }                    // Incompatible version changes increment the hundreds' place:                  if (dbVersion >= 200) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);                  }                    if (dbVersion < 17) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is older than I know how to work with"' dbVersion);                  }                    if (dbVersion < 18) {                      const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" +                          "PRAGMA user_version = 18";                        RunStatements(upgradeSql);                      dbVersion = 18;                  }                    if (dbVersion < 101) {                      const string upgradeSql = "PRAGMA user_version = 101";                      RunStatements(upgradeSql);                      dbVersion = 101;                  }                    if(dbVersion < 102) {                      const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" +                          "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" +                          "WHERE expiry_timestamp not null;" +                          "PRAGMA user_version = 102";                      RunStatements(upgradeSql);                      dbVersion = 102;                  }                    if (isNew) {                      RunStatements("END TRANSACTION");                      SetInfo("pruned"' "true"); // See Compact for explanation                  }                    if (!isNew && !_readOnly) {                      OptimizeSQLIndexes();                  }              } catch(CouchbaseLiteException) {                  Log.To.Database.E(TAG' "Error initializing the SQLite storage engine' rethrowing...");                  StorageEngine.Close();                  throw;              } catch(Exception e) {                  StorageEngine.Close();                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                      "Error initializing SQLite storage engine");              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,Open,The following statement contains a magic number: try {                  RunStatements("PRAGMA foreign_keys = ON; PRAGMA journal_mode=WAL;");                    // Check the user_version number we last stored in the sqliteDb:                  var dbVersion = StorageEngine.GetVersion();                  bool isNew = dbVersion == 17;                  if (isNew) {                      RunStatements("BEGIN TRANSACTION");                  }                    // Incompatible version changes increment the hundreds' place:                  if (dbVersion >= 200) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is newer (>= 200) than I know how to work with"' dbVersion);                  }                    if (dbVersion < 17) {                      throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.DbError' TAG'                          "Database version ({0}) is older than I know how to work with"' dbVersion);                  }                    if (dbVersion < 18) {                      const string upgradeSql = "ALTER TABLE revs ADD COLUMN doc_type TEXT;" +                          "PRAGMA user_version = 18";                        RunStatements(upgradeSql);                      dbVersion = 18;                  }                    if (dbVersion < 101) {                      const string upgradeSql = "PRAGMA user_version = 101";                      RunStatements(upgradeSql);                      dbVersion = 101;                  }                    if(dbVersion < 102) {                      const string upgradeSql = "ALTER TABLE docs ADD COLUMN expiry_timestamp INTEGER;" +                          "CREATE INDEX IF NOT EXISTS docs_expiry ON docs(expiry_timestamp)" +                          "WHERE expiry_timestamp not null;" +                          "PRAGMA user_version = 102";                      RunStatements(upgradeSql);                      dbVersion = 102;                  }                    if (isNew) {                      RunStatements("END TRANSACTION");                      SetInfo("pruned"' "true"); // See Compact for explanation                  }                    if (!isNew && !_readOnly) {                      OptimizeSQLIndexes();                  }              } catch(CouchbaseLiteException) {                  Log.To.Database.E(TAG' "Error initializing the SQLite storage engine' rethrowing...");                  StorageEngine.Close();                  throw;              } catch(Exception e) {                  StorageEngine.Close();                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                      "Error initializing SQLite storage engine");              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PruneRevsToMaxDepth,The following statement contains a magic number: try {                  cursor = StorageEngine.RawQuery(sql);                    while (cursor.MoveToNext()) {                      docNumericID = cursor.GetLong(0);                        var minGenRevId = cursor.GetString(1).AsRevID();                      var maxGenRevId = cursor.GetString(2).AsRevID();                        minGen = minGenRevId.Generation;                      maxGen = maxGenRevId.Generation;                        if ((maxGen - minGen + 1) > maxDepth) {                          toPrune[docNumericID] = (maxGen - minGen);                      }                  }                    if (toPrune.Count == 0) {                      return 0;                  }                    RunInTransaction(() =>                  {                      foreach (var pair in toPrune) {                          outPruned += PruneDocument("?"' pair.Key' pair.Value);                      }                        return true;                  });              } catch (Exception e) {                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG' "Error pruning database");              } finally {                  if (cursor != null) {                      cursor.Close();                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetWinner,The following statement contains a magic number: TryQuery(c =>              {                  revId = c.GetString(0).AsRevID();                  outDeleted.Value = c.GetInt(1) != 0;                  // The document is in conflict if there are two+ result rows that are not deletions.                  outConflict.Value = !outDeleted && c.MoveToNext() && c.GetInt(1) == 0;                  return false;              }' "SELECT revid' deleted FROM revs WHERE doc_id=? and current=1 ORDER BY deleted asc' revid desc LIMIT ?"'                  docNumericId' (!outConflict.IsNull ? 2 : 1));
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocumentRevisions,The following statement contains a magic number: var innerStatus = TryQuery(c =>              {                  var rev = new RevisionInternal(docId' c.GetString(1).AsRevID()' c.GetInt(2) != 0);                  rev.Sequence = c.GetLong(0);                  revs.Add(rev);                    return true;              }' sql.ToString()' docNumericId);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,SetInfo,The following statement contains a magic number: var vals = new ContentValues(2);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: var transactionStatus = TryQuery(c =>              {                  var revIDToUse = revId;                  if(revIDToUse == null) {                      revIDToUse = c.GetString(0).AsRevID();                  }                    bool deleted = c.GetInt(1) != 0;                  if (revId != null || !deleted) {                      result = new RevisionInternal(docId' revIDToUse' deleted);                      result.Sequence = c.GetLong(2);                      if (withBody) {                          result.SetJson(c.GetBlob(3));                      } else {                          result.Missing = c.GetInt(3) == 0;                      }                  }                    return revId == null && deleted;              }' sb.ToString()' docNumericId' revId?.ToString());
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: var transactionStatus = TryQuery(c =>              {                  var revIDToUse = revId;                  if(revIDToUse == null) {                      revIDToUse = c.GetString(0).AsRevID();                  }                    bool deleted = c.GetInt(1) != 0;                  if (revId != null || !deleted) {                      result = new RevisionInternal(docId' revIDToUse' deleted);                      result.Sequence = c.GetLong(2);                      if (withBody) {                          result.SetJson(c.GetBlob(3));                      } else {                          result.Missing = c.GetInt(3) == 0;                      }                  }                    return revId == null && deleted;              }' sb.ToString()' docNumericId' revId?.ToString());
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetDocument,The following statement contains a magic number: var transactionStatus = TryQuery(c =>              {                  var revIDToUse = revId;                  if(revIDToUse == null) {                      revIDToUse = c.GetString(0).AsRevID();                  }                    bool deleted = c.GetInt(1) != 0;                  if (revId != null || !deleted) {                      result = new RevisionInternal(docId' revIDToUse' deleted);                      result.Sequence = c.GetLong(2);                      if (withBody) {                          result.SetJson(c.GetBlob(3));                      } else {                          result.Missing = c.GetInt(3) == 0;                      }                  }                    return revId == null && deleted;              }' sb.ToString()' docNumericId' revId?.ToString());
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetRevisionHistory,The following statement contains a magic number: var status = TryQuery(c =>              {                  var sequence = c.GetLong(0);                  bool matches;                  if(lastSequence == 0) {                      matches = revId == c.GetString(2).AsRevID();                  } else {                      matches = lastSequence == sequence;                  }                    if(matches) {                      var nextRevId = c.GetString(2).AsRevID();                      history.Add(nextRevId);                      lastSequence = c.GetLong(1);                      if(lastSequence == 0) {                          return false;                      }                        if(ancestorRevIds != null && ancestorRevIds.Contains(revId)) {                          return false;                      }                  }                    return true;              }' "SELECT sequence' parent' revid" +              " FROM revs WHERE doc_id=? ORDER BY sequence DESC"' docNumericId);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetRevisionHistory,The following statement contains a magic number: var status = TryQuery(c =>              {                  var sequence = c.GetLong(0);                  bool matches;                  if(lastSequence == 0) {                      matches = revId == c.GetString(2).AsRevID();                  } else {                      matches = lastSequence == sequence;                  }                    if(matches) {                      var nextRevId = c.GetString(2).AsRevID();                      history.Add(nextRevId);                      lastSequence = c.GetLong(1);                      if(lastSequence == 0) {                          return false;                      }                        if(ancestorRevIds != null && ancestorRevIds.Contains(revId)) {                          return false;                      }                  }                    return true;              }' "SELECT sequence' parent' revid" +              " FROM revs WHERE doc_id=? ORDER BY sequence DESC"' docNumericId);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetPossibleAncestors,The following statement contains a magic number: for(int current = 1; current >= 0; current--) {                  var status = TryQuery(c =>                  {                      if (c.GetInt(1) == 0) {                          if (haveBodies) {                              haveBodies.Value = false;                          }                            if (withBodiesOnly) {                              return true;                          }                      } else if(withBodiesOnly) {                          var body = Manager.GetObjectMapper().ReadValue<IDictionary<string' object>>(c.GetBlob(2));                          if (body.ContainsKey("_removed")) {                              return true; // Skip _removed                          }                      }                      revIDs.Add(c.GetString(0).AsRevID());                                              return true;                  }' sql' docNumericId' current' $"{generation}-"' sqlLimit);                    if(status.Code != StatusCode.NotFound && status.IsError) {                      return null;                  }                    if (revIDs.Count > 0) {                      return revIDs;                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {                  c = StorageEngine.RawQuery(sql.ToString()' args.ToArray());                  bool keepGoing = c.MoveToNext();                  while(keepGoing) {                      long docNumericId = c.GetLong(0);                      string docId = c.GetString(1);                      var revId = c.GetString(2);                      long sequence = c.GetLong(3);                      bool deleted = includeDeletedDocs && c.GetInt(includeDocs ? 6 : 4) != 0;                        RevisionInternal docRevision = null;                      if(includeDocs) {                          // Fill in the document contents:                          docRevision = RevisionWithDocID(docId' revId.AsRevID()' deleted' sequence' c.GetBlob(4));                          Debug.Assert(docRevision != null);                      }                        // Iterate over following rows with the same doc_id -- these are conflicts.                      // Skip them' but collect their revIDs if the 'conflicts' option is set:                      List<string> conflicts = null;                      while((keepGoing = c.MoveToNext()) && c.GetLong(0) == docNumericId) {                          if(options.AllDocsMode >= AllDocsMode.ShowConflicts) {                              if(conflicts == null) {                                  conflicts = new List<string>();                                  conflicts.Add(revId.ToString());                              }                                conflicts.Add(c.GetString(2));                          }                      }                        if(options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {                          continue;                      }                        var value = new NonNullDictionary<string' object> {                          { "rev"' revId }'                          { "deleted"' deleted ? (object)true : null }'                          { "_conflicts"' conflicts } // (not found in CouchDB)                      };                        var row = new QueryRow(docId' sequence' docId' value' docRevision' null);                      if(options.Keys != null) {                          docs[docId] = row;                      } else if(options.Filter == null || options.Filter(row)) {                          rows.Add(row);                      }                  }              } catch(Exception e) {                  Log.To.Database.W(TAG' "Error in all docs query' returning null..."' e);                  return null;              } finally {                  if(c != null) {                      c.Close();                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {                  c = StorageEngine.RawQuery(sql.ToString()' args.ToArray());                  bool keepGoing = c.MoveToNext();                  while(keepGoing) {                      long docNumericId = c.GetLong(0);                      string docId = c.GetString(1);                      var revId = c.GetString(2);                      long sequence = c.GetLong(3);                      bool deleted = includeDeletedDocs && c.GetInt(includeDocs ? 6 : 4) != 0;                        RevisionInternal docRevision = null;                      if(includeDocs) {                          // Fill in the document contents:                          docRevision = RevisionWithDocID(docId' revId.AsRevID()' deleted' sequence' c.GetBlob(4));                          Debug.Assert(docRevision != null);                      }                        // Iterate over following rows with the same doc_id -- these are conflicts.                      // Skip them' but collect their revIDs if the 'conflicts' option is set:                      List<string> conflicts = null;                      while((keepGoing = c.MoveToNext()) && c.GetLong(0) == docNumericId) {                          if(options.AllDocsMode >= AllDocsMode.ShowConflicts) {                              if(conflicts == null) {                                  conflicts = new List<string>();                                  conflicts.Add(revId.ToString());                              }                                conflicts.Add(c.GetString(2));                          }                      }                        if(options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {                          continue;                      }                        var value = new NonNullDictionary<string' object> {                          { "rev"' revId }'                          { "deleted"' deleted ? (object)true : null }'                          { "_conflicts"' conflicts } // (not found in CouchDB)                      };                        var row = new QueryRow(docId' sequence' docId' value' docRevision' null);                      if(options.Keys != null) {                          docs[docId] = row;                      } else if(options.Filter == null || options.Filter(row)) {                          rows.Add(row);                      }                  }              } catch(Exception e) {                  Log.To.Database.W(TAG' "Error in all docs query' returning null..."' e);                  return null;              } finally {                  if(c != null) {                      c.Close();                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {                  c = StorageEngine.RawQuery(sql.ToString()' args.ToArray());                  bool keepGoing = c.MoveToNext();                  while(keepGoing) {                      long docNumericId = c.GetLong(0);                      string docId = c.GetString(1);                      var revId = c.GetString(2);                      long sequence = c.GetLong(3);                      bool deleted = includeDeletedDocs && c.GetInt(includeDocs ? 6 : 4) != 0;                        RevisionInternal docRevision = null;                      if(includeDocs) {                          // Fill in the document contents:                          docRevision = RevisionWithDocID(docId' revId.AsRevID()' deleted' sequence' c.GetBlob(4));                          Debug.Assert(docRevision != null);                      }                        // Iterate over following rows with the same doc_id -- these are conflicts.                      // Skip them' but collect their revIDs if the 'conflicts' option is set:                      List<string> conflicts = null;                      while((keepGoing = c.MoveToNext()) && c.GetLong(0) == docNumericId) {                          if(options.AllDocsMode >= AllDocsMode.ShowConflicts) {                              if(conflicts == null) {                                  conflicts = new List<string>();                                  conflicts.Add(revId.ToString());                              }                                conflicts.Add(c.GetString(2));                          }                      }                        if(options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {                          continue;                      }                        var value = new NonNullDictionary<string' object> {                          { "rev"' revId }'                          { "deleted"' deleted ? (object)true : null }'                          { "_conflicts"' conflicts } // (not found in CouchDB)                      };                        var row = new QueryRow(docId' sequence' docId' value' docRevision' null);                      if(options.Keys != null) {                          docs[docId] = row;                      } else if(options.Filter == null || options.Filter(row)) {                          rows.Add(row);                      }                  }              } catch(Exception e) {                  Log.To.Database.W(TAG' "Error in all docs query' returning null..."' e);                  return null;              } finally {                  if(c != null) {                      c.Close();                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {                  c = StorageEngine.RawQuery(sql.ToString()' args.ToArray());                  bool keepGoing = c.MoveToNext();                  while(keepGoing) {                      long docNumericId = c.GetLong(0);                      string docId = c.GetString(1);                      var revId = c.GetString(2);                      long sequence = c.GetLong(3);                      bool deleted = includeDeletedDocs && c.GetInt(includeDocs ? 6 : 4) != 0;                        RevisionInternal docRevision = null;                      if(includeDocs) {                          // Fill in the document contents:                          docRevision = RevisionWithDocID(docId' revId.AsRevID()' deleted' sequence' c.GetBlob(4));                          Debug.Assert(docRevision != null);                      }                        // Iterate over following rows with the same doc_id -- these are conflicts.                      // Skip them' but collect their revIDs if the 'conflicts' option is set:                      List<string> conflicts = null;                      while((keepGoing = c.MoveToNext()) && c.GetLong(0) == docNumericId) {                          if(options.AllDocsMode >= AllDocsMode.ShowConflicts) {                              if(conflicts == null) {                                  conflicts = new List<string>();                                  conflicts.Add(revId.ToString());                              }                                conflicts.Add(c.GetString(2));                          }                      }                        if(options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {                          continue;                      }                        var value = new NonNullDictionary<string' object> {                          { "rev"' revId }'                          { "deleted"' deleted ? (object)true : null }'                          { "_conflicts"' conflicts } // (not found in CouchDB)                      };                        var row = new QueryRow(docId' sequence' docId' value' docRevision' null);                      if(options.Keys != null) {                          docs[docId] = row;                      } else if(options.Filter == null || options.Filter(row)) {                          rows.Add(row);                      }                  }              } catch(Exception e) {                  Log.To.Database.W(TAG' "Error in all docs query' returning null..."' e);                  return null;              } finally {                  if(c != null) {                      c.Close();                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {                  c = StorageEngine.RawQuery(sql.ToString()' args.ToArray());                  bool keepGoing = c.MoveToNext();                  while(keepGoing) {                      long docNumericId = c.GetLong(0);                      string docId = c.GetString(1);                      var revId = c.GetString(2);                      long sequence = c.GetLong(3);                      bool deleted = includeDeletedDocs && c.GetInt(includeDocs ? 6 : 4) != 0;                        RevisionInternal docRevision = null;                      if(includeDocs) {                          // Fill in the document contents:                          docRevision = RevisionWithDocID(docId' revId.AsRevID()' deleted' sequence' c.GetBlob(4));                          Debug.Assert(docRevision != null);                      }                        // Iterate over following rows with the same doc_id -- these are conflicts.                      // Skip them' but collect their revIDs if the 'conflicts' option is set:                      List<string> conflicts = null;                      while((keepGoing = c.MoveToNext()) && c.GetLong(0) == docNumericId) {                          if(options.AllDocsMode >= AllDocsMode.ShowConflicts) {                              if(conflicts == null) {                                  conflicts = new List<string>();                                  conflicts.Add(revId.ToString());                              }                                conflicts.Add(c.GetString(2));                          }                      }                        if(options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {                          continue;                      }                        var value = new NonNullDictionary<string' object> {                          { "rev"' revId }'                          { "deleted"' deleted ? (object)true : null }'                          { "_conflicts"' conflicts } // (not found in CouchDB)                      };                        var row = new QueryRow(docId' sequence' docId' value' docRevision' null);                      if(options.Keys != null) {                          docs[docId] = row;                      } else if(options.Filter == null || options.Filter(row)) {                          rows.Add(row);                      }                  }              } catch(Exception e) {                  Log.To.Database.W(TAG' "Error in all docs query' returning null..."' e);                  return null;              } finally {                  if(c != null) {                      c.Close();                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetAllDocs,The following statement contains a magic number: try {                  c = StorageEngine.RawQuery(sql.ToString()' args.ToArray());                  bool keepGoing = c.MoveToNext();                  while(keepGoing) {                      long docNumericId = c.GetLong(0);                      string docId = c.GetString(1);                      var revId = c.GetString(2);                      long sequence = c.GetLong(3);                      bool deleted = includeDeletedDocs && c.GetInt(includeDocs ? 6 : 4) != 0;                        RevisionInternal docRevision = null;                      if(includeDocs) {                          // Fill in the document contents:                          docRevision = RevisionWithDocID(docId' revId.AsRevID()' deleted' sequence' c.GetBlob(4));                          Debug.Assert(docRevision != null);                      }                        // Iterate over following rows with the same doc_id -- these are conflicts.                      // Skip them' but collect their revIDs if the 'conflicts' option is set:                      List<string> conflicts = null;                      while((keepGoing = c.MoveToNext()) && c.GetLong(0) == docNumericId) {                          if(options.AllDocsMode >= AllDocsMode.ShowConflicts) {                              if(conflicts == null) {                                  conflicts = new List<string>();                                  conflicts.Add(revId.ToString());                              }                                conflicts.Add(c.GetString(2));                          }                      }                        if(options.AllDocsMode == AllDocsMode.OnlyConflicts && conflicts == null) {                          continue;                      }                        var value = new NonNullDictionary<string' object> {                          { "rev"' revId }'                          { "deleted"' deleted ? (object)true : null }'                          { "_conflicts"' conflicts } // (not found in CouchDB)                      };                        var row = new QueryRow(docId' sequence' docId' value' docRevision' null);                      if(options.Keys != null) {                          docs[docId] = row;                      } else if(options.Filter == null || options.Filter(row)) {                          rows.Add(row);                      }                  }              } catch(Exception e) {                  Log.To.Database.W(TAG' "Error in all docs query' returning null..."' e);                  return null;              } finally {                  if(c != null) {                      c.Close();                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The following statement contains a magic number: TryQuery(c =>              {                  if(!options.IncludeConflicts) {                      // Only count the first rev for a given doc (the rest will be losing conflicts):                      var docNumericId = c.GetLong(1);                      if(docNumericId == lastDocId) {                          return true;                      }                        lastDocId = docNumericId;                  }                    string docId = c.GetString(2);                  var revId = c.GetString(3).AsRevID();                  bool deleted = c.GetInt(4) != 0;                  var rev = new RevisionInternal(docId' revId' deleted);                  rev.Sequence = c.GetLong(0);                  if(includeDocs) {                      rev.SetJson(c.GetBlob(5));                  }                    if((filter == null || filter(rev)) && returned++ < options.Limit) {                      changes.Add(rev);                  }                    if(returned >= options.Limit) {                      return false;                  }                    return true;              }' sql' lastSequence);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The following statement contains a magic number: TryQuery(c =>              {                  if(!options.IncludeConflicts) {                      // Only count the first rev for a given doc (the rest will be losing conflicts):                      var docNumericId = c.GetLong(1);                      if(docNumericId == lastDocId) {                          return true;                      }                        lastDocId = docNumericId;                  }                    string docId = c.GetString(2);                  var revId = c.GetString(3).AsRevID();                  bool deleted = c.GetInt(4) != 0;                  var rev = new RevisionInternal(docId' revId' deleted);                  rev.Sequence = c.GetLong(0);                  if(includeDocs) {                      rev.SetJson(c.GetBlob(5));                  }                    if((filter == null || filter(rev)) && returned++ < options.Limit) {                      changes.Add(rev);                  }                    if(returned >= options.Limit) {                      return false;                  }                    return true;              }' sql' lastSequence);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The following statement contains a magic number: TryQuery(c =>              {                  if(!options.IncludeConflicts) {                      // Only count the first rev for a given doc (the rest will be losing conflicts):                      var docNumericId = c.GetLong(1);                      if(docNumericId == lastDocId) {                          return true;                      }                        lastDocId = docNumericId;                  }                    string docId = c.GetString(2);                  var revId = c.GetString(3).AsRevID();                  bool deleted = c.GetInt(4) != 0;                  var rev = new RevisionInternal(docId' revId' deleted);                  rev.Sequence = c.GetLong(0);                  if(includeDocs) {                      rev.SetJson(c.GetBlob(5));                  }                    if((filter == null || filter(rev)) && returned++ < options.Limit) {                      changes.Add(rev);                  }                    if(returned >= options.Limit) {                      return false;                  }                    return true;              }' sql' lastSequence);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSince,The following statement contains a magic number: TryQuery(c =>              {                  if(!options.IncludeConflicts) {                      // Only count the first rev for a given doc (the rest will be losing conflicts):                      var docNumericId = c.GetLong(1);                      if(docNumericId == lastDocId) {                          return true;                      }                        lastDocId = docNumericId;                  }                    string docId = c.GetString(2);                  var revId = c.GetString(3).AsRevID();                  bool deleted = c.GetInt(4) != 0;                  var rev = new RevisionInternal(docId' revId' deleted);                  rev.Sequence = c.GetLong(0);                  if(includeDocs) {                      rev.SetJson(c.GetBlob(5));                  }                    if((filter == null || filter(rev)) && returned++ < options.Limit) {                      changes.Add(rev);                  }                    if(returned >= options.Limit) {                      return false;                  }                    return true;              }' sql' lastSequence);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: using(var c = StorageEngine.RawQuery(sql' lastSequence)) {                  while(c.MoveToNext()) {                      if(options.SortBySequence) {                          if(losingSequences?.Contains(c.GetLong(0)) == true) {                              continue;                          }                      } else if(!options.IncludeConflicts) {                          // Only count the first rev for a given doc (the rest will be losing conflicts):                          var docNumericId = c.GetLong(1);                          if(docNumericId == lastDocId) {                              continue;                          }                            lastDocId = docNumericId;                      }                        string docId = c.GetString(2);                      var revId = c.GetString(3).AsRevID();                      bool deleted = c.GetInt(4) != 0;                      var rev = new RevisionInternal(docId' revId' deleted);                      rev.Sequence = c.GetLong(0);                      if(includeDocs) {                          rev.SetJson(c.GetBlob(5));                      }                        if(filter == null || filter(rev) && returned++ < options.Limit) {                          yield return rev;                      }                        if(returned >= options.Limit) {                          break;                      }                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: using(var c = StorageEngine.RawQuery(sql' lastSequence)) {                  while(c.MoveToNext()) {                      if(options.SortBySequence) {                          if(losingSequences?.Contains(c.GetLong(0)) == true) {                              continue;                          }                      } else if(!options.IncludeConflicts) {                          // Only count the first rev for a given doc (the rest will be losing conflicts):                          var docNumericId = c.GetLong(1);                          if(docNumericId == lastDocId) {                              continue;                          }                            lastDocId = docNumericId;                      }                        string docId = c.GetString(2);                      var revId = c.GetString(3).AsRevID();                      bool deleted = c.GetInt(4) != 0;                      var rev = new RevisionInternal(docId' revId' deleted);                      rev.Sequence = c.GetLong(0);                      if(includeDocs) {                          rev.SetJson(c.GetBlob(5));                      }                        if(filter == null || filter(rev) && returned++ < options.Limit) {                          yield return rev;                      }                        if(returned >= options.Limit) {                          break;                      }                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: using(var c = StorageEngine.RawQuery(sql' lastSequence)) {                  while(c.MoveToNext()) {                      if(options.SortBySequence) {                          if(losingSequences?.Contains(c.GetLong(0)) == true) {                              continue;                          }                      } else if(!options.IncludeConflicts) {                          // Only count the first rev for a given doc (the rest will be losing conflicts):                          var docNumericId = c.GetLong(1);                          if(docNumericId == lastDocId) {                              continue;                          }                            lastDocId = docNumericId;                      }                        string docId = c.GetString(2);                      var revId = c.GetString(3).AsRevID();                      bool deleted = c.GetInt(4) != 0;                      var rev = new RevisionInternal(docId' revId' deleted);                      rev.Sequence = c.GetLong(0);                      if(includeDocs) {                          rev.SetJson(c.GetBlob(5));                      }                        if(filter == null || filter(rev) && returned++ < options.Limit) {                          yield return rev;                      }                        if(returned >= options.Limit) {                          break;                      }                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,ChangesSinceStreaming,The following statement contains a magic number: using(var c = StorageEngine.RawQuery(sql' lastSequence)) {                  while(c.MoveToNext()) {                      if(options.SortBySequence) {                          if(losingSequences?.Contains(c.GetLong(0)) == true) {                              continue;                          }                      } else if(!options.IncludeConflicts) {                          // Only count the first rev for a given doc (the rest will be losing conflicts):                          var docNumericId = c.GetLong(1);                          if(docNumericId == lastDocId) {                              continue;                          }                            lastDocId = docNumericId;                      }                        string docId = c.GetString(2);                      var revId = c.GetString(3).AsRevID();                      bool deleted = c.GetInt(4) != 0;                      var rev = new RevisionInternal(docId' revId' deleted);                      rev.Sequence = c.GetLong(0);                      if(includeDocs) {                          rev.SetJson(c.GetBlob(5));                      }                        if(filter == null || filter(rev) && returned++ < options.Limit) {                          yield return rev;                      }                        if(returned >= options.Limit) {                          break;                      }                  }              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,PurgeRevisions,The following statement contains a magic number: RunInTransaction(() =>              {                  foreach(var docId in docsToRev.Keys) {                      var docNumericId = GetDocNumericID(docId);                      if(docNumericId == 0) {                          // no such document; skip it                          continue;                      }                        IEnumerable<string> revsPurged = null;                      var revIDs = docsToRev[docId];                      if(revIDs == null) {                          throw Misc.CreateExceptionAndLog(Log.To.Database' StatusCode.BadParam' TAG'                              "Illegal null revIds for {0}"' new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure));                      } else if(revIDs.Count == 0) {                          revsPurged = new List<string>();                      } else if(revIDs.Contains("*")) {                          // Delete all revisions if magic "*" revision ID is given.  Deleting the 'docs'                          // row will delete all 'revs' rows due to cascading.                          try {                              StorageEngine.Delete("docs"' "doc_id=?"' docNumericId.ToString());                          } catch(CouchbaseLiteException) {                              Log.To.Database.E(TAG' "Failed to delete revisions of {0}' rethrowing..."'                                   new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure));                              throw;                          } catch(Exception e) {                              throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                                  "Error deleting revisions of {0}"' new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure));                          }                            InvalidateDocNumericID(docId);                          NotifyPurgedDocument(docId);                          revsPurged = new List<string> { "*" };                      } else {                          // Iterate over all the revisions of the doc' in reverse sequence order.                          // Keep track of all the sequences to delete' i.e. the given revs and ancestors'                          // but not any non-given leaf revs or their ancestors.                          const string sql = "SELECT revid' sequence' parent FROM revs WHERE doc_id=? ORDER BY sequence DESC";                          HashSet<long> seqsToPurge = new HashSet<long>();                          HashSet<long> seqsToKeep = new HashSet<long>();                          HashSet<string> revsToPurge = new HashSet<string>();                          TryQuery(c =>                           {                              string revId = c.GetString(0);                              long sequence = c.GetLong(1);                              long parent = c.GetLong(2);                              if(seqsToPurge.Contains(sequence) || revIDs.Contains(revId) && !seqsToKeep.Contains(sequence)) {                                  // Purge it and maybe its parent:                                  seqsToPurge.Add(sequence);                                  revsToPurge.Add(revId);                                  if(parent > 0) {                                      seqsToPurge.Add(parent);                                  }                              } else {                                  // Keep it and its parent:                                  seqsToPurge.Remove(sequence);                                  revsToPurge.Remove(revId);                                  seqsToKeep.Add(parent);                              }                              return true;                          }' sql' docNumericId);                            seqsToPurge.ExceptWith(seqsToKeep);                          Log.To.Database.I(TAG' "Purging doc '{0}' revs ({1}); asked for ({2})"'                               new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure)'                              new LogJsonString(revsToPurge.ToStringArray())'                              new LogJsonString(revIDs));                                                    if(seqsToPurge.Any()) {                              // Now delete the sequences to be purged.                              var deleteSql = String.Format("sequence in ({0})"' String.Join("' "' seqsToPurge.ToStringArray()));                              int count = 0;                              try {                                  count = StorageEngine.Delete("revs"' deleteSql);                              } catch(CouchbaseLiteException) {                                  Log.To.Database.E(TAG' "Failed to delete revisions of {0}' rethrowing..."'                                       new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure));                                  throw;                              } catch(Exception e) {                                  throw Misc.CreateExceptionAndLog(Log.To.Database' e' TAG'                                      "Error deleting revisions of {0}"' new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure));                              }                                if(count != seqsToPurge.Count) {                                  Log.To.Database.W(TAG' "Only {0} revisions deleted of {1}"' count' String.Join("' "' seqsToPurge.ToStringArray()));                              }                          }                            revsPurged = revsToPurge;                      }                        result["docID"] = revIDs.Where(x => revsPurged.Contains(x));                  }                    return true;              });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteCouchStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteCouchStore.cs,GetLocalDocument,The following statement contains a magic number: TryQuery(c =>              {                  var gotRevId = c.GetString(0).AsRevID();                  if(revId != null && revId != gotRevId) {                      return false;                  }                    var json = c.GetBlob(1);                  IDictionary<string' object> properties;                  if(json == null || !json.Any() || (json.Length == 2 && json[0] == (byte)'{' && json[1] == '}')) {                      properties = new Dictionary<string' object>();                  } else {                      try {                          properties = Manager.GetObjectMapper().ReadValue<IDictionary<string' object>>(json);                      } catch(Exception) {                          return false;                      }                  }                    properties.SetDocRevID(docId' gotRevId);                  result = new RevisionInternal(docId' gotRevId' false);                  result.SetProperties(properties);                    return false;              }' "SELECT revid' json FROM localdocs WHERE docid=?"' docId);
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Open,The following statement contains a magic number: try {                                    OpenRWConnection(_readOnly);                  if(schema != null && GetVersion() == 0) {                      foreach (var statement in schema.Split(';')) {                          ExecSQL(statement);                      }                  }                    _readerConnections = new ConnectionPool (3' OpenROConnection' Close);              } catch(CouchbaseLiteException) {                  Log.To.Database.W(TAG' "Error opening SQLite storage engine' rethrowing...");                  throw;              } catch (Exception ex) {                  throw Misc.CreateExceptionAndLog(Log.To.Database' ex' TAG' "Failed to open SQLite storage engine");              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqlitePCLRawStorageEngine,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqlitePclRawStorageEngine.cs,Close,The following statement contains a magic number: try              {                  // Close any open statements' otherwise the                  // sqlite connection won't actually close.                  sqlite3_stmt next = null;                  while ((next = dbCopy.next_stmt(next))!= null) {                      next.Dispose();                  }                     dbCopy.close();              } catch (KeyNotFoundException ex) {                  // Appears to be a bug in sqlite3.find_stmt. Concurrency issue in static dictionary?                  // Assuming we're done.                  Log.To.Database.W(TAG' "Abandoning database close."' ex);              } catch (ugly.sqlite3_exception ex) {                  Log.To.Database.I(TAG' "Retrying database close due to exception."' ex);                  // Assuming a basic retry fixes this.                  Thread.Sleep(5000);                  dbCopy.close();              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RunQuery,The following statement contains a magic number: dbStorage.TryQuery(c =>               {                  var docId = c.GetString(2);                  status = action(new Lazy<byte[]>(() => c.GetBlob(0))' new Lazy<byte[]>(() => c.GetBlob(1))' docId' c);                  if(status.IsError || status.Code == StatusCode.Reserved) {                      return false;                  } else if((int)status.Code <= 0) {                      status.Code = StatusCode.Ok;                  }                    return true;              }' sql.ToString()' args.ToArray());
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction(() =>                  {                      long dbMaxSequence = db.LastSequence;                      long forViewLastSequence = LastSequenceIndexed;                        // Check whether we need to update at all'                      // and remove obsolete emitted results from the 'maps' table:                      long minLastSequence = dbMaxSequence;                      long[] viewLastSequence = new long[inputViews.Count()];                      int deletedCount = 0;                      int i = 0;                      HashSet<string> docTypes = new HashSet<string>();                      IDictionary<string' string> viewDocTypes = null;                      bool allDocTypes = false;                      IDictionary<int' int> viewTotalRows = new Dictionary<int' int>();                      List<SqliteViewStore> views = new List<SqliteViewStore>(inputViews.Count());                      List<MapDelegate> mapBlocks = new List<MapDelegate>();                      foreach (var view in inputViews.Cast<SqliteViewStore>()) {                          var viewDelegate = view.Delegate;                          var mapBlock = viewDelegate == null ? null : viewDelegate.Map;                          if (mapBlock == null) {                              Debug.Assert(view != this' String.Format("Cannot index view {0}: no map block registered"' view.Name));                              Log.To.View.V(Tag' "    {0} has no map block; skipping it"' view.Name);                              continue;                          }                            long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;                          if(last >= dbMaxSequence) {                              Log.To.View.V(Tag' "{0} is already up to date' skipping..."' view.Name);                              continue;                          }                            views.Add(view);                          mapBlocks.Add(mapBlock);                            int viewId = view.ViewID;                          Debug.Assert(viewId > 0' String.Format("View '{0}' not found in database"' view.Name));                            int totalRows = view.TotalRows;                          viewTotalRows[viewId] = totalRows;                              viewLastSequence[i++] = last;                          if (last < 0) {                              throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                  "Invalid last sequence indexed ({0}) received from {1}"' last' view);                          }                            if (last < dbMaxSequence) {                              minLastSequence = Math.Min(minLastSequence' last);                              Log.To.View.V(Tag' "    {0} last indexed at #{1}"' view.Name' last);                                string docType = viewDelegate.DocumentType;                              if (docType != null) {                                  docTypes.Add(docType);                                  if (viewDocTypes == null) {                                      viewDocTypes = new Dictionary<string' string>();                                  }                                    viewDocTypes[view.Name] = docType;                              } else {                                  // can't filter by doc_type                                  allDocTypes = true;                               }                                bool ok = true;                              int changes = 0;                              if (last == 0) {                                  try {                                      // If the lastSequence has been reset to 0' make sure to remove all map results:                                      using(var changesCursor =  db.StorageEngine.RawQuery(view.QueryString("SELECT COUNT(*) FROM maps_#"))) {                                          changes = changesCursor.GetInt(0);                                      }                                        view.DeleteIndex();                                      view.CreateIndex();                                  } catch(SQLitePCL.Ugly.ugly.sqlite3_exception e) {                                      if(e.errcode == raw.SQLITE_MISUSE) {                                          // Somehow' the maps table does not exist                                          Log.To.View.I(Tag' "Maps table for view does not exist' trying to recover by creating it...");                                          view.CreateIndex();                                      } else {                                          ok = false;                                      }                                  }                                   catch (Exception) {                                      ok = false;                                  }                              } else {                                  db.OptimizeSQLIndexes(); // ensures query will use the right indexes                                  // Delete all obsolete map results (ones from since-replaced revisions):                                  try {                                      changes = db.StorageEngine.ExecSQL(view.QueryString("DELETE FROM 'maps_#' WHERE sequence IN (" +                                      "SELECT parent FROM revs WHERE sequence>?" +                                      "AND +parent>0 AND +parent<=?)")' last' last);                                  } catch (Exception) {                                      ok = false;                                  }                              }                                if (!ok) {                                  throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                      "Error deleting obsolete map results before index update");                              }                                // Update #deleted rows                              deletedCount += changes;                                // Only count these deletes as changes if this isn't a view reset to 0                              if (last != 0) {                                  viewTotalRows[viewId] -= changes;                              }                          }                      }                        if (minLastSequence == dbMaxSequence) {                          return true;                      }                        Log.To.View.I(Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."'                          ViewNames(views)' minLastSequence' dbMaxSequence);                        // This is the emit() block' which gets called from within the user-defined map() block                      // that's called down below.                      SqliteViewStore currentView = null;                      IDictionary<string' object> currentDoc = null;                      long sequence = minLastSequence;                      Status emitStatus = new Status(StatusCode.Ok);                      int insertedCount = 0;                      EmitDelegate emit = (key' value) =>                      {                          if(key == null) {                              Log.To.View.W(Tag' "Emit function called with a null key; ignoring");                              return;                          }                            StatusCode s = currentView.Emit(key' value' value == currentDoc' sequence);                          if (s != StatusCode.Ok) {                              emitStatus.Code = s;                          } else {                              viewTotalRows[currentView.ViewID] += 1;                              insertedCount++;                          }                      };                        // Now scan every revision added since the last time the views were indexed:                      bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);                      var sql = new StringBuilder("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");                      if (checkDocTypes) {                          sql.Append("' doc_type ");                      }                        sql.Append("FROM revs " +                                "JOIN docs ON docs.doc_id = revs.doc_id " +                                "WHERE sequence>? AND +current>0 ");                      if (minLastSequence == 0) {                          sql.Append("AND +deleted=0 ");                      }                        if (!allDocTypes && docTypes.Count > 0) {                      sql.AppendFormat("AND doc_type IN ({0}) "' Utility.JoinQuoted(docTypes));                      }                        sql.Append("ORDER BY +revs.doc_id' +deleted' +revid DESC");                        Cursor c = null;                      Cursor c2 = null;                      try {                          c = db.StorageEngine.RawQuery(sql.ToString()' minLastSequence' dbMaxSequence);                          bool keepGoing = c.MoveToNext();                          while (keepGoing) {                              // Get row values now' before the code below advances 'c':                              long doc_id = c.GetLong(0);                              sequence = c.GetLong(1);                              string docId = c.GetString(2);                              if (docId.StartsWith("_design/")) { // design documents don't get indexed                                  keepGoing = c.MoveToNext();                                  continue;                              }                                var revId = c.GetString(3).AsRevID();                              var json = c.GetBlob(4);                              bool deleted = c.GetInt(5) != 0;                              string docType = checkDocTypes ? c.GetString(6) : null;                                // Skip rows with the same doc_id -- these are losing conflicts.                              var conflicts = default(List<string>);                              while ((keepGoing = c.MoveToNext()) && c.GetLong(0) == doc_id) {                                  if(conflicts == null) {                                      conflicts = new List<string>();                                  }                                                                    conflicts.Add(c.GetString(3));                              }                                long realSequence = sequence; // because sequence may be changed' below                              if (minLastSequence > 0) {                                  // Find conflicts with documents from previous indexings.                                  using (c2 = db.StorageEngine.RawQuery("SELECT revid' sequence FROM revs " +                                    "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " +                                    "ORDER BY revID DESC "' doc_id' minLastSequence)) {                                        if (c2.MoveToNext()) {                                          var oldRevId = c2.GetString(0).AsRevID();                                          // This is the revision that used to be the 'winner'.                                          // Remove its emitted rows:                                          long oldSequence = c2.GetLong(1);                                          foreach (var view in views) {                                              int changes = db.StorageEngine.ExecSQL(QueryString("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);                                              deletedCount += changes;                                              viewTotalRows[view.ViewID] -= changes;                                          }                                            if (deleted || oldRevId.CompareTo(revId) > 0) {                                              // It still 'wins' the conflict' so it's the one that                                              // should be mapped [again]' not the current revision!                                              revId = oldRevId;                                              deleted = false;                                              sequence = oldSequence;                                              json = db.QueryOrDefault<byte[]>(x => x.GetBlob(0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);                                          }                                            if (!deleted) {                                              // Conflict revisions:                                              if (conflicts == null) {                                                  conflicts = new List<string>();                                              }                                                conflicts.Add(oldRevId.ToString());                                              while (c2.MoveToNext()) {                                                  conflicts.Add(c2.GetString(0));                                              }                                          }                                      }                                  }                              }                                if (deleted) {                                  continue;                              }                                // Get the document properties' to pass to the map function:                              currentDoc = db.GetDocumentProperties(json' docId' revId' deleted' sequence);                              if (currentDoc == null) {                                  Log.To.View.W(Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."'                                  new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure)' revId);                                  continue;                              }                                currentDoc["_local_seq"] = sequence;                              if(conflicts != null) {                                  currentDoc["_conflicts"] = conflicts;                              }                                // Call the user-defined map() to emit new key/value pairs from this revision:                              int viewIndex = -1;                              var e = views.GetEnumerator();                              while (e.MoveNext()) {                                  currentView = e.Current;                                  ++viewIndex;                                  if (viewLastSequence[viewIndex] < realSequence) {                                      if (checkDocTypes) {                                          var viewDocType = viewDocTypes[currentView.Name];                                          if (viewDocType != null && viewDocType != docType) {                                              // skip; view's documentType doesn't match this doc                                              continue;                                          }                                      }                                            Log.To.View.V(Tag' "    #{0}: map \"{1}\" for view {2}..."'                                          sequence' docId' e.Current.Name);                                      try {                                          mapBlocks[viewIndex](currentDoc' emit);                                      } catch (Exception x) {                                          Log.To.View.E(Tag' String.Format("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);                                          emitStatus.Code = StatusCode.Exception;                                      }                                        if (emitStatus.IsError) {                                          c.Dispose();                                          return false;                                      }                                  }                              }                                currentView = null;                          }                      } catch(CouchbaseLiteException) {                          Log.To.View.E(Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);                          throw;                      } catch (Exception e) {                          throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);                      } finally {                          if (c != null) {                              c.Dispose();                          }                      }                        // Finally' record the last revision sequence number that was indexed and update #rows:                      foreach (var view in views) {                          view.FinishCreatingIndex();                          int newTotalRows = viewTotalRows[view.ViewID];                          Debug.Assert(newTotalRows >= 0);                            var args = new ContentValues();                          args["lastSequence"] = dbMaxSequence;                          args["total_docs"] = newTotalRows;                          try {                              db.StorageEngine.Update("views"' args' "view_id=?"' view.ViewID.ToString());                          } catch (CouchbaseLiteException) {                              Log.To.View.E(Tag' "Failed to update view {0}' rethrowing..."' view.Name);                              throw;                          } catch(Exception e) {                              throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating view {0}"' view.Name);                          }                      }                        Log.To.View.I(Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"'                          ViewNames(views)' dbMaxSequence' deletedCount' insertedCount);                      return true;                  });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction(() =>                  {                      long dbMaxSequence = db.LastSequence;                      long forViewLastSequence = LastSequenceIndexed;                        // Check whether we need to update at all'                      // and remove obsolete emitted results from the 'maps' table:                      long minLastSequence = dbMaxSequence;                      long[] viewLastSequence = new long[inputViews.Count()];                      int deletedCount = 0;                      int i = 0;                      HashSet<string> docTypes = new HashSet<string>();                      IDictionary<string' string> viewDocTypes = null;                      bool allDocTypes = false;                      IDictionary<int' int> viewTotalRows = new Dictionary<int' int>();                      List<SqliteViewStore> views = new List<SqliteViewStore>(inputViews.Count());                      List<MapDelegate> mapBlocks = new List<MapDelegate>();                      foreach (var view in inputViews.Cast<SqliteViewStore>()) {                          var viewDelegate = view.Delegate;                          var mapBlock = viewDelegate == null ? null : viewDelegate.Map;                          if (mapBlock == null) {                              Debug.Assert(view != this' String.Format("Cannot index view {0}: no map block registered"' view.Name));                              Log.To.View.V(Tag' "    {0} has no map block; skipping it"' view.Name);                              continue;                          }                            long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;                          if(last >= dbMaxSequence) {                              Log.To.View.V(Tag' "{0} is already up to date' skipping..."' view.Name);                              continue;                          }                            views.Add(view);                          mapBlocks.Add(mapBlock);                            int viewId = view.ViewID;                          Debug.Assert(viewId > 0' String.Format("View '{0}' not found in database"' view.Name));                            int totalRows = view.TotalRows;                          viewTotalRows[viewId] = totalRows;                              viewLastSequence[i++] = last;                          if (last < 0) {                              throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                  "Invalid last sequence indexed ({0}) received from {1}"' last' view);                          }                            if (last < dbMaxSequence) {                              minLastSequence = Math.Min(minLastSequence' last);                              Log.To.View.V(Tag' "    {0} last indexed at #{1}"' view.Name' last);                                string docType = viewDelegate.DocumentType;                              if (docType != null) {                                  docTypes.Add(docType);                                  if (viewDocTypes == null) {                                      viewDocTypes = new Dictionary<string' string>();                                  }                                    viewDocTypes[view.Name] = docType;                              } else {                                  // can't filter by doc_type                                  allDocTypes = true;                               }                                bool ok = true;                              int changes = 0;                              if (last == 0) {                                  try {                                      // If the lastSequence has been reset to 0' make sure to remove all map results:                                      using(var changesCursor =  db.StorageEngine.RawQuery(view.QueryString("SELECT COUNT(*) FROM maps_#"))) {                                          changes = changesCursor.GetInt(0);                                      }                                        view.DeleteIndex();                                      view.CreateIndex();                                  } catch(SQLitePCL.Ugly.ugly.sqlite3_exception e) {                                      if(e.errcode == raw.SQLITE_MISUSE) {                                          // Somehow' the maps table does not exist                                          Log.To.View.I(Tag' "Maps table for view does not exist' trying to recover by creating it...");                                          view.CreateIndex();                                      } else {                                          ok = false;                                      }                                  }                                   catch (Exception) {                                      ok = false;                                  }                              } else {                                  db.OptimizeSQLIndexes(); // ensures query will use the right indexes                                  // Delete all obsolete map results (ones from since-replaced revisions):                                  try {                                      changes = db.StorageEngine.ExecSQL(view.QueryString("DELETE FROM 'maps_#' WHERE sequence IN (" +                                      "SELECT parent FROM revs WHERE sequence>?" +                                      "AND +parent>0 AND +parent<=?)")' last' last);                                  } catch (Exception) {                                      ok = false;                                  }                              }                                if (!ok) {                                  throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                      "Error deleting obsolete map results before index update");                              }                                // Update #deleted rows                              deletedCount += changes;                                // Only count these deletes as changes if this isn't a view reset to 0                              if (last != 0) {                                  viewTotalRows[viewId] -= changes;                              }                          }                      }                        if (minLastSequence == dbMaxSequence) {                          return true;                      }                        Log.To.View.I(Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."'                          ViewNames(views)' minLastSequence' dbMaxSequence);                        // This is the emit() block' which gets called from within the user-defined map() block                      // that's called down below.                      SqliteViewStore currentView = null;                      IDictionary<string' object> currentDoc = null;                      long sequence = minLastSequence;                      Status emitStatus = new Status(StatusCode.Ok);                      int insertedCount = 0;                      EmitDelegate emit = (key' value) =>                      {                          if(key == null) {                              Log.To.View.W(Tag' "Emit function called with a null key; ignoring");                              return;                          }                            StatusCode s = currentView.Emit(key' value' value == currentDoc' sequence);                          if (s != StatusCode.Ok) {                              emitStatus.Code = s;                          } else {                              viewTotalRows[currentView.ViewID] += 1;                              insertedCount++;                          }                      };                        // Now scan every revision added since the last time the views were indexed:                      bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);                      var sql = new StringBuilder("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");                      if (checkDocTypes) {                          sql.Append("' doc_type ");                      }                        sql.Append("FROM revs " +                                "JOIN docs ON docs.doc_id = revs.doc_id " +                                "WHERE sequence>? AND +current>0 ");                      if (minLastSequence == 0) {                          sql.Append("AND +deleted=0 ");                      }                        if (!allDocTypes && docTypes.Count > 0) {                      sql.AppendFormat("AND doc_type IN ({0}) "' Utility.JoinQuoted(docTypes));                      }                        sql.Append("ORDER BY +revs.doc_id' +deleted' +revid DESC");                        Cursor c = null;                      Cursor c2 = null;                      try {                          c = db.StorageEngine.RawQuery(sql.ToString()' minLastSequence' dbMaxSequence);                          bool keepGoing = c.MoveToNext();                          while (keepGoing) {                              // Get row values now' before the code below advances 'c':                              long doc_id = c.GetLong(0);                              sequence = c.GetLong(1);                              string docId = c.GetString(2);                              if (docId.StartsWith("_design/")) { // design documents don't get indexed                                  keepGoing = c.MoveToNext();                                  continue;                              }                                var revId = c.GetString(3).AsRevID();                              var json = c.GetBlob(4);                              bool deleted = c.GetInt(5) != 0;                              string docType = checkDocTypes ? c.GetString(6) : null;                                // Skip rows with the same doc_id -- these are losing conflicts.                              var conflicts = default(List<string>);                              while ((keepGoing = c.MoveToNext()) && c.GetLong(0) == doc_id) {                                  if(conflicts == null) {                                      conflicts = new List<string>();                                  }                                                                    conflicts.Add(c.GetString(3));                              }                                long realSequence = sequence; // because sequence may be changed' below                              if (minLastSequence > 0) {                                  // Find conflicts with documents from previous indexings.                                  using (c2 = db.StorageEngine.RawQuery("SELECT revid' sequence FROM revs " +                                    "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " +                                    "ORDER BY revID DESC "' doc_id' minLastSequence)) {                                        if (c2.MoveToNext()) {                                          var oldRevId = c2.GetString(0).AsRevID();                                          // This is the revision that used to be the 'winner'.                                          // Remove its emitted rows:                                          long oldSequence = c2.GetLong(1);                                          foreach (var view in views) {                                              int changes = db.StorageEngine.ExecSQL(QueryString("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);                                              deletedCount += changes;                                              viewTotalRows[view.ViewID] -= changes;                                          }                                            if (deleted || oldRevId.CompareTo(revId) > 0) {                                              // It still 'wins' the conflict' so it's the one that                                              // should be mapped [again]' not the current revision!                                              revId = oldRevId;                                              deleted = false;                                              sequence = oldSequence;                                              json = db.QueryOrDefault<byte[]>(x => x.GetBlob(0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);                                          }                                            if (!deleted) {                                              // Conflict revisions:                                              if (conflicts == null) {                                                  conflicts = new List<string>();                                              }                                                conflicts.Add(oldRevId.ToString());                                              while (c2.MoveToNext()) {                                                  conflicts.Add(c2.GetString(0));                                              }                                          }                                      }                                  }                              }                                if (deleted) {                                  continue;                              }                                // Get the document properties' to pass to the map function:                              currentDoc = db.GetDocumentProperties(json' docId' revId' deleted' sequence);                              if (currentDoc == null) {                                  Log.To.View.W(Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."'                                  new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure)' revId);                                  continue;                              }                                currentDoc["_local_seq"] = sequence;                              if(conflicts != null) {                                  currentDoc["_conflicts"] = conflicts;                              }                                // Call the user-defined map() to emit new key/value pairs from this revision:                              int viewIndex = -1;                              var e = views.GetEnumerator();                              while (e.MoveNext()) {                                  currentView = e.Current;                                  ++viewIndex;                                  if (viewLastSequence[viewIndex] < realSequence) {                                      if (checkDocTypes) {                                          var viewDocType = viewDocTypes[currentView.Name];                                          if (viewDocType != null && viewDocType != docType) {                                              // skip; view's documentType doesn't match this doc                                              continue;                                          }                                      }                                            Log.To.View.V(Tag' "    #{0}: map \"{1}\" for view {2}..."'                                          sequence' docId' e.Current.Name);                                      try {                                          mapBlocks[viewIndex](currentDoc' emit);                                      } catch (Exception x) {                                          Log.To.View.E(Tag' String.Format("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);                                          emitStatus.Code = StatusCode.Exception;                                      }                                        if (emitStatus.IsError) {                                          c.Dispose();                                          return false;                                      }                                  }                              }                                currentView = null;                          }                      } catch(CouchbaseLiteException) {                          Log.To.View.E(Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);                          throw;                      } catch (Exception e) {                          throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);                      } finally {                          if (c != null) {                              c.Dispose();                          }                      }                        // Finally' record the last revision sequence number that was indexed and update #rows:                      foreach (var view in views) {                          view.FinishCreatingIndex();                          int newTotalRows = viewTotalRows[view.ViewID];                          Debug.Assert(newTotalRows >= 0);                            var args = new ContentValues();                          args["lastSequence"] = dbMaxSequence;                          args["total_docs"] = newTotalRows;                          try {                              db.StorageEngine.Update("views"' args' "view_id=?"' view.ViewID.ToString());                          } catch (CouchbaseLiteException) {                              Log.To.View.E(Tag' "Failed to update view {0}' rethrowing..."' view.Name);                              throw;                          } catch(Exception e) {                              throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating view {0}"' view.Name);                          }                      }                        Log.To.View.I(Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"'                          ViewNames(views)' dbMaxSequence' deletedCount' insertedCount);                      return true;                  });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction(() =>                  {                      long dbMaxSequence = db.LastSequence;                      long forViewLastSequence = LastSequenceIndexed;                        // Check whether we need to update at all'                      // and remove obsolete emitted results from the 'maps' table:                      long minLastSequence = dbMaxSequence;                      long[] viewLastSequence = new long[inputViews.Count()];                      int deletedCount = 0;                      int i = 0;                      HashSet<string> docTypes = new HashSet<string>();                      IDictionary<string' string> viewDocTypes = null;                      bool allDocTypes = false;                      IDictionary<int' int> viewTotalRows = new Dictionary<int' int>();                      List<SqliteViewStore> views = new List<SqliteViewStore>(inputViews.Count());                      List<MapDelegate> mapBlocks = new List<MapDelegate>();                      foreach (var view in inputViews.Cast<SqliteViewStore>()) {                          var viewDelegate = view.Delegate;                          var mapBlock = viewDelegate == null ? null : viewDelegate.Map;                          if (mapBlock == null) {                              Debug.Assert(view != this' String.Format("Cannot index view {0}: no map block registered"' view.Name));                              Log.To.View.V(Tag' "    {0} has no map block; skipping it"' view.Name);                              continue;                          }                            long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;                          if(last >= dbMaxSequence) {                              Log.To.View.V(Tag' "{0} is already up to date' skipping..."' view.Name);                              continue;                          }                            views.Add(view);                          mapBlocks.Add(mapBlock);                            int viewId = view.ViewID;                          Debug.Assert(viewId > 0' String.Format("View '{0}' not found in database"' view.Name));                            int totalRows = view.TotalRows;                          viewTotalRows[viewId] = totalRows;                              viewLastSequence[i++] = last;                          if (last < 0) {                              throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                  "Invalid last sequence indexed ({0}) received from {1}"' last' view);                          }                            if (last < dbMaxSequence) {                              minLastSequence = Math.Min(minLastSequence' last);                              Log.To.View.V(Tag' "    {0} last indexed at #{1}"' view.Name' last);                                string docType = viewDelegate.DocumentType;                              if (docType != null) {                                  docTypes.Add(docType);                                  if (viewDocTypes == null) {                                      viewDocTypes = new Dictionary<string' string>();                                  }                                    viewDocTypes[view.Name] = docType;                              } else {                                  // can't filter by doc_type                                  allDocTypes = true;                               }                                bool ok = true;                              int changes = 0;                              if (last == 0) {                                  try {                                      // If the lastSequence has been reset to 0' make sure to remove all map results:                                      using(var changesCursor =  db.StorageEngine.RawQuery(view.QueryString("SELECT COUNT(*) FROM maps_#"))) {                                          changes = changesCursor.GetInt(0);                                      }                                        view.DeleteIndex();                                      view.CreateIndex();                                  } catch(SQLitePCL.Ugly.ugly.sqlite3_exception e) {                                      if(e.errcode == raw.SQLITE_MISUSE) {                                          // Somehow' the maps table does not exist                                          Log.To.View.I(Tag' "Maps table for view does not exist' trying to recover by creating it...");                                          view.CreateIndex();                                      } else {                                          ok = false;                                      }                                  }                                   catch (Exception) {                                      ok = false;                                  }                              } else {                                  db.OptimizeSQLIndexes(); // ensures query will use the right indexes                                  // Delete all obsolete map results (ones from since-replaced revisions):                                  try {                                      changes = db.StorageEngine.ExecSQL(view.QueryString("DELETE FROM 'maps_#' WHERE sequence IN (" +                                      "SELECT parent FROM revs WHERE sequence>?" +                                      "AND +parent>0 AND +parent<=?)")' last' last);                                  } catch (Exception) {                                      ok = false;                                  }                              }                                if (!ok) {                                  throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                      "Error deleting obsolete map results before index update");                              }                                // Update #deleted rows                              deletedCount += changes;                                // Only count these deletes as changes if this isn't a view reset to 0                              if (last != 0) {                                  viewTotalRows[viewId] -= changes;                              }                          }                      }                        if (minLastSequence == dbMaxSequence) {                          return true;                      }                        Log.To.View.I(Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."'                          ViewNames(views)' minLastSequence' dbMaxSequence);                        // This is the emit() block' which gets called from within the user-defined map() block                      // that's called down below.                      SqliteViewStore currentView = null;                      IDictionary<string' object> currentDoc = null;                      long sequence = minLastSequence;                      Status emitStatus = new Status(StatusCode.Ok);                      int insertedCount = 0;                      EmitDelegate emit = (key' value) =>                      {                          if(key == null) {                              Log.To.View.W(Tag' "Emit function called with a null key; ignoring");                              return;                          }                            StatusCode s = currentView.Emit(key' value' value == currentDoc' sequence);                          if (s != StatusCode.Ok) {                              emitStatus.Code = s;                          } else {                              viewTotalRows[currentView.ViewID] += 1;                              insertedCount++;                          }                      };                        // Now scan every revision added since the last time the views were indexed:                      bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);                      var sql = new StringBuilder("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");                      if (checkDocTypes) {                          sql.Append("' doc_type ");                      }                        sql.Append("FROM revs " +                                "JOIN docs ON docs.doc_id = revs.doc_id " +                                "WHERE sequence>? AND +current>0 ");                      if (minLastSequence == 0) {                          sql.Append("AND +deleted=0 ");                      }                        if (!allDocTypes && docTypes.Count > 0) {                      sql.AppendFormat("AND doc_type IN ({0}) "' Utility.JoinQuoted(docTypes));                      }                        sql.Append("ORDER BY +revs.doc_id' +deleted' +revid DESC");                        Cursor c = null;                      Cursor c2 = null;                      try {                          c = db.StorageEngine.RawQuery(sql.ToString()' minLastSequence' dbMaxSequence);                          bool keepGoing = c.MoveToNext();                          while (keepGoing) {                              // Get row values now' before the code below advances 'c':                              long doc_id = c.GetLong(0);                              sequence = c.GetLong(1);                              string docId = c.GetString(2);                              if (docId.StartsWith("_design/")) { // design documents don't get indexed                                  keepGoing = c.MoveToNext();                                  continue;                              }                                var revId = c.GetString(3).AsRevID();                              var json = c.GetBlob(4);                              bool deleted = c.GetInt(5) != 0;                              string docType = checkDocTypes ? c.GetString(6) : null;                                // Skip rows with the same doc_id -- these are losing conflicts.                              var conflicts = default(List<string>);                              while ((keepGoing = c.MoveToNext()) && c.GetLong(0) == doc_id) {                                  if(conflicts == null) {                                      conflicts = new List<string>();                                  }                                                                    conflicts.Add(c.GetString(3));                              }                                long realSequence = sequence; // because sequence may be changed' below                              if (minLastSequence > 0) {                                  // Find conflicts with documents from previous indexings.                                  using (c2 = db.StorageEngine.RawQuery("SELECT revid' sequence FROM revs " +                                    "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " +                                    "ORDER BY revID DESC "' doc_id' minLastSequence)) {                                        if (c2.MoveToNext()) {                                          var oldRevId = c2.GetString(0).AsRevID();                                          // This is the revision that used to be the 'winner'.                                          // Remove its emitted rows:                                          long oldSequence = c2.GetLong(1);                                          foreach (var view in views) {                                              int changes = db.StorageEngine.ExecSQL(QueryString("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);                                              deletedCount += changes;                                              viewTotalRows[view.ViewID] -= changes;                                          }                                            if (deleted || oldRevId.CompareTo(revId) > 0) {                                              // It still 'wins' the conflict' so it's the one that                                              // should be mapped [again]' not the current revision!                                              revId = oldRevId;                                              deleted = false;                                              sequence = oldSequence;                                              json = db.QueryOrDefault<byte[]>(x => x.GetBlob(0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);                                          }                                            if (!deleted) {                                              // Conflict revisions:                                              if (conflicts == null) {                                                  conflicts = new List<string>();                                              }                                                conflicts.Add(oldRevId.ToString());                                              while (c2.MoveToNext()) {                                                  conflicts.Add(c2.GetString(0));                                              }                                          }                                      }                                  }                              }                                if (deleted) {                                  continue;                              }                                // Get the document properties' to pass to the map function:                              currentDoc = db.GetDocumentProperties(json' docId' revId' deleted' sequence);                              if (currentDoc == null) {                                  Log.To.View.W(Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."'                                  new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure)' revId);                                  continue;                              }                                currentDoc["_local_seq"] = sequence;                              if(conflicts != null) {                                  currentDoc["_conflicts"] = conflicts;                              }                                // Call the user-defined map() to emit new key/value pairs from this revision:                              int viewIndex = -1;                              var e = views.GetEnumerator();                              while (e.MoveNext()) {                                  currentView = e.Current;                                  ++viewIndex;                                  if (viewLastSequence[viewIndex] < realSequence) {                                      if (checkDocTypes) {                                          var viewDocType = viewDocTypes[currentView.Name];                                          if (viewDocType != null && viewDocType != docType) {                                              // skip; view's documentType doesn't match this doc                                              continue;                                          }                                      }                                            Log.To.View.V(Tag' "    #{0}: map \"{1}\" for view {2}..."'                                          sequence' docId' e.Current.Name);                                      try {                                          mapBlocks[viewIndex](currentDoc' emit);                                      } catch (Exception x) {                                          Log.To.View.E(Tag' String.Format("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);                                          emitStatus.Code = StatusCode.Exception;                                      }                                        if (emitStatus.IsError) {                                          c.Dispose();                                          return false;                                      }                                  }                              }                                currentView = null;                          }                      } catch(CouchbaseLiteException) {                          Log.To.View.E(Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);                          throw;                      } catch (Exception e) {                          throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);                      } finally {                          if (c != null) {                              c.Dispose();                          }                      }                        // Finally' record the last revision sequence number that was indexed and update #rows:                      foreach (var view in views) {                          view.FinishCreatingIndex();                          int newTotalRows = viewTotalRows[view.ViewID];                          Debug.Assert(newTotalRows >= 0);                            var args = new ContentValues();                          args["lastSequence"] = dbMaxSequence;                          args["total_docs"] = newTotalRows;                          try {                              db.StorageEngine.Update("views"' args' "view_id=?"' view.ViewID.ToString());                          } catch (CouchbaseLiteException) {                              Log.To.View.E(Tag' "Failed to update view {0}' rethrowing..."' view.Name);                              throw;                          } catch(Exception e) {                              throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating view {0}"' view.Name);                          }                      }                        Log.To.View.I(Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"'                          ViewNames(views)' dbMaxSequence' deletedCount' insertedCount);                      return true;                  });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction(() =>                  {                      long dbMaxSequence = db.LastSequence;                      long forViewLastSequence = LastSequenceIndexed;                        // Check whether we need to update at all'                      // and remove obsolete emitted results from the 'maps' table:                      long minLastSequence = dbMaxSequence;                      long[] viewLastSequence = new long[inputViews.Count()];                      int deletedCount = 0;                      int i = 0;                      HashSet<string> docTypes = new HashSet<string>();                      IDictionary<string' string> viewDocTypes = null;                      bool allDocTypes = false;                      IDictionary<int' int> viewTotalRows = new Dictionary<int' int>();                      List<SqliteViewStore> views = new List<SqliteViewStore>(inputViews.Count());                      List<MapDelegate> mapBlocks = new List<MapDelegate>();                      foreach (var view in inputViews.Cast<SqliteViewStore>()) {                          var viewDelegate = view.Delegate;                          var mapBlock = viewDelegate == null ? null : viewDelegate.Map;                          if (mapBlock == null) {                              Debug.Assert(view != this' String.Format("Cannot index view {0}: no map block registered"' view.Name));                              Log.To.View.V(Tag' "    {0} has no map block; skipping it"' view.Name);                              continue;                          }                            long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;                          if(last >= dbMaxSequence) {                              Log.To.View.V(Tag' "{0} is already up to date' skipping..."' view.Name);                              continue;                          }                            views.Add(view);                          mapBlocks.Add(mapBlock);                            int viewId = view.ViewID;                          Debug.Assert(viewId > 0' String.Format("View '{0}' not found in database"' view.Name));                            int totalRows = view.TotalRows;                          viewTotalRows[viewId] = totalRows;                              viewLastSequence[i++] = last;                          if (last < 0) {                              throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                  "Invalid last sequence indexed ({0}) received from {1}"' last' view);                          }                            if (last < dbMaxSequence) {                              minLastSequence = Math.Min(minLastSequence' last);                              Log.To.View.V(Tag' "    {0} last indexed at #{1}"' view.Name' last);                                string docType = viewDelegate.DocumentType;                              if (docType != null) {                                  docTypes.Add(docType);                                  if (viewDocTypes == null) {                                      viewDocTypes = new Dictionary<string' string>();                                  }                                    viewDocTypes[view.Name] = docType;                              } else {                                  // can't filter by doc_type                                  allDocTypes = true;                               }                                bool ok = true;                              int changes = 0;                              if (last == 0) {                                  try {                                      // If the lastSequence has been reset to 0' make sure to remove all map results:                                      using(var changesCursor =  db.StorageEngine.RawQuery(view.QueryString("SELECT COUNT(*) FROM maps_#"))) {                                          changes = changesCursor.GetInt(0);                                      }                                        view.DeleteIndex();                                      view.CreateIndex();                                  } catch(SQLitePCL.Ugly.ugly.sqlite3_exception e) {                                      if(e.errcode == raw.SQLITE_MISUSE) {                                          // Somehow' the maps table does not exist                                          Log.To.View.I(Tag' "Maps table for view does not exist' trying to recover by creating it...");                                          view.CreateIndex();                                      } else {                                          ok = false;                                      }                                  }                                   catch (Exception) {                                      ok = false;                                  }                              } else {                                  db.OptimizeSQLIndexes(); // ensures query will use the right indexes                                  // Delete all obsolete map results (ones from since-replaced revisions):                                  try {                                      changes = db.StorageEngine.ExecSQL(view.QueryString("DELETE FROM 'maps_#' WHERE sequence IN (" +                                      "SELECT parent FROM revs WHERE sequence>?" +                                      "AND +parent>0 AND +parent<=?)")' last' last);                                  } catch (Exception) {                                      ok = false;                                  }                              }                                if (!ok) {                                  throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                      "Error deleting obsolete map results before index update");                              }                                // Update #deleted rows                              deletedCount += changes;                                // Only count these deletes as changes if this isn't a view reset to 0                              if (last != 0) {                                  viewTotalRows[viewId] -= changes;                              }                          }                      }                        if (minLastSequence == dbMaxSequence) {                          return true;                      }                        Log.To.View.I(Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."'                          ViewNames(views)' minLastSequence' dbMaxSequence);                        // This is the emit() block' which gets called from within the user-defined map() block                      // that's called down below.                      SqliteViewStore currentView = null;                      IDictionary<string' object> currentDoc = null;                      long sequence = minLastSequence;                      Status emitStatus = new Status(StatusCode.Ok);                      int insertedCount = 0;                      EmitDelegate emit = (key' value) =>                      {                          if(key == null) {                              Log.To.View.W(Tag' "Emit function called with a null key; ignoring");                              return;                          }                            StatusCode s = currentView.Emit(key' value' value == currentDoc' sequence);                          if (s != StatusCode.Ok) {                              emitStatus.Code = s;                          } else {                              viewTotalRows[currentView.ViewID] += 1;                              insertedCount++;                          }                      };                        // Now scan every revision added since the last time the views were indexed:                      bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);                      var sql = new StringBuilder("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");                      if (checkDocTypes) {                          sql.Append("' doc_type ");                      }                        sql.Append("FROM revs " +                                "JOIN docs ON docs.doc_id = revs.doc_id " +                                "WHERE sequence>? AND +current>0 ");                      if (minLastSequence == 0) {                          sql.Append("AND +deleted=0 ");                      }                        if (!allDocTypes && docTypes.Count > 0) {                      sql.AppendFormat("AND doc_type IN ({0}) "' Utility.JoinQuoted(docTypes));                      }                        sql.Append("ORDER BY +revs.doc_id' +deleted' +revid DESC");                        Cursor c = null;                      Cursor c2 = null;                      try {                          c = db.StorageEngine.RawQuery(sql.ToString()' minLastSequence' dbMaxSequence);                          bool keepGoing = c.MoveToNext();                          while (keepGoing) {                              // Get row values now' before the code below advances 'c':                              long doc_id = c.GetLong(0);                              sequence = c.GetLong(1);                              string docId = c.GetString(2);                              if (docId.StartsWith("_design/")) { // design documents don't get indexed                                  keepGoing = c.MoveToNext();                                  continue;                              }                                var revId = c.GetString(3).AsRevID();                              var json = c.GetBlob(4);                              bool deleted = c.GetInt(5) != 0;                              string docType = checkDocTypes ? c.GetString(6) : null;                                // Skip rows with the same doc_id -- these are losing conflicts.                              var conflicts = default(List<string>);                              while ((keepGoing = c.MoveToNext()) && c.GetLong(0) == doc_id) {                                  if(conflicts == null) {                                      conflicts = new List<string>();                                  }                                                                    conflicts.Add(c.GetString(3));                              }                                long realSequence = sequence; // because sequence may be changed' below                              if (minLastSequence > 0) {                                  // Find conflicts with documents from previous indexings.                                  using (c2 = db.StorageEngine.RawQuery("SELECT revid' sequence FROM revs " +                                    "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " +                                    "ORDER BY revID DESC "' doc_id' minLastSequence)) {                                        if (c2.MoveToNext()) {                                          var oldRevId = c2.GetString(0).AsRevID();                                          // This is the revision that used to be the 'winner'.                                          // Remove its emitted rows:                                          long oldSequence = c2.GetLong(1);                                          foreach (var view in views) {                                              int changes = db.StorageEngine.ExecSQL(QueryString("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);                                              deletedCount += changes;                                              viewTotalRows[view.ViewID] -= changes;                                          }                                            if (deleted || oldRevId.CompareTo(revId) > 0) {                                              // It still 'wins' the conflict' so it's the one that                                              // should be mapped [again]' not the current revision!                                              revId = oldRevId;                                              deleted = false;                                              sequence = oldSequence;                                              json = db.QueryOrDefault<byte[]>(x => x.GetBlob(0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);                                          }                                            if (!deleted) {                                              // Conflict revisions:                                              if (conflicts == null) {                                                  conflicts = new List<string>();                                              }                                                conflicts.Add(oldRevId.ToString());                                              while (c2.MoveToNext()) {                                                  conflicts.Add(c2.GetString(0));                                              }                                          }                                      }                                  }                              }                                if (deleted) {                                  continue;                              }                                // Get the document properties' to pass to the map function:                              currentDoc = db.GetDocumentProperties(json' docId' revId' deleted' sequence);                              if (currentDoc == null) {                                  Log.To.View.W(Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."'                                  new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure)' revId);                                  continue;                              }                                currentDoc["_local_seq"] = sequence;                              if(conflicts != null) {                                  currentDoc["_conflicts"] = conflicts;                              }                                // Call the user-defined map() to emit new key/value pairs from this revision:                              int viewIndex = -1;                              var e = views.GetEnumerator();                              while (e.MoveNext()) {                                  currentView = e.Current;                                  ++viewIndex;                                  if (viewLastSequence[viewIndex] < realSequence) {                                      if (checkDocTypes) {                                          var viewDocType = viewDocTypes[currentView.Name];                                          if (viewDocType != null && viewDocType != docType) {                                              // skip; view's documentType doesn't match this doc                                              continue;                                          }                                      }                                            Log.To.View.V(Tag' "    #{0}: map \"{1}\" for view {2}..."'                                          sequence' docId' e.Current.Name);                                      try {                                          mapBlocks[viewIndex](currentDoc' emit);                                      } catch (Exception x) {                                          Log.To.View.E(Tag' String.Format("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);                                          emitStatus.Code = StatusCode.Exception;                                      }                                        if (emitStatus.IsError) {                                          c.Dispose();                                          return false;                                      }                                  }                              }                                currentView = null;                          }                      } catch(CouchbaseLiteException) {                          Log.To.View.E(Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);                          throw;                      } catch (Exception e) {                          throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);                      } finally {                          if (c != null) {                              c.Dispose();                          }                      }                        // Finally' record the last revision sequence number that was indexed and update #rows:                      foreach (var view in views) {                          view.FinishCreatingIndex();                          int newTotalRows = viewTotalRows[view.ViewID];                          Debug.Assert(newTotalRows >= 0);                            var args = new ContentValues();                          args["lastSequence"] = dbMaxSequence;                          args["total_docs"] = newTotalRows;                          try {                              db.StorageEngine.Update("views"' args' "view_id=?"' view.ViewID.ToString());                          } catch (CouchbaseLiteException) {                              Log.To.View.E(Tag' "Failed to update view {0}' rethrowing..."' view.Name);                              throw;                          } catch(Exception e) {                              throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating view {0}"' view.Name);                          }                      }                        Log.To.View.I(Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"'                          ViewNames(views)' dbMaxSequence' deletedCount' insertedCount);                      return true;                  });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction(() =>                  {                      long dbMaxSequence = db.LastSequence;                      long forViewLastSequence = LastSequenceIndexed;                        // Check whether we need to update at all'                      // and remove obsolete emitted results from the 'maps' table:                      long minLastSequence = dbMaxSequence;                      long[] viewLastSequence = new long[inputViews.Count()];                      int deletedCount = 0;                      int i = 0;                      HashSet<string> docTypes = new HashSet<string>();                      IDictionary<string' string> viewDocTypes = null;                      bool allDocTypes = false;                      IDictionary<int' int> viewTotalRows = new Dictionary<int' int>();                      List<SqliteViewStore> views = new List<SqliteViewStore>(inputViews.Count());                      List<MapDelegate> mapBlocks = new List<MapDelegate>();                      foreach (var view in inputViews.Cast<SqliteViewStore>()) {                          var viewDelegate = view.Delegate;                          var mapBlock = viewDelegate == null ? null : viewDelegate.Map;                          if (mapBlock == null) {                              Debug.Assert(view != this' String.Format("Cannot index view {0}: no map block registered"' view.Name));                              Log.To.View.V(Tag' "    {0} has no map block; skipping it"' view.Name);                              continue;                          }                            long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;                          if(last >= dbMaxSequence) {                              Log.To.View.V(Tag' "{0} is already up to date' skipping..."' view.Name);                              continue;                          }                            views.Add(view);                          mapBlocks.Add(mapBlock);                            int viewId = view.ViewID;                          Debug.Assert(viewId > 0' String.Format("View '{0}' not found in database"' view.Name));                            int totalRows = view.TotalRows;                          viewTotalRows[viewId] = totalRows;                              viewLastSequence[i++] = last;                          if (last < 0) {                              throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                  "Invalid last sequence indexed ({0}) received from {1}"' last' view);                          }                            if (last < dbMaxSequence) {                              minLastSequence = Math.Min(minLastSequence' last);                              Log.To.View.V(Tag' "    {0} last indexed at #{1}"' view.Name' last);                                string docType = viewDelegate.DocumentType;                              if (docType != null) {                                  docTypes.Add(docType);                                  if (viewDocTypes == null) {                                      viewDocTypes = new Dictionary<string' string>();                                  }                                    viewDocTypes[view.Name] = docType;                              } else {                                  // can't filter by doc_type                                  allDocTypes = true;                               }                                bool ok = true;                              int changes = 0;                              if (last == 0) {                                  try {                                      // If the lastSequence has been reset to 0' make sure to remove all map results:                                      using(var changesCursor =  db.StorageEngine.RawQuery(view.QueryString("SELECT COUNT(*) FROM maps_#"))) {                                          changes = changesCursor.GetInt(0);                                      }                                        view.DeleteIndex();                                      view.CreateIndex();                                  } catch(SQLitePCL.Ugly.ugly.sqlite3_exception e) {                                      if(e.errcode == raw.SQLITE_MISUSE) {                                          // Somehow' the maps table does not exist                                          Log.To.View.I(Tag' "Maps table for view does not exist' trying to recover by creating it...");                                          view.CreateIndex();                                      } else {                                          ok = false;                                      }                                  }                                   catch (Exception) {                                      ok = false;                                  }                              } else {                                  db.OptimizeSQLIndexes(); // ensures query will use the right indexes                                  // Delete all obsolete map results (ones from since-replaced revisions):                                  try {                                      changes = db.StorageEngine.ExecSQL(view.QueryString("DELETE FROM 'maps_#' WHERE sequence IN (" +                                      "SELECT parent FROM revs WHERE sequence>?" +                                      "AND +parent>0 AND +parent<=?)")' last' last);                                  } catch (Exception) {                                      ok = false;                                  }                              }                                if (!ok) {                                  throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                      "Error deleting obsolete map results before index update");                              }                                // Update #deleted rows                              deletedCount += changes;                                // Only count these deletes as changes if this isn't a view reset to 0                              if (last != 0) {                                  viewTotalRows[viewId] -= changes;                              }                          }                      }                        if (minLastSequence == dbMaxSequence) {                          return true;                      }                        Log.To.View.I(Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."'                          ViewNames(views)' minLastSequence' dbMaxSequence);                        // This is the emit() block' which gets called from within the user-defined map() block                      // that's called down below.                      SqliteViewStore currentView = null;                      IDictionary<string' object> currentDoc = null;                      long sequence = minLastSequence;                      Status emitStatus = new Status(StatusCode.Ok);                      int insertedCount = 0;                      EmitDelegate emit = (key' value) =>                      {                          if(key == null) {                              Log.To.View.W(Tag' "Emit function called with a null key; ignoring");                              return;                          }                            StatusCode s = currentView.Emit(key' value' value == currentDoc' sequence);                          if (s != StatusCode.Ok) {                              emitStatus.Code = s;                          } else {                              viewTotalRows[currentView.ViewID] += 1;                              insertedCount++;                          }                      };                        // Now scan every revision added since the last time the views were indexed:                      bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);                      var sql = new StringBuilder("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");                      if (checkDocTypes) {                          sql.Append("' doc_type ");                      }                        sql.Append("FROM revs " +                                "JOIN docs ON docs.doc_id = revs.doc_id " +                                "WHERE sequence>? AND +current>0 ");                      if (minLastSequence == 0) {                          sql.Append("AND +deleted=0 ");                      }                        if (!allDocTypes && docTypes.Count > 0) {                      sql.AppendFormat("AND doc_type IN ({0}) "' Utility.JoinQuoted(docTypes));                      }                        sql.Append("ORDER BY +revs.doc_id' +deleted' +revid DESC");                        Cursor c = null;                      Cursor c2 = null;                      try {                          c = db.StorageEngine.RawQuery(sql.ToString()' minLastSequence' dbMaxSequence);                          bool keepGoing = c.MoveToNext();                          while (keepGoing) {                              // Get row values now' before the code below advances 'c':                              long doc_id = c.GetLong(0);                              sequence = c.GetLong(1);                              string docId = c.GetString(2);                              if (docId.StartsWith("_design/")) { // design documents don't get indexed                                  keepGoing = c.MoveToNext();                                  continue;                              }                                var revId = c.GetString(3).AsRevID();                              var json = c.GetBlob(4);                              bool deleted = c.GetInt(5) != 0;                              string docType = checkDocTypes ? c.GetString(6) : null;                                // Skip rows with the same doc_id -- these are losing conflicts.                              var conflicts = default(List<string>);                              while ((keepGoing = c.MoveToNext()) && c.GetLong(0) == doc_id) {                                  if(conflicts == null) {                                      conflicts = new List<string>();                                  }                                                                    conflicts.Add(c.GetString(3));                              }                                long realSequence = sequence; // because sequence may be changed' below                              if (minLastSequence > 0) {                                  // Find conflicts with documents from previous indexings.                                  using (c2 = db.StorageEngine.RawQuery("SELECT revid' sequence FROM revs " +                                    "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " +                                    "ORDER BY revID DESC "' doc_id' minLastSequence)) {                                        if (c2.MoveToNext()) {                                          var oldRevId = c2.GetString(0).AsRevID();                                          // This is the revision that used to be the 'winner'.                                          // Remove its emitted rows:                                          long oldSequence = c2.GetLong(1);                                          foreach (var view in views) {                                              int changes = db.StorageEngine.ExecSQL(QueryString("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);                                              deletedCount += changes;                                              viewTotalRows[view.ViewID] -= changes;                                          }                                            if (deleted || oldRevId.CompareTo(revId) > 0) {                                              // It still 'wins' the conflict' so it's the one that                                              // should be mapped [again]' not the current revision!                                              revId = oldRevId;                                              deleted = false;                                              sequence = oldSequence;                                              json = db.QueryOrDefault<byte[]>(x => x.GetBlob(0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);                                          }                                            if (!deleted) {                                              // Conflict revisions:                                              if (conflicts == null) {                                                  conflicts = new List<string>();                                              }                                                conflicts.Add(oldRevId.ToString());                                              while (c2.MoveToNext()) {                                                  conflicts.Add(c2.GetString(0));                                              }                                          }                                      }                                  }                              }                                if (deleted) {                                  continue;                              }                                // Get the document properties' to pass to the map function:                              currentDoc = db.GetDocumentProperties(json' docId' revId' deleted' sequence);                              if (currentDoc == null) {                                  Log.To.View.W(Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."'                                  new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure)' revId);                                  continue;                              }                                currentDoc["_local_seq"] = sequence;                              if(conflicts != null) {                                  currentDoc["_conflicts"] = conflicts;                              }                                // Call the user-defined map() to emit new key/value pairs from this revision:                              int viewIndex = -1;                              var e = views.GetEnumerator();                              while (e.MoveNext()) {                                  currentView = e.Current;                                  ++viewIndex;                                  if (viewLastSequence[viewIndex] < realSequence) {                                      if (checkDocTypes) {                                          var viewDocType = viewDocTypes[currentView.Name];                                          if (viewDocType != null && viewDocType != docType) {                                              // skip; view's documentType doesn't match this doc                                              continue;                                          }                                      }                                            Log.To.View.V(Tag' "    #{0}: map \"{1}\" for view {2}..."'                                          sequence' docId' e.Current.Name);                                      try {                                          mapBlocks[viewIndex](currentDoc' emit);                                      } catch (Exception x) {                                          Log.To.View.E(Tag' String.Format("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);                                          emitStatus.Code = StatusCode.Exception;                                      }                                        if (emitStatus.IsError) {                                          c.Dispose();                                          return false;                                      }                                  }                              }                                currentView = null;                          }                      } catch(CouchbaseLiteException) {                          Log.To.View.E(Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);                          throw;                      } catch (Exception e) {                          throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);                      } finally {                          if (c != null) {                              c.Dispose();                          }                      }                        // Finally' record the last revision sequence number that was indexed and update #rows:                      foreach (var view in views) {                          view.FinishCreatingIndex();                          int newTotalRows = viewTotalRows[view.ViewID];                          Debug.Assert(newTotalRows >= 0);                            var args = new ContentValues();                          args["lastSequence"] = dbMaxSequence;                          args["total_docs"] = newTotalRows;                          try {                              db.StorageEngine.Update("views"' args' "view_id=?"' view.ViewID.ToString());                          } catch (CouchbaseLiteException) {                              Log.To.View.E(Tag' "Failed to update view {0}' rethrowing..."' view.Name);                              throw;                          } catch(Exception e) {                              throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating view {0}"' view.Name);                          }                      }                        Log.To.View.I(Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"'                          ViewNames(views)' dbMaxSequence' deletedCount' insertedCount);                      return true;                  });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,UpdateIndexes,The following statement contains a magic number: status = db.RunInTransaction(() =>                  {                      long dbMaxSequence = db.LastSequence;                      long forViewLastSequence = LastSequenceIndexed;                        // Check whether we need to update at all'                      // and remove obsolete emitted results from the 'maps' table:                      long minLastSequence = dbMaxSequence;                      long[] viewLastSequence = new long[inputViews.Count()];                      int deletedCount = 0;                      int i = 0;                      HashSet<string> docTypes = new HashSet<string>();                      IDictionary<string' string> viewDocTypes = null;                      bool allDocTypes = false;                      IDictionary<int' int> viewTotalRows = new Dictionary<int' int>();                      List<SqliteViewStore> views = new List<SqliteViewStore>(inputViews.Count());                      List<MapDelegate> mapBlocks = new List<MapDelegate>();                      foreach (var view in inputViews.Cast<SqliteViewStore>()) {                          var viewDelegate = view.Delegate;                          var mapBlock = viewDelegate == null ? null : viewDelegate.Map;                          if (mapBlock == null) {                              Debug.Assert(view != this' String.Format("Cannot index view {0}: no map block registered"' view.Name));                              Log.To.View.V(Tag' "    {0} has no map block; skipping it"' view.Name);                              continue;                          }                            long last = view == this ? forViewLastSequence : view.LastSequenceIndexed;                          if(last >= dbMaxSequence) {                              Log.To.View.V(Tag' "{0} is already up to date' skipping..."' view.Name);                              continue;                          }                            views.Add(view);                          mapBlocks.Add(mapBlock);                            int viewId = view.ViewID;                          Debug.Assert(viewId > 0' String.Format("View '{0}' not found in database"' view.Name));                            int totalRows = view.TotalRows;                          viewTotalRows[viewId] = totalRows;                              viewLastSequence[i++] = last;                          if (last < 0) {                              throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                  "Invalid last sequence indexed ({0}) received from {1}"' last' view);                          }                            if (last < dbMaxSequence) {                              minLastSequence = Math.Min(minLastSequence' last);                              Log.To.View.V(Tag' "    {0} last indexed at #{1}"' view.Name' last);                                string docType = viewDelegate.DocumentType;                              if (docType != null) {                                  docTypes.Add(docType);                                  if (viewDocTypes == null) {                                      viewDocTypes = new Dictionary<string' string>();                                  }                                    viewDocTypes[view.Name] = docType;                              } else {                                  // can't filter by doc_type                                  allDocTypes = true;                               }                                bool ok = true;                              int changes = 0;                              if (last == 0) {                                  try {                                      // If the lastSequence has been reset to 0' make sure to remove all map results:                                      using(var changesCursor =  db.StorageEngine.RawQuery(view.QueryString("SELECT COUNT(*) FROM maps_#"))) {                                          changes = changesCursor.GetInt(0);                                      }                                        view.DeleteIndex();                                      view.CreateIndex();                                  } catch(SQLitePCL.Ugly.ugly.sqlite3_exception e) {                                      if(e.errcode == raw.SQLITE_MISUSE) {                                          // Somehow' the maps table does not exist                                          Log.To.View.I(Tag' "Maps table for view does not exist' trying to recover by creating it...");                                          view.CreateIndex();                                      } else {                                          ok = false;                                      }                                  }                                   catch (Exception) {                                      ok = false;                                  }                              } else {                                  db.OptimizeSQLIndexes(); // ensures query will use the right indexes                                  // Delete all obsolete map results (ones from since-replaced revisions):                                  try {                                      changes = db.StorageEngine.ExecSQL(view.QueryString("DELETE FROM 'maps_#' WHERE sequence IN (" +                                      "SELECT parent FROM revs WHERE sequence>?" +                                      "AND +parent>0 AND +parent<=?)")' last' last);                                  } catch (Exception) {                                      ok = false;                                  }                              }                                if (!ok) {                                  throw Misc.CreateExceptionAndLog(Log.To.View' StatusCode.DbError' Tag'                                      "Error deleting obsolete map results before index update");                              }                                // Update #deleted rows                              deletedCount += changes;                                // Only count these deletes as changes if this isn't a view reset to 0                              if (last != 0) {                                  viewTotalRows[viewId] -= changes;                              }                          }                      }                        if (minLastSequence == dbMaxSequence) {                          return true;                      }                        Log.To.View.I(Tag' "Updating indexes of ({0}) from #{1} to #{2} ..."'                          ViewNames(views)' minLastSequence' dbMaxSequence);                        // This is the emit() block' which gets called from within the user-defined map() block                      // that's called down below.                      SqliteViewStore currentView = null;                      IDictionary<string' object> currentDoc = null;                      long sequence = minLastSequence;                      Status emitStatus = new Status(StatusCode.Ok);                      int insertedCount = 0;                      EmitDelegate emit = (key' value) =>                      {                          if(key == null) {                              Log.To.View.W(Tag' "Emit function called with a null key; ignoring");                              return;                          }                            StatusCode s = currentView.Emit(key' value' value == currentDoc' sequence);                          if (s != StatusCode.Ok) {                              emitStatus.Code = s;                          } else {                              viewTotalRows[currentView.ViewID] += 1;                              insertedCount++;                          }                      };                        // Now scan every revision added since the last time the views were indexed:                      bool checkDocTypes = docTypes.Count > 1 || (allDocTypes && docTypes.Count > 0);                      var sql = new StringBuilder("SELECT revs.doc_id' sequence' docid' revid' json' deleted ");                      if (checkDocTypes) {                          sql.Append("' doc_type ");                      }                        sql.Append("FROM revs " +                                "JOIN docs ON docs.doc_id = revs.doc_id " +                                "WHERE sequence>? AND +current>0 ");                      if (minLastSequence == 0) {                          sql.Append("AND +deleted=0 ");                      }                        if (!allDocTypes && docTypes.Count > 0) {                      sql.AppendFormat("AND doc_type IN ({0}) "' Utility.JoinQuoted(docTypes));                      }                        sql.Append("ORDER BY +revs.doc_id' +deleted' +revid DESC");                        Cursor c = null;                      Cursor c2 = null;                      try {                          c = db.StorageEngine.RawQuery(sql.ToString()' minLastSequence' dbMaxSequence);                          bool keepGoing = c.MoveToNext();                          while (keepGoing) {                              // Get row values now' before the code below advances 'c':                              long doc_id = c.GetLong(0);                              sequence = c.GetLong(1);                              string docId = c.GetString(2);                              if (docId.StartsWith("_design/")) { // design documents don't get indexed                                  keepGoing = c.MoveToNext();                                  continue;                              }                                var revId = c.GetString(3).AsRevID();                              var json = c.GetBlob(4);                              bool deleted = c.GetInt(5) != 0;                              string docType = checkDocTypes ? c.GetString(6) : null;                                // Skip rows with the same doc_id -- these are losing conflicts.                              var conflicts = default(List<string>);                              while ((keepGoing = c.MoveToNext()) && c.GetLong(0) == doc_id) {                                  if(conflicts == null) {                                      conflicts = new List<string>();                                  }                                                                    conflicts.Add(c.GetString(3));                              }                                long realSequence = sequence; // because sequence may be changed' below                              if (minLastSequence > 0) {                                  // Find conflicts with documents from previous indexings.                                  using (c2 = db.StorageEngine.RawQuery("SELECT revid' sequence FROM revs " +                                    "WHERE doc_id=? AND sequence<=? AND current>0 AND deleted=0 " +                                    "ORDER BY revID DESC "' doc_id' minLastSequence)) {                                        if (c2.MoveToNext()) {                                          var oldRevId = c2.GetString(0).AsRevID();                                          // This is the revision that used to be the 'winner'.                                          // Remove its emitted rows:                                          long oldSequence = c2.GetLong(1);                                          foreach (var view in views) {                                              int changes = db.StorageEngine.ExecSQL(QueryString("DELETE FROM 'maps_#' WHERE sequence=?")' oldSequence);                                              deletedCount += changes;                                              viewTotalRows[view.ViewID] -= changes;                                          }                                            if (deleted || oldRevId.CompareTo(revId) > 0) {                                              // It still 'wins' the conflict' so it's the one that                                              // should be mapped [again]' not the current revision!                                              revId = oldRevId;                                              deleted = false;                                              sequence = oldSequence;                                              json = db.QueryOrDefault<byte[]>(x => x.GetBlob(0)' null' "SELECT json FROM revs WHERE sequence=?"' sequence);                                          }                                            if (!deleted) {                                              // Conflict revisions:                                              if (conflicts == null) {                                                  conflicts = new List<string>();                                              }                                                conflicts.Add(oldRevId.ToString());                                              while (c2.MoveToNext()) {                                                  conflicts.Add(c2.GetString(0));                                              }                                          }                                      }                                  }                              }                                if (deleted) {                                  continue;                              }                                // Get the document properties' to pass to the map function:                              currentDoc = db.GetDocumentProperties(json' docId' revId' deleted' sequence);                              if (currentDoc == null) {                                  Log.To.View.W(Tag' "Failed to parse JSON of doc {0} rev {1}' skipping..."'                                  new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure)' revId);                                  continue;                              }                                currentDoc["_local_seq"] = sequence;                              if(conflicts != null) {                                  currentDoc["_conflicts"] = conflicts;                              }                                // Call the user-defined map() to emit new key/value pairs from this revision:                              int viewIndex = -1;                              var e = views.GetEnumerator();                              while (e.MoveNext()) {                                  currentView = e.Current;                                  ++viewIndex;                                  if (viewLastSequence[viewIndex] < realSequence) {                                      if (checkDocTypes) {                                          var viewDocType = viewDocTypes[currentView.Name];                                          if (viewDocType != null && viewDocType != docType) {                                              // skip; view's documentType doesn't match this doc                                              continue;                                          }                                      }                                            Log.To.View.V(Tag' "    #{0}: map \"{1}\" for view {2}..."'                                          sequence' docId' e.Current.Name);                                      try {                                          mapBlocks[viewIndex](currentDoc' emit);                                      } catch (Exception x) {                                          Log.To.View.E(Tag' String.Format("Exception in map() block for view {0}' cancelling update..."' currentView.Name)' x);                                          emitStatus.Code = StatusCode.Exception;                                      }                                        if (emitStatus.IsError) {                                          c.Dispose();                                          return false;                                      }                                  }                              }                                currentView = null;                          }                      } catch(CouchbaseLiteException) {                          Log.To.View.E(Tag' "Failed to update index for {0}' rethrowing..."' currentView.Name);                          throw;                      } catch (Exception e) {                          throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating index for {0}"' currentView.Name);                      } finally {                          if (c != null) {                              c.Dispose();                          }                      }                        // Finally' record the last revision sequence number that was indexed and update #rows:                      foreach (var view in views) {                          view.FinishCreatingIndex();                          int newTotalRows = viewTotalRows[view.ViewID];                          Debug.Assert(newTotalRows >= 0);                            var args = new ContentValues();                          args["lastSequence"] = dbMaxSequence;                          args["total_docs"] = newTotalRows;                          try {                              db.StorageEngine.Update("views"' args' "view_id=?"' view.ViewID.ToString());                          } catch (CouchbaseLiteException) {                              Log.To.View.E(Tag' "Failed to update view {0}' rethrowing..."' view.Name);                              throw;                          } catch(Exception e) {                              throw Misc.CreateExceptionAndLog(Log.To.View' e' Tag' "Error updating view {0}"' view.Name);                          }                      }                        Log.To.View.I(Tag' "...Finished re-indexing ({0}) to #{1} (deleted {2}' added {3})"'                          ViewNames(views)' dbMaxSequence' deletedCount' insertedCount);                      return true;                  });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: RunQuery(options' (keyData' valueData' docId' cursor) =>              {                  long sequence = cursor.GetLong(3);                  RevisionInternal docRevision = null;                  if(options.IncludeDocs) {                      IDictionary<string' object> value = null;                      if(valueData != null && !RowValueIsEntireDoc(valueData.Value)) {                          value = valueData.Value.AsDictionary<string' object>();                      }                        string linkedId = value?.CblID();                      if(linkedId != null) {                          // Linked document: http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Linked_documents                          var linkedRev = value?.CblRev(); //usually null                          docRevision = db.GetDocument(linkedId' linkedRev' true);                          sequence = docRevision == null ? 0 : docRevision.Sequence;                      } else {                          docRevision = db.GetRevision(docId' cursor.GetString(4).AsRevID()' false' sequence' cursor.GetBlob(5));                      }                  }                    Log.To.Query.V(Tag' "Query {0}: Found row with key={1}' value={2}' id={3}"'                      Name' new SecureLogString(keyData.Value' LogMessageSensitivity.PotentiallyInsecure)'                      new SecureLogString(valueData.Value' LogMessageSensitivity.PotentiallyInsecure)'                      new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure));                    QueryRow row = null;                  if(false) {                      //TODO: bbox                  } else {                      row = new QueryRow(docId' sequence' keyData.Value' valueData.Value' docRevision' this);                  }                    if(filter != null) {                      if(!filter(row)) {                          return new Status(StatusCode.Ok);                      }                        if(skip > 0) {                          --skip;                          return new Status(StatusCode.Ok);                      }                  }                      if(limit-- == 0) {                      return new Status(StatusCode.Reserved);                  }                  rows.Add(row);                    return new Status(StatusCode.Ok);              });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: RunQuery(options' (keyData' valueData' docId' cursor) =>              {                  long sequence = cursor.GetLong(3);                  RevisionInternal docRevision = null;                  if(options.IncludeDocs) {                      IDictionary<string' object> value = null;                      if(valueData != null && !RowValueIsEntireDoc(valueData.Value)) {                          value = valueData.Value.AsDictionary<string' object>();                      }                        string linkedId = value?.CblID();                      if(linkedId != null) {                          // Linked document: http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Linked_documents                          var linkedRev = value?.CblRev(); //usually null                          docRevision = db.GetDocument(linkedId' linkedRev' true);                          sequence = docRevision == null ? 0 : docRevision.Sequence;                      } else {                          docRevision = db.GetRevision(docId' cursor.GetString(4).AsRevID()' false' sequence' cursor.GetBlob(5));                      }                  }                    Log.To.Query.V(Tag' "Query {0}: Found row with key={1}' value={2}' id={3}"'                      Name' new SecureLogString(keyData.Value' LogMessageSensitivity.PotentiallyInsecure)'                      new SecureLogString(valueData.Value' LogMessageSensitivity.PotentiallyInsecure)'                      new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure));                    QueryRow row = null;                  if(false) {                      //TODO: bbox                  } else {                      row = new QueryRow(docId' sequence' keyData.Value' valueData.Value' docRevision' this);                  }                    if(filter != null) {                      if(!filter(row)) {                          return new Status(StatusCode.Ok);                      }                        if(skip > 0) {                          --skip;                          return new Status(StatusCode.Ok);                      }                  }                      if(limit-- == 0) {                      return new Status(StatusCode.Reserved);                  }                  rows.Add(row);                    return new Status(StatusCode.Ok);              });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,RegularQuery,The following statement contains a magic number: RunQuery(options' (keyData' valueData' docId' cursor) =>              {                  long sequence = cursor.GetLong(3);                  RevisionInternal docRevision = null;                  if(options.IncludeDocs) {                      IDictionary<string' object> value = null;                      if(valueData != null && !RowValueIsEntireDoc(valueData.Value)) {                          value = valueData.Value.AsDictionary<string' object>();                      }                        string linkedId = value?.CblID();                      if(linkedId != null) {                          // Linked document: http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Linked_documents                          var linkedRev = value?.CblRev(); //usually null                          docRevision = db.GetDocument(linkedId' linkedRev' true);                          sequence = docRevision == null ? 0 : docRevision.Sequence;                      } else {                          docRevision = db.GetRevision(docId' cursor.GetString(4).AsRevID()' false' sequence' cursor.GetBlob(5));                      }                  }                    Log.To.Query.V(Tag' "Query {0}: Found row with key={1}' value={2}' id={3}"'                      Name' new SecureLogString(keyData.Value' LogMessageSensitivity.PotentiallyInsecure)'                      new SecureLogString(valueData.Value' LogMessageSensitivity.PotentiallyInsecure)'                      new SecureLogString(docId' LogMessageSensitivity.PotentiallyInsecure));                    QueryRow row = null;                  if(false) {                      //TODO: bbox                  } else {                      row = new QueryRow(docId' sequence' keyData.Value' valueData.Value' docRevision' this);                  }                    if(filter != null) {                      if(!filter(row)) {                          return new Status(StatusCode.Ok);                      }                        if(skip > 0) {                          --skip;                          return new Status(StatusCode.Ok);                      }                  }                      if(limit-- == 0) {                      return new Status(StatusCode.Reserved);                  }                  rows.Add(row);                    return new Status(StatusCode.Ok);              });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,ReducedQuery,The following statement contains a magic number: if (reduce != null) {                  keysToReduce = new List<object>(100);                  valuesToReduce = new List<object>(100);              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,ReducedQuery,The following statement contains a magic number: if (reduce != null) {                  keysToReduce = new List<object>(100);                  valuesToReduce = new List<object>(100);              }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,SqliteViewStore,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\SqliteViewStore.cs,Dump,The following statement contains a magic number: _dbStorage.TryQuery(c =>              {                  retVal.Add(new Dictionary<string' object>() {                      { "seq"' c.GetLong(0) }'                      { "key"' c.GetString(1) }'                      { "val"' c.GetString(2) }                  });                    return true;              }' QueryString("SELECT sequence' key' value FROM 'maps_#' ORDER BY key"));
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportDoc,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(revQuery))) {                      long sequence = raw.sqlite3_column_int64(revQuery' 0);                      var revID = raw.sqlite3_column_text(revQuery' 1).AsRevID();                      long parentSeq = raw.sqlite3_column_int64(revQuery' 2);                      bool current = raw.sqlite3_column_int(revQuery' 3) != 0;                        if (current) {                          // Add a leaf revision:                          bool deleted = raw.sqlite3_column_int(revQuery' 4) != 0;                          IEnumerable<byte> json = raw.sqlite3_column_blob(revQuery' 5);                          if (json == null) {                              json = Encoding.UTF8.GetBytes("{}");                          }                            var nuJson = new List<byte>(json);                          try {                              AddAttachmentsToSequence(sequence' nuJson);                          } catch(CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to add attachments to sequence {0}' rethrowing..."' sequence);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error adding attachments to sequence {0}"' sequence);                          }                            json = nuJson;                          RevisionInternal rev = new RevisionInternal(docID' revID' deleted);                          rev.SetJson(json);                            var history = new List<RevisionID>();                          history.Add(revID);                          while (parentSeq > 0) {                              var ancestor = tree.Get(parentSeq);                              Debug.Assert(ancestor != null' String.Format("Couldn't find parent sequence of {0} (doc {1})"' parentSeq' docID));                              history.Add((RevisionID)ancestor[0]);                              parentSeq = (long)ancestor[1];                          }                            Log.To.Upgrade.V(TAG' "Upgrading doc {0} history {1}"' rev' Manager.GetObjectMapper().WriteValueAsString(history));                          try {                              _db.ForceInsert(rev' history' null);                          } catch (CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to insert revision {0} into target database' rethrowing..."' rev);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error inserting revision {0} into target database"' rev);                          }                            NumRevs++;                      } else {                          tree[sequence] = new List<object> { revID' parentSeq };                      }                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportDoc,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(revQuery))) {                      long sequence = raw.sqlite3_column_int64(revQuery' 0);                      var revID = raw.sqlite3_column_text(revQuery' 1).AsRevID();                      long parentSeq = raw.sqlite3_column_int64(revQuery' 2);                      bool current = raw.sqlite3_column_int(revQuery' 3) != 0;                        if (current) {                          // Add a leaf revision:                          bool deleted = raw.sqlite3_column_int(revQuery' 4) != 0;                          IEnumerable<byte> json = raw.sqlite3_column_blob(revQuery' 5);                          if (json == null) {                              json = Encoding.UTF8.GetBytes("{}");                          }                            var nuJson = new List<byte>(json);                          try {                              AddAttachmentsToSequence(sequence' nuJson);                          } catch(CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to add attachments to sequence {0}' rethrowing..."' sequence);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error adding attachments to sequence {0}"' sequence);                          }                            json = nuJson;                          RevisionInternal rev = new RevisionInternal(docID' revID' deleted);                          rev.SetJson(json);                            var history = new List<RevisionID>();                          history.Add(revID);                          while (parentSeq > 0) {                              var ancestor = tree.Get(parentSeq);                              Debug.Assert(ancestor != null' String.Format("Couldn't find parent sequence of {0} (doc {1})"' parentSeq' docID));                              history.Add((RevisionID)ancestor[0]);                              parentSeq = (long)ancestor[1];                          }                            Log.To.Upgrade.V(TAG' "Upgrading doc {0} history {1}"' rev' Manager.GetObjectMapper().WriteValueAsString(history));                          try {                              _db.ForceInsert(rev' history' null);                          } catch (CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to insert revision {0} into target database' rethrowing..."' rev);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error inserting revision {0} into target database"' rev);                          }                            NumRevs++;                      } else {                          tree[sequence] = new List<object> { revID' parentSeq };                      }                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportDoc,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(revQuery))) {                      long sequence = raw.sqlite3_column_int64(revQuery' 0);                      var revID = raw.sqlite3_column_text(revQuery' 1).AsRevID();                      long parentSeq = raw.sqlite3_column_int64(revQuery' 2);                      bool current = raw.sqlite3_column_int(revQuery' 3) != 0;                        if (current) {                          // Add a leaf revision:                          bool deleted = raw.sqlite3_column_int(revQuery' 4) != 0;                          IEnumerable<byte> json = raw.sqlite3_column_blob(revQuery' 5);                          if (json == null) {                              json = Encoding.UTF8.GetBytes("{}");                          }                            var nuJson = new List<byte>(json);                          try {                              AddAttachmentsToSequence(sequence' nuJson);                          } catch(CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to add attachments to sequence {0}' rethrowing..."' sequence);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error adding attachments to sequence {0}"' sequence);                          }                            json = nuJson;                          RevisionInternal rev = new RevisionInternal(docID' revID' deleted);                          rev.SetJson(json);                            var history = new List<RevisionID>();                          history.Add(revID);                          while (parentSeq > 0) {                              var ancestor = tree.Get(parentSeq);                              Debug.Assert(ancestor != null' String.Format("Couldn't find parent sequence of {0} (doc {1})"' parentSeq' docID));                              history.Add((RevisionID)ancestor[0]);                              parentSeq = (long)ancestor[1];                          }                            Log.To.Upgrade.V(TAG' "Upgrading doc {0} history {1}"' rev' Manager.GetObjectMapper().WriteValueAsString(history));                          try {                              _db.ForceInsert(rev' history' null);                          } catch (CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to insert revision {0} into target database' rethrowing..."' rev);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error inserting revision {0} into target database"' rev);                          }                            NumRevs++;                      } else {                          tree[sequence] = new List<object> { revID' parentSeq };                      }                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportDoc,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(revQuery))) {                      long sequence = raw.sqlite3_column_int64(revQuery' 0);                      var revID = raw.sqlite3_column_text(revQuery' 1).AsRevID();                      long parentSeq = raw.sqlite3_column_int64(revQuery' 2);                      bool current = raw.sqlite3_column_int(revQuery' 3) != 0;                        if (current) {                          // Add a leaf revision:                          bool deleted = raw.sqlite3_column_int(revQuery' 4) != 0;                          IEnumerable<byte> json = raw.sqlite3_column_blob(revQuery' 5);                          if (json == null) {                              json = Encoding.UTF8.GetBytes("{}");                          }                            var nuJson = new List<byte>(json);                          try {                              AddAttachmentsToSequence(sequence' nuJson);                          } catch(CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to add attachments to sequence {0}' rethrowing..."' sequence);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error adding attachments to sequence {0}"' sequence);                          }                            json = nuJson;                          RevisionInternal rev = new RevisionInternal(docID' revID' deleted);                          rev.SetJson(json);                            var history = new List<RevisionID>();                          history.Add(revID);                          while (parentSeq > 0) {                              var ancestor = tree.Get(parentSeq);                              Debug.Assert(ancestor != null' String.Format("Couldn't find parent sequence of {0} (doc {1})"' parentSeq' docID));                              history.Add((RevisionID)ancestor[0]);                              parentSeq = (long)ancestor[1];                          }                            Log.To.Upgrade.V(TAG' "Upgrading doc {0} history {1}"' rev' Manager.GetObjectMapper().WriteValueAsString(history));                          try {                              _db.ForceInsert(rev' history' null);                          } catch (CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to insert revision {0} into target database' rethrowing..."' rev);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error inserting revision {0} into target database"' rev);                          }                            NumRevs++;                      } else {                          tree[sequence] = new List<object> { revID' parentSeq };                      }                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,AddAttachmentsToSequence,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(attQuery))) {                      string name = raw.sqlite3_column_text(attQuery' 0);                      var key = raw.sqlite3_column_blob(attQuery' 1);                      string mimeType = raw.sqlite3_column_text(attQuery' 2);                      long length = raw.sqlite3_column_int64(attQuery' 3);                      int revpos = raw.sqlite3_column_int(attQuery' 4);                      int encoding = raw.sqlite3_column_int(attQuery' 5);                      long encodedLength = raw.sqlite3_column_int64(attQuery' 6);                        if (key.Length != SHA1.Create().HashSize / 8) {                          raw.sqlite3_finalize(attQuery);                          throw Misc.CreateExceptionAndLog(Log.To.Upgrade' StatusCode.CorruptError' TAG'                              "Digest key length incorrect ({0})"' Convert.ToBase64String(key));                      }                        var blobKey = new BlobKey(key);                      var att = new NonNullDictionary<string' object> {                          { "type"' mimeType }'                          { "digest"' blobKey.Base64Digest() }'                          { "length"' length }'                          { "revpos"' revpos }'                          { "follows"' true }'                          { "encoding"' encoding != 0 ? "gzip" : null }'                          { "encoded_length"' encoding != 0 ? (object)encodedLength : null }                      };                        attachments[name] = att;                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,AddAttachmentsToSequence,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(attQuery))) {                      string name = raw.sqlite3_column_text(attQuery' 0);                      var key = raw.sqlite3_column_blob(attQuery' 1);                      string mimeType = raw.sqlite3_column_text(attQuery' 2);                      long length = raw.sqlite3_column_int64(attQuery' 3);                      int revpos = raw.sqlite3_column_int(attQuery' 4);                      int encoding = raw.sqlite3_column_int(attQuery' 5);                      long encodedLength = raw.sqlite3_column_int64(attQuery' 6);                        if (key.Length != SHA1.Create().HashSize / 8) {                          raw.sqlite3_finalize(attQuery);                          throw Misc.CreateExceptionAndLog(Log.To.Upgrade' StatusCode.CorruptError' TAG'                              "Digest key length incorrect ({0})"' Convert.ToBase64String(key));                      }                        var blobKey = new BlobKey(key);                      var att = new NonNullDictionary<string' object> {                          { "type"' mimeType }'                          { "digest"' blobKey.Base64Digest() }'                          { "length"' length }'                          { "revpos"' revpos }'                          { "follows"' true }'                          { "encoding"' encoding != 0 ? "gzip" : null }'                          { "encoded_length"' encoding != 0 ? (object)encodedLength : null }                      };                        attachments[name] = att;                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,AddAttachmentsToSequence,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(attQuery))) {                      string name = raw.sqlite3_column_text(attQuery' 0);                      var key = raw.sqlite3_column_blob(attQuery' 1);                      string mimeType = raw.sqlite3_column_text(attQuery' 2);                      long length = raw.sqlite3_column_int64(attQuery' 3);                      int revpos = raw.sqlite3_column_int(attQuery' 4);                      int encoding = raw.sqlite3_column_int(attQuery' 5);                      long encodedLength = raw.sqlite3_column_int64(attQuery' 6);                        if (key.Length != SHA1.Create().HashSize / 8) {                          raw.sqlite3_finalize(attQuery);                          throw Misc.CreateExceptionAndLog(Log.To.Upgrade' StatusCode.CorruptError' TAG'                              "Digest key length incorrect ({0})"' Convert.ToBase64String(key));                      }                        var blobKey = new BlobKey(key);                      var att = new NonNullDictionary<string' object> {                          { "type"' mimeType }'                          { "digest"' blobKey.Base64Digest() }'                          { "length"' length }'                          { "revpos"' revpos }'                          { "follows"' true }'                          { "encoding"' encoding != 0 ? "gzip" : null }'                          { "encoded_length"' encoding != 0 ? (object)encodedLength : null }                      };                        attachments[name] = att;                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,AddAttachmentsToSequence,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(attQuery))) {                      string name = raw.sqlite3_column_text(attQuery' 0);                      var key = raw.sqlite3_column_blob(attQuery' 1);                      string mimeType = raw.sqlite3_column_text(attQuery' 2);                      long length = raw.sqlite3_column_int64(attQuery' 3);                      int revpos = raw.sqlite3_column_int(attQuery' 4);                      int encoding = raw.sqlite3_column_int(attQuery' 5);                      long encodedLength = raw.sqlite3_column_int64(attQuery' 6);                        if (key.Length != SHA1.Create().HashSize / 8) {                          raw.sqlite3_finalize(attQuery);                          throw Misc.CreateExceptionAndLog(Log.To.Upgrade' StatusCode.CorruptError' TAG'                              "Digest key length incorrect ({0})"' Convert.ToBase64String(key));                      }                        var blobKey = new BlobKey(key);                      var att = new NonNullDictionary<string' object> {                          { "type"' mimeType }'                          { "digest"' blobKey.Base64Digest() }'                          { "length"' length }'                          { "revpos"' revpos }'                          { "follows"' true }'                          { "encoding"' encoding != 0 ? "gzip" : null }'                          { "encoded_length"' encoding != 0 ? (object)encodedLength : null }                      };                        attachments[name] = att;                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,AddAttachmentsToSequence,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(attQuery))) {                      string name = raw.sqlite3_column_text(attQuery' 0);                      var key = raw.sqlite3_column_blob(attQuery' 1);                      string mimeType = raw.sqlite3_column_text(attQuery' 2);                      long length = raw.sqlite3_column_int64(attQuery' 3);                      int revpos = raw.sqlite3_column_int(attQuery' 4);                      int encoding = raw.sqlite3_column_int(attQuery' 5);                      long encodedLength = raw.sqlite3_column_int64(attQuery' 6);                        if (key.Length != SHA1.Create().HashSize / 8) {                          raw.sqlite3_finalize(attQuery);                          throw Misc.CreateExceptionAndLog(Log.To.Upgrade' StatusCode.CorruptError' TAG'                              "Digest key length incorrect ({0})"' Convert.ToBase64String(key));                      }                        var blobKey = new BlobKey(key);                      var att = new NonNullDictionary<string' object> {                          { "type"' mimeType }'                          { "digest"' blobKey.Base64Digest() }'                          { "length"' length }'                          { "revpos"' revpos }'                          { "follows"' true }'                          { "encoding"' encoding != 0 ? "gzip" : null }'                          { "encoded_length"' encoding != 0 ? (object)encodedLength : null }                      };                        attachments[name] = att;                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,AddAttachmentsToSequence,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(attQuery))) {                      string name = raw.sqlite3_column_text(attQuery' 0);                      var key = raw.sqlite3_column_blob(attQuery' 1);                      string mimeType = raw.sqlite3_column_text(attQuery' 2);                      long length = raw.sqlite3_column_int64(attQuery' 3);                      int revpos = raw.sqlite3_column_int(attQuery' 4);                      int encoding = raw.sqlite3_column_int(attQuery' 5);                      long encodedLength = raw.sqlite3_column_int64(attQuery' 6);                        if (key.Length != SHA1.Create().HashSize / 8) {                          raw.sqlite3_finalize(attQuery);                          throw Misc.CreateExceptionAndLog(Log.To.Upgrade' StatusCode.CorruptError' TAG'                              "Digest key length incorrect ({0})"' Convert.ToBase64String(key));                      }                        var blobKey = new BlobKey(key);                      var att = new NonNullDictionary<string' object> {                          { "type"' mimeType }'                          { "digest"' blobKey.Base64Digest() }'                          { "length"' length }'                          { "revpos"' revpos }'                          { "follows"' true }'                          { "encoding"' encoding != 0 ? "gzip" : null }'                          { "encoded_length"' encoding != 0 ? (object)encodedLength : null }                      };                        attachments[name] = att;                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,AddAttachmentsToSequence,The following statement contains a magic number: if (attachments.Count > 0) {                      // Splice attachment JSON into the document JSON:                      var attJson = Manager.GetObjectMapper().WriteValueAsBytes(new Dictionary<string' object> { { "_attachments"' attachments } });                        if (json.Count > 2) {                          json.Insert(json.Count - 1' (byte)''');                      }                        json.InsertRange(json.Count - 1' attJson.Skip(1).Take(attJson.Count() - 2));                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,AddAttachmentsToSequence,The following statement contains a magic number: if (attachments.Count > 0) {                      // Splice attachment JSON into the document JSON:                      var attJson = Manager.GetObjectMapper().WriteValueAsBytes(new Dictionary<string' object> { { "_attachments"' attachments } });                        if (json.Count > 2) {                          json.Insert(json.Count - 1' (byte)''');                      }                        json.InsertRange(json.Count - 1' attJson.Skip(1).Take(attJson.Count() - 2));                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportLocalDocs,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(localQuery))) {                      string docID = raw.sqlite3_column_text(localQuery' 0);                      var data = raw.sqlite3_column_blob(localQuery' 1);                      IDictionary<string' object> props = null;                      try {                          props = Manager.GetObjectMapper().ReadValue<IDictionary<string' object>>(data);                      } catch (CouchbaseLiteException) {                      }                        Log.To.Upgrade.V(TAG' "Upgrading local doc '{0}'"' docID);                      if (props != null) {                          try {                              if(docID.StartsWith("_local/")) {                                  docID = docID.Substring(7);                              }                                _db.PutLocalDocument(docID' props);                          } catch(CouchbaseLiteException e) {                              Log.To.Database.W(TAG' "Couldn't import local doc '{0}': {1}' skipping..."' docID' e.CBLStatus);                          }                      }                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,Import,The following statement contains a magic number: if (err == raw.SQLITE_ROW) {                      sqlite3_stmt stmt2 = null;                      PrepareSQL(ref stmt2' "SELECT * FROM maps");                      while ((err = raw.sqlite3_step(stmt2)) == raw.SQLITE_ROW) {                          int viewId = raw.sqlite3_column_int(stmt2' 0);                          sqlite3_stmt stmt3 = null;                           PrepareSQL(ref stmt3' "CREATE TABLE IF NOT EXISTS maps_" + viewId +                               " (sequence INTEGER NOT NULL REFERENCES revs(sequence) ON DELETE CASCADE'" +                              "key TEXT NOT NULL COLLATE JSON'" +                              "value TEXT'" +                              "fulltext_id INTEGER' " +                              "bbox_id INTEGER' " +                              "geokey BLOB)");                          raw.sqlite3_step(stmt3);                          raw.sqlite3_finalize(stmt3);                          stmt3 = null;                            var sequence = raw.sqlite3_column_int64(stmt2' 1);                          var key = raw.sqlite3_column_text(stmt2' 2);                          var value = raw.sqlite3_column_text(stmt2' 3);                            var insertSql = String.Format("INSERT INTO maps_{0} (sequence' key' value) VALUES (?' ?' ?)"'                                              viewId);                                                    PrepareSQL(ref stmt3' insertSql);                          raw.sqlite3_bind_int64(stmt3' 0' sequence);                          raw.sqlite3_bind_text(stmt3' 1' key);                          raw.sqlite3_bind_text(stmt3' 2' value);                          raw.sqlite3_step(stmt3);                          raw.sqlite3_finalize(stmt3);                      }                        raw.sqlite3_finalize(stmt2);                      stmt2 = null;                      PrepareSQL(ref stmt2' "DROP TABLE maps");                      raw.sqlite3_step(stmt2);                      raw.sqlite3_finalize(stmt2);                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,Import,The following statement contains a magic number: if (err == raw.SQLITE_ROW) {                      sqlite3_stmt stmt2 = null;                      PrepareSQL(ref stmt2' "SELECT * FROM maps");                      while ((err = raw.sqlite3_step(stmt2)) == raw.SQLITE_ROW) {                          int viewId = raw.sqlite3_column_int(stmt2' 0);                          sqlite3_stmt stmt3 = null;                           PrepareSQL(ref stmt3' "CREATE TABLE IF NOT EXISTS maps_" + viewId +                               " (sequence INTEGER NOT NULL REFERENCES revs(sequence) ON DELETE CASCADE'" +                              "key TEXT NOT NULL COLLATE JSON'" +                              "value TEXT'" +                              "fulltext_id INTEGER' " +                              "bbox_id INTEGER' " +                              "geokey BLOB)");                          raw.sqlite3_step(stmt3);                          raw.sqlite3_finalize(stmt3);                          stmt3 = null;                            var sequence = raw.sqlite3_column_int64(stmt2' 1);                          var key = raw.sqlite3_column_text(stmt2' 2);                          var value = raw.sqlite3_column_text(stmt2' 3);                            var insertSql = String.Format("INSERT INTO maps_{0} (sequence' key' value) VALUES (?' ?' ?)"'                                              viewId);                                                    PrepareSQL(ref stmt3' insertSql);                          raw.sqlite3_bind_int64(stmt3' 0' sequence);                          raw.sqlite3_bind_text(stmt3' 1' key);                          raw.sqlite3_bind_text(stmt3' 2' value);                          raw.sqlite3_step(stmt3);                          raw.sqlite3_finalize(stmt3);                      }                        raw.sqlite3_finalize(stmt2);                      stmt2 = null;                      PrepareSQL(ref stmt2' "DROP TABLE maps");                      raw.sqlite3_step(stmt2);                      raw.sqlite3_finalize(stmt2);                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,Import,The following statement contains a magic number: if (err == raw.SQLITE_ROW) {                      sqlite3_stmt stmt2 = null;                      PrepareSQL(ref stmt2' "SELECT * FROM maps");                      while ((err = raw.sqlite3_step(stmt2)) == raw.SQLITE_ROW) {                          int viewId = raw.sqlite3_column_int(stmt2' 0);                          sqlite3_stmt stmt3 = null;                           PrepareSQL(ref stmt3' "CREATE TABLE IF NOT EXISTS maps_" + viewId +                               " (sequence INTEGER NOT NULL REFERENCES revs(sequence) ON DELETE CASCADE'" +                              "key TEXT NOT NULL COLLATE JSON'" +                              "value TEXT'" +                              "fulltext_id INTEGER' " +                              "bbox_id INTEGER' " +                              "geokey BLOB)");                          raw.sqlite3_step(stmt3);                          raw.sqlite3_finalize(stmt3);                          stmt3 = null;                            var sequence = raw.sqlite3_column_int64(stmt2' 1);                          var key = raw.sqlite3_column_text(stmt2' 2);                          var value = raw.sqlite3_column_text(stmt2' 3);                            var insertSql = String.Format("INSERT INTO maps_{0} (sequence' key' value) VALUES (?' ?' ?)"'                                              viewId);                                                    PrepareSQL(ref stmt3' insertSql);                          raw.sqlite3_bind_int64(stmt3' 0' sequence);                          raw.sqlite3_bind_text(stmt3' 1' key);                          raw.sqlite3_bind_text(stmt3' 2' value);                          raw.sqlite3_step(stmt3);                          raw.sqlite3_finalize(stmt3);                      }                        raw.sqlite3_finalize(stmt2);                      stmt2 = null;                      PrepareSQL(ref stmt2' "DROP TABLE maps");                      raw.sqlite3_step(stmt2);                      raw.sqlite3_finalize(stmt2);                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,Import,The following statement contains a magic number: if (version >= 101) {                      _db.Delete();                      MoveSqliteFiles(destPath' _path);                      var secondaryUpgrade = new v11_upgrader(_db' _path);                      secondaryUpgrade.Import();                      var newPath = Path.Combine(Path.GetDirectoryName(_path)' _db.Name + Manager.DatabaseSuffix);                      if (newPath != _db.DbDirectory) {                          Directory.Move(Path.Combine(Path.GetDirectoryName(_path)' _db.Name + Manager.DatabaseSuffix)' _db.DbDirectory);                      }                      return;                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v1_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,Import,The following statement contains a magic number: _db.RunInTransaction(() =>                  {                      int transactionErr;                      int count = 0;                      while(raw.SQLITE_ROW == (transactionErr = raw.sqlite3_step(docQuery))) {                          long docNumericID = raw.sqlite3_column_int64(docQuery' 0);                          string docID = raw.sqlite3_column_text(docQuery' 1);                          try {                              ImportDoc(docID' docNumericID);                          } catch(CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to import document #{0} ({1})' rethrowing"' docNumericID'                                   new SecureLogString(docID' LogMessageSensitivity.PotentiallyInsecure));                              throw;                          } catch(Exception e) {                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG'                                   "Error importing documents");                          }                                                    if((++count % 1000) == 0) {                              Log.To.Upgrade.I(TAG' "Migrated {0} documents"' count);                          }                      }                                                return transactionErr == raw.SQLITE_DONE;                  });
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v12_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportDoc,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(revQuery))) {                      long sequence = raw.sqlite3_column_int64(revQuery' 0);                      var revID = raw.sqlite3_column_text(revQuery' 1).AsRevID();                      long parentSeq = raw.sqlite3_column_int64(revQuery' 2);                      bool current = raw.sqlite3_column_int(revQuery' 3) != 0;                      bool noAtts = raw.sqlite3_column_int(revQuery' 6) != 0;                        if (current) {                          // Add a leaf revision:                          bool deleted = raw.sqlite3_column_int(revQuery' 4) != 0;                          IEnumerable<byte> json = raw.sqlite3_column_blob(revQuery' 5);                          if (json == null) {                              json = Encoding.UTF8.GetBytes("{}");                          }                            var nuJson = json.ToList();                          if (!noAtts) {                              try {                                  UpdateAttachmentFollows(nuJson);                              } catch(CouchbaseLiteException) {                                  Log.To.Upgrade.E(TAG' "Failed to process attachments' rethrowing...");                                  throw;                              } catch(Exception e) {                                  throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error processing attachments");                              }                          }                            json = nuJson;                          RevisionInternal rev = new RevisionInternal(docID' revID' deleted);                          rev.SetJson(json);                            var history = new List<RevisionID>();                          history.Add(revID);                          while (parentSeq > 0) {                              var ancestor = tree.Get(parentSeq);                              Debug.Assert(ancestor != null' String.Format("Couldn't find parent sequence of {0} (doc {1})"' parentSeq' docID));                              history.Add((RevisionID)ancestor[0]);                              parentSeq = (long)ancestor[1];                          }                            Log.To.Upgrade.V(TAG' "Upgrading doc {0} history {1}"' rev' Manager.GetObjectMapper().WriteValueAsString(history));                          try {                              _db.ForceInsert(rev' history' null);                          } catch (CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to insert revision {0} into target database' rethrowing..."' rev);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG'                                  "Error inserting revision {0} into target database"' rev);                          }                            NumRevs++;                      } else {                          tree[sequence] = new List<object> { revID' parentSeq };                      }                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v12_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportDoc,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(revQuery))) {                      long sequence = raw.sqlite3_column_int64(revQuery' 0);                      var revID = raw.sqlite3_column_text(revQuery' 1).AsRevID();                      long parentSeq = raw.sqlite3_column_int64(revQuery' 2);                      bool current = raw.sqlite3_column_int(revQuery' 3) != 0;                      bool noAtts = raw.sqlite3_column_int(revQuery' 6) != 0;                        if (current) {                          // Add a leaf revision:                          bool deleted = raw.sqlite3_column_int(revQuery' 4) != 0;                          IEnumerable<byte> json = raw.sqlite3_column_blob(revQuery' 5);                          if (json == null) {                              json = Encoding.UTF8.GetBytes("{}");                          }                            var nuJson = json.ToList();                          if (!noAtts) {                              try {                                  UpdateAttachmentFollows(nuJson);                              } catch(CouchbaseLiteException) {                                  Log.To.Upgrade.E(TAG' "Failed to process attachments' rethrowing...");                                  throw;                              } catch(Exception e) {                                  throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error processing attachments");                              }                          }                            json = nuJson;                          RevisionInternal rev = new RevisionInternal(docID' revID' deleted);                          rev.SetJson(json);                            var history = new List<RevisionID>();                          history.Add(revID);                          while (parentSeq > 0) {                              var ancestor = tree.Get(parentSeq);                              Debug.Assert(ancestor != null' String.Format("Couldn't find parent sequence of {0} (doc {1})"' parentSeq' docID));                              history.Add((RevisionID)ancestor[0]);                              parentSeq = (long)ancestor[1];                          }                            Log.To.Upgrade.V(TAG' "Upgrading doc {0} history {1}"' rev' Manager.GetObjectMapper().WriteValueAsString(history));                          try {                              _db.ForceInsert(rev' history' null);                          } catch (CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to insert revision {0} into target database' rethrowing..."' rev);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG'                                  "Error inserting revision {0} into target database"' rev);                          }                            NumRevs++;                      } else {                          tree[sequence] = new List<object> { revID' parentSeq };                      }                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v12_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportDoc,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(revQuery))) {                      long sequence = raw.sqlite3_column_int64(revQuery' 0);                      var revID = raw.sqlite3_column_text(revQuery' 1).AsRevID();                      long parentSeq = raw.sqlite3_column_int64(revQuery' 2);                      bool current = raw.sqlite3_column_int(revQuery' 3) != 0;                      bool noAtts = raw.sqlite3_column_int(revQuery' 6) != 0;                        if (current) {                          // Add a leaf revision:                          bool deleted = raw.sqlite3_column_int(revQuery' 4) != 0;                          IEnumerable<byte> json = raw.sqlite3_column_blob(revQuery' 5);                          if (json == null) {                              json = Encoding.UTF8.GetBytes("{}");                          }                            var nuJson = json.ToList();                          if (!noAtts) {                              try {                                  UpdateAttachmentFollows(nuJson);                              } catch(CouchbaseLiteException) {                                  Log.To.Upgrade.E(TAG' "Failed to process attachments' rethrowing...");                                  throw;                              } catch(Exception e) {                                  throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error processing attachments");                              }                          }                            json = nuJson;                          RevisionInternal rev = new RevisionInternal(docID' revID' deleted);                          rev.SetJson(json);                            var history = new List<RevisionID>();                          history.Add(revID);                          while (parentSeq > 0) {                              var ancestor = tree.Get(parentSeq);                              Debug.Assert(ancestor != null' String.Format("Couldn't find parent sequence of {0} (doc {1})"' parentSeq' docID));                              history.Add((RevisionID)ancestor[0]);                              parentSeq = (long)ancestor[1];                          }                            Log.To.Upgrade.V(TAG' "Upgrading doc {0} history {1}"' rev' Manager.GetObjectMapper().WriteValueAsString(history));                          try {                              _db.ForceInsert(rev' history' null);                          } catch (CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to insert revision {0} into target database' rethrowing..."' rev);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG'                                  "Error inserting revision {0} into target database"' rev);                          }                            NumRevs++;                      } else {                          tree[sequence] = new List<object> { revID' parentSeq };                      }                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v12_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportDoc,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(revQuery))) {                      long sequence = raw.sqlite3_column_int64(revQuery' 0);                      var revID = raw.sqlite3_column_text(revQuery' 1).AsRevID();                      long parentSeq = raw.sqlite3_column_int64(revQuery' 2);                      bool current = raw.sqlite3_column_int(revQuery' 3) != 0;                      bool noAtts = raw.sqlite3_column_int(revQuery' 6) != 0;                        if (current) {                          // Add a leaf revision:                          bool deleted = raw.sqlite3_column_int(revQuery' 4) != 0;                          IEnumerable<byte> json = raw.sqlite3_column_blob(revQuery' 5);                          if (json == null) {                              json = Encoding.UTF8.GetBytes("{}");                          }                            var nuJson = json.ToList();                          if (!noAtts) {                              try {                                  UpdateAttachmentFollows(nuJson);                              } catch(CouchbaseLiteException) {                                  Log.To.Upgrade.E(TAG' "Failed to process attachments' rethrowing...");                                  throw;                              } catch(Exception e) {                                  throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error processing attachments");                              }                          }                            json = nuJson;                          RevisionInternal rev = new RevisionInternal(docID' revID' deleted);                          rev.SetJson(json);                            var history = new List<RevisionID>();                          history.Add(revID);                          while (parentSeq > 0) {                              var ancestor = tree.Get(parentSeq);                              Debug.Assert(ancestor != null' String.Format("Couldn't find parent sequence of {0} (doc {1})"' parentSeq' docID));                              history.Add((RevisionID)ancestor[0]);                              parentSeq = (long)ancestor[1];                          }                            Log.To.Upgrade.V(TAG' "Upgrading doc {0} history {1}"' rev' Manager.GetObjectMapper().WriteValueAsString(history));                          try {                              _db.ForceInsert(rev' history' null);                          } catch (CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to insert revision {0} into target database' rethrowing..."' rev);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG'                                  "Error inserting revision {0} into target database"' rev);                          }                            NumRevs++;                      } else {                          tree[sequence] = new List<object> { revID' parentSeq };                      }                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v12_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,ImportDoc,The following statement contains a magic number: while (raw.SQLITE_ROW == (err = raw.sqlite3_step(revQuery))) {                      long sequence = raw.sqlite3_column_int64(revQuery' 0);                      var revID = raw.sqlite3_column_text(revQuery' 1).AsRevID();                      long parentSeq = raw.sqlite3_column_int64(revQuery' 2);                      bool current = raw.sqlite3_column_int(revQuery' 3) != 0;                      bool noAtts = raw.sqlite3_column_int(revQuery' 6) != 0;                        if (current) {                          // Add a leaf revision:                          bool deleted = raw.sqlite3_column_int(revQuery' 4) != 0;                          IEnumerable<byte> json = raw.sqlite3_column_blob(revQuery' 5);                          if (json == null) {                              json = Encoding.UTF8.GetBytes("{}");                          }                            var nuJson = json.ToList();                          if (!noAtts) {                              try {                                  UpdateAttachmentFollows(nuJson);                              } catch(CouchbaseLiteException) {                                  Log.To.Upgrade.E(TAG' "Failed to process attachments' rethrowing...");                                  throw;                              } catch(Exception e) {                                  throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG' "Error processing attachments");                              }                          }                            json = nuJson;                          RevisionInternal rev = new RevisionInternal(docID' revID' deleted);                          rev.SetJson(json);                            var history = new List<RevisionID>();                          history.Add(revID);                          while (parentSeq > 0) {                              var ancestor = tree.Get(parentSeq);                              Debug.Assert(ancestor != null' String.Format("Couldn't find parent sequence of {0} (doc {1})"' parentSeq' docID));                              history.Add((RevisionID)ancestor[0]);                              parentSeq = (long)ancestor[1];                          }                            Log.To.Upgrade.V(TAG' "Upgrading doc {0} history {1}"' rev' Manager.GetObjectMapper().WriteValueAsString(history));                          try {                              _db.ForceInsert(rev' history' null);                          } catch (CouchbaseLiteException) {                              Log.To.Upgrade.E(TAG' "Failed to insert revision {0} into target database' rethrowing..."' rev);                              raw.sqlite3_finalize(revQuery);                              throw;                          } catch(Exception e) {                              raw.sqlite3_finalize(revQuery);                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG'                                  "Error inserting revision {0} into target database"' rev);                          }                            NumRevs++;                      } else {                          tree[sequence] = new List<object> { revID' parentSeq };                      }                  }
Magic Number,Couchbase.Lite.Storage.CustomSQLite,v12_upgrader,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\DatabaseUpgraderFactory_Upgraders.cs,Import,The following statement contains a magic number: _db.RunInTransaction(() =>                  {                      int transactionErr;                      int count = 0;                      while(raw.SQLITE_ROW == (transactionErr = raw.sqlite3_step(docQuery))) {                          long docNumericID = raw.sqlite3_column_int64(docQuery' 0);                          string docID = raw.sqlite3_column_text(docQuery' 1);                          try {                              ImportDoc(docID' docNumericID);                          } catch(CouchbaseLiteException) {                              Log.To.Database.E(TAG' "Failed to import document #{0} ({1})' rethrowing"' docNumericID'                                   new SecureLogString(docID' LogMessageSensitivity.PotentiallyInsecure));                              throw;                          } catch(Exception e) {                              throw Misc.CreateExceptionAndLog(Log.To.Upgrade' e' TAG'                                  "Error importing document #{0} ({1})"' docNumericID'                                   new SecureLogString(docID' LogMessageSensitivity.PotentiallyInsecure));                          }                            if((++count % 1000) == 0) {                              Log.To.Upgrade.I(TAG' "Migrated {0} documents"' count);                          }                      }                        return transactionErr == raw.SQLITE_DONE;                  });
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: if (d < 10)                   return d;
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: if (d < 6)                   return d + 10;
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: if (d < 6)                   return d + 10;
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: if (d < 6)                   return d + 10;
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,DigitToInt,The following statement contains a magic number: if (d < 6)                   return d + 10;
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (mantSize == 0)               {                  fraction = 0.0;                  p = 0;                  goto Done;              } else {                  int frac1 = 0;                  for (; mantSize > 9; --mantSize)                   {                      c = str[p];                      ++p;                        if (c == '.')                      {                          c = str[p];                          ++p;                      }                        frac1 = 10 * frac1 + (c - '0');                  }                    int frac2 = 0;                  for (; mantSize > 0; --mantSize)                   {                      c = str[p];                      ++p;                        if (c == '.')                      {                          c = str[p];                          ++p;                      }                        frac2 = 10 * frac2 + (c - '0');                  }                    fraction = (double) ((1.0e9 * frac1) + frac2);              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (mantSize == 0)               {                  fraction = 0.0;                  p = 0;                  goto Done;              } else {                  int frac1 = 0;                  for (; mantSize > 9; --mantSize)                   {                      c = str[p];                      ++p;                        if (c == '.')                      {                          c = str[p];                          ++p;                      }                        frac1 = 10 * frac1 + (c - '0');                  }                    int frac2 = 0;                  for (; mantSize > 0; --mantSize)                   {                      c = str[p];                      ++p;                        if (c == '.')                      {                          c = str[p];                          ++p;                      }                        frac2 = 10 * frac2 + (c - '0');                  }                    fraction = (double) ((1.0e9 * frac1) + frac2);              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (mantSize == 0)               {                  fraction = 0.0;                  p = 0;                  goto Done;              } else {                  int frac1 = 0;                  for (; mantSize > 9; --mantSize)                   {                      c = str[p];                      ++p;                        if (c == '.')                      {                          c = str[p];                          ++p;                      }                        frac1 = 10 * frac1 + (c - '0');                  }                    int frac2 = 0;                  for (; mantSize > 0; --mantSize)                   {                      c = str[p];                      ++p;                        if (c == '.')                      {                          c = str[p];                          ++p;                      }                        frac2 = 10 * frac2 + (c - '0');                  }                    fraction = (double) ((1.0e9 * frac1) + frac2);              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (mantSize == 0)               {                  fraction = 0.0;                  p = 0;                  goto Done;              } else {                  int frac1 = 0;                  for (; mantSize > 9; --mantSize)                   {                      c = str[p];                      ++p;                        if (c == '.')                      {                          c = str[p];                          ++p;                      }                        frac1 = 10 * frac1 + (c - '0');                  }                    int frac2 = 0;                  for (; mantSize > 0; --mantSize)                   {                      c = str[p];                      ++p;                        if (c == '.')                      {                          c = str[p];                          ++p;                      }                        frac2 = 10 * frac2 + (c - '0');                  }                    fraction = (double) ((1.0e9 * frac1) + frac2);              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Strtod,The following statement contains a magic number: if (p < str.Length && (str[p] == 'E' || str[p] == 'e'))               {                  ++p;                    if (p < length)                  {                      if (str[p] == '-')                       {                          expSign = 1;                          ++p;                      } else if (str[p] == '+')                          ++p;                        if (!Char.IsDigit(str[p])) {                          p = pExp;                          goto Done;                      }                        while (p < length && Char.IsDigit(str[p]))                      {                          exp = exp * 10 + (str[p] - '0');                          ++p;                      }                    }              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {              case 'u':                  // \u is a Unicode escape; 4 hex digits follow.                  int uIndex = index + 1;                    // TODO: Check Valid Digit                  if (uIndex + 3 < str.Length)                   {                      int uc = (DigitToInt(str[uIndex + 0]) << 12) |                          (DigitToInt(str[uIndex + 1]) << 8) |                          (DigitToInt(str[uIndex + 2]) << 4) |                          (DigitToInt(str[uIndex + 3]));                        if (uc > 127)                       {                          // TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);                      }                        endPos = uIndex + 3;                      return (char)uc;                  }                   break;              case 'b':                   c = '\b';                  break;              case 'n':                  c = '\n';                  break;              case 'r':                  c = '\r';                  break;              case 't':                  c = '\t';                  break;              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {              case 'u':                  // \u is a Unicode escape; 4 hex digits follow.                  int uIndex = index + 1;                    // TODO: Check Valid Digit                  if (uIndex + 3 < str.Length)                   {                      int uc = (DigitToInt(str[uIndex + 0]) << 12) |                          (DigitToInt(str[uIndex + 1]) << 8) |                          (DigitToInt(str[uIndex + 2]) << 4) |                          (DigitToInt(str[uIndex + 3]));                        if (uc > 127)                       {                          // TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);                      }                        endPos = uIndex + 3;                      return (char)uc;                  }                   break;              case 'b':                   c = '\b';                  break;              case 'n':                  c = '\n';                  break;              case 'r':                  c = '\r';                  break;              case 't':                  c = '\t';                  break;              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {              case 'u':                  // \u is a Unicode escape; 4 hex digits follow.                  int uIndex = index + 1;                    // TODO: Check Valid Digit                  if (uIndex + 3 < str.Length)                   {                      int uc = (DigitToInt(str[uIndex + 0]) << 12) |                          (DigitToInt(str[uIndex + 1]) << 8) |                          (DigitToInt(str[uIndex + 2]) << 4) |                          (DigitToInt(str[uIndex + 3]));                        if (uc > 127)                       {                          // TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);                      }                        endPos = uIndex + 3;                      return (char)uc;                  }                   break;              case 'b':                   c = '\b';                  break;              case 'n':                  c = '\n';                  break;              case 'r':                  c = '\r';                  break;              case 't':                  c = '\t';                  break;              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {              case 'u':                  // \u is a Unicode escape; 4 hex digits follow.                  int uIndex = index + 1;                    // TODO: Check Valid Digit                  if (uIndex + 3 < str.Length)                   {                      int uc = (DigitToInt(str[uIndex + 0]) << 12) |                          (DigitToInt(str[uIndex + 1]) << 8) |                          (DigitToInt(str[uIndex + 2]) << 4) |                          (DigitToInt(str[uIndex + 3]));                        if (uc > 127)                       {                          // TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);                      }                        endPos = uIndex + 3;                      return (char)uc;                  }                   break;              case 'b':                   c = '\b';                  break;              case 'n':                  c = '\n';                  break;              case 'r':                  c = '\r';                  break;              case 't':                  c = '\t';                  break;              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {              case 'u':                  // \u is a Unicode escape; 4 hex digits follow.                  int uIndex = index + 1;                    // TODO: Check Valid Digit                  if (uIndex + 3 < str.Length)                   {                      int uc = (DigitToInt(str[uIndex + 0]) << 12) |                          (DigitToInt(str[uIndex + 1]) << 8) |                          (DigitToInt(str[uIndex + 2]) << 4) |                          (DigitToInt(str[uIndex + 3]));                        if (uc > 127)                       {                          // TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);                      }                        endPos = uIndex + 3;                      return (char)uc;                  }                   break;              case 'b':                   c = '\b';                  break;              case 'n':                  c = '\n';                  break;              case 'r':                  c = '\r';                  break;              case 't':                  c = '\t';                  break;              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {              case 'u':                  // \u is a Unicode escape; 4 hex digits follow.                  int uIndex = index + 1;                    // TODO: Check Valid Digit                  if (uIndex + 3 < str.Length)                   {                      int uc = (DigitToInt(str[uIndex + 0]) << 12) |                          (DigitToInt(str[uIndex + 1]) << 8) |                          (DigitToInt(str[uIndex + 2]) << 4) |                          (DigitToInt(str[uIndex + 3]));                        if (uc > 127)                       {                          // TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);                      }                        endPos = uIndex + 3;                      return (char)uc;                  }                   break;              case 'b':                   c = '\b';                  break;              case 'n':                  c = '\n';                  break;              case 'r':                  c = '\r';                  break;              case 't':                  c = '\t';                  break;              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {              case 'u':                  // \u is a Unicode escape; 4 hex digits follow.                  int uIndex = index + 1;                    // TODO: Check Valid Digit                  if (uIndex + 3 < str.Length)                   {                      int uc = (DigitToInt(str[uIndex + 0]) << 12) |                          (DigitToInt(str[uIndex + 1]) << 8) |                          (DigitToInt(str[uIndex + 2]) << 4) |                          (DigitToInt(str[uIndex + 3]));                        if (uc > 127)                       {                          // TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);                      }                        endPos = uIndex + 3;                      return (char)uc;                  }                   break;              case 'b':                   c = '\b';                  break;              case 'n':                  c = '\n';                  break;              case 'r':                  c = '\r';                  break;              case 't':                  c = '\t';                  break;              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following statement contains a magic number: switch (c) {              case 'u':                  // \u is a Unicode escape; 4 hex digits follow.                  int uIndex = index + 1;                    // TODO: Check Valid Digit                  if (uIndex + 3 < str.Length)                   {                      int uc = (DigitToInt(str[uIndex + 0]) << 12) |                          (DigitToInt(str[uIndex + 1]) << 8) |                          (DigitToInt(str[uIndex + 2]) << 4) |                          (DigitToInt(str[uIndex + 3]));                        if (uc > 127)                       {                          // TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);                      }                        endPos = uIndex + 3;                      return (char)uc;                  }                   break;              case 'b':                   c = '\b';                  break;              case 'n':                  c = '\n';                  break;              case 'r':                  c = '\r';                  break;              case 't':                  c = '\t';                  break;              }
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: do               {                  var type1 = ValueTypeOf(index1 < param1.Length ? param1[index1] : '\0');                  var type2 = ValueTypeOf(index2 < param2.Length ? param2[index2] : '\0');                    if (type1 != type2)                  {                      if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma))                      {                          if (++arrayIndex >= arrayLimit)                               return 0;                      }                        if (mode != JsonCollationMode.Raw)                          return Cmp((int)type1' (int)type2);                      else                          return Cmp(RawOrderOfValueType(type1)' RawOrderOfValueType(type2));                  }                  else                   {                      switch(type1)                      {                      case ValueType.Null:                      case ValueType.True:                          index1 += 4;                          index2 += 4;                          break;                      case ValueType.False:                          index1 += 5;                          index2 += 5;                          break;                      case ValueType.Number:                          int next1;                          int next2;                          diff = DCmp(ReadNumber(param1' index1' out next1)'                               ReadNumber(param2' index2' out next2));                          if (diff != 0)                               return diff;                             index1 = next1;                          index2 = next2;                            break;                      case ValueType.String:                          int endPos1;                          int endPos2;                          if (mode == JsonCollationMode.Unicode)                              diff = CompareStringsUnicode(param1' index1' out endPos1' param2' index2' out endPos2);                          else                              diff = CompareStringsAscii(param1' index1' out endPos1' param2' index2' out endPos2);                            if (diff != 0)                               return diff;                            index1 = endPos1 + 1;                          index2 = endPos2 + 1;                            break;                      case ValueType.Array:                      case ValueType.Object:                          ++index1;                          ++index2;                          ++depth;                          break;                      case ValueType.EndArray:                      case ValueType.EndObject:                          ++index1;                          ++index2;                          --depth;                          break;                      case ValueType.Comma:                          if (depth == 1 && (++arrayIndex >= arrayLimit))                              return 0;                          ++index1;                          ++index2;                          break;                      case ValueType.Colon:                          ++index1;                          ++index2;                          break;                      case ValueType.Illegal:                          return 0;                      }                  }                } while (depth > 0);
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: do               {                  var type1 = ValueTypeOf(index1 < param1.Length ? param1[index1] : '\0');                  var type2 = ValueTypeOf(index2 < param2.Length ? param2[index2] : '\0');                    if (type1 != type2)                  {                      if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma))                      {                          if (++arrayIndex >= arrayLimit)                               return 0;                      }                        if (mode != JsonCollationMode.Raw)                          return Cmp((int)type1' (int)type2);                      else                          return Cmp(RawOrderOfValueType(type1)' RawOrderOfValueType(type2));                  }                  else                   {                      switch(type1)                      {                      case ValueType.Null:                      case ValueType.True:                          index1 += 4;                          index2 += 4;                          break;                      case ValueType.False:                          index1 += 5;                          index2 += 5;                          break;                      case ValueType.Number:                          int next1;                          int next2;                          diff = DCmp(ReadNumber(param1' index1' out next1)'                               ReadNumber(param2' index2' out next2));                          if (diff != 0)                               return diff;                             index1 = next1;                          index2 = next2;                            break;                      case ValueType.String:                          int endPos1;                          int endPos2;                          if (mode == JsonCollationMode.Unicode)                              diff = CompareStringsUnicode(param1' index1' out endPos1' param2' index2' out endPos2);                          else                              diff = CompareStringsAscii(param1' index1' out endPos1' param2' index2' out endPos2);                            if (diff != 0)                               return diff;                            index1 = endPos1 + 1;                          index2 = endPos2 + 1;                            break;                      case ValueType.Array:                      case ValueType.Object:                          ++index1;                          ++index2;                          ++depth;                          break;                      case ValueType.EndArray:                      case ValueType.EndObject:                          ++index1;                          ++index2;                          --depth;                          break;                      case ValueType.Comma:                          if (depth == 1 && (++arrayIndex >= arrayLimit))                              return 0;                          ++index1;                          ++index2;                          break;                      case ValueType.Colon:                          ++index1;                          ++index2;                          break;                      case ValueType.Illegal:                          return 0;                      }                  }                } while (depth > 0);
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: do               {                  var type1 = ValueTypeOf(index1 < param1.Length ? param1[index1] : '\0');                  var type2 = ValueTypeOf(index2 < param2.Length ? param2[index2] : '\0');                    if (type1 != type2)                  {                      if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma))                      {                          if (++arrayIndex >= arrayLimit)                               return 0;                      }                        if (mode != JsonCollationMode.Raw)                          return Cmp((int)type1' (int)type2);                      else                          return Cmp(RawOrderOfValueType(type1)' RawOrderOfValueType(type2));                  }                  else                   {                      switch(type1)                      {                      case ValueType.Null:                      case ValueType.True:                          index1 += 4;                          index2 += 4;                          break;                      case ValueType.False:                          index1 += 5;                          index2 += 5;                          break;                      case ValueType.Number:                          int next1;                          int next2;                          diff = DCmp(ReadNumber(param1' index1' out next1)'                               ReadNumber(param2' index2' out next2));                          if (diff != 0)                               return diff;                             index1 = next1;                          index2 = next2;                            break;                      case ValueType.String:                          int endPos1;                          int endPos2;                          if (mode == JsonCollationMode.Unicode)                              diff = CompareStringsUnicode(param1' index1' out endPos1' param2' index2' out endPos2);                          else                              diff = CompareStringsAscii(param1' index1' out endPos1' param2' index2' out endPos2);                            if (diff != 0)                               return diff;                            index1 = endPos1 + 1;                          index2 = endPos2 + 1;                            break;                      case ValueType.Array:                      case ValueType.Object:                          ++index1;                          ++index2;                          ++depth;                          break;                      case ValueType.EndArray:                      case ValueType.EndObject:                          ++index1;                          ++index2;                          --depth;                          break;                      case ValueType.Comma:                          if (depth == 1 && (++arrayIndex >= arrayLimit))                              return 0;                          ++index1;                          ++index2;                          break;                      case ValueType.Colon:                          ++index1;                          ++index2;                          break;                      case ValueType.Illegal:                          return 0;                      }                  }                } while (depth > 0);
Magic Number,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following statement contains a magic number: do               {                  var type1 = ValueTypeOf(index1 < param1.Length ? param1[index1] : '\0');                  var type2 = ValueTypeOf(index2 < param2.Length ? param2[index2] : '\0');                    if (type1 != type2)                  {                      if (depth == 1 && (type1 == ValueType.Comma || type2 == ValueType.Comma))                      {                          if (++arrayIndex >= arrayLimit)                               return 0;                      }                        if (mode != JsonCollationMode.Raw)                          return Cmp((int)type1' (int)type2);                      else                          return Cmp(RawOrderOfValueType(type1)' RawOrderOfValueType(type2));                  }                  else                   {                      switch(type1)                      {                      case ValueType.Null:                      case ValueType.True:                          index1 += 4;                          index2 += 4;                          break;                      case ValueType.False:                          index1 += 5;                          index2 += 5;                          break;                      case ValueType.Number:                          int next1;                          int next2;                          diff = DCmp(ReadNumber(param1' index1' out next1)'                               ReadNumber(param2' index2' out next2));                          if (diff != 0)                               return diff;                             index1 = next1;                          index2 = next2;                            break;                      case ValueType.String:                          int endPos1;                          int endPos2;                          if (mode == JsonCollationMode.Unicode)                              diff = CompareStringsUnicode(param1' index1' out endPos1' param2' index2' out endPos2);                          else                              diff = CompareStringsAscii(param1' index1' out endPos1' param2' index2' out endPos2);                            if (diff != 0)                               return diff;                            index1 = endPos1 + 1;                          index2 = endPos2 + 1;                            break;                      case ValueType.Array:                      case ValueType.Object:                          ++index1;                          ++index2;                          ++depth;                          break;                      case ValueType.EndArray:                      case ValueType.EndObject:                          ++index1;                          ++index2;                          --depth;                          break;                      case ValueType.Comma:                          if (depth == 1 && (++arrayIndex >= arrayLimit))                              return 0;                          ++index1;                          ++index2;                          break;                      case ValueType.Colon:                          ++index1;                          ++index2;                          break;                      case ValueType.Illegal:                          return 0;                      }                  }                } while (depth > 0);
Magic Number,Couchbase.Lite,RevIdCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\RevIdCollator.cs,ParseDigits,The following statement contains a magic number: for (var i = 0; i < endPos; i++) {                  var ch = rev[i];                  if (!Char.IsDigit(ch))                  {                      return 0;                  }                  result = (10 * result) + (ch - '0');              }
Magic Number,Couchbase.Lite,RevIdCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\RevIdCollator.cs,Compare,The following statement contains a magic number: if ((dash1 == 1 && dash2 == 1)                   || dash1 > 8 || dash2 > 8                  || dash1 == -1 || dash2 == -1)              {                  // Single-digit generation #s' or improper rev IDs; just compare as plain text:                  return DefaultCollate(rev1' rev2);              }
Magic Number,Couchbase.Lite,RevIdCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\RevIdCollator.cs,Compare,The following statement contains a magic number: if ((dash1 == 1 && dash2 == 1)                   || dash1 > 8 || dash2 > 8                  || dash1 == -1 || dash2 == -1)              {                  // Single-digit generation #s' or improper rev IDs; just compare as plain text:                  return DefaultCollate(rev1' rev2);              }
Magic Number,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,agg_function_hook_bridge_step_impl,The following statement contains a magic number: IntPtr agg = NativeMethods.sqlite3_aggregate_context (context' 8);
Magic Number,SQLitePCL,SQLite3Provider_cbsqlite,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,agg_function_hook_bridge_final_impl,The following statement contains a magic number: IntPtr agg = NativeMethods.sqlite3_aggregate_context (context' 8);
Magic Number,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,TryLoadFromArchDirectory,The following statement contains a magic number: var architecture = IntPtr.Size == 4                  ? "x86"                  : "x64";
Magic Number,SQLitePCL,NativeMethods,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\CustomSQLite\SQLite3Provider_cbsqlite.cs,TryLoadFromArchDirectory,The following statement contains a magic number: const uint LOAD_WITH_ALTERED_SEARCH_PATH = 8;
Missing Default,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,ConvertEscape,The following switch statement is missing a default case: switch (c) {              case 'u':                  // \u is a Unicode escape; 4 hex digits follow.                  int uIndex = index + 1;                    // TODO: Check Valid Digit                  if (uIndex + 3 < str.Length)                   {                      int uc = (DigitToInt(str[uIndex + 0]) << 12) |                          (DigitToInt(str[uIndex + 1]) << 8) |                          (DigitToInt(str[uIndex + 2]) << 4) |                          (DigitToInt(str[uIndex + 3]));                        if (uc > 127)                       {                          // TODO: Warn(@"CBLCollateJSON can't correctly compare \\u%.4s"' digits);                      }                        endPos = uIndex + 3;                      return (char)uc;                  }                   break;              case 'b':                   c = '\b';                  break;              case 'n':                  c = '\n';                  break;              case 'r':                  c = '\r';                  break;              case 't':                  c = '\t';                  break;              }
Missing Default,Couchbase.Lite,JsonCollator,C:\repos\couchbase_couchbase-lite-net\src\StorageEngines\SQLiteCommon\storage.sqlite.common\src\JsonCollator.cs,Compare,The following switch statement is missing a default case: switch(type1)                      {                      case ValueType.Null:                      case ValueType.True:                          index1 += 4;                          index2 += 4;                          break;                      case ValueType.False:                          index1 += 5;                          index2 += 5;                          break;                      case ValueType.Number:                          int next1;                          int next2;                          diff = DCmp(ReadNumber(param1' index1' out next1)'                               ReadNumber(param2' index2' out next2));                          if (diff != 0)                               return diff;                             index1 = next1;                          index2 = next2;                            break;                      case ValueType.String:                          int endPos1;                          int endPos2;                          if (mode == JsonCollationMode.Unicode)                              diff = CompareStringsUnicode(param1' index1' out endPos1' param2' index2' out endPos2);                          else                              diff = CompareStringsAscii(param1' index1' out endPos1' param2' index2' out endPos2);                            if (diff != 0)                               return diff;                            index1 = endPos1 + 1;                          index2 = endPos2 + 1;                            break;                      case ValueType.Array:                      case ValueType.Object:                          ++index1;                          ++index2;                          ++depth;                          break;                      case ValueType.EndArray:                      case ValueType.EndObject:                          ++index1;                          ++index2;                          --depth;                          break;                      case ValueType.Comma:                          if (depth == 1 && (++arrayIndex >= arrayLimit))                              return 0;                          ++index1;                          ++index2;                          break;                      case ValueType.Colon:                          ++index1;                          ++index2;                          break;                      case ValueType.Illegal:                          return 0;                      }
