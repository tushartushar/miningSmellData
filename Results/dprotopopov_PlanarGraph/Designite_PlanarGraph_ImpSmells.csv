Implementation smell,Namespace,Class,File,Method,Description
Long Method,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The method has 339 lines of code.
Long Method,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The method has 373 lines of code.
Long Method,PlanarGraph.Comparer,GraphComparer,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Comparer\GraphComparer.cs,Compare,The method has 123 lines of code.
Complex Method,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,Cyclomatic complexity of the method is 49
Complex Method,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,Cyclomatic complexity of the method is 55
Complex Method,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetAllGraphPaths,Cyclomatic complexity of the method is 10
Long Parameter List,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The method has 48 parameters.
Long Parameter List,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The method has 72 parameters.
Long Parameter List,PlanarGraph.Collections,PathCollection,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Collections\PathCollection.cs,Distinct,The method has 13 parameters.
Long Parameter List,PlanarGraph.Comparer,CircleComparer,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Comparer\CircleComparer.cs,Compare,The method has 7 parameters.
Long Parameter List,PlanarGraph.Comparer,EdgeComparer,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Comparer\EdgeComparer.cs,Compare,The method has 7 parameters.
Long Parameter List,PlanarGraph.Comparer,GraphComparer,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Comparer\GraphComparer.cs,Compare,The method has 12 parameters.
Long Parameter List,PlanarGraph.Comparer,PathComparer,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Comparer\PathComparer.cs,Compare,The method has 7 parameters.
Long Parameter List,PlanarGraph.Comparer,StackListQueueComparer,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Comparer\StackListQueueComparer.cs,Compare,The method has 17 parameters.
Long Parameter List,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,SplitBy,The method has 7 parameters.
Long Parameter List,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetVector,The method has 5 parameters.
Long Parameter List,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetSubgraphPaths,The method has 8 parameters.
Long Parameter List,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetFromToPaths,The method has 6 parameters.
Long Parameter List,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetAllGraphPaths,The method has 9 parameters.
Long Parameter List,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Random,The method has 6 parameters.
Long Parameter List,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetMinPathLengths,The method has 9 parameters.
Long Parameter List,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetSubgraph,The method has 6 parameters.
Long Parameter List,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetSubgraph,The method has 7 parameters.
Long Parameter List,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The method has 8 parameters.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "	Debug.Assert (graph.Children.All (pair => pair.Value.All (value => graph.Children.ContainsKey (value) && graph.Children [value].Contains (pair.Key)))); " is 151.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "				context.SubGraphQueue.Enqueue (subsubgraphs.Select (subgraph => subGraph.GetSubgraph (subgraph.Vertices.Union (bridges)))); " is 123.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "				context.CachedSubGraphPathsQueue.Enqueue (subsubgraphs.Select (subgraph => Graph.GetSubgraphPaths (subgraph.Vertices.Union (bridges)' cachedSubGraphPaths))); " is 157.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "			var paths = new PathCollection (fromTo.SelectMany (pair => pair.Value).SelectMany (pair => pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle)); " is 152.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "								CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ()); " is 244.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "							Dictionary<int' int> dictionary = indexes.Select ((value' index) => new KeyValuePair<int' int> (index' value)).Where (pair => pair.Value >= 0).ToDictionary (pair => pair.Key' pair => pair.Value); " is 195.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "							var dictionary2 = new StackListQueue<KeyValuePair<Path' Vertex>> (dictionary.Select (pair => new KeyValuePair<Path' Vertex> (new Path (paths [pair.Key])' new Vertex (context.Builded.Vertices [pair.Value])))); " is 208.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "							paths.AddRangeExcept (new PathCollection (dictionary2.SelectMany (pair => pair.Key.SplitBy (pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle)).Distinct ())); " is 167.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "					paths.ReplaceAll (new PathCollection (paths.SelectMany (context.Builded.Split)).Where (Path.IsNoVertix).Where (Path.IsNoCircle)); " is 129.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "							CudafySequencies.SetSequencies (paths.Select (path => path.Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Edges.Select (edge => edge.Select (vertex => vertex.Id).ToArray ()).ToArray ()); " is 200.
Long Statement,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The length of the statement  "						for (int nextPathIndex = counts.ToList ().IndexOf (minCount' pathIndex + 1); nextPathIndex > 0; nextPathIndex = counts.ToList ().IndexOf (minCount' nextPathIndex + 1)) " is 167.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "	Debug.Assert (graph.Children.All (pair => pair.Value.All (value => graph.Children.ContainsKey (value) && graph.Children [value].Contains (pair.Key)))); " is 151.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "		var circles = new StackListQueue<Circle> (cachedSubGraphPaths.Where (pair => pair.Key > 2).SelectMany (pair => subGraph.Vertices.SelectMany (vertex => pair.Value.Where (pair2 => pair2.Key.Key.Equals (pair2.Key.Value)).SelectMany (pair2 => pair2.Value.Select (path => new Circle (path.GetRange (0' path.Count - 1))))))); " is 319.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "		//     приведён алгорим позволяющий проверить ' что цикл является тау-циклом за количество операций меньшее чем приведение " is 122.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "		//     матрицы к каноническому виду. Поэтому если действительно надо сделать хорошую реализацию' то либо надо закоментировать " is 125.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "					CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ()); " is 155.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "					booleanMatrix = new BooleanMatrix (CudafyMatrix.GetIndexes ().Select ((first' row) => new KeyValuePair<int' int> (row' first)).Where (pair => pair.Value >= 0).Select (pair => arrayOfArray [pair.Key].Select (value => value != 0))); " is 230.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "					CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ()); " is 155.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "				Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).SelectMany (index => booleanMatrix.Where (vector => vector.Count > index && vector [index])).Count () == booleanMatrix.Count); " is 195.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "					Debug.WriteLine (string.Join (Environment.NewLine' arrayOfArray.Select (v => string.Join ("'"' v.Select (i => i.ToString ()))))); " is 129.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "							WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture))))); " is 161.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "						CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ()); " is 155.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "							Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture))))); " is 151.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "									CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (v => v.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ()); " is 145.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "									Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value); " is 161.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "									matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor))); " is 237.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "						Dictionary<int' int> dictionary = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value); " is 160.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "						booleanMatrix = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor))); " is 243.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "						WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture))))); " is 161.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "					CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ()); " is 155.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "						Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture))))); " is 151.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "							Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value); " is 161.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "							var matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor))); " is 241.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "				Dictionary<int' int> dictionary2 = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value); " is 161.
Long Statement,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The length of the statement  "				booleanMatrix = new BooleanMatrix (dictionary2.Select (pair1 => dictionary2.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor))); " is 245.
Long Statement,PlanarGraph.Collections,PathCollection,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Collections\PathCollection.cs,Distinct,The length of the statement  "			var list = new StackListQueue<StackListQueue<int>> (this.Select (path => new StackListQueue<int> (path.Select (vertex => vertex.Id)))); " is 135.
Long Statement,PlanarGraph.Collections,PathCollection,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Collections\PathCollection.cs,Distinct,The length of the statement  "			var list1 = new StackListQueue<StackListQueue<int>> (paths1.Select (path => new StackListQueue<int> (path.Select (vertex => vertex.Id)))); " is 138.
Long Statement,PlanarGraph.Collections,PathCollection,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Collections\PathCollection.cs,Distinct,The length of the statement  "			var list2 = new StackListQueue<StackListQueue<int>> (paths1.Select (path => new StackListQueue<int> (path.GetReverse ().Select (vertex => vertex.Id)))); " is 152.
Long Statement,PlanarGraph.Collections,PathCollection,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Collections\PathCollection.cs,Distinct,The length of the statement  "				CudafySequencies.SetSequencies (list1.Select (item => item.ToArray ()).ToArray ()' list2.Select (item => item.ToArray ()).ToArray ()); " is 134.
Long Statement,PlanarGraph.Comparer,KeyValuePairVertexVertexComparer,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Comparer\KeyValuePairVertexVertexComparer.cs,GetHashCode,The length of the statement  "	return VertexComparer.GetHashCode (obj.Key) ^ (~VertexComparer.GetHashCode (obj.Key) << 1) ^ (VertexComparer.GetHashCode (obj.Key) >> 1); " is 137.
Long Statement,PlanarGraph.Comparer,StackListQueueComparer,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Comparer\StackListQueueComparer.cs,Compare,The length of the statement  "			CudafySequencies.SetSequencies (list11.Select (i => i.ToArray ()).ToArray ()' list22.Select (i => i.ToArray ()).ToArray ()); " is 124.
Long Statement,PlanarGraph.Comparer,StackListQueueComparer,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Comparer\StackListQueueComparer.cs,Compare,The length of the statement  "		return list1.Select ((t' i) => t.Select ((item' j) => item - list2 [i] [j]).FirstOrDefault (compare => compare != 0)).FirstOrDefault (compare => compare != 0); " is 159.
Long Statement,PlanarGraph.Data,Circle,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Circle.cs,IsTau,The length of the statement  "	Dictionary<KeyValuePair<Vertex' Vertex>' int> lengths = circleGraph.GetMinPathLengths (this' circleGraph.GetAllGraphPaths ()); " is 126.
Long Statement,PlanarGraph.Data,Circle,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Circle.cs,Split,The length of the statement  "	Debug.WriteLineIf (list.Any ()' this + " split by " + graph + " is " + string.Join ("'"' list.Select (item => item.ToString ()))); " is 130.
Long Statement,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,BelongsTo,The length of the statement  "	return this.All (children.ContainsKey) && Enumerable.Range (0' Count - 1).All (i => children [this [i]].Contains (this [i + 1])); " is 129.
Long Statement,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,SplitBy,The length of the statement  "			CudafySequencies.SetSequencies (segment.Select (GetInts).Select (item => item.ToArray ()).ToArray ()' GetRange (1' Count - 2).Select (GetInts).Select (item => item.ToArray ()).ToArray ()); " is 188.
Long Statement,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,SplitBy,The length of the statement  "	Debug.WriteLineIf (list.Any ()' this + " split by " + segment + " is " + string.Join ("'"' list.Select (item => item.ToString ()))); " is 132.
Long Statement,PlanarGraph.Data,Edge,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Edge.cs,Split,The length of the statement  "	Debug.WriteLineIf (list.Any ()' this + " split by " + path + " is " + string.Join ("'"' list.Select (item => item.ToString ()))); " is 129.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetVector,The length of the statement  "				CudafySequencies.SetSequencies (list1.Select (item => item.ToArray ()).ToArray ()' list2.Select (item => item.ToArray ()).ToArray ()); " is 134.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetSubgraphPaths,The length of the statement  "	return new Dictionary<int' PathDictionary> (GetFromToPaths (vertices' vertices' cachedAllGraphPaths).ToDictionary (p => p.Key' p => new PathDictionary (p.Value.Select (pair => new { " is 181.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetSubgraphPaths,The length of the statement  "	}).Where (@t => @t.list1.Any ()).Select (@t => new KeyValuePair<KeyValuePair<Vertex' Vertex>' PathCollection> (@t.pair.Key' new PathCollection (@t.list1)))))); " is 159.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetFromToPaths,The length of the statement  "	return new Dictionary<int' PathDictionary> (cachedAllGraphPaths.ToDictionary (p => p.Key' p => new PathDictionary (p.Value.Where (pair => listFrom.Contains (pair.Key.Key) && listTo.Contains (pair.Key.Value))))); " is 211.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetAllGraphPaths,The length of the statement  "		Dictionary<int' PathDictionary> dictionary1 = Enumerable.Range (2' vertices.Count).ToDictionary (len => len' len => new PathDictionary (key' new PathCollection (collection.Where (p => p.Count == len)))); " is 203.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,RemoveIntermedians,The length of the statement  "	for (Vertex v = Vertices.FirstOrDefault (vertex => this.Count (vertex.BelongsTo) == 2); v != null; v = Vertices.FirstOrDefault (vertex => this.Count (vertex.BelongsTo) == 2)) { " is 176.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetAllSubGraphs,The length of the statement  "		Dictionary<Vertex' VertexSortedCollection> children = list1.ToDictionary (vertex => vertex' vertex => Children [vertex]); " is 121.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetMinPathLengths,The length of the statement  "	IEnumerable<KeyValuePair<KeyValuePair<Vertex' Vertex>' int>> fromTo = GetFromToPaths (vertices' vertices' cachedAllGraphPaths).SelectMany (p => p.Value.Select (pair => new KeyValuePair<KeyValuePair<Vertex' Vertex>' int> (pair.Key' p.Key))); " is 240.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetMinPathLengths,The length of the statement  "	return fromTo.Select (pair => pair.Key).Distinct (_keyValuePairVertexVertexComparer).ToDictionary (pair => pair' pair => fromTo.Where (p2 => p2.Key.Key == pair.Key && p2.Key.Value == pair.Value).Min (p => p.Value)); " is 215.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetSubgraph,The length of the statement  "	return new Graph (Children.Where (pair => vertices.Contains (pair.Key)).Select (pair => new KeyValuePair<Vertex' VertexSortedCollection> (pair.Key' new VertexSortedCollection (pair.Value.Intersect (vertices)))).Where (pair => pair.Value.Any ()).ToDictionary (pair => pair.Key' pair => pair.Value)); " is 298.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetSubgraph,The length of the statement  "	return new Graph (Children.Where (pair => vertices.Contains (pair.Key)).Select (pair => new KeyValuePair<Vertex' VertexSortedCollection> (pair.Key' new VertexSortedCollection (pair.Value.Intersect (bridges)))).Where (pair => pair.Value.Any ()).ToDictionary (pair => pair.Key' pair => pair.Value)); " is 297.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The length of the statement  "				CudafySequencies.SetSequencies (Vertices.Select (path.GetInts).Select (item => item.ToArray ()).ToArray ()' path.GetRange (1' Count - 2).Select (path.GetInts).Select (item => item.ToArray ()).ToArray ()); " is 204.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The length of the statement  "		if (((prev + 1) == indexes [0]) && children.ContainsKey (path [prev]) && children [path [prev]].Contains (path [indexes [0]])) " is 126.
Long Statement,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The length of the statement  "	Debug.WriteLineIf (list.Any ()' path + " split by " + this + " is " + string.Join ("'"' list.Select (item => item.ToString ()))); " is 129.
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: foreach (Context context in queue) {  	while (context.SubGraphQueue.Any ()) {  		Graph subGraph = context.SubGraphQueue.Dequeue ();  		if (WorkerLog != null)  			WorkerLog ("Проверка связанной компоненты " + subGraph);  		Dictionary<int' PathDictionary> cachedSubGraphPaths = context.CachedSubGraphPathsQueue.Dequeue ();  		// На вход подаются графы' обладающие следующими свойствами:  		// граф связный;  		// граф имеет хотя бы один цикл;  		// граф не имеет мостиков' т. е. ребер' после удаления которых   		// граф распадается на две компонеты связности.  		if (WorkerLog != null)  			WorkerLog ("Находим мосты после удаления которых граф распадается на несколько компонет связности");  		var vertices = new StackListQueue<Vertex> (subGraph.Vertices);  		var bridges = new StackListQueue<Vertex> ();  		for (int i = 0; i < vertices.Count; i++) {  			Vertex dequeue = vertices.Dequeue ();  			IEnumerable<Graph> subsubgraphs = subGraph.GetSubgraph (vertices).GetAllSubGraphs ();  			if (subsubgraphs.Count () > 1)  				bridges.Add (dequeue);  			vertices.Enqueue (dequeue);  		}  		Debug.Assert (bridges.Count != vertices.Count);  		if (bridges.Any ()) {  			// Если в графе есть мосты' то их нужно разрезать' провести отдельно плоскую укладку   			// каждой компоненты связности' а затем соединить их мостами.   			// Здесь может возникнуть трудность: в процессе укладки концевые вершины моста могут   			// оказаться внутри плоского графа. Нарисуем одну компоненту связности'   			// и будем присоединять к ней другие последовательно.  			// Каждую новую компоненту связности будем рисовать в той грани' в которой лежит   			// концевая вершина соответствующего моста. Так как граф связности мостами компонент   			// связности является деревом' мы сумеем получить плоскую укладку.  			if (WorkerLog != null)  				WorkerLog ("В графе есть мосты' их нужно разрезать' провести отдельно плоскую укладку' а затем соединить их мостами.");  			if (WorkerLog != null)  				WorkerLog ("Мосты: " + string.Join ("'"' bridges));  			IEnumerable<Vertex> exceptBridges = vertices.Except (bridges);  			IEnumerable<Graph> subsubgraphs = subGraph.GetSubgraph (exceptBridges).GetAllSubGraphs ();  			Debug.WriteLine ("subsubgraphs = " + subsubgraphs.Count ());  			context.SubGraphQueue.Enqueue (subsubgraphs.Select (subgraph => subGraph.GetSubgraph (subgraph.Vertices.Union (bridges))));  			context.CachedSubGraphPathsQueue.Enqueue (subsubgraphs.Select (subgraph => Graph.GetSubgraphPaths (subgraph.Vertices.Union (bridges)' cachedSubGraphPaths)));  			continue;  		}  		if (WorkerLog != null)  			WorkerLog ("Находим ЛЮБОЙ МАКСИМАЛЬНОЙ ДЛИНЫ простой цикл в графе");  		Circle circle = null;  		for (int i = cachedSubGraphPaths.Keys.Max (); i > 3; i--) {  			foreach (var pair in cachedSubGraphPaths.Where (pair => pair.Key == i)) {  				foreach (var key in subGraph.Vertices.Select (vertex => new KeyValuePair<Vertex' Vertex> (vertex' vertex))) {  					if (pair.Value.ContainsKey (key) && pair.Value [key].Any ()) {  						foreach (Path path in pair.Value [key]) {  							circle = new Circle (path.GetRange (0' path.Count - 1));  							if (Circle.IsSimple (circle))  								break;  							circle = null;  						}  						if (circle != null)  							break;  					}  					if (circle != null)  						break;  				}  				if (circle != null)  					break;  			}  			if (circle != null)  				break;  		}  		if (circle == null && !context.Edges.Any ()) {  			// граф — дерево и нарисовать его плоскую укладку тривиально.  			// Поскольку мы ещё не начинали рисовать' то значит всё проверено  			continue;  		}  		// Инициализация алгоритма производится так: выбираем любой простой цикл;  		// и получаем две грани: Γ1 — внешнюю и Γ2 — внутреннюю  		if (circle != null && !context.Edges.Any ()) {  			context.Edges.Add (new Edge (circle));  		}  		if (circle != null) {  			context.Edges.Add (new Edge (circle));  			context.Builded.Add (context.Edges.Last ());  		}  		// Если циклов нет' то надо проверить' что данное дерево   		// можно вписать в уже построенный граф  		Debug.WriteLine ("SubGraph " + subGraph);  		Debug.WriteLine ("builded " + context.Builded);  		Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (e => e.ToString ())));  		//// Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:  		//// ребро' оба конца которого принадлежат G′' но само оно не принадлежит G′;  		//// связную компоненту графа G – G′' дополненную всеми ребрами графа G'   		//// один из концов которых принадлежит связной компоненте'   		//// а второй из графа G′.  		VertexSortedCollection buildedVertices = context.Builded.Vertices;  		Dictionary<int' PathDictionary> fromTo = Graph.GetFromToPaths (buildedVertices' buildedVertices' cachedSubGraphPaths);  		var paths = new PathCollection (fromTo.SelectMany (pair => pair.Value).SelectMany (pair => pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  		Debug.WriteLine ("paths " + paths);  		//var secondGraph = new Graph(subGraph.Except(context.Builded));  		//if (secondGraph.Any())  		//{  		//    IEnumerable<Graph> collection = secondGraph.GetAllSubGraphs();  		//    context.SubGraphQueue.Enqueue(collection);  		//    context.CachedSubGraphPathsQueue.Enqueue(  		//        collection.Select(subgraph => Graph.GetSubgraphPaths(subgraph.Vertices' cachedSubGraphPaths)));  		//}  		paths.ReplaceAll (paths.Distinct ());  		Debug.WriteLine ("paths " + paths);  		paths.RemoveAll (context.Builded.Contains);  		Debug.WriteLine ("paths " + paths);  		Debug.WriteLine ("builded " + context.Builded);  		Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (e => e.ToString ())));  		while (paths.Any ()) {  			paths.RemoveAll (context.Builded.Contains);  			Debug.WriteLine ("paths " + paths);  			if (!paths.Any ())  				continue;  			if (Settings.EnableCudafy)  				try {  					while (paths.Any (Path.IsLong)) {  						// Находим для всех путей их перечечения с уже построенным графом  						// Разбиваем пути в найденных точках пересечения с уже построенным графом  						// Если точек пересечения не найдено' то выходим из цикла  						int['] matrix;  						int[] indexes;  						lock (CudafySequencies.Semaphore) {  							CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ());  							CudafySequencies.Execute ("CountIntersections");  							// подсчитываем число пересечений  							matrix = CudafySequencies.GetMatrix ();  						}  						lock (CudafyMatrix.Semaphore) {  							CudafyMatrix.SetMatrix (matrix);  							CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  							// находим индексы ненулевых элементов в строках  							indexes = CudafyMatrix.GetIndexes ();  						}  						Dictionary<int' int> dictionary = indexes.Select ((value' index) => new KeyValuePair<int' int> (index' value)).Where (pair => pair.Value >= 0).ToDictionary (pair => pair.Key' pair => pair.Value);  						if (!dictionary.Any ())  							break;  						Debug.Assert (dictionary.All (pair => pair.Key >= 0));  						Debug.Assert (dictionary.All (pair => pair.Value >= 0));  						Debug.Assert (dictionary.All (pair => pair.Key < paths.Count));  						Debug.Assert (dictionary.All (pair => pair.Value < context.Builded.Vertices.Count));  						var dictionary2 = new StackListQueue<KeyValuePair<Path' Vertex>> (dictionary.Select (pair => new KeyValuePair<Path' Vertex> (new Path (paths [pair.Key])' new Vertex (context.Builded.Vertices [pair.Value]))));  						var list = new StackListQueue<int> (dictionary.Select (pair => pair.Key).Distinct ());  						list.Sort ();  						Debug.Assert (dictionary2.All (pair => pair.Key.Count > 1));  						for (int i = list.Count; i-- > 0;)  							paths.RemoveAt (list [i]);  						paths.AddRangeExcept (new PathCollection (dictionary2.SelectMany (pair => pair.Key.SplitBy (pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle)).Distinct ()));  						paths.ReplaceAll (paths.Distinct ());  						paths.RemoveAll (context.Builded.Contains);  					}  				}  				catch (Exception ex) {  					if (WorkerLog != null)  						WorkerLog (ex.ToString ());  					paths.ReplaceAll (paths.SelectMany (context.Builded.Split).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  					paths.ReplaceAll (paths.Distinct ());  					paths.RemoveAll (context.Builded.Contains);  				}  				finally {  				}  			else {  				Debug.WriteLine ("paths... " + paths);  				paths.ReplaceAll (new PathCollection (paths.SelectMany (context.Builded.Split)).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  				Debug.WriteLine ("paths... " + paths);  				paths.ReplaceAll (paths.Distinct ());  				Debug.WriteLine ("paths... " + paths);  				paths.RemoveAll (context.Builded.Contains);  				Debug.WriteLine ("paths... " + paths);  			}  			Debug.WriteLine ("paths... " + paths);  			if (!paths.Any ())  				continue;  			// Общий шаг алгоритма следующий:   			// обозреваются все сегменты Si и определяются числа |Γ(Si)|.   			// Если хоть одно из них равно 0' то граф не планарен' конец.   			// Иначе' выбираем сегмент' для которого число |Γ(S)| минимально' или   			// один из множества' если таких сегментов несколько.   			// В этом сегменте найдем цепь между двумя контактными вершинами и уложим ее   			// в любую из граней множества Γ(S)' совместив контактные вершины сегмента   			// с соответствующими вершинами грани.   			// При этом данная грань разобьется на две.   			// Уже уложенная часть графа G′ по количеству ребер и вершин увеличится'   			// а сегмент' из которого вынута цепь' исчезнет или развалится на меньшие   			// с новыми контактными вершинами' ведущими к вершинам G′.  			// В результате повторения общего шага   			// либо будет получена плоская укладка' когда множество сегментов станет пустым'   			// либо будет получено' что граф G не является планарным.  			Debug.WriteLine ("Шаг алгоритма");  			Debug.WriteLine ("paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  			Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  			// Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:  			// ребро' оба конца которого принадлежат G′' но само оно не принадлежит G′;  			// связную компоненту графа G – G′' дополненную всеми ребрами графа G'   			// один из концов которых принадлежит связной компоненте'   			// а второй из графа G′.  			// Для каждого сегмента S найти множество Γ(S). Если существует сегмент S' для которого |Γ(S)| = 0' то граф не  			// планарный' конец.  			int minCount;  			Path path1;  			Edge edge1;  			if (Settings.EnableCudafy)  				try {  					int['] matrix;  					int[] counts;  					int[] indexes;  					lock (CudafySequencies.Semaphore) {  						CudafySequencies.SetSequencies (paths.Select (path => path.Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Edges.Select (edge => edge.Select (vertex => vertex.Id).ToArray ()).ToArray ());  						CudafySequencies.Execute ("IsFromTo");  						matrix = CudafySequencies.GetMatrix ();  					}  					lock (CudafyMatrix.Semaphore) {  						CudafyMatrix.SetMatrix (matrix);  						CudafyMatrix.ExecuteCountMinInColumn ();  						counts = CudafyMatrix.GetCounts ().ToArray ();  						minCount = CudafyMatrix.GetMinCount ();  						if (WorkerLog != null)  							WorkerLog ("min |Γ(S)| = " + minCount);  						if (minCount == 0) {  							if (WorkerLog != null)  								WorkerLog ("Существует сегмент S' для которого |Γ(S)| = 0");  							if (WorkerLog != null)  								WorkerLog ("Граф не планарен");  							Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  							Debug.WriteLine ("Graph:" + context.Builded);  							Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  							Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  							bool result = false;  							if (WorkerComplite != null)  								WorkerComplite (result);  							return result;  						}  						CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  						indexes = CudafyMatrix.GetIndexes ();  					}  					int pathIndex = counts.ToList ().IndexOf (minCount);  					for (int nextPathIndex = counts.ToList ().IndexOf (minCount' pathIndex + 1); nextPathIndex > 0; nextPathIndex = counts.ToList ().IndexOf (minCount' nextPathIndex + 1))  						if (paths [nextPathIndex].Count > paths [pathIndex].Count)  							pathIndex = nextPathIndex;  					int edgeIndex = indexes [pathIndex];  					path1 = paths [pathIndex];  					edge1 = context.Edges [edgeIndex];  				}  				catch (Exception ex) {  					if (WorkerLog != null)  						WorkerLog (ex.ToString ());  					minCount = paths.Select (path => context.Edges.Count (path.FromTo)).Min ();  					if (minCount == 0) {  						Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  						Debug.WriteLine ("Graph:" + context.Builded);  						Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  						Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  						bool result = false;  						if (WorkerComplite != null)  							WorkerComplite (result);  						return result;  					}  					int count = paths.Where (path => context.Edges.Count (path.FromTo) == minCount).Max (path => path.Count);  					path1 = paths.First (path => context.Edges.Count (path.FromTo) == minCount && path.Count == count);  					edge1 = context.Edges.First (path1.FromTo);  				}  			else {  				minCount = paths.Select (path => context.Edges.Count (path.FromTo)).Min ();  				if (minCount == 0) {  					Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  					Debug.WriteLine ("Graph:" + context.Builded);  					Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  					Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  					bool result = false;  					if (WorkerComplite != null)  						WorkerComplite (result);  					Settings.EnableCudafy = enableCudafy;  					return result;  				}  				int count = paths.Where (path => context.Edges.Count (path.FromTo) == minCount).Max (path => path.Count);  				path1 = paths.First (path => context.Edges.Count (path.FromTo) == minCount && path.Count == count);  				edge1 = context.Edges.First (path1.FromTo);  			}  			// Выбираем один из сегментов с минимальным числом' вмещающих его граней.  			// Выбираем одну из подходящих граней для выбранного сегмента.  			// В данном сегменте выбираем цепь между двумя контактными вершинами и укладываем ее в выбранной грани.  			Debug.Assert (minCount > 0);  			Debug.WriteLine ("path1:" + path1);  			Debug.WriteLine ("edge1:" + edge1);  			context.Edges.AddRange (edge1.Split (path1));  			context.Builded.Add (path1);  			paths.Remove (path1);  			context.Edges.RemoveAt (context.Edges.IndexOf (edge1));  		}  		if (WorkerLog != null)  			WorkerLog ("Конец проверки связанной компоненты");  	}  }  
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: foreach (Context context in queue) {  	while (context.SubGraphQueue.Any ()) {  		Graph subGraph = context.SubGraphQueue.Dequeue ();  		if (WorkerLog != null)  			WorkerLog ("Проверка связанной компоненты " + subGraph);  		Dictionary<int' PathDictionary> cachedSubGraphPaths = context.CachedSubGraphPathsQueue.Dequeue ();  		// На вход подаются графы' обладающие следующими свойствами:  		// граф связный;  		// граф имеет хотя бы один цикл;  		// граф не имеет мостиков' т. е. ребер' после удаления которых   		// граф распадается на две компонеты связности.  		if (WorkerLog != null)  			WorkerLog ("Находим мосты после удаления которых граф распадается на несколько компонет связности");  		var vertices = new StackListQueue<Vertex> (subGraph.Vertices);  		var bridges = new StackListQueue<Vertex> ();  		for (int i = 0; i < vertices.Count; i++) {  			Vertex dequeue = vertices.Dequeue ();  			IEnumerable<Graph> subsubgraphs = subGraph.GetSubgraph (vertices).GetAllSubGraphs ();  			if (subsubgraphs.Count () > 1)  				bridges.Add (dequeue);  			vertices.Enqueue (dequeue);  		}  		Debug.Assert (bridges.Count != vertices.Count);  		if (bridges.Any ()) {  			// Если в графе есть мосты' то их нужно разрезать' провести отдельно плоскую укладку   			// каждой компоненты связности' а затем соединить их мостами.   			// Здесь может возникнуть трудность: в процессе укладки концевые вершины моста могут   			// оказаться внутри плоского графа. Нарисуем одну компоненту связности'   			// и будем присоединять к ней другие последовательно.  			// Каждую новую компоненту связности будем рисовать в той грани' в которой лежит   			// концевая вершина соответствующего моста. Так как граф связности мостами компонент   			// связности является деревом' мы сумеем получить плоскую укладку.  			if (WorkerLog != null)  				WorkerLog ("В графе есть мосты' их нужно разрезать' провести отдельно плоскую укладку' а затем соединить их мостами.");  			if (WorkerLog != null)  				WorkerLog ("Мосты: " + string.Join ("'"' bridges));  			IEnumerable<Vertex> exceptBridges = vertices.Except (bridges);  			IEnumerable<Graph> subsubgraphs = subGraph.GetSubgraph (exceptBridges).GetAllSubGraphs ();  			Debug.WriteLine ("subsubgraphs = " + subsubgraphs.Count ());  			context.SubGraphQueue.Enqueue (subsubgraphs.Select (subgraph => subGraph.GetSubgraph (subgraph.Vertices.Union (bridges))));  			context.CachedSubGraphPathsQueue.Enqueue (subsubgraphs.Select (subgraph => Graph.GetSubgraphPaths (subgraph.Vertices.Union (bridges)' cachedSubGraphPaths)));  			continue;  		}  		if (WorkerLog != null)  			WorkerLog ("Находим ЛЮБОЙ МАКСИМАЛЬНОЙ ДЛИНЫ простой цикл в графе");  		Circle circle = null;  		for (int i = cachedSubGraphPaths.Keys.Max (); i > 3; i--) {  			foreach (var pair in cachedSubGraphPaths.Where (pair => pair.Key == i)) {  				foreach (var key in subGraph.Vertices.Select (vertex => new KeyValuePair<Vertex' Vertex> (vertex' vertex))) {  					if (pair.Value.ContainsKey (key) && pair.Value [key].Any ()) {  						foreach (Path path in pair.Value [key]) {  							circle = new Circle (path.GetRange (0' path.Count - 1));  							if (Circle.IsSimple (circle))  								break;  							circle = null;  						}  						if (circle != null)  							break;  					}  					if (circle != null)  						break;  				}  				if (circle != null)  					break;  			}  			if (circle != null)  				break;  		}  		if (circle == null && !context.Edges.Any ()) {  			// граф — дерево и нарисовать его плоскую укладку тривиально.  			// Поскольку мы ещё не начинали рисовать' то значит всё проверено  			continue;  		}  		// Инициализация алгоритма производится так: выбираем любой простой цикл;  		// и получаем две грани: Γ1 — внешнюю и Γ2 — внутреннюю  		if (circle != null && !context.Edges.Any ()) {  			context.Edges.Add (new Edge (circle));  		}  		if (circle != null) {  			context.Edges.Add (new Edge (circle));  			context.Builded.Add (context.Edges.Last ());  		}  		// Если циклов нет' то надо проверить' что данное дерево   		// можно вписать в уже построенный граф  		Debug.WriteLine ("SubGraph " + subGraph);  		Debug.WriteLine ("builded " + context.Builded);  		Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (e => e.ToString ())));  		//// Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:  		//// ребро' оба конца которого принадлежат G′' но само оно не принадлежит G′;  		//// связную компоненту графа G – G′' дополненную всеми ребрами графа G'   		//// один из концов которых принадлежит связной компоненте'   		//// а второй из графа G′.  		VertexSortedCollection buildedVertices = context.Builded.Vertices;  		Dictionary<int' PathDictionary> fromTo = Graph.GetFromToPaths (buildedVertices' buildedVertices' cachedSubGraphPaths);  		var paths = new PathCollection (fromTo.SelectMany (pair => pair.Value).SelectMany (pair => pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  		Debug.WriteLine ("paths " + paths);  		//var secondGraph = new Graph(subGraph.Except(context.Builded));  		//if (secondGraph.Any())  		//{  		//    IEnumerable<Graph> collection = secondGraph.GetAllSubGraphs();  		//    context.SubGraphQueue.Enqueue(collection);  		//    context.CachedSubGraphPathsQueue.Enqueue(  		//        collection.Select(subgraph => Graph.GetSubgraphPaths(subgraph.Vertices' cachedSubGraphPaths)));  		//}  		paths.ReplaceAll (paths.Distinct ());  		Debug.WriteLine ("paths " + paths);  		paths.RemoveAll (context.Builded.Contains);  		Debug.WriteLine ("paths " + paths);  		Debug.WriteLine ("builded " + context.Builded);  		Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (e => e.ToString ())));  		while (paths.Any ()) {  			paths.RemoveAll (context.Builded.Contains);  			Debug.WriteLine ("paths " + paths);  			if (!paths.Any ())  				continue;  			if (Settings.EnableCudafy)  				try {  					while (paths.Any (Path.IsLong)) {  						// Находим для всех путей их перечечения с уже построенным графом  						// Разбиваем пути в найденных точках пересечения с уже построенным графом  						// Если точек пересечения не найдено' то выходим из цикла  						int['] matrix;  						int[] indexes;  						lock (CudafySequencies.Semaphore) {  							CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ());  							CudafySequencies.Execute ("CountIntersections");  							// подсчитываем число пересечений  							matrix = CudafySequencies.GetMatrix ();  						}  						lock (CudafyMatrix.Semaphore) {  							CudafyMatrix.SetMatrix (matrix);  							CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  							// находим индексы ненулевых элементов в строках  							indexes = CudafyMatrix.GetIndexes ();  						}  						Dictionary<int' int> dictionary = indexes.Select ((value' index) => new KeyValuePair<int' int> (index' value)).Where (pair => pair.Value >= 0).ToDictionary (pair => pair.Key' pair => pair.Value);  						if (!dictionary.Any ())  							break;  						Debug.Assert (dictionary.All (pair => pair.Key >= 0));  						Debug.Assert (dictionary.All (pair => pair.Value >= 0));  						Debug.Assert (dictionary.All (pair => pair.Key < paths.Count));  						Debug.Assert (dictionary.All (pair => pair.Value < context.Builded.Vertices.Count));  						var dictionary2 = new StackListQueue<KeyValuePair<Path' Vertex>> (dictionary.Select (pair => new KeyValuePair<Path' Vertex> (new Path (paths [pair.Key])' new Vertex (context.Builded.Vertices [pair.Value]))));  						var list = new StackListQueue<int> (dictionary.Select (pair => pair.Key).Distinct ());  						list.Sort ();  						Debug.Assert (dictionary2.All (pair => pair.Key.Count > 1));  						for (int i = list.Count; i-- > 0;)  							paths.RemoveAt (list [i]);  						paths.AddRangeExcept (new PathCollection (dictionary2.SelectMany (pair => pair.Key.SplitBy (pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle)).Distinct ()));  						paths.ReplaceAll (paths.Distinct ());  						paths.RemoveAll (context.Builded.Contains);  					}  				}  				catch (Exception ex) {  					if (WorkerLog != null)  						WorkerLog (ex.ToString ());  					paths.ReplaceAll (paths.SelectMany (context.Builded.Split).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  					paths.ReplaceAll (paths.Distinct ());  					paths.RemoveAll (context.Builded.Contains);  				}  				finally {  				}  			else {  				Debug.WriteLine ("paths... " + paths);  				paths.ReplaceAll (new PathCollection (paths.SelectMany (context.Builded.Split)).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  				Debug.WriteLine ("paths... " + paths);  				paths.ReplaceAll (paths.Distinct ());  				Debug.WriteLine ("paths... " + paths);  				paths.RemoveAll (context.Builded.Contains);  				Debug.WriteLine ("paths... " + paths);  			}  			Debug.WriteLine ("paths... " + paths);  			if (!paths.Any ())  				continue;  			// Общий шаг алгоритма следующий:   			// обозреваются все сегменты Si и определяются числа |Γ(Si)|.   			// Если хоть одно из них равно 0' то граф не планарен' конец.   			// Иначе' выбираем сегмент' для которого число |Γ(S)| минимально' или   			// один из множества' если таких сегментов несколько.   			// В этом сегменте найдем цепь между двумя контактными вершинами и уложим ее   			// в любую из граней множества Γ(S)' совместив контактные вершины сегмента   			// с соответствующими вершинами грани.   			// При этом данная грань разобьется на две.   			// Уже уложенная часть графа G′ по количеству ребер и вершин увеличится'   			// а сегмент' из которого вынута цепь' исчезнет или развалится на меньшие   			// с новыми контактными вершинами' ведущими к вершинам G′.  			// В результате повторения общего шага   			// либо будет получена плоская укладка' когда множество сегментов станет пустым'   			// либо будет получено' что граф G не является планарным.  			Debug.WriteLine ("Шаг алгоритма");  			Debug.WriteLine ("paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  			Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  			// Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:  			// ребро' оба конца которого принадлежат G′' но само оно не принадлежит G′;  			// связную компоненту графа G – G′' дополненную всеми ребрами графа G'   			// один из концов которых принадлежит связной компоненте'   			// а второй из графа G′.  			// Для каждого сегмента S найти множество Γ(S). Если существует сегмент S' для которого |Γ(S)| = 0' то граф не  			// планарный' конец.  			int minCount;  			Path path1;  			Edge edge1;  			if (Settings.EnableCudafy)  				try {  					int['] matrix;  					int[] counts;  					int[] indexes;  					lock (CudafySequencies.Semaphore) {  						CudafySequencies.SetSequencies (paths.Select (path => path.Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Edges.Select (edge => edge.Select (vertex => vertex.Id).ToArray ()).ToArray ());  						CudafySequencies.Execute ("IsFromTo");  						matrix = CudafySequencies.GetMatrix ();  					}  					lock (CudafyMatrix.Semaphore) {  						CudafyMatrix.SetMatrix (matrix);  						CudafyMatrix.ExecuteCountMinInColumn ();  						counts = CudafyMatrix.GetCounts ().ToArray ();  						minCount = CudafyMatrix.GetMinCount ();  						if (WorkerLog != null)  							WorkerLog ("min |Γ(S)| = " + minCount);  						if (minCount == 0) {  							if (WorkerLog != null)  								WorkerLog ("Существует сегмент S' для которого |Γ(S)| = 0");  							if (WorkerLog != null)  								WorkerLog ("Граф не планарен");  							Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  							Debug.WriteLine ("Graph:" + context.Builded);  							Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  							Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  							bool result = false;  							if (WorkerComplite != null)  								WorkerComplite (result);  							return result;  						}  						CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  						indexes = CudafyMatrix.GetIndexes ();  					}  					int pathIndex = counts.ToList ().IndexOf (minCount);  					for (int nextPathIndex = counts.ToList ().IndexOf (minCount' pathIndex + 1); nextPathIndex > 0; nextPathIndex = counts.ToList ().IndexOf (minCount' nextPathIndex + 1))  						if (paths [nextPathIndex].Count > paths [pathIndex].Count)  							pathIndex = nextPathIndex;  					int edgeIndex = indexes [pathIndex];  					path1 = paths [pathIndex];  					edge1 = context.Edges [edgeIndex];  				}  				catch (Exception ex) {  					if (WorkerLog != null)  						WorkerLog (ex.ToString ());  					minCount = paths.Select (path => context.Edges.Count (path.FromTo)).Min ();  					if (minCount == 0) {  						Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  						Debug.WriteLine ("Graph:" + context.Builded);  						Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  						Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  						bool result = false;  						if (WorkerComplite != null)  							WorkerComplite (result);  						return result;  					}  					int count = paths.Where (path => context.Edges.Count (path.FromTo) == minCount).Max (path => path.Count);  					path1 = paths.First (path => context.Edges.Count (path.FromTo) == minCount && path.Count == count);  					edge1 = context.Edges.First (path1.FromTo);  				}  			else {  				minCount = paths.Select (path => context.Edges.Count (path.FromTo)).Min ();  				if (minCount == 0) {  					Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  					Debug.WriteLine ("Graph:" + context.Builded);  					Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  					Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  					bool result = false;  					if (WorkerComplite != null)  						WorkerComplite (result);  					Settings.EnableCudafy = enableCudafy;  					return result;  				}  				int count = paths.Where (path => context.Edges.Count (path.FromTo) == minCount).Max (path => path.Count);  				path1 = paths.First (path => context.Edges.Count (path.FromTo) == minCount && path.Count == count);  				edge1 = context.Edges.First (path1.FromTo);  			}  			// Выбираем один из сегментов с минимальным числом' вмещающих его граней.  			// Выбираем одну из подходящих граней для выбранного сегмента.  			// В данном сегменте выбираем цепь между двумя контактными вершинами и укладываем ее в выбранной грани.  			Debug.Assert (minCount > 0);  			Debug.WriteLine ("path1:" + path1);  			Debug.WriteLine ("edge1:" + edge1);  			context.Edges.AddRange (edge1.Split (path1));  			context.Builded.Add (path1);  			paths.Remove (path1);  			context.Edges.RemoveAt (context.Edges.IndexOf (edge1));  		}  		if (WorkerLog != null)  			WorkerLog ("Конец проверки связанной компоненты");  	}  }  
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: while (context.SubGraphQueue.Any ()) {  	Graph subGraph = context.SubGraphQueue.Dequeue ();  	if (WorkerLog != null)  		WorkerLog ("Проверка связанной компоненты " + subGraph);  	Dictionary<int' PathDictionary> cachedSubGraphPaths = context.CachedSubGraphPathsQueue.Dequeue ();  	// На вход подаются графы' обладающие следующими свойствами:  	// граф связный;  	// граф имеет хотя бы один цикл;  	// граф не имеет мостиков' т. е. ребер' после удаления которых   	// граф распадается на две компонеты связности.  	if (WorkerLog != null)  		WorkerLog ("Находим мосты после удаления которых граф распадается на несколько компонет связности");  	var vertices = new StackListQueue<Vertex> (subGraph.Vertices);  	var bridges = new StackListQueue<Vertex> ();  	for (int i = 0; i < vertices.Count; i++) {  		Vertex dequeue = vertices.Dequeue ();  		IEnumerable<Graph> subsubgraphs = subGraph.GetSubgraph (vertices).GetAllSubGraphs ();  		if (subsubgraphs.Count () > 1)  			bridges.Add (dequeue);  		vertices.Enqueue (dequeue);  	}  	Debug.Assert (bridges.Count != vertices.Count);  	if (bridges.Any ()) {  		// Если в графе есть мосты' то их нужно разрезать' провести отдельно плоскую укладку   		// каждой компоненты связности' а затем соединить их мостами.   		// Здесь может возникнуть трудность: в процессе укладки концевые вершины моста могут   		// оказаться внутри плоского графа. Нарисуем одну компоненту связности'   		// и будем присоединять к ней другие последовательно.  		// Каждую новую компоненту связности будем рисовать в той грани' в которой лежит   		// концевая вершина соответствующего моста. Так как граф связности мостами компонент   		// связности является деревом' мы сумеем получить плоскую укладку.  		if (WorkerLog != null)  			WorkerLog ("В графе есть мосты' их нужно разрезать' провести отдельно плоскую укладку' а затем соединить их мостами.");  		if (WorkerLog != null)  			WorkerLog ("Мосты: " + string.Join ("'"' bridges));  		IEnumerable<Vertex> exceptBridges = vertices.Except (bridges);  		IEnumerable<Graph> subsubgraphs = subGraph.GetSubgraph (exceptBridges).GetAllSubGraphs ();  		Debug.WriteLine ("subsubgraphs = " + subsubgraphs.Count ());  		context.SubGraphQueue.Enqueue (subsubgraphs.Select (subgraph => subGraph.GetSubgraph (subgraph.Vertices.Union (bridges))));  		context.CachedSubGraphPathsQueue.Enqueue (subsubgraphs.Select (subgraph => Graph.GetSubgraphPaths (subgraph.Vertices.Union (bridges)' cachedSubGraphPaths)));  		continue;  	}  	if (WorkerLog != null)  		WorkerLog ("Находим ЛЮБОЙ МАКСИМАЛЬНОЙ ДЛИНЫ простой цикл в графе");  	Circle circle = null;  	for (int i = cachedSubGraphPaths.Keys.Max (); i > 3; i--) {  		foreach (var pair in cachedSubGraphPaths.Where (pair => pair.Key == i)) {  			foreach (var key in subGraph.Vertices.Select (vertex => new KeyValuePair<Vertex' Vertex> (vertex' vertex))) {  				if (pair.Value.ContainsKey (key) && pair.Value [key].Any ()) {  					foreach (Path path in pair.Value [key]) {  						circle = new Circle (path.GetRange (0' path.Count - 1));  						if (Circle.IsSimple (circle))  							break;  						circle = null;  					}  					if (circle != null)  						break;  				}  				if (circle != null)  					break;  			}  			if (circle != null)  				break;  		}  		if (circle != null)  			break;  	}  	if (circle == null && !context.Edges.Any ()) {  		// граф — дерево и нарисовать его плоскую укладку тривиально.  		// Поскольку мы ещё не начинали рисовать' то значит всё проверено  		continue;  	}  	// Инициализация алгоритма производится так: выбираем любой простой цикл;  	// и получаем две грани: Γ1 — внешнюю и Γ2 — внутреннюю  	if (circle != null && !context.Edges.Any ()) {  		context.Edges.Add (new Edge (circle));  	}  	if (circle != null) {  		context.Edges.Add (new Edge (circle));  		context.Builded.Add (context.Edges.Last ());  	}  	// Если циклов нет' то надо проверить' что данное дерево   	// можно вписать в уже построенный граф  	Debug.WriteLine ("SubGraph " + subGraph);  	Debug.WriteLine ("builded " + context.Builded);  	Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (e => e.ToString ())));  	//// Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:  	//// ребро' оба конца которого принадлежат G′' но само оно не принадлежит G′;  	//// связную компоненту графа G – G′' дополненную всеми ребрами графа G'   	//// один из концов которых принадлежит связной компоненте'   	//// а второй из графа G′.  	VertexSortedCollection buildedVertices = context.Builded.Vertices;  	Dictionary<int' PathDictionary> fromTo = Graph.GetFromToPaths (buildedVertices' buildedVertices' cachedSubGraphPaths);  	var paths = new PathCollection (fromTo.SelectMany (pair => pair.Value).SelectMany (pair => pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  	Debug.WriteLine ("paths " + paths);  	//var secondGraph = new Graph(subGraph.Except(context.Builded));  	//if (secondGraph.Any())  	//{  	//    IEnumerable<Graph> collection = secondGraph.GetAllSubGraphs();  	//    context.SubGraphQueue.Enqueue(collection);  	//    context.CachedSubGraphPathsQueue.Enqueue(  	//        collection.Select(subgraph => Graph.GetSubgraphPaths(subgraph.Vertices' cachedSubGraphPaths)));  	//}  	paths.ReplaceAll (paths.Distinct ());  	Debug.WriteLine ("paths " + paths);  	paths.RemoveAll (context.Builded.Contains);  	Debug.WriteLine ("paths " + paths);  	Debug.WriteLine ("builded " + context.Builded);  	Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (e => e.ToString ())));  	while (paths.Any ()) {  		paths.RemoveAll (context.Builded.Contains);  		Debug.WriteLine ("paths " + paths);  		if (!paths.Any ())  			continue;  		if (Settings.EnableCudafy)  			try {  				while (paths.Any (Path.IsLong)) {  					// Находим для всех путей их перечечения с уже построенным графом  					// Разбиваем пути в найденных точках пересечения с уже построенным графом  					// Если точек пересечения не найдено' то выходим из цикла  					int['] matrix;  					int[] indexes;  					lock (CudafySequencies.Semaphore) {  						CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ());  						CudafySequencies.Execute ("CountIntersections");  						// подсчитываем число пересечений  						matrix = CudafySequencies.GetMatrix ();  					}  					lock (CudafyMatrix.Semaphore) {  						CudafyMatrix.SetMatrix (matrix);  						CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  						// находим индексы ненулевых элементов в строках  						indexes = CudafyMatrix.GetIndexes ();  					}  					Dictionary<int' int> dictionary = indexes.Select ((value' index) => new KeyValuePair<int' int> (index' value)).Where (pair => pair.Value >= 0).ToDictionary (pair => pair.Key' pair => pair.Value);  					if (!dictionary.Any ())  						break;  					Debug.Assert (dictionary.All (pair => pair.Key >= 0));  					Debug.Assert (dictionary.All (pair => pair.Value >= 0));  					Debug.Assert (dictionary.All (pair => pair.Key < paths.Count));  					Debug.Assert (dictionary.All (pair => pair.Value < context.Builded.Vertices.Count));  					var dictionary2 = new StackListQueue<KeyValuePair<Path' Vertex>> (dictionary.Select (pair => new KeyValuePair<Path' Vertex> (new Path (paths [pair.Key])' new Vertex (context.Builded.Vertices [pair.Value]))));  					var list = new StackListQueue<int> (dictionary.Select (pair => pair.Key).Distinct ());  					list.Sort ();  					Debug.Assert (dictionary2.All (pair => pair.Key.Count > 1));  					for (int i = list.Count; i-- > 0;)  						paths.RemoveAt (list [i]);  					paths.AddRangeExcept (new PathCollection (dictionary2.SelectMany (pair => pair.Key.SplitBy (pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle)).Distinct ()));  					paths.ReplaceAll (paths.Distinct ());  					paths.RemoveAll (context.Builded.Contains);  				}  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				paths.ReplaceAll (paths.SelectMany (context.Builded.Split).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  				paths.ReplaceAll (paths.Distinct ());  				paths.RemoveAll (context.Builded.Contains);  			}  			finally {  			}  		else {  			Debug.WriteLine ("paths... " + paths);  			paths.ReplaceAll (new PathCollection (paths.SelectMany (context.Builded.Split)).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  			Debug.WriteLine ("paths... " + paths);  			paths.ReplaceAll (paths.Distinct ());  			Debug.WriteLine ("paths... " + paths);  			paths.RemoveAll (context.Builded.Contains);  			Debug.WriteLine ("paths... " + paths);  		}  		Debug.WriteLine ("paths... " + paths);  		if (!paths.Any ())  			continue;  		// Общий шаг алгоритма следующий:   		// обозреваются все сегменты Si и определяются числа |Γ(Si)|.   		// Если хоть одно из них равно 0' то граф не планарен' конец.   		// Иначе' выбираем сегмент' для которого число |Γ(S)| минимально' или   		// один из множества' если таких сегментов несколько.   		// В этом сегменте найдем цепь между двумя контактными вершинами и уложим ее   		// в любую из граней множества Γ(S)' совместив контактные вершины сегмента   		// с соответствующими вершинами грани.   		// При этом данная грань разобьется на две.   		// Уже уложенная часть графа G′ по количеству ребер и вершин увеличится'   		// а сегмент' из которого вынута цепь' исчезнет или развалится на меньшие   		// с новыми контактными вершинами' ведущими к вершинам G′.  		// В результате повторения общего шага   		// либо будет получена плоская укладка' когда множество сегментов станет пустым'   		// либо будет получено' что граф G не является планарным.  		Debug.WriteLine ("Шаг алгоритма");  		Debug.WriteLine ("paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  		Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  		// Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:  		// ребро' оба конца которого принадлежат G′' но само оно не принадлежит G′;  		// связную компоненту графа G – G′' дополненную всеми ребрами графа G'   		// один из концов которых принадлежит связной компоненте'   		// а второй из графа G′.  		// Для каждого сегмента S найти множество Γ(S). Если существует сегмент S' для которого |Γ(S)| = 0' то граф не  		// планарный' конец.  		int minCount;  		Path path1;  		Edge edge1;  		if (Settings.EnableCudafy)  			try {  				int['] matrix;  				int[] counts;  				int[] indexes;  				lock (CudafySequencies.Semaphore) {  					CudafySequencies.SetSequencies (paths.Select (path => path.Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Edges.Select (edge => edge.Select (vertex => vertex.Id).ToArray ()).ToArray ());  					CudafySequencies.Execute ("IsFromTo");  					matrix = CudafySequencies.GetMatrix ();  				}  				lock (CudafyMatrix.Semaphore) {  					CudafyMatrix.SetMatrix (matrix);  					CudafyMatrix.ExecuteCountMinInColumn ();  					counts = CudafyMatrix.GetCounts ().ToArray ();  					minCount = CudafyMatrix.GetMinCount ();  					if (WorkerLog != null)  						WorkerLog ("min |Γ(S)| = " + minCount);  					if (minCount == 0) {  						if (WorkerLog != null)  							WorkerLog ("Существует сегмент S' для которого |Γ(S)| = 0");  						if (WorkerLog != null)  							WorkerLog ("Граф не планарен");  						Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  						Debug.WriteLine ("Graph:" + context.Builded);  						Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  						Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  						bool result = false;  						if (WorkerComplite != null)  							WorkerComplite (result);  						return result;  					}  					CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  					indexes = CudafyMatrix.GetIndexes ();  				}  				int pathIndex = counts.ToList ().IndexOf (minCount);  				for (int nextPathIndex = counts.ToList ().IndexOf (minCount' pathIndex + 1); nextPathIndex > 0; nextPathIndex = counts.ToList ().IndexOf (minCount' nextPathIndex + 1))  					if (paths [nextPathIndex].Count > paths [pathIndex].Count)  						pathIndex = nextPathIndex;  				int edgeIndex = indexes [pathIndex];  				path1 = paths [pathIndex];  				edge1 = context.Edges [edgeIndex];  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				minCount = paths.Select (path => context.Edges.Count (path.FromTo)).Min ();  				if (minCount == 0) {  					Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  					Debug.WriteLine ("Graph:" + context.Builded);  					Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  					Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  					bool result = false;  					if (WorkerComplite != null)  						WorkerComplite (result);  					return result;  				}  				int count = paths.Where (path => context.Edges.Count (path.FromTo) == minCount).Max (path => path.Count);  				path1 = paths.First (path => context.Edges.Count (path.FromTo) == minCount && path.Count == count);  				edge1 = context.Edges.First (path1.FromTo);  			}  		else {  			minCount = paths.Select (path => context.Edges.Count (path.FromTo)).Min ();  			if (minCount == 0) {  				Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  				Debug.WriteLine ("Graph:" + context.Builded);  				Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  				Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  				bool result = false;  				if (WorkerComplite != null)  					WorkerComplite (result);  				Settings.EnableCudafy = enableCudafy;  				return result;  			}  			int count = paths.Where (path => context.Edges.Count (path.FromTo) == minCount).Max (path => path.Count);  			path1 = paths.First (path => context.Edges.Count (path.FromTo) == minCount && path.Count == count);  			edge1 = context.Edges.First (path1.FromTo);  		}  		// Выбираем один из сегментов с минимальным числом' вмещающих его граней.  		// Выбираем одну из подходящих граней для выбранного сегмента.  		// В данном сегменте выбираем цепь между двумя контактными вершинами и укладываем ее в выбранной грани.  		Debug.Assert (minCount > 0);  		Debug.WriteLine ("path1:" + path1);  		Debug.WriteLine ("edge1:" + edge1);  		context.Edges.AddRange (edge1.Split (path1));  		context.Builded.Add (path1);  		paths.Remove (path1);  		context.Edges.RemoveAt (context.Edges.IndexOf (edge1));  	}  	if (WorkerLog != null)  		WorkerLog ("Конец проверки связанной компоненты");  }  
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: while (context.SubGraphQueue.Any ()) {  	Graph subGraph = context.SubGraphQueue.Dequeue ();  	if (WorkerLog != null)  		WorkerLog ("Проверка связанной компоненты " + subGraph);  	Dictionary<int' PathDictionary> cachedSubGraphPaths = context.CachedSubGraphPathsQueue.Dequeue ();  	// На вход подаются графы' обладающие следующими свойствами:  	// граф связный;  	// граф имеет хотя бы один цикл;  	// граф не имеет мостиков' т. е. ребер' после удаления которых   	// граф распадается на две компонеты связности.  	if (WorkerLog != null)  		WorkerLog ("Находим мосты после удаления которых граф распадается на несколько компонет связности");  	var vertices = new StackListQueue<Vertex> (subGraph.Vertices);  	var bridges = new StackListQueue<Vertex> ();  	for (int i = 0; i < vertices.Count; i++) {  		Vertex dequeue = vertices.Dequeue ();  		IEnumerable<Graph> subsubgraphs = subGraph.GetSubgraph (vertices).GetAllSubGraphs ();  		if (subsubgraphs.Count () > 1)  			bridges.Add (dequeue);  		vertices.Enqueue (dequeue);  	}  	Debug.Assert (bridges.Count != vertices.Count);  	if (bridges.Any ()) {  		// Если в графе есть мосты' то их нужно разрезать' провести отдельно плоскую укладку   		// каждой компоненты связности' а затем соединить их мостами.   		// Здесь может возникнуть трудность: в процессе укладки концевые вершины моста могут   		// оказаться внутри плоского графа. Нарисуем одну компоненту связности'   		// и будем присоединять к ней другие последовательно.  		// Каждую новую компоненту связности будем рисовать в той грани' в которой лежит   		// концевая вершина соответствующего моста. Так как граф связности мостами компонент   		// связности является деревом' мы сумеем получить плоскую укладку.  		if (WorkerLog != null)  			WorkerLog ("В графе есть мосты' их нужно разрезать' провести отдельно плоскую укладку' а затем соединить их мостами.");  		if (WorkerLog != null)  			WorkerLog ("Мосты: " + string.Join ("'"' bridges));  		IEnumerable<Vertex> exceptBridges = vertices.Except (bridges);  		IEnumerable<Graph> subsubgraphs = subGraph.GetSubgraph (exceptBridges).GetAllSubGraphs ();  		Debug.WriteLine ("subsubgraphs = " + subsubgraphs.Count ());  		context.SubGraphQueue.Enqueue (subsubgraphs.Select (subgraph => subGraph.GetSubgraph (subgraph.Vertices.Union (bridges))));  		context.CachedSubGraphPathsQueue.Enqueue (subsubgraphs.Select (subgraph => Graph.GetSubgraphPaths (subgraph.Vertices.Union (bridges)' cachedSubGraphPaths)));  		continue;  	}  	if (WorkerLog != null)  		WorkerLog ("Находим ЛЮБОЙ МАКСИМАЛЬНОЙ ДЛИНЫ простой цикл в графе");  	Circle circle = null;  	for (int i = cachedSubGraphPaths.Keys.Max (); i > 3; i--) {  		foreach (var pair in cachedSubGraphPaths.Where (pair => pair.Key == i)) {  			foreach (var key in subGraph.Vertices.Select (vertex => new KeyValuePair<Vertex' Vertex> (vertex' vertex))) {  				if (pair.Value.ContainsKey (key) && pair.Value [key].Any ()) {  					foreach (Path path in pair.Value [key]) {  						circle = new Circle (path.GetRange (0' path.Count - 1));  						if (Circle.IsSimple (circle))  							break;  						circle = null;  					}  					if (circle != null)  						break;  				}  				if (circle != null)  					break;  			}  			if (circle != null)  				break;  		}  		if (circle != null)  			break;  	}  	if (circle == null && !context.Edges.Any ()) {  		// граф — дерево и нарисовать его плоскую укладку тривиально.  		// Поскольку мы ещё не начинали рисовать' то значит всё проверено  		continue;  	}  	// Инициализация алгоритма производится так: выбираем любой простой цикл;  	// и получаем две грани: Γ1 — внешнюю и Γ2 — внутреннюю  	if (circle != null && !context.Edges.Any ()) {  		context.Edges.Add (new Edge (circle));  	}  	if (circle != null) {  		context.Edges.Add (new Edge (circle));  		context.Builded.Add (context.Edges.Last ());  	}  	// Если циклов нет' то надо проверить' что данное дерево   	// можно вписать в уже построенный граф  	Debug.WriteLine ("SubGraph " + subGraph);  	Debug.WriteLine ("builded " + context.Builded);  	Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (e => e.ToString ())));  	//// Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:  	//// ребро' оба конца которого принадлежат G′' но само оно не принадлежит G′;  	//// связную компоненту графа G – G′' дополненную всеми ребрами графа G'   	//// один из концов которых принадлежит связной компоненте'   	//// а второй из графа G′.  	VertexSortedCollection buildedVertices = context.Builded.Vertices;  	Dictionary<int' PathDictionary> fromTo = Graph.GetFromToPaths (buildedVertices' buildedVertices' cachedSubGraphPaths);  	var paths = new PathCollection (fromTo.SelectMany (pair => pair.Value).SelectMany (pair => pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  	Debug.WriteLine ("paths " + paths);  	//var secondGraph = new Graph(subGraph.Except(context.Builded));  	//if (secondGraph.Any())  	//{  	//    IEnumerable<Graph> collection = secondGraph.GetAllSubGraphs();  	//    context.SubGraphQueue.Enqueue(collection);  	//    context.CachedSubGraphPathsQueue.Enqueue(  	//        collection.Select(subgraph => Graph.GetSubgraphPaths(subgraph.Vertices' cachedSubGraphPaths)));  	//}  	paths.ReplaceAll (paths.Distinct ());  	Debug.WriteLine ("paths " + paths);  	paths.RemoveAll (context.Builded.Contains);  	Debug.WriteLine ("paths " + paths);  	Debug.WriteLine ("builded " + context.Builded);  	Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (e => e.ToString ())));  	while (paths.Any ()) {  		paths.RemoveAll (context.Builded.Contains);  		Debug.WriteLine ("paths " + paths);  		if (!paths.Any ())  			continue;  		if (Settings.EnableCudafy)  			try {  				while (paths.Any (Path.IsLong)) {  					// Находим для всех путей их перечечения с уже построенным графом  					// Разбиваем пути в найденных точках пересечения с уже построенным графом  					// Если точек пересечения не найдено' то выходим из цикла  					int['] matrix;  					int[] indexes;  					lock (CudafySequencies.Semaphore) {  						CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ());  						CudafySequencies.Execute ("CountIntersections");  						// подсчитываем число пересечений  						matrix = CudafySequencies.GetMatrix ();  					}  					lock (CudafyMatrix.Semaphore) {  						CudafyMatrix.SetMatrix (matrix);  						CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  						// находим индексы ненулевых элементов в строках  						indexes = CudafyMatrix.GetIndexes ();  					}  					Dictionary<int' int> dictionary = indexes.Select ((value' index) => new KeyValuePair<int' int> (index' value)).Where (pair => pair.Value >= 0).ToDictionary (pair => pair.Key' pair => pair.Value);  					if (!dictionary.Any ())  						break;  					Debug.Assert (dictionary.All (pair => pair.Key >= 0));  					Debug.Assert (dictionary.All (pair => pair.Value >= 0));  					Debug.Assert (dictionary.All (pair => pair.Key < paths.Count));  					Debug.Assert (dictionary.All (pair => pair.Value < context.Builded.Vertices.Count));  					var dictionary2 = new StackListQueue<KeyValuePair<Path' Vertex>> (dictionary.Select (pair => new KeyValuePair<Path' Vertex> (new Path (paths [pair.Key])' new Vertex (context.Builded.Vertices [pair.Value]))));  					var list = new StackListQueue<int> (dictionary.Select (pair => pair.Key).Distinct ());  					list.Sort ();  					Debug.Assert (dictionary2.All (pair => pair.Key.Count > 1));  					for (int i = list.Count; i-- > 0;)  						paths.RemoveAt (list [i]);  					paths.AddRangeExcept (new PathCollection (dictionary2.SelectMany (pair => pair.Key.SplitBy (pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle)).Distinct ()));  					paths.ReplaceAll (paths.Distinct ());  					paths.RemoveAll (context.Builded.Contains);  				}  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				paths.ReplaceAll (paths.SelectMany (context.Builded.Split).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  				paths.ReplaceAll (paths.Distinct ());  				paths.RemoveAll (context.Builded.Contains);  			}  			finally {  			}  		else {  			Debug.WriteLine ("paths... " + paths);  			paths.ReplaceAll (new PathCollection (paths.SelectMany (context.Builded.Split)).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  			Debug.WriteLine ("paths... " + paths);  			paths.ReplaceAll (paths.Distinct ());  			Debug.WriteLine ("paths... " + paths);  			paths.RemoveAll (context.Builded.Contains);  			Debug.WriteLine ("paths... " + paths);  		}  		Debug.WriteLine ("paths... " + paths);  		if (!paths.Any ())  			continue;  		// Общий шаг алгоритма следующий:   		// обозреваются все сегменты Si и определяются числа |Γ(Si)|.   		// Если хоть одно из них равно 0' то граф не планарен' конец.   		// Иначе' выбираем сегмент' для которого число |Γ(S)| минимально' или   		// один из множества' если таких сегментов несколько.   		// В этом сегменте найдем цепь между двумя контактными вершинами и уложим ее   		// в любую из граней множества Γ(S)' совместив контактные вершины сегмента   		// с соответствующими вершинами грани.   		// При этом данная грань разобьется на две.   		// Уже уложенная часть графа G′ по количеству ребер и вершин увеличится'   		// а сегмент' из которого вынута цепь' исчезнет или развалится на меньшие   		// с новыми контактными вершинами' ведущими к вершинам G′.  		// В результате повторения общего шага   		// либо будет получена плоская укладка' когда множество сегментов станет пустым'   		// либо будет получено' что граф G не является планарным.  		Debug.WriteLine ("Шаг алгоритма");  		Debug.WriteLine ("paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  		Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  		// Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:  		// ребро' оба конца которого принадлежат G′' но само оно не принадлежит G′;  		// связную компоненту графа G – G′' дополненную всеми ребрами графа G'   		// один из концов которых принадлежит связной компоненте'   		// а второй из графа G′.  		// Для каждого сегмента S найти множество Γ(S). Если существует сегмент S' для которого |Γ(S)| = 0' то граф не  		// планарный' конец.  		int minCount;  		Path path1;  		Edge edge1;  		if (Settings.EnableCudafy)  			try {  				int['] matrix;  				int[] counts;  				int[] indexes;  				lock (CudafySequencies.Semaphore) {  					CudafySequencies.SetSequencies (paths.Select (path => path.Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Edges.Select (edge => edge.Select (vertex => vertex.Id).ToArray ()).ToArray ());  					CudafySequencies.Execute ("IsFromTo");  					matrix = CudafySequencies.GetMatrix ();  				}  				lock (CudafyMatrix.Semaphore) {  					CudafyMatrix.SetMatrix (matrix);  					CudafyMatrix.ExecuteCountMinInColumn ();  					counts = CudafyMatrix.GetCounts ().ToArray ();  					minCount = CudafyMatrix.GetMinCount ();  					if (WorkerLog != null)  						WorkerLog ("min |Γ(S)| = " + minCount);  					if (minCount == 0) {  						if (WorkerLog != null)  							WorkerLog ("Существует сегмент S' для которого |Γ(S)| = 0");  						if (WorkerLog != null)  							WorkerLog ("Граф не планарен");  						Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  						Debug.WriteLine ("Graph:" + context.Builded);  						Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  						Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  						bool result = false;  						if (WorkerComplite != null)  							WorkerComplite (result);  						return result;  					}  					CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  					indexes = CudafyMatrix.GetIndexes ();  				}  				int pathIndex = counts.ToList ().IndexOf (minCount);  				for (int nextPathIndex = counts.ToList ().IndexOf (minCount' pathIndex + 1); nextPathIndex > 0; nextPathIndex = counts.ToList ().IndexOf (minCount' nextPathIndex + 1))  					if (paths [nextPathIndex].Count > paths [pathIndex].Count)  						pathIndex = nextPathIndex;  				int edgeIndex = indexes [pathIndex];  				path1 = paths [pathIndex];  				edge1 = context.Edges [edgeIndex];  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				minCount = paths.Select (path => context.Edges.Count (path.FromTo)).Min ();  				if (minCount == 0) {  					Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  					Debug.WriteLine ("Graph:" + context.Builded);  					Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  					Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  					bool result = false;  					if (WorkerComplite != null)  						WorkerComplite (result);  					return result;  				}  				int count = paths.Where (path => context.Edges.Count (path.FromTo) == minCount).Max (path => path.Count);  				path1 = paths.First (path => context.Edges.Count (path.FromTo) == minCount && path.Count == count);  				edge1 = context.Edges.First (path1.FromTo);  			}  		else {  			minCount = paths.Select (path => context.Edges.Count (path.FromTo)).Min ();  			if (minCount == 0) {  				Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  				Debug.WriteLine ("Graph:" + context.Builded);  				Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  				Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  				bool result = false;  				if (WorkerComplite != null)  					WorkerComplite (result);  				Settings.EnableCudafy = enableCudafy;  				return result;  			}  			int count = paths.Where (path => context.Edges.Count (path.FromTo) == minCount).Max (path => path.Count);  			path1 = paths.First (path => context.Edges.Count (path.FromTo) == minCount && path.Count == count);  			edge1 = context.Edges.First (path1.FromTo);  		}  		// Выбираем один из сегментов с минимальным числом' вмещающих его граней.  		// Выбираем одну из подходящих граней для выбранного сегмента.  		// В данном сегменте выбираем цепь между двумя контактными вершинами и укладываем ее в выбранной грани.  		Debug.Assert (minCount > 0);  		Debug.WriteLine ("path1:" + path1);  		Debug.WriteLine ("edge1:" + edge1);  		context.Edges.AddRange (edge1.Split (path1));  		context.Builded.Add (path1);  		paths.Remove (path1);  		context.Edges.RemoveAt (context.Edges.IndexOf (edge1));  	}  	if (WorkerLog != null)  		WorkerLog ("Конец проверки связанной компоненты");  }  
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: for (int i = cachedSubGraphPaths.Keys.Max (); i > 3; i--) {  	foreach (var pair in cachedSubGraphPaths.Where (pair => pair.Key == i)) {  		foreach (var key in subGraph.Vertices.Select (vertex => new KeyValuePair<Vertex' Vertex> (vertex' vertex))) {  			if (pair.Value.ContainsKey (key) && pair.Value [key].Any ()) {  				foreach (Path path in pair.Value [key]) {  					circle = new Circle (path.GetRange (0' path.Count - 1));  					if (Circle.IsSimple (circle))  						break;  					circle = null;  				}  				if (circle != null)  					break;  			}  			if (circle != null)  				break;  		}  		if (circle != null)  			break;  	}  	if (circle != null)  		break;  }  
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: while (paths.Any ()) {  	paths.RemoveAll (context.Builded.Contains);  	Debug.WriteLine ("paths " + paths);  	if (!paths.Any ())  		continue;  	if (Settings.EnableCudafy)  		try {  			while (paths.Any (Path.IsLong)) {  				// Находим для всех путей их перечечения с уже построенным графом  				// Разбиваем пути в найденных точках пересечения с уже построенным графом  				// Если точек пересечения не найдено' то выходим из цикла  				int['] matrix;  				int[] indexes;  				lock (CudafySequencies.Semaphore) {  					CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ());  					CudafySequencies.Execute ("CountIntersections");  					// подсчитываем число пересечений  					matrix = CudafySequencies.GetMatrix ();  				}  				lock (CudafyMatrix.Semaphore) {  					CudafyMatrix.SetMatrix (matrix);  					CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  					// находим индексы ненулевых элементов в строках  					indexes = CudafyMatrix.GetIndexes ();  				}  				Dictionary<int' int> dictionary = indexes.Select ((value' index) => new KeyValuePair<int' int> (index' value)).Where (pair => pair.Value >= 0).ToDictionary (pair => pair.Key' pair => pair.Value);  				if (!dictionary.Any ())  					break;  				Debug.Assert (dictionary.All (pair => pair.Key >= 0));  				Debug.Assert (dictionary.All (pair => pair.Value >= 0));  				Debug.Assert (dictionary.All (pair => pair.Key < paths.Count));  				Debug.Assert (dictionary.All (pair => pair.Value < context.Builded.Vertices.Count));  				var dictionary2 = new StackListQueue<KeyValuePair<Path' Vertex>> (dictionary.Select (pair => new KeyValuePair<Path' Vertex> (new Path (paths [pair.Key])' new Vertex (context.Builded.Vertices [pair.Value]))));  				var list = new StackListQueue<int> (dictionary.Select (pair => pair.Key).Distinct ());  				list.Sort ();  				Debug.Assert (dictionary2.All (pair => pair.Key.Count > 1));  				for (int i = list.Count; i-- > 0;)  					paths.RemoveAt (list [i]);  				paths.AddRangeExcept (new PathCollection (dictionary2.SelectMany (pair => pair.Key.SplitBy (pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle)).Distinct ()));  				paths.ReplaceAll (paths.Distinct ());  				paths.RemoveAll (context.Builded.Contains);  			}  		}  		catch (Exception ex) {  			if (WorkerLog != null)  				WorkerLog (ex.ToString ());  			paths.ReplaceAll (paths.SelectMany (context.Builded.Split).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  			paths.ReplaceAll (paths.Distinct ());  			paths.RemoveAll (context.Builded.Contains);  		}  		finally {  		}  	else {  		Debug.WriteLine ("paths... " + paths);  		paths.ReplaceAll (new PathCollection (paths.SelectMany (context.Builded.Split)).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  		Debug.WriteLine ("paths... " + paths);  		paths.ReplaceAll (paths.Distinct ());  		Debug.WriteLine ("paths... " + paths);  		paths.RemoveAll (context.Builded.Contains);  		Debug.WriteLine ("paths... " + paths);  	}  	Debug.WriteLine ("paths... " + paths);  	if (!paths.Any ())  		continue;  	// Общий шаг алгоритма следующий:   	// обозреваются все сегменты Si и определяются числа |Γ(Si)|.   	// Если хоть одно из них равно 0' то граф не планарен' конец.   	// Иначе' выбираем сегмент' для которого число |Γ(S)| минимально' или   	// один из множества' если таких сегментов несколько.   	// В этом сегменте найдем цепь между двумя контактными вершинами и уложим ее   	// в любую из граней множества Γ(S)' совместив контактные вершины сегмента   	// с соответствующими вершинами грани.   	// При этом данная грань разобьется на две.   	// Уже уложенная часть графа G′ по количеству ребер и вершин увеличится'   	// а сегмент' из которого вынута цепь' исчезнет или развалится на меньшие   	// с новыми контактными вершинами' ведущими к вершинам G′.  	// В результате повторения общего шага   	// либо будет получена плоская укладка' когда множество сегментов станет пустым'   	// либо будет получено' что граф G не является планарным.  	Debug.WriteLine ("Шаг алгоритма");  	Debug.WriteLine ("paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  	Debug.WriteLine ("edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  	// Каждый сегмент S относительно уже построенного графа G′ представляет собой одно из двух:  	// ребро' оба конца которого принадлежат G′' но само оно не принадлежит G′;  	// связную компоненту графа G – G′' дополненную всеми ребрами графа G'   	// один из концов которых принадлежит связной компоненте'   	// а второй из графа G′.  	// Для каждого сегмента S найти множество Γ(S). Если существует сегмент S' для которого |Γ(S)| = 0' то граф не  	// планарный' конец.  	int minCount;  	Path path1;  	Edge edge1;  	if (Settings.EnableCudafy)  		try {  			int['] matrix;  			int[] counts;  			int[] indexes;  			lock (CudafySequencies.Semaphore) {  				CudafySequencies.SetSequencies (paths.Select (path => path.Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Edges.Select (edge => edge.Select (vertex => vertex.Id).ToArray ()).ToArray ());  				CudafySequencies.Execute ("IsFromTo");  				matrix = CudafySequencies.GetMatrix ();  			}  			lock (CudafyMatrix.Semaphore) {  				CudafyMatrix.SetMatrix (matrix);  				CudafyMatrix.ExecuteCountMinInColumn ();  				counts = CudafyMatrix.GetCounts ().ToArray ();  				minCount = CudafyMatrix.GetMinCount ();  				if (WorkerLog != null)  					WorkerLog ("min |Γ(S)| = " + minCount);  				if (minCount == 0) {  					if (WorkerLog != null)  						WorkerLog ("Существует сегмент S' для которого |Γ(S)| = 0");  					if (WorkerLog != null)  						WorkerLog ("Граф не планарен");  					Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  					Debug.WriteLine ("Graph:" + context.Builded);  					Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  					Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  					bool result = false;  					if (WorkerComplite != null)  						WorkerComplite (result);  					return result;  				}  				CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  				indexes = CudafyMatrix.GetIndexes ();  			}  			int pathIndex = counts.ToList ().IndexOf (minCount);  			for (int nextPathIndex = counts.ToList ().IndexOf (minCount' pathIndex + 1); nextPathIndex > 0; nextPathIndex = counts.ToList ().IndexOf (minCount' nextPathIndex + 1))  				if (paths [nextPathIndex].Count > paths [pathIndex].Count)  					pathIndex = nextPathIndex;  			int edgeIndex = indexes [pathIndex];  			path1 = paths [pathIndex];  			edge1 = context.Edges [edgeIndex];  		}  		catch (Exception ex) {  			if (WorkerLog != null)  				WorkerLog (ex.ToString ());  			minCount = paths.Select (path => context.Edges.Count (path.FromTo)).Min ();  			if (minCount == 0) {  				Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  				Debug.WriteLine ("Graph:" + context.Builded);  				Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  				Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  				bool result = false;  				if (WorkerComplite != null)  					WorkerComplite (result);  				return result;  			}  			int count = paths.Where (path => context.Edges.Count (path.FromTo) == minCount).Max (path => path.Count);  			path1 = paths.First (path => context.Edges.Count (path.FromTo) == minCount && path.Count == count);  			edge1 = context.Edges.First (path1.FromTo);  		}  	else {  		minCount = paths.Select (path => context.Edges.Count (path.FromTo)).Min ();  		if (minCount == 0) {  			Debug.WriteLine ("существует сегмент S' для которого |Γ(S)| = 0");  			Debug.WriteLine ("Graph:" + context.Builded);  			Debug.WriteLine ("Paths:" + string.Join (Environment.NewLine' paths.Select (path => path.ToString ())));  			Debug.WriteLine ("Edges:" + string.Join (Environment.NewLine' context.Edges.Select (edge => edge.ToString ())));  			bool result = false;  			if (WorkerComplite != null)  				WorkerComplite (result);  			Settings.EnableCudafy = enableCudafy;  			return result;  		}  		int count = paths.Where (path => context.Edges.Count (path.FromTo) == minCount).Max (path => path.Count);  		path1 = paths.First (path => context.Edges.Count (path.FromTo) == minCount && path.Count == count);  		edge1 = context.Edges.First (path1.FromTo);  	}  	// Выбираем один из сегментов с минимальным числом' вмещающих его граней.  	// Выбираем одну из подходящих граней для выбранного сегмента.  	// В данном сегменте выбираем цепь между двумя контактными вершинами и укладываем ее в выбранной грани.  	Debug.Assert (minCount > 0);  	Debug.WriteLine ("path1:" + path1);  	Debug.WriteLine ("edge1:" + edge1);  	context.Edges.AddRange (edge1.Split (path1));  	context.Builded.Add (path1);  	paths.Remove (path1);  	context.Edges.RemoveAt (context.Edges.IndexOf (edge1));  }  
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: if (Settings.EnableCudafy)  	try {  		while (paths.Any (Path.IsLong)) {  			// Находим для всех путей их перечечения с уже построенным графом  			// Разбиваем пути в найденных точках пересечения с уже построенным графом  			// Если точек пересечения не найдено' то выходим из цикла  			int['] matrix;  			int[] indexes;  			lock (CudafySequencies.Semaphore) {  				CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ());  				CudafySequencies.Execute ("CountIntersections");  				// подсчитываем число пересечений  				matrix = CudafySequencies.GetMatrix ();  			}  			lock (CudafyMatrix.Semaphore) {  				CudafyMatrix.SetMatrix (matrix);  				CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  				// находим индексы ненулевых элементов в строках  				indexes = CudafyMatrix.GetIndexes ();  			}  			Dictionary<int' int> dictionary = indexes.Select ((value' index) => new KeyValuePair<int' int> (index' value)).Where (pair => pair.Value >= 0).ToDictionary (pair => pair.Key' pair => pair.Value);  			if (!dictionary.Any ())  				break;  			Debug.Assert (dictionary.All (pair => pair.Key >= 0));  			Debug.Assert (dictionary.All (pair => pair.Value >= 0));  			Debug.Assert (dictionary.All (pair => pair.Key < paths.Count));  			Debug.Assert (dictionary.All (pair => pair.Value < context.Builded.Vertices.Count));  			var dictionary2 = new StackListQueue<KeyValuePair<Path' Vertex>> (dictionary.Select (pair => new KeyValuePair<Path' Vertex> (new Path (paths [pair.Key])' new Vertex (context.Builded.Vertices [pair.Value]))));  			var list = new StackListQueue<int> (dictionary.Select (pair => pair.Key).Distinct ());  			list.Sort ();  			Debug.Assert (dictionary2.All (pair => pair.Key.Count > 1));  			for (int i = list.Count; i-- > 0;)  				paths.RemoveAt (list [i]);  			paths.AddRangeExcept (new PathCollection (dictionary2.SelectMany (pair => pair.Key.SplitBy (pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle)).Distinct ()));  			paths.ReplaceAll (paths.Distinct ());  			paths.RemoveAll (context.Builded.Contains);  		}  	}  	catch (Exception ex) {  		if (WorkerLog != null)  			WorkerLog (ex.ToString ());  		paths.ReplaceAll (paths.SelectMany (context.Builded.Split).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  		paths.ReplaceAll (paths.Distinct ());  		paths.RemoveAll (context.Builded.Contains);  	}  	finally {  	}  else {  	Debug.WriteLine ("paths... " + paths);  	paths.ReplaceAll (new PathCollection (paths.SelectMany (context.Builded.Split)).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  	Debug.WriteLine ("paths... " + paths);  	paths.ReplaceAll (paths.Distinct ());  	Debug.WriteLine ("paths... " + paths);  	paths.RemoveAll (context.Builded.Contains);  	Debug.WriteLine ("paths... " + paths);  }  
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: try {  	while (paths.Any (Path.IsLong)) {  		// Находим для всех путей их перечечения с уже построенным графом  		// Разбиваем пути в найденных точках пересечения с уже построенным графом  		// Если точек пересечения не найдено' то выходим из цикла  		int['] matrix;  		int[] indexes;  		lock (CudafySequencies.Semaphore) {  			CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ());  			CudafySequencies.Execute ("CountIntersections");  			// подсчитываем число пересечений  			matrix = CudafySequencies.GetMatrix ();  		}  		lock (CudafyMatrix.Semaphore) {  			CudafyMatrix.SetMatrix (matrix);  			CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  			// находим индексы ненулевых элементов в строках  			indexes = CudafyMatrix.GetIndexes ();  		}  		Dictionary<int' int> dictionary = indexes.Select ((value' index) => new KeyValuePair<int' int> (index' value)).Where (pair => pair.Value >= 0).ToDictionary (pair => pair.Key' pair => pair.Value);  		if (!dictionary.Any ())  			break;  		Debug.Assert (dictionary.All (pair => pair.Key >= 0));  		Debug.Assert (dictionary.All (pair => pair.Value >= 0));  		Debug.Assert (dictionary.All (pair => pair.Key < paths.Count));  		Debug.Assert (dictionary.All (pair => pair.Value < context.Builded.Vertices.Count));  		var dictionary2 = new StackListQueue<KeyValuePair<Path' Vertex>> (dictionary.Select (pair => new KeyValuePair<Path' Vertex> (new Path (paths [pair.Key])' new Vertex (context.Builded.Vertices [pair.Value]))));  		var list = new StackListQueue<int> (dictionary.Select (pair => pair.Key).Distinct ());  		list.Sort ();  		Debug.Assert (dictionary2.All (pair => pair.Key.Count > 1));  		for (int i = list.Count; i-- > 0;)  			paths.RemoveAt (list [i]);  		paths.AddRangeExcept (new PathCollection (dictionary2.SelectMany (pair => pair.Key.SplitBy (pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle)).Distinct ()));  		paths.ReplaceAll (paths.Distinct ());  		paths.RemoveAll (context.Builded.Contains);  	}  }  catch (Exception ex) {  	if (WorkerLog != null)  		WorkerLog (ex.ToString ());  	paths.ReplaceAll (paths.SelectMany (context.Builded.Split).Where (Path.IsNoVertix).Where (Path.IsNoCircle));  	paths.ReplaceAll (paths.Distinct ());  	paths.RemoveAll (context.Builded.Contains);  }  finally {  }  
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: while (paths.Any (Path.IsLong)) {  	// Находим для всех путей их перечечения с уже построенным графом  	// Разбиваем пути в найденных точках пересечения с уже построенным графом  	// Если точек пересечения не найдено' то выходим из цикла  	int['] matrix;  	int[] indexes;  	lock (CudafySequencies.Semaphore) {  		CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ());  		CudafySequencies.Execute ("CountIntersections");  		// подсчитываем число пересечений  		matrix = CudafySequencies.GetMatrix ();  	}  	lock (CudafyMatrix.Semaphore) {  		CudafyMatrix.SetMatrix (matrix);  		CudafyMatrix.ExecuteRepeatZeroIndexOfNonZero ();  		// находим индексы ненулевых элементов в строках  		indexes = CudafyMatrix.GetIndexes ();  	}  	Dictionary<int' int> dictionary = indexes.Select ((value' index) => new KeyValuePair<int' int> (index' value)).Where (pair => pair.Value >= 0).ToDictionary (pair => pair.Key' pair => pair.Value);  	if (!dictionary.Any ())  		break;  	Debug.Assert (dictionary.All (pair => pair.Key >= 0));  	Debug.Assert (dictionary.All (pair => pair.Value >= 0));  	Debug.Assert (dictionary.All (pair => pair.Key < paths.Count));  	Debug.Assert (dictionary.All (pair => pair.Value < context.Builded.Vertices.Count));  	var dictionary2 = new StackListQueue<KeyValuePair<Path' Vertex>> (dictionary.Select (pair => new KeyValuePair<Path' Vertex> (new Path (paths [pair.Key])' new Vertex (context.Builded.Vertices [pair.Value]))));  	var list = new StackListQueue<int> (dictionary.Select (pair => pair.Key).Distinct ());  	list.Sort ();  	Debug.Assert (dictionary2.All (pair => pair.Key.Count > 1));  	for (int i = list.Count; i-- > 0;)  		paths.RemoveAt (list [i]);  	paths.AddRangeExcept (new PathCollection (dictionary2.SelectMany (pair => pair.Key.SplitBy (pair.Value).Where (Path.IsNoVertix).Where (Path.IsNoCircle)).Distinct ()));  	paths.ReplaceAll (paths.Distinct ());  	paths.RemoveAll (context.Builded.Contains);  }  
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: lock (CudafySequencies.Semaphore) {  	CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ());  	CudafySequencies.Execute ("CountIntersections");  	// подсчитываем число пересечений  	matrix = CudafySequencies.GetMatrix ();  }  
Magic Number,PlanarGraph.Algorithm,GammaAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\GammaAlgorithm.cs,IsPlanar,The following statement contains a magic number: CudafySequencies.SetSequencies (paths.Select (path => path.GetRange (1' path.Count - 2).Select (vertex => vertex.Id).ToArray ()).ToArray ()' context.Builded.Vertices.Select (vertex => new StackListQueue<int> (vertex.Id).ToArray ()).ToArray ());  
Magic Number,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The following statement contains a magic number: foreach (Graph subGraph in stackListQueue) {  	if (WorkerLog != null)  		WorkerLog ("Проверка связанной компоненты " + subGraph);  	// листья представляют собой дерево и нарисовать его плоскую укладку тривиально.  	subGraph.RemoveAllTrees ();  	if (subGraph.Vertices.Count () < 2)  		continue;  	Dictionary<int' PathDictionary> cachedSubGraphPaths = Graph.GetSubgraphPaths (subGraph.Vertices' cachedAllGraphPaths);  	if (WorkerLog != null)  		WorkerLog ("Находим ВСЕ циклы в графе длины не менее 2 и не более размера графа");  	var circles = new StackListQueue<Circle> (cachedSubGraphPaths.Where (pair => pair.Key > 2).SelectMany (pair => subGraph.Vertices.SelectMany (vertex => pair.Value.Where (pair2 => pair2.Key.Key.Equals (pair2.Key.Value)).SelectMany (pair2 => pair2.Value.Select (path => new Circle (path.GetRange (0' path.Count - 1)))))));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//if (WorkerLog != null) WorkerLog("Находим все циклы в графе");  	//IEnumerable<Circle> circles = subGraph.GetAllGraphCircles(cachedSubGraphPaths);  	if (!circles.Any ())  		continue;  	// граф — дерево и нарисовать его плоскую укладку тривиально.  	if (WorkerLog != null)  		WorkerLog ("Удаляем дубликаты");  	circles = new StackListQueue<Circle> (circles.Distinct (CircleComparer));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//Debug.Assert(subGraph.Vertices.Count() ==  	//             circles.SelectMany(circle => circle.ToList()).Distinct().Count());  	//     С технической точки зрения проверять' что цикл является простым и тау-циклом нет необходимости' поскольку не  	//     приведён алгорим позволяющий проверить ' что цикл является тау-циклом за количество операций меньшее чем приведение  	//     матрицы к каноническому виду. Поэтому если действительно надо сделать хорошую реализацию' то либо надо закоментировать  	//     проверки циклов на простоту и что они являются тау-циклами с помощью приведения к каноническому виду ' либо  	//     предложить алгоритм быстрой проверки' что цикл является тау-циклом  	if (WorkerLog != null)  		WorkerLog ("Ограничиваем простыми циклами");  	circles.RemoveAll (Circle.IsNotSimple);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	if (WorkerLog != null)  		WorkerLog ("Удаляем элементарные циклы и петли");  	circles.RemoveAll (circle => circle.Count < 3);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//if (WorkerLog != null) WorkerLog("Ограничиваем тау-циклами");  	//circles.RemoveAll(circle => !circle.IsTau());  	//if (WorkerLog != null) WorkerLog(string.Format("Количество циклов {0}"' circles.Count()));  	Debug.WriteLine (string.Join (Environment.NewLine' circles.Select (circle => circle.ToString ())));  	if (WorkerLog != null)  		WorkerLog ("Строим матрицу над GF2 из найденных циклов");  	var booleanMatrix = new BooleanMatrix (circles.Select (subGraph.GetVector));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  	foreach (var r in booleanMatrix)  		if (r.Count () < booleanMatrix.Length)  			r.Add (Enumerable.Repeat (false' booleanMatrix.Length - r.Count ()));  	Debug.WriteLine ("matrix:");  	Debug.WriteLine (booleanMatrix);  	// отыскание минимума некоторого функционала на множестве базисов подпространства квазициклов  	// Шаг 1. Приведение матрицы к каноническому виду  	if (WorkerLog != null)  		WorkerLog ("Приводим матрицу к каноническому виду");  	if (Settings.EnableCudafy)  		lock (CudafyMatrix.Semaphore) {  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для приведения матрицы к каноническому виду  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				// Использование алгоритма Гаусса-Жордана  				// Для приведения матрицы к каноническому виду  				CudafyMatrix.ExecuteGaussJordan ();  				// Удаляем нулевые строки  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				booleanMatrix = new BooleanMatrix (CudafyMatrix.GetIndexes ().Select ((first' row) => new KeyValuePair<int' int> (row' first)).Where (pair => pair.Value >= 0).Select (pair => arrayOfArray [pair.Key].Select (value => value != 0)));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				/////////////////////////////////////////////////////  				// Приведение матрицы к каноническому виду обычным способом  				booleanMatrix.GaussJordan ();  				booleanMatrix.RemoveAll (BooleanVector.IsZero);  			}  			if (WorkerLog != null)  				WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  			// Матрица имеет канонический вид  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  			Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).Distinct ().Count () == booleanMatrix.Count);  			Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).SelectMany (index => booleanMatrix.Where (vector => vector.Count > index && vector [index])).Count () == booleanMatrix.Count);  			// Поскольку в колонках содержится по одной единице' то к строке можно прибавить только одну другую строку  			int n = booleanMatrix.Count;  			int macLane;  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для расчёта целевой функции симплекс-метода  				Debug.Assert (CudafyMatrix.GetMatrix () != null);  				CudafyMatrix.SetIndexes (Enumerable.Range (0' n).ToArray ());  				CudafyMatrix.ExecuteMacLane ();  				macLane = CudafyMatrix.GetMacLane ();  				#if DEBUG  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				Debug.WriteLine (string.Join (Environment.NewLine' arrayOfArray.Select (v => string.Join ("'"' v.Select (i => i.ToString ())))));  				#endif  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				///////////////////////////////////////////////////  				// Вычисление целевой функции обычным методом  				macLane = booleanMatrix.MacLane;  			}  			Debug.WriteLine ("macLane = " + macLane);  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  			int k = Math.Min (2' Math.Max (1' n));  			k = Math.Min (n' k);  			if (WorkerLog != null)  				WorkerLog ("Начало симплекс-метода");  			if (WorkerLog != null)  				WorkerLog ("Текущий macLane = " + macLane);  			for (bool updated = true; k <= n && updated && macLane > 0;) {  				Debug.Assert (booleanMatrix.Length == subGraph.Count ());  				List<int> values = Enumerable.Range (0' n).ToList ();  				updated = false;  				List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  				while (macLane > 0) {  					if (WorkerLog != null)  						WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  					List<int> indexes = values.ToList ();  					foreach (int index in indexOfIndex)  						indexes [index] = n - 1;  					while (macLane > 0) {  						Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  						// Проверяем' что матрица образованная indexes является обратимой  						var detMatrix = new BooleanMatrix (indexes);  						if (detMatrix.Det ()) {  							BooleanMatrix matrix2;  							int macLane2 = 0;  							try {  								/////////////////////////////////////////////////////  								// Использование параллельных вычислений CUDA  								// для расчёта целевой функции симплекс-метода  								Debug.Assert (CudafyMatrix.GetMatrix () != null);  								CudafyMatrix.SetIndexes (indexes.ToArray ());  								CudafyMatrix.ExecuteMacLane ();  								macLane2 = CudafyMatrix.GetMacLane ();  								#if DEBUG  								CudafyMatrix.ExecuteUpdate ();  								int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  								matrix2 = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  								CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (v => v.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  								#endif  							}  							catch (Exception ex) {  								if (WorkerLog != null)  									WorkerLog (ex.ToString ());  								///////////////////////////////////////////////////  								// Вычисление целевой функции обычным методом  								Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  								matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  								macLane2 = matrix2.MacLane;  							}  							finally {  								Debug.WriteLine ("macLane = " + macLane2);  							}  							if (macLane > macLane2) {  								if (WorkerLog != null)  									WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  								Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  								values = indexes.ToList ();  								macLane = macLane2;  								updated = true;  								Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  								Debug.WriteLine ("matrix2:");  								Debug.WriteLine (matrix2);  							}  							if (macLane == 0)  								break;  						}  						else {  							Debug.WriteLine ("Матрица не обратима");  						}  						int i = k;  						while (i-- > 0)  							if (indexes [indexOfIndex [i]]-- > 0)  								break;  							else  								indexes [indexOfIndex [i]] = n - 1;  						if (i < 0)  							break;  					}  					int count = k;  					while (count-- > 0)  						if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  							break;  						else  							indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  					if (count < 0)  						break;  				}  				if (WorkerLog != null)  					WorkerLog ("Смена начальной точки симплекс-метода");  				try {  					/////////////////////////////////////////////////////  					// Использование параллельных вычислений CUDA  					// для смены базиса симплекс-метода  					Debug.Assert (CudafyMatrix.GetMatrix () != null);  					CudafyMatrix.SetIndexes (values.ToArray ());  					CudafyMatrix.ExecuteUpdate ();  					#if DEBUG  					int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  					booleanMatrix = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  					#endif  				}  				catch (Exception ex) {  					if (WorkerLog != null)  						WorkerLog (ex.ToString ());  					///////////////////////////////////////////////////  					// Cмена базиса симплекс-метода обычным методом  					Dictionary<int' int> dictionary = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  					booleanMatrix = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  				}  				Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  				Debug.WriteLine ("matrix:");  				Debug.WriteLine (booleanMatrix);  			}  			if (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  				if (WorkerLog != null)  					WorkerLog ("Граф не планарен");  				bool result = false;  				if (WorkerComplite != null)  					WorkerComplite (result);  				return result;  			}  		}  	else {  		// Приведение матрицы к каноническому виду обычным способом  		booleanMatrix.GaussJordan ();  		booleanMatrix.RemoveAll (BooleanVector.IsZero);  		if (WorkerLog != null)  			WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  		int macLane = booleanMatrix.MacLane;  		Debug.WriteLine ("macLane = " + macLane);  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  		int n = booleanMatrix.Count;  		int k = Math.Min (2' Math.Max (1' n));  		k = Math.Min (n' k);  		if (WorkerLog != null)  			WorkerLog ("Начало симплекс-метода");  		if (WorkerLog != null)  			WorkerLog ("Текущий macLane = " + macLane);  		for (bool updated = true; k <= n && updated && macLane > 0;) {  			Debug.Assert (booleanMatrix.Length == subGraph.Count ());  			List<int> values = Enumerable.Range (0' n).ToList ();  			updated = false;  			List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  			while (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				List<int> indexes = values.ToList ();  				foreach (int index in indexOfIndex)  					indexes [index] = n - 1;  				while (macLane > 0) {  					Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					// Проверяем' что матрица образованная indexes является обратимой  					var detMatrix = new BooleanMatrix (indexes);  					if (detMatrix.Det ()) {  						int macLane2 = 0;  						///////////////////////////////////////////////////  						// Вычисление целевой функции обычным методом  						Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  						var matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  						macLane2 = matrix2.MacLane;  						Debug.WriteLine ("macLane = " + macLane2);  						if (macLane > macLane2) {  							if (WorkerLog != null)  								WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  							Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  							values = indexes.ToList ();  							macLane = macLane2;  							updated = true;  							Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  							Debug.WriteLine ("matrix2:");  							Debug.WriteLine (matrix2);  						}  						if (macLane == 0)  							break;  					}  					else {  						Debug.WriteLine ("Матрица не обратима");  					}  					int i = k;  					while (i-- > 0)  						if (indexes [indexOfIndex [i]]-- > 0)  							break;  						else  							indexes [indexOfIndex [i]] = n - 1;  					if (i < 0)  						break;  				}  				int count = k;  				while (count-- > 0)  					if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  						break;  					else  						indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  				if (count < 0)  					break;  			}  			if (WorkerLog != null)  				WorkerLog ("Смена начальной точки симплекс-метода");  			///////////////////////////////////////////////////  			// Cмена базиса симплекс-метода обычным методом  			Dictionary<int' int> dictionary2 = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  			booleanMatrix = new BooleanMatrix (dictionary2.Select (pair1 => dictionary2.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  			Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  		}  		if (macLane > 0) {  			if (WorkerLog != null)  				WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  			if (WorkerLog != null)  				WorkerLog ("Граф не планарен");  			bool result = false;  			if (WorkerComplite != null)  				WorkerComplite (result);  			return result;  		}  	}  	if (WorkerLog != null)  		WorkerLog ("Конец проверки связанной компоненты");  }  
Magic Number,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The following statement contains a magic number: foreach (Graph subGraph in stackListQueue) {  	if (WorkerLog != null)  		WorkerLog ("Проверка связанной компоненты " + subGraph);  	// листья представляют собой дерево и нарисовать его плоскую укладку тривиально.  	subGraph.RemoveAllTrees ();  	if (subGraph.Vertices.Count () < 2)  		continue;  	Dictionary<int' PathDictionary> cachedSubGraphPaths = Graph.GetSubgraphPaths (subGraph.Vertices' cachedAllGraphPaths);  	if (WorkerLog != null)  		WorkerLog ("Находим ВСЕ циклы в графе длины не менее 2 и не более размера графа");  	var circles = new StackListQueue<Circle> (cachedSubGraphPaths.Where (pair => pair.Key > 2).SelectMany (pair => subGraph.Vertices.SelectMany (vertex => pair.Value.Where (pair2 => pair2.Key.Key.Equals (pair2.Key.Value)).SelectMany (pair2 => pair2.Value.Select (path => new Circle (path.GetRange (0' path.Count - 1)))))));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//if (WorkerLog != null) WorkerLog("Находим все циклы в графе");  	//IEnumerable<Circle> circles = subGraph.GetAllGraphCircles(cachedSubGraphPaths);  	if (!circles.Any ())  		continue;  	// граф — дерево и нарисовать его плоскую укладку тривиально.  	if (WorkerLog != null)  		WorkerLog ("Удаляем дубликаты");  	circles = new StackListQueue<Circle> (circles.Distinct (CircleComparer));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//Debug.Assert(subGraph.Vertices.Count() ==  	//             circles.SelectMany(circle => circle.ToList()).Distinct().Count());  	//     С технической точки зрения проверять' что цикл является простым и тау-циклом нет необходимости' поскольку не  	//     приведён алгорим позволяющий проверить ' что цикл является тау-циклом за количество операций меньшее чем приведение  	//     матрицы к каноническому виду. Поэтому если действительно надо сделать хорошую реализацию' то либо надо закоментировать  	//     проверки циклов на простоту и что они являются тау-циклами с помощью приведения к каноническому виду ' либо  	//     предложить алгоритм быстрой проверки' что цикл является тау-циклом  	if (WorkerLog != null)  		WorkerLog ("Ограничиваем простыми циклами");  	circles.RemoveAll (Circle.IsNotSimple);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	if (WorkerLog != null)  		WorkerLog ("Удаляем элементарные циклы и петли");  	circles.RemoveAll (circle => circle.Count < 3);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//if (WorkerLog != null) WorkerLog("Ограничиваем тау-циклами");  	//circles.RemoveAll(circle => !circle.IsTau());  	//if (WorkerLog != null) WorkerLog(string.Format("Количество циклов {0}"' circles.Count()));  	Debug.WriteLine (string.Join (Environment.NewLine' circles.Select (circle => circle.ToString ())));  	if (WorkerLog != null)  		WorkerLog ("Строим матрицу над GF2 из найденных циклов");  	var booleanMatrix = new BooleanMatrix (circles.Select (subGraph.GetVector));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  	foreach (var r in booleanMatrix)  		if (r.Count () < booleanMatrix.Length)  			r.Add (Enumerable.Repeat (false' booleanMatrix.Length - r.Count ()));  	Debug.WriteLine ("matrix:");  	Debug.WriteLine (booleanMatrix);  	// отыскание минимума некоторого функционала на множестве базисов подпространства квазициклов  	// Шаг 1. Приведение матрицы к каноническому виду  	if (WorkerLog != null)  		WorkerLog ("Приводим матрицу к каноническому виду");  	if (Settings.EnableCudafy)  		lock (CudafyMatrix.Semaphore) {  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для приведения матрицы к каноническому виду  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				// Использование алгоритма Гаусса-Жордана  				// Для приведения матрицы к каноническому виду  				CudafyMatrix.ExecuteGaussJordan ();  				// Удаляем нулевые строки  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				booleanMatrix = new BooleanMatrix (CudafyMatrix.GetIndexes ().Select ((first' row) => new KeyValuePair<int' int> (row' first)).Where (pair => pair.Value >= 0).Select (pair => arrayOfArray [pair.Key].Select (value => value != 0)));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				/////////////////////////////////////////////////////  				// Приведение матрицы к каноническому виду обычным способом  				booleanMatrix.GaussJordan ();  				booleanMatrix.RemoveAll (BooleanVector.IsZero);  			}  			if (WorkerLog != null)  				WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  			// Матрица имеет канонический вид  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  			Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).Distinct ().Count () == booleanMatrix.Count);  			Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).SelectMany (index => booleanMatrix.Where (vector => vector.Count > index && vector [index])).Count () == booleanMatrix.Count);  			// Поскольку в колонках содержится по одной единице' то к строке можно прибавить только одну другую строку  			int n = booleanMatrix.Count;  			int macLane;  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для расчёта целевой функции симплекс-метода  				Debug.Assert (CudafyMatrix.GetMatrix () != null);  				CudafyMatrix.SetIndexes (Enumerable.Range (0' n).ToArray ());  				CudafyMatrix.ExecuteMacLane ();  				macLane = CudafyMatrix.GetMacLane ();  				#if DEBUG  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				Debug.WriteLine (string.Join (Environment.NewLine' arrayOfArray.Select (v => string.Join ("'"' v.Select (i => i.ToString ())))));  				#endif  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				///////////////////////////////////////////////////  				// Вычисление целевой функции обычным методом  				macLane = booleanMatrix.MacLane;  			}  			Debug.WriteLine ("macLane = " + macLane);  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  			int k = Math.Min (2' Math.Max (1' n));  			k = Math.Min (n' k);  			if (WorkerLog != null)  				WorkerLog ("Начало симплекс-метода");  			if (WorkerLog != null)  				WorkerLog ("Текущий macLane = " + macLane);  			for (bool updated = true; k <= n && updated && macLane > 0;) {  				Debug.Assert (booleanMatrix.Length == subGraph.Count ());  				List<int> values = Enumerable.Range (0' n).ToList ();  				updated = false;  				List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  				while (macLane > 0) {  					if (WorkerLog != null)  						WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  					List<int> indexes = values.ToList ();  					foreach (int index in indexOfIndex)  						indexes [index] = n - 1;  					while (macLane > 0) {  						Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  						// Проверяем' что матрица образованная indexes является обратимой  						var detMatrix = new BooleanMatrix (indexes);  						if (detMatrix.Det ()) {  							BooleanMatrix matrix2;  							int macLane2 = 0;  							try {  								/////////////////////////////////////////////////////  								// Использование параллельных вычислений CUDA  								// для расчёта целевой функции симплекс-метода  								Debug.Assert (CudafyMatrix.GetMatrix () != null);  								CudafyMatrix.SetIndexes (indexes.ToArray ());  								CudafyMatrix.ExecuteMacLane ();  								macLane2 = CudafyMatrix.GetMacLane ();  								#if DEBUG  								CudafyMatrix.ExecuteUpdate ();  								int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  								matrix2 = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  								CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (v => v.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  								#endif  							}  							catch (Exception ex) {  								if (WorkerLog != null)  									WorkerLog (ex.ToString ());  								///////////////////////////////////////////////////  								// Вычисление целевой функции обычным методом  								Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  								matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  								macLane2 = matrix2.MacLane;  							}  							finally {  								Debug.WriteLine ("macLane = " + macLane2);  							}  							if (macLane > macLane2) {  								if (WorkerLog != null)  									WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  								Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  								values = indexes.ToList ();  								macLane = macLane2;  								updated = true;  								Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  								Debug.WriteLine ("matrix2:");  								Debug.WriteLine (matrix2);  							}  							if (macLane == 0)  								break;  						}  						else {  							Debug.WriteLine ("Матрица не обратима");  						}  						int i = k;  						while (i-- > 0)  							if (indexes [indexOfIndex [i]]-- > 0)  								break;  							else  								indexes [indexOfIndex [i]] = n - 1;  						if (i < 0)  							break;  					}  					int count = k;  					while (count-- > 0)  						if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  							break;  						else  							indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  					if (count < 0)  						break;  				}  				if (WorkerLog != null)  					WorkerLog ("Смена начальной точки симплекс-метода");  				try {  					/////////////////////////////////////////////////////  					// Использование параллельных вычислений CUDA  					// для смены базиса симплекс-метода  					Debug.Assert (CudafyMatrix.GetMatrix () != null);  					CudafyMatrix.SetIndexes (values.ToArray ());  					CudafyMatrix.ExecuteUpdate ();  					#if DEBUG  					int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  					booleanMatrix = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  					#endif  				}  				catch (Exception ex) {  					if (WorkerLog != null)  						WorkerLog (ex.ToString ());  					///////////////////////////////////////////////////  					// Cмена базиса симплекс-метода обычным методом  					Dictionary<int' int> dictionary = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  					booleanMatrix = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  				}  				Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  				Debug.WriteLine ("matrix:");  				Debug.WriteLine (booleanMatrix);  			}  			if (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  				if (WorkerLog != null)  					WorkerLog ("Граф не планарен");  				bool result = false;  				if (WorkerComplite != null)  					WorkerComplite (result);  				return result;  			}  		}  	else {  		// Приведение матрицы к каноническому виду обычным способом  		booleanMatrix.GaussJordan ();  		booleanMatrix.RemoveAll (BooleanVector.IsZero);  		if (WorkerLog != null)  			WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  		int macLane = booleanMatrix.MacLane;  		Debug.WriteLine ("macLane = " + macLane);  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  		int n = booleanMatrix.Count;  		int k = Math.Min (2' Math.Max (1' n));  		k = Math.Min (n' k);  		if (WorkerLog != null)  			WorkerLog ("Начало симплекс-метода");  		if (WorkerLog != null)  			WorkerLog ("Текущий macLane = " + macLane);  		for (bool updated = true; k <= n && updated && macLane > 0;) {  			Debug.Assert (booleanMatrix.Length == subGraph.Count ());  			List<int> values = Enumerable.Range (0' n).ToList ();  			updated = false;  			List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  			while (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				List<int> indexes = values.ToList ();  				foreach (int index in indexOfIndex)  					indexes [index] = n - 1;  				while (macLane > 0) {  					Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					// Проверяем' что матрица образованная indexes является обратимой  					var detMatrix = new BooleanMatrix (indexes);  					if (detMatrix.Det ()) {  						int macLane2 = 0;  						///////////////////////////////////////////////////  						// Вычисление целевой функции обычным методом  						Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  						var matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  						macLane2 = matrix2.MacLane;  						Debug.WriteLine ("macLane = " + macLane2);  						if (macLane > macLane2) {  							if (WorkerLog != null)  								WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  							Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  							values = indexes.ToList ();  							macLane = macLane2;  							updated = true;  							Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  							Debug.WriteLine ("matrix2:");  							Debug.WriteLine (matrix2);  						}  						if (macLane == 0)  							break;  					}  					else {  						Debug.WriteLine ("Матрица не обратима");  					}  					int i = k;  					while (i-- > 0)  						if (indexes [indexOfIndex [i]]-- > 0)  							break;  						else  							indexes [indexOfIndex [i]] = n - 1;  					if (i < 0)  						break;  				}  				int count = k;  				while (count-- > 0)  					if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  						break;  					else  						indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  				if (count < 0)  					break;  			}  			if (WorkerLog != null)  				WorkerLog ("Смена начальной точки симплекс-метода");  			///////////////////////////////////////////////////  			// Cмена базиса симплекс-метода обычным методом  			Dictionary<int' int> dictionary2 = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  			booleanMatrix = new BooleanMatrix (dictionary2.Select (pair1 => dictionary2.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  			Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  		}  		if (macLane > 0) {  			if (WorkerLog != null)  				WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  			if (WorkerLog != null)  				WorkerLog ("Граф не планарен");  			bool result = false;  			if (WorkerComplite != null)  				WorkerComplite (result);  			return result;  		}  	}  	if (WorkerLog != null)  		WorkerLog ("Конец проверки связанной компоненты");  }  
Magic Number,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The following statement contains a magic number: foreach (Graph subGraph in stackListQueue) {  	if (WorkerLog != null)  		WorkerLog ("Проверка связанной компоненты " + subGraph);  	// листья представляют собой дерево и нарисовать его плоскую укладку тривиально.  	subGraph.RemoveAllTrees ();  	if (subGraph.Vertices.Count () < 2)  		continue;  	Dictionary<int' PathDictionary> cachedSubGraphPaths = Graph.GetSubgraphPaths (subGraph.Vertices' cachedAllGraphPaths);  	if (WorkerLog != null)  		WorkerLog ("Находим ВСЕ циклы в графе длины не менее 2 и не более размера графа");  	var circles = new StackListQueue<Circle> (cachedSubGraphPaths.Where (pair => pair.Key > 2).SelectMany (pair => subGraph.Vertices.SelectMany (vertex => pair.Value.Where (pair2 => pair2.Key.Key.Equals (pair2.Key.Value)).SelectMany (pair2 => pair2.Value.Select (path => new Circle (path.GetRange (0' path.Count - 1)))))));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//if (WorkerLog != null) WorkerLog("Находим все циклы в графе");  	//IEnumerable<Circle> circles = subGraph.GetAllGraphCircles(cachedSubGraphPaths);  	if (!circles.Any ())  		continue;  	// граф — дерево и нарисовать его плоскую укладку тривиально.  	if (WorkerLog != null)  		WorkerLog ("Удаляем дубликаты");  	circles = new StackListQueue<Circle> (circles.Distinct (CircleComparer));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//Debug.Assert(subGraph.Vertices.Count() ==  	//             circles.SelectMany(circle => circle.ToList()).Distinct().Count());  	//     С технической точки зрения проверять' что цикл является простым и тау-циклом нет необходимости' поскольку не  	//     приведён алгорим позволяющий проверить ' что цикл является тау-циклом за количество операций меньшее чем приведение  	//     матрицы к каноническому виду. Поэтому если действительно надо сделать хорошую реализацию' то либо надо закоментировать  	//     проверки циклов на простоту и что они являются тау-циклами с помощью приведения к каноническому виду ' либо  	//     предложить алгоритм быстрой проверки' что цикл является тау-циклом  	if (WorkerLog != null)  		WorkerLog ("Ограничиваем простыми циклами");  	circles.RemoveAll (Circle.IsNotSimple);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	if (WorkerLog != null)  		WorkerLog ("Удаляем элементарные циклы и петли");  	circles.RemoveAll (circle => circle.Count < 3);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//if (WorkerLog != null) WorkerLog("Ограничиваем тау-циклами");  	//circles.RemoveAll(circle => !circle.IsTau());  	//if (WorkerLog != null) WorkerLog(string.Format("Количество циклов {0}"' circles.Count()));  	Debug.WriteLine (string.Join (Environment.NewLine' circles.Select (circle => circle.ToString ())));  	if (WorkerLog != null)  		WorkerLog ("Строим матрицу над GF2 из найденных циклов");  	var booleanMatrix = new BooleanMatrix (circles.Select (subGraph.GetVector));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  	foreach (var r in booleanMatrix)  		if (r.Count () < booleanMatrix.Length)  			r.Add (Enumerable.Repeat (false' booleanMatrix.Length - r.Count ()));  	Debug.WriteLine ("matrix:");  	Debug.WriteLine (booleanMatrix);  	// отыскание минимума некоторого функционала на множестве базисов подпространства квазициклов  	// Шаг 1. Приведение матрицы к каноническому виду  	if (WorkerLog != null)  		WorkerLog ("Приводим матрицу к каноническому виду");  	if (Settings.EnableCudafy)  		lock (CudafyMatrix.Semaphore) {  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для приведения матрицы к каноническому виду  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				// Использование алгоритма Гаусса-Жордана  				// Для приведения матрицы к каноническому виду  				CudafyMatrix.ExecuteGaussJordan ();  				// Удаляем нулевые строки  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				booleanMatrix = new BooleanMatrix (CudafyMatrix.GetIndexes ().Select ((first' row) => new KeyValuePair<int' int> (row' first)).Where (pair => pair.Value >= 0).Select (pair => arrayOfArray [pair.Key].Select (value => value != 0)));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				/////////////////////////////////////////////////////  				// Приведение матрицы к каноническому виду обычным способом  				booleanMatrix.GaussJordan ();  				booleanMatrix.RemoveAll (BooleanVector.IsZero);  			}  			if (WorkerLog != null)  				WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  			// Матрица имеет канонический вид  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  			Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).Distinct ().Count () == booleanMatrix.Count);  			Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).SelectMany (index => booleanMatrix.Where (vector => vector.Count > index && vector [index])).Count () == booleanMatrix.Count);  			// Поскольку в колонках содержится по одной единице' то к строке можно прибавить только одну другую строку  			int n = booleanMatrix.Count;  			int macLane;  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для расчёта целевой функции симплекс-метода  				Debug.Assert (CudafyMatrix.GetMatrix () != null);  				CudafyMatrix.SetIndexes (Enumerable.Range (0' n).ToArray ());  				CudafyMatrix.ExecuteMacLane ();  				macLane = CudafyMatrix.GetMacLane ();  				#if DEBUG  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				Debug.WriteLine (string.Join (Environment.NewLine' arrayOfArray.Select (v => string.Join ("'"' v.Select (i => i.ToString ())))));  				#endif  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				///////////////////////////////////////////////////  				// Вычисление целевой функции обычным методом  				macLane = booleanMatrix.MacLane;  			}  			Debug.WriteLine ("macLane = " + macLane);  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  			int k = Math.Min (2' Math.Max (1' n));  			k = Math.Min (n' k);  			if (WorkerLog != null)  				WorkerLog ("Начало симплекс-метода");  			if (WorkerLog != null)  				WorkerLog ("Текущий macLane = " + macLane);  			for (bool updated = true; k <= n && updated && macLane > 0;) {  				Debug.Assert (booleanMatrix.Length == subGraph.Count ());  				List<int> values = Enumerable.Range (0' n).ToList ();  				updated = false;  				List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  				while (macLane > 0) {  					if (WorkerLog != null)  						WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  					List<int> indexes = values.ToList ();  					foreach (int index in indexOfIndex)  						indexes [index] = n - 1;  					while (macLane > 0) {  						Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  						// Проверяем' что матрица образованная indexes является обратимой  						var detMatrix = new BooleanMatrix (indexes);  						if (detMatrix.Det ()) {  							BooleanMatrix matrix2;  							int macLane2 = 0;  							try {  								/////////////////////////////////////////////////////  								// Использование параллельных вычислений CUDA  								// для расчёта целевой функции симплекс-метода  								Debug.Assert (CudafyMatrix.GetMatrix () != null);  								CudafyMatrix.SetIndexes (indexes.ToArray ());  								CudafyMatrix.ExecuteMacLane ();  								macLane2 = CudafyMatrix.GetMacLane ();  								#if DEBUG  								CudafyMatrix.ExecuteUpdate ();  								int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  								matrix2 = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  								CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (v => v.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  								#endif  							}  							catch (Exception ex) {  								if (WorkerLog != null)  									WorkerLog (ex.ToString ());  								///////////////////////////////////////////////////  								// Вычисление целевой функции обычным методом  								Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  								matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  								macLane2 = matrix2.MacLane;  							}  							finally {  								Debug.WriteLine ("macLane = " + macLane2);  							}  							if (macLane > macLane2) {  								if (WorkerLog != null)  									WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  								Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  								values = indexes.ToList ();  								macLane = macLane2;  								updated = true;  								Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  								Debug.WriteLine ("matrix2:");  								Debug.WriteLine (matrix2);  							}  							if (macLane == 0)  								break;  						}  						else {  							Debug.WriteLine ("Матрица не обратима");  						}  						int i = k;  						while (i-- > 0)  							if (indexes [indexOfIndex [i]]-- > 0)  								break;  							else  								indexes [indexOfIndex [i]] = n - 1;  						if (i < 0)  							break;  					}  					int count = k;  					while (count-- > 0)  						if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  							break;  						else  							indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  					if (count < 0)  						break;  				}  				if (WorkerLog != null)  					WorkerLog ("Смена начальной точки симплекс-метода");  				try {  					/////////////////////////////////////////////////////  					// Использование параллельных вычислений CUDA  					// для смены базиса симплекс-метода  					Debug.Assert (CudafyMatrix.GetMatrix () != null);  					CudafyMatrix.SetIndexes (values.ToArray ());  					CudafyMatrix.ExecuteUpdate ();  					#if DEBUG  					int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  					booleanMatrix = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  					#endif  				}  				catch (Exception ex) {  					if (WorkerLog != null)  						WorkerLog (ex.ToString ());  					///////////////////////////////////////////////////  					// Cмена базиса симплекс-метода обычным методом  					Dictionary<int' int> dictionary = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  					booleanMatrix = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  				}  				Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  				Debug.WriteLine ("matrix:");  				Debug.WriteLine (booleanMatrix);  			}  			if (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  				if (WorkerLog != null)  					WorkerLog ("Граф не планарен");  				bool result = false;  				if (WorkerComplite != null)  					WorkerComplite (result);  				return result;  			}  		}  	else {  		// Приведение матрицы к каноническому виду обычным способом  		booleanMatrix.GaussJordan ();  		booleanMatrix.RemoveAll (BooleanVector.IsZero);  		if (WorkerLog != null)  			WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  		int macLane = booleanMatrix.MacLane;  		Debug.WriteLine ("macLane = " + macLane);  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  		int n = booleanMatrix.Count;  		int k = Math.Min (2' Math.Max (1' n));  		k = Math.Min (n' k);  		if (WorkerLog != null)  			WorkerLog ("Начало симплекс-метода");  		if (WorkerLog != null)  			WorkerLog ("Текущий macLane = " + macLane);  		for (bool updated = true; k <= n && updated && macLane > 0;) {  			Debug.Assert (booleanMatrix.Length == subGraph.Count ());  			List<int> values = Enumerable.Range (0' n).ToList ();  			updated = false;  			List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  			while (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				List<int> indexes = values.ToList ();  				foreach (int index in indexOfIndex)  					indexes [index] = n - 1;  				while (macLane > 0) {  					Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					// Проверяем' что матрица образованная indexes является обратимой  					var detMatrix = new BooleanMatrix (indexes);  					if (detMatrix.Det ()) {  						int macLane2 = 0;  						///////////////////////////////////////////////////  						// Вычисление целевой функции обычным методом  						Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  						var matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  						macLane2 = matrix2.MacLane;  						Debug.WriteLine ("macLane = " + macLane2);  						if (macLane > macLane2) {  							if (WorkerLog != null)  								WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  							Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  							values = indexes.ToList ();  							macLane = macLane2;  							updated = true;  							Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  							Debug.WriteLine ("matrix2:");  							Debug.WriteLine (matrix2);  						}  						if (macLane == 0)  							break;  					}  					else {  						Debug.WriteLine ("Матрица не обратима");  					}  					int i = k;  					while (i-- > 0)  						if (indexes [indexOfIndex [i]]-- > 0)  							break;  						else  							indexes [indexOfIndex [i]] = n - 1;  					if (i < 0)  						break;  				}  				int count = k;  				while (count-- > 0)  					if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  						break;  					else  						indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  				if (count < 0)  					break;  			}  			if (WorkerLog != null)  				WorkerLog ("Смена начальной точки симплекс-метода");  			///////////////////////////////////////////////////  			// Cмена базиса симплекс-метода обычным методом  			Dictionary<int' int> dictionary2 = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  			booleanMatrix = new BooleanMatrix (dictionary2.Select (pair1 => dictionary2.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  			Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  		}  		if (macLane > 0) {  			if (WorkerLog != null)  				WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  			if (WorkerLog != null)  				WorkerLog ("Граф не планарен");  			bool result = false;  			if (WorkerComplite != null)  				WorkerComplite (result);  			return result;  		}  	}  	if (WorkerLog != null)  		WorkerLog ("Конец проверки связанной компоненты");  }  
Magic Number,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The following statement contains a magic number: foreach (Graph subGraph in stackListQueue) {  	if (WorkerLog != null)  		WorkerLog ("Проверка связанной компоненты " + subGraph);  	// листья представляют собой дерево и нарисовать его плоскую укладку тривиально.  	subGraph.RemoveAllTrees ();  	if (subGraph.Vertices.Count () < 2)  		continue;  	Dictionary<int' PathDictionary> cachedSubGraphPaths = Graph.GetSubgraphPaths (subGraph.Vertices' cachedAllGraphPaths);  	if (WorkerLog != null)  		WorkerLog ("Находим ВСЕ циклы в графе длины не менее 2 и не более размера графа");  	var circles = new StackListQueue<Circle> (cachedSubGraphPaths.Where (pair => pair.Key > 2).SelectMany (pair => subGraph.Vertices.SelectMany (vertex => pair.Value.Where (pair2 => pair2.Key.Key.Equals (pair2.Key.Value)).SelectMany (pair2 => pair2.Value.Select (path => new Circle (path.GetRange (0' path.Count - 1)))))));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//if (WorkerLog != null) WorkerLog("Находим все циклы в графе");  	//IEnumerable<Circle> circles = subGraph.GetAllGraphCircles(cachedSubGraphPaths);  	if (!circles.Any ())  		continue;  	// граф — дерево и нарисовать его плоскую укладку тривиально.  	if (WorkerLog != null)  		WorkerLog ("Удаляем дубликаты");  	circles = new StackListQueue<Circle> (circles.Distinct (CircleComparer));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//Debug.Assert(subGraph.Vertices.Count() ==  	//             circles.SelectMany(circle => circle.ToList()).Distinct().Count());  	//     С технической точки зрения проверять' что цикл является простым и тау-циклом нет необходимости' поскольку не  	//     приведён алгорим позволяющий проверить ' что цикл является тау-циклом за количество операций меньшее чем приведение  	//     матрицы к каноническому виду. Поэтому если действительно надо сделать хорошую реализацию' то либо надо закоментировать  	//     проверки циклов на простоту и что они являются тау-циклами с помощью приведения к каноническому виду ' либо  	//     предложить алгоритм быстрой проверки' что цикл является тау-циклом  	if (WorkerLog != null)  		WorkerLog ("Ограничиваем простыми циклами");  	circles.RemoveAll (Circle.IsNotSimple);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	if (WorkerLog != null)  		WorkerLog ("Удаляем элементарные циклы и петли");  	circles.RemoveAll (circle => circle.Count < 3);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//if (WorkerLog != null) WorkerLog("Ограничиваем тау-циклами");  	//circles.RemoveAll(circle => !circle.IsTau());  	//if (WorkerLog != null) WorkerLog(string.Format("Количество циклов {0}"' circles.Count()));  	Debug.WriteLine (string.Join (Environment.NewLine' circles.Select (circle => circle.ToString ())));  	if (WorkerLog != null)  		WorkerLog ("Строим матрицу над GF2 из найденных циклов");  	var booleanMatrix = new BooleanMatrix (circles.Select (subGraph.GetVector));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  	foreach (var r in booleanMatrix)  		if (r.Count () < booleanMatrix.Length)  			r.Add (Enumerable.Repeat (false' booleanMatrix.Length - r.Count ()));  	Debug.WriteLine ("matrix:");  	Debug.WriteLine (booleanMatrix);  	// отыскание минимума некоторого функционала на множестве базисов подпространства квазициклов  	// Шаг 1. Приведение матрицы к каноническому виду  	if (WorkerLog != null)  		WorkerLog ("Приводим матрицу к каноническому виду");  	if (Settings.EnableCudafy)  		lock (CudafyMatrix.Semaphore) {  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для приведения матрицы к каноническому виду  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				// Использование алгоритма Гаусса-Жордана  				// Для приведения матрицы к каноническому виду  				CudafyMatrix.ExecuteGaussJordan ();  				// Удаляем нулевые строки  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				booleanMatrix = new BooleanMatrix (CudafyMatrix.GetIndexes ().Select ((first' row) => new KeyValuePair<int' int> (row' first)).Where (pair => pair.Value >= 0).Select (pair => arrayOfArray [pair.Key].Select (value => value != 0)));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				/////////////////////////////////////////////////////  				// Приведение матрицы к каноническому виду обычным способом  				booleanMatrix.GaussJordan ();  				booleanMatrix.RemoveAll (BooleanVector.IsZero);  			}  			if (WorkerLog != null)  				WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  			// Матрица имеет канонический вид  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  			Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).Distinct ().Count () == booleanMatrix.Count);  			Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).SelectMany (index => booleanMatrix.Where (vector => vector.Count > index && vector [index])).Count () == booleanMatrix.Count);  			// Поскольку в колонках содержится по одной единице' то к строке можно прибавить только одну другую строку  			int n = booleanMatrix.Count;  			int macLane;  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для расчёта целевой функции симплекс-метода  				Debug.Assert (CudafyMatrix.GetMatrix () != null);  				CudafyMatrix.SetIndexes (Enumerable.Range (0' n).ToArray ());  				CudafyMatrix.ExecuteMacLane ();  				macLane = CudafyMatrix.GetMacLane ();  				#if DEBUG  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				Debug.WriteLine (string.Join (Environment.NewLine' arrayOfArray.Select (v => string.Join ("'"' v.Select (i => i.ToString ())))));  				#endif  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				///////////////////////////////////////////////////  				// Вычисление целевой функции обычным методом  				macLane = booleanMatrix.MacLane;  			}  			Debug.WriteLine ("macLane = " + macLane);  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  			int k = Math.Min (2' Math.Max (1' n));  			k = Math.Min (n' k);  			if (WorkerLog != null)  				WorkerLog ("Начало симплекс-метода");  			if (WorkerLog != null)  				WorkerLog ("Текущий macLane = " + macLane);  			for (bool updated = true; k <= n && updated && macLane > 0;) {  				Debug.Assert (booleanMatrix.Length == subGraph.Count ());  				List<int> values = Enumerable.Range (0' n).ToList ();  				updated = false;  				List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  				while (macLane > 0) {  					if (WorkerLog != null)  						WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  					List<int> indexes = values.ToList ();  					foreach (int index in indexOfIndex)  						indexes [index] = n - 1;  					while (macLane > 0) {  						Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  						// Проверяем' что матрица образованная indexes является обратимой  						var detMatrix = new BooleanMatrix (indexes);  						if (detMatrix.Det ()) {  							BooleanMatrix matrix2;  							int macLane2 = 0;  							try {  								/////////////////////////////////////////////////////  								// Использование параллельных вычислений CUDA  								// для расчёта целевой функции симплекс-метода  								Debug.Assert (CudafyMatrix.GetMatrix () != null);  								CudafyMatrix.SetIndexes (indexes.ToArray ());  								CudafyMatrix.ExecuteMacLane ();  								macLane2 = CudafyMatrix.GetMacLane ();  								#if DEBUG  								CudafyMatrix.ExecuteUpdate ();  								int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  								matrix2 = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  								CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (v => v.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  								#endif  							}  							catch (Exception ex) {  								if (WorkerLog != null)  									WorkerLog (ex.ToString ());  								///////////////////////////////////////////////////  								// Вычисление целевой функции обычным методом  								Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  								matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  								macLane2 = matrix2.MacLane;  							}  							finally {  								Debug.WriteLine ("macLane = " + macLane2);  							}  							if (macLane > macLane2) {  								if (WorkerLog != null)  									WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  								Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  								values = indexes.ToList ();  								macLane = macLane2;  								updated = true;  								Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  								Debug.WriteLine ("matrix2:");  								Debug.WriteLine (matrix2);  							}  							if (macLane == 0)  								break;  						}  						else {  							Debug.WriteLine ("Матрица не обратима");  						}  						int i = k;  						while (i-- > 0)  							if (indexes [indexOfIndex [i]]-- > 0)  								break;  							else  								indexes [indexOfIndex [i]] = n - 1;  						if (i < 0)  							break;  					}  					int count = k;  					while (count-- > 0)  						if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  							break;  						else  							indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  					if (count < 0)  						break;  				}  				if (WorkerLog != null)  					WorkerLog ("Смена начальной точки симплекс-метода");  				try {  					/////////////////////////////////////////////////////  					// Использование параллельных вычислений CUDA  					// для смены базиса симплекс-метода  					Debug.Assert (CudafyMatrix.GetMatrix () != null);  					CudafyMatrix.SetIndexes (values.ToArray ());  					CudafyMatrix.ExecuteUpdate ();  					#if DEBUG  					int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  					booleanMatrix = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  					#endif  				}  				catch (Exception ex) {  					if (WorkerLog != null)  						WorkerLog (ex.ToString ());  					///////////////////////////////////////////////////  					// Cмена базиса симплекс-метода обычным методом  					Dictionary<int' int> dictionary = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  					booleanMatrix = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  				}  				Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  				Debug.WriteLine ("matrix:");  				Debug.WriteLine (booleanMatrix);  			}  			if (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  				if (WorkerLog != null)  					WorkerLog ("Граф не планарен");  				bool result = false;  				if (WorkerComplite != null)  					WorkerComplite (result);  				return result;  			}  		}  	else {  		// Приведение матрицы к каноническому виду обычным способом  		booleanMatrix.GaussJordan ();  		booleanMatrix.RemoveAll (BooleanVector.IsZero);  		if (WorkerLog != null)  			WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  		int macLane = booleanMatrix.MacLane;  		Debug.WriteLine ("macLane = " + macLane);  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  		int n = booleanMatrix.Count;  		int k = Math.Min (2' Math.Max (1' n));  		k = Math.Min (n' k);  		if (WorkerLog != null)  			WorkerLog ("Начало симплекс-метода");  		if (WorkerLog != null)  			WorkerLog ("Текущий macLane = " + macLane);  		for (bool updated = true; k <= n && updated && macLane > 0;) {  			Debug.Assert (booleanMatrix.Length == subGraph.Count ());  			List<int> values = Enumerable.Range (0' n).ToList ();  			updated = false;  			List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  			while (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				List<int> indexes = values.ToList ();  				foreach (int index in indexOfIndex)  					indexes [index] = n - 1;  				while (macLane > 0) {  					Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					// Проверяем' что матрица образованная indexes является обратимой  					var detMatrix = new BooleanMatrix (indexes);  					if (detMatrix.Det ()) {  						int macLane2 = 0;  						///////////////////////////////////////////////////  						// Вычисление целевой функции обычным методом  						Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  						var matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  						macLane2 = matrix2.MacLane;  						Debug.WriteLine ("macLane = " + macLane2);  						if (macLane > macLane2) {  							if (WorkerLog != null)  								WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  							Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  							values = indexes.ToList ();  							macLane = macLane2;  							updated = true;  							Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  							Debug.WriteLine ("matrix2:");  							Debug.WriteLine (matrix2);  						}  						if (macLane == 0)  							break;  					}  					else {  						Debug.WriteLine ("Матрица не обратима");  					}  					int i = k;  					while (i-- > 0)  						if (indexes [indexOfIndex [i]]-- > 0)  							break;  						else  							indexes [indexOfIndex [i]] = n - 1;  					if (i < 0)  						break;  				}  				int count = k;  				while (count-- > 0)  					if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  						break;  					else  						indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  				if (count < 0)  					break;  			}  			if (WorkerLog != null)  				WorkerLog ("Смена начальной точки симплекс-метода");  			///////////////////////////////////////////////////  			// Cмена базиса симплекс-метода обычным методом  			Dictionary<int' int> dictionary2 = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  			booleanMatrix = new BooleanMatrix (dictionary2.Select (pair1 => dictionary2.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  			Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  		}  		if (macLane > 0) {  			if (WorkerLog != null)  				WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  			if (WorkerLog != null)  				WorkerLog ("Граф не планарен");  			bool result = false;  			if (WorkerComplite != null)  				WorkerComplite (result);  			return result;  		}  	}  	if (WorkerLog != null)  		WorkerLog ("Конец проверки связанной компоненты");  }  
Magic Number,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The following statement contains a magic number: foreach (Graph subGraph in stackListQueue) {  	if (WorkerLog != null)  		WorkerLog ("Проверка связанной компоненты " + subGraph);  	// листья представляют собой дерево и нарисовать его плоскую укладку тривиально.  	subGraph.RemoveAllTrees ();  	if (subGraph.Vertices.Count () < 2)  		continue;  	Dictionary<int' PathDictionary> cachedSubGraphPaths = Graph.GetSubgraphPaths (subGraph.Vertices' cachedAllGraphPaths);  	if (WorkerLog != null)  		WorkerLog ("Находим ВСЕ циклы в графе длины не менее 2 и не более размера графа");  	var circles = new StackListQueue<Circle> (cachedSubGraphPaths.Where (pair => pair.Key > 2).SelectMany (pair => subGraph.Vertices.SelectMany (vertex => pair.Value.Where (pair2 => pair2.Key.Key.Equals (pair2.Key.Value)).SelectMany (pair2 => pair2.Value.Select (path => new Circle (path.GetRange (0' path.Count - 1)))))));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//if (WorkerLog != null) WorkerLog("Находим все циклы в графе");  	//IEnumerable<Circle> circles = subGraph.GetAllGraphCircles(cachedSubGraphPaths);  	if (!circles.Any ())  		continue;  	// граф — дерево и нарисовать его плоскую укладку тривиально.  	if (WorkerLog != null)  		WorkerLog ("Удаляем дубликаты");  	circles = new StackListQueue<Circle> (circles.Distinct (CircleComparer));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//Debug.Assert(subGraph.Vertices.Count() ==  	//             circles.SelectMany(circle => circle.ToList()).Distinct().Count());  	//     С технической точки зрения проверять' что цикл является простым и тау-циклом нет необходимости' поскольку не  	//     приведён алгорим позволяющий проверить ' что цикл является тау-циклом за количество операций меньшее чем приведение  	//     матрицы к каноническому виду. Поэтому если действительно надо сделать хорошую реализацию' то либо надо закоментировать  	//     проверки циклов на простоту и что они являются тау-циклами с помощью приведения к каноническому виду ' либо  	//     предложить алгоритм быстрой проверки' что цикл является тау-циклом  	if (WorkerLog != null)  		WorkerLog ("Ограничиваем простыми циклами");  	circles.RemoveAll (Circle.IsNotSimple);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	if (WorkerLog != null)  		WorkerLog ("Удаляем элементарные циклы и петли");  	circles.RemoveAll (circle => circle.Count < 3);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Количество циклов {0}"' circles.Count ()));  	//if (WorkerLog != null) WorkerLog("Ограничиваем тау-циклами");  	//circles.RemoveAll(circle => !circle.IsTau());  	//if (WorkerLog != null) WorkerLog(string.Format("Количество циклов {0}"' circles.Count()));  	Debug.WriteLine (string.Join (Environment.NewLine' circles.Select (circle => circle.ToString ())));  	if (WorkerLog != null)  		WorkerLog ("Строим матрицу над GF2 из найденных циклов");  	var booleanMatrix = new BooleanMatrix (circles.Select (subGraph.GetVector));  	if (WorkerLog != null)  		WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  	foreach (var r in booleanMatrix)  		if (r.Count () < booleanMatrix.Length)  			r.Add (Enumerable.Repeat (false' booleanMatrix.Length - r.Count ()));  	Debug.WriteLine ("matrix:");  	Debug.WriteLine (booleanMatrix);  	// отыскание минимума некоторого функционала на множестве базисов подпространства квазициклов  	// Шаг 1. Приведение матрицы к каноническому виду  	if (WorkerLog != null)  		WorkerLog ("Приводим матрицу к каноническому виду");  	if (Settings.EnableCudafy)  		lock (CudafyMatrix.Semaphore) {  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для приведения матрицы к каноническому виду  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				// Использование алгоритма Гаусса-Жордана  				// Для приведения матрицы к каноническому виду  				CudafyMatrix.ExecuteGaussJordan ();  				// Удаляем нулевые строки  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				booleanMatrix = new BooleanMatrix (CudafyMatrix.GetIndexes ().Select ((first' row) => new KeyValuePair<int' int> (row' first)).Where (pair => pair.Value >= 0).Select (pair => arrayOfArray [pair.Key].Select (value => value != 0)));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				/////////////////////////////////////////////////////  				// Приведение матрицы к каноническому виду обычным способом  				booleanMatrix.GaussJordan ();  				booleanMatrix.RemoveAll (BooleanVector.IsZero);  			}  			if (WorkerLog != null)  				WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  			// Матрица имеет канонический вид  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  			Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).Distinct ().Count () == booleanMatrix.Count);  			Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).SelectMany (index => booleanMatrix.Where (vector => vector.Count > index && vector [index])).Count () == booleanMatrix.Count);  			// Поскольку в колонках содержится по одной единице' то к строке можно прибавить только одну другую строку  			int n = booleanMatrix.Count;  			int macLane;  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для расчёта целевой функции симплекс-метода  				Debug.Assert (CudafyMatrix.GetMatrix () != null);  				CudafyMatrix.SetIndexes (Enumerable.Range (0' n).ToArray ());  				CudafyMatrix.ExecuteMacLane ();  				macLane = CudafyMatrix.GetMacLane ();  				#if DEBUG  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				Debug.WriteLine (string.Join (Environment.NewLine' arrayOfArray.Select (v => string.Join ("'"' v.Select (i => i.ToString ())))));  				#endif  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				///////////////////////////////////////////////////  				// Вычисление целевой функции обычным методом  				macLane = booleanMatrix.MacLane;  			}  			Debug.WriteLine ("macLane = " + macLane);  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  			int k = Math.Min (2' Math.Max (1' n));  			k = Math.Min (n' k);  			if (WorkerLog != null)  				WorkerLog ("Начало симплекс-метода");  			if (WorkerLog != null)  				WorkerLog ("Текущий macLane = " + macLane);  			for (bool updated = true; k <= n && updated && macLane > 0;) {  				Debug.Assert (booleanMatrix.Length == subGraph.Count ());  				List<int> values = Enumerable.Range (0' n).ToList ();  				updated = false;  				List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  				while (macLane > 0) {  					if (WorkerLog != null)  						WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  					List<int> indexes = values.ToList ();  					foreach (int index in indexOfIndex)  						indexes [index] = n - 1;  					while (macLane > 0) {  						Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  						// Проверяем' что матрица образованная indexes является обратимой  						var detMatrix = new BooleanMatrix (indexes);  						if (detMatrix.Det ()) {  							BooleanMatrix matrix2;  							int macLane2 = 0;  							try {  								/////////////////////////////////////////////////////  								// Использование параллельных вычислений CUDA  								// для расчёта целевой функции симплекс-метода  								Debug.Assert (CudafyMatrix.GetMatrix () != null);  								CudafyMatrix.SetIndexes (indexes.ToArray ());  								CudafyMatrix.ExecuteMacLane ();  								macLane2 = CudafyMatrix.GetMacLane ();  								#if DEBUG  								CudafyMatrix.ExecuteUpdate ();  								int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  								matrix2 = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  								CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (v => v.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  								#endif  							}  							catch (Exception ex) {  								if (WorkerLog != null)  									WorkerLog (ex.ToString ());  								///////////////////////////////////////////////////  								// Вычисление целевой функции обычным методом  								Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  								matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  								macLane2 = matrix2.MacLane;  							}  							finally {  								Debug.WriteLine ("macLane = " + macLane2);  							}  							if (macLane > macLane2) {  								if (WorkerLog != null)  									WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  								Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  								values = indexes.ToList ();  								macLane = macLane2;  								updated = true;  								Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  								Debug.WriteLine ("matrix2:");  								Debug.WriteLine (matrix2);  							}  							if (macLane == 0)  								break;  						}  						else {  							Debug.WriteLine ("Матрица не обратима");  						}  						int i = k;  						while (i-- > 0)  							if (indexes [indexOfIndex [i]]-- > 0)  								break;  							else  								indexes [indexOfIndex [i]] = n - 1;  						if (i < 0)  							break;  					}  					int count = k;  					while (count-- > 0)  						if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  							break;  						else  							indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  					if (count < 0)  						break;  				}  				if (WorkerLog != null)  					WorkerLog ("Смена начальной точки симплекс-метода");  				try {  					/////////////////////////////////////////////////////  					// Использование параллельных вычислений CUDA  					// для смены базиса симплекс-метода  					Debug.Assert (CudafyMatrix.GetMatrix () != null);  					CudafyMatrix.SetIndexes (values.ToArray ());  					CudafyMatrix.ExecuteUpdate ();  					#if DEBUG  					int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  					booleanMatrix = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  					#endif  				}  				catch (Exception ex) {  					if (WorkerLog != null)  						WorkerLog (ex.ToString ());  					///////////////////////////////////////////////////  					// Cмена базиса симплекс-метода обычным методом  					Dictionary<int' int> dictionary = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  					booleanMatrix = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  				}  				Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  				Debug.WriteLine ("matrix:");  				Debug.WriteLine (booleanMatrix);  			}  			if (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  				if (WorkerLog != null)  					WorkerLog ("Граф не планарен");  				bool result = false;  				if (WorkerComplite != null)  					WorkerComplite (result);  				return result;  			}  		}  	else {  		// Приведение матрицы к каноническому виду обычным способом  		booleanMatrix.GaussJordan ();  		booleanMatrix.RemoveAll (BooleanVector.IsZero);  		if (WorkerLog != null)  			WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  		int macLane = booleanMatrix.MacLane;  		Debug.WriteLine ("macLane = " + macLane);  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  		int n = booleanMatrix.Count;  		int k = Math.Min (2' Math.Max (1' n));  		k = Math.Min (n' k);  		if (WorkerLog != null)  			WorkerLog ("Начало симплекс-метода");  		if (WorkerLog != null)  			WorkerLog ("Текущий macLane = " + macLane);  		for (bool updated = true; k <= n && updated && macLane > 0;) {  			Debug.Assert (booleanMatrix.Length == subGraph.Count ());  			List<int> values = Enumerable.Range (0' n).ToList ();  			updated = false;  			List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  			while (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				List<int> indexes = values.ToList ();  				foreach (int index in indexOfIndex)  					indexes [index] = n - 1;  				while (macLane > 0) {  					Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					// Проверяем' что матрица образованная indexes является обратимой  					var detMatrix = new BooleanMatrix (indexes);  					if (detMatrix.Det ()) {  						int macLane2 = 0;  						///////////////////////////////////////////////////  						// Вычисление целевой функции обычным методом  						Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  						var matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  						macLane2 = matrix2.MacLane;  						Debug.WriteLine ("macLane = " + macLane2);  						if (macLane > macLane2) {  							if (WorkerLog != null)  								WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  							Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  							values = indexes.ToList ();  							macLane = macLane2;  							updated = true;  							Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  							Debug.WriteLine ("matrix2:");  							Debug.WriteLine (matrix2);  						}  						if (macLane == 0)  							break;  					}  					else {  						Debug.WriteLine ("Матрица не обратима");  					}  					int i = k;  					while (i-- > 0)  						if (indexes [indexOfIndex [i]]-- > 0)  							break;  						else  							indexes [indexOfIndex [i]] = n - 1;  					if (i < 0)  						break;  				}  				int count = k;  				while (count-- > 0)  					if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  						break;  					else  						indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  				if (count < 0)  					break;  			}  			if (WorkerLog != null)  				WorkerLog ("Смена начальной точки симплекс-метода");  			///////////////////////////////////////////////////  			// Cмена базиса симплекс-метода обычным методом  			Dictionary<int' int> dictionary2 = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  			booleanMatrix = new BooleanMatrix (dictionary2.Select (pair1 => dictionary2.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  			Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  		}  		if (macLane > 0) {  			if (WorkerLog != null)  				WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  			if (WorkerLog != null)  				WorkerLog ("Граф не планарен");  			bool result = false;  			if (WorkerComplite != null)  				WorkerComplite (result);  			return result;  		}  	}  	if (WorkerLog != null)  		WorkerLog ("Конец проверки связанной компоненты");  }  
Magic Number,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The following statement contains a magic number: if (subGraph.Vertices.Count () < 2)  	continue;  
Magic Number,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The following statement contains a magic number: circles.RemoveAll (circle => circle.Count < 3);  
Magic Number,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The following statement contains a magic number: if (Settings.EnableCudafy)  	lock (CudafyMatrix.Semaphore) {  		try {  			/////////////////////////////////////////////////////  			// Использование параллельных вычислений CUDA  			// для приведения матрицы к каноническому виду  			CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  			// Использование алгоритма Гаусса-Жордана  			// Для приведения матрицы к каноническому виду  			CudafyMatrix.ExecuteGaussJordan ();  			// Удаляем нулевые строки  			int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  			booleanMatrix = new BooleanMatrix (CudafyMatrix.GetIndexes ().Select ((first' row) => new KeyValuePair<int' int> (row' first)).Where (pair => pair.Value >= 0).Select (pair => arrayOfArray [pair.Key].Select (value => value != 0)));  			CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  		}  		catch (Exception ex) {  			if (WorkerLog != null)  				WorkerLog (ex.ToString ());  			/////////////////////////////////////////////////////  			// Приведение матрицы к каноническому виду обычным способом  			booleanMatrix.GaussJordan ();  			booleanMatrix.RemoveAll (BooleanVector.IsZero);  		}  		if (WorkerLog != null)  			WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  		// Матрица имеет канонический вид  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  		Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).Distinct ().Count () == booleanMatrix.Count);  		Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).SelectMany (index => booleanMatrix.Where (vector => vector.Count > index && vector [index])).Count () == booleanMatrix.Count);  		// Поскольку в колонках содержится по одной единице' то к строке можно прибавить только одну другую строку  		int n = booleanMatrix.Count;  		int macLane;  		try {  			/////////////////////////////////////////////////////  			// Использование параллельных вычислений CUDA  			// для расчёта целевой функции симплекс-метода  			Debug.Assert (CudafyMatrix.GetMatrix () != null);  			CudafyMatrix.SetIndexes (Enumerable.Range (0' n).ToArray ());  			CudafyMatrix.ExecuteMacLane ();  			macLane = CudafyMatrix.GetMacLane ();  			#if DEBUG  			int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  			Debug.WriteLine (string.Join (Environment.NewLine' arrayOfArray.Select (v => string.Join ("'"' v.Select (i => i.ToString ())))));  			#endif  		}  		catch (Exception ex) {  			if (WorkerLog != null)  				WorkerLog (ex.ToString ());  			///////////////////////////////////////////////////  			// Вычисление целевой функции обычным методом  			macLane = booleanMatrix.MacLane;  		}  		Debug.WriteLine ("macLane = " + macLane);  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  		int k = Math.Min (2' Math.Max (1' n));  		k = Math.Min (n' k);  		if (WorkerLog != null)  			WorkerLog ("Начало симплекс-метода");  		if (WorkerLog != null)  			WorkerLog ("Текущий macLane = " + macLane);  		for (bool updated = true; k <= n && updated && macLane > 0;) {  			Debug.Assert (booleanMatrix.Length == subGraph.Count ());  			List<int> values = Enumerable.Range (0' n).ToList ();  			updated = false;  			List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  			while (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				List<int> indexes = values.ToList ();  				foreach (int index in indexOfIndex)  					indexes [index] = n - 1;  				while (macLane > 0) {  					Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					// Проверяем' что матрица образованная indexes является обратимой  					var detMatrix = new BooleanMatrix (indexes);  					if (detMatrix.Det ()) {  						BooleanMatrix matrix2;  						int macLane2 = 0;  						try {  							/////////////////////////////////////////////////////  							// Использование параллельных вычислений CUDA  							// для расчёта целевой функции симплекс-метода  							Debug.Assert (CudafyMatrix.GetMatrix () != null);  							CudafyMatrix.SetIndexes (indexes.ToArray ());  							CudafyMatrix.ExecuteMacLane ();  							macLane2 = CudafyMatrix.GetMacLane ();  							#if DEBUG  							CudafyMatrix.ExecuteUpdate ();  							int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  							matrix2 = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  							CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (v => v.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  							#endif  						}  						catch (Exception ex) {  							if (WorkerLog != null)  								WorkerLog (ex.ToString ());  							///////////////////////////////////////////////////  							// Вычисление целевой функции обычным методом  							Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  							matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  							macLane2 = matrix2.MacLane;  						}  						finally {  							Debug.WriteLine ("macLane = " + macLane2);  						}  						if (macLane > macLane2) {  							if (WorkerLog != null)  								WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  							Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  							values = indexes.ToList ();  							macLane = macLane2;  							updated = true;  							Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  							Debug.WriteLine ("matrix2:");  							Debug.WriteLine (matrix2);  						}  						if (macLane == 0)  							break;  					}  					else {  						Debug.WriteLine ("Матрица не обратима");  					}  					int i = k;  					while (i-- > 0)  						if (indexes [indexOfIndex [i]]-- > 0)  							break;  						else  							indexes [indexOfIndex [i]] = n - 1;  					if (i < 0)  						break;  				}  				int count = k;  				while (count-- > 0)  					if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  						break;  					else  						indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  				if (count < 0)  					break;  			}  			if (WorkerLog != null)  				WorkerLog ("Смена начальной точки симплекс-метода");  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для смены базиса симплекс-метода  				Debug.Assert (CudafyMatrix.GetMatrix () != null);  				CudafyMatrix.SetIndexes (values.ToArray ());  				CudafyMatrix.ExecuteUpdate ();  				#if DEBUG  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				booleanMatrix = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  				#endif  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				///////////////////////////////////////////////////  				// Cмена базиса симплекс-метода обычным методом  				Dictionary<int' int> dictionary = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  				booleanMatrix = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  			}  			Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  		}  		if (macLane > 0) {  			if (WorkerLog != null)  				WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  			if (WorkerLog != null)  				WorkerLog ("Граф не планарен");  			bool result = false;  			if (WorkerComplite != null)  				WorkerComplite (result);  			return result;  		}  	}  else {  	// Приведение матрицы к каноническому виду обычным способом  	booleanMatrix.GaussJordan ();  	booleanMatrix.RemoveAll (BooleanVector.IsZero);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  	int macLane = booleanMatrix.MacLane;  	Debug.WriteLine ("macLane = " + macLane);  	Debug.WriteLine ("matrix:");  	Debug.WriteLine (booleanMatrix);  	int n = booleanMatrix.Count;  	int k = Math.Min (2' Math.Max (1' n));  	k = Math.Min (n' k);  	if (WorkerLog != null)  		WorkerLog ("Начало симплекс-метода");  	if (WorkerLog != null)  		WorkerLog ("Текущий macLane = " + macLane);  	for (bool updated = true; k <= n && updated && macLane > 0;) {  		Debug.Assert (booleanMatrix.Length == subGraph.Count ());  		List<int> values = Enumerable.Range (0' n).ToList ();  		updated = false;  		List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  		while (macLane > 0) {  			if (WorkerLog != null)  				WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  			CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  			List<int> indexes = values.ToList ();  			foreach (int index in indexOfIndex)  				indexes [index] = n - 1;  			while (macLane > 0) {  				Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  				// Проверяем' что матрица образованная indexes является обратимой  				var detMatrix = new BooleanMatrix (indexes);  				if (detMatrix.Det ()) {  					int macLane2 = 0;  					///////////////////////////////////////////////////  					// Вычисление целевой функции обычным методом  					Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  					var matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  					macLane2 = matrix2.MacLane;  					Debug.WriteLine ("macLane = " + macLane2);  					if (macLane > macLane2) {  						if (WorkerLog != null)  							WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  						Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  						values = indexes.ToList ();  						macLane = macLane2;  						updated = true;  						Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  						Debug.WriteLine ("matrix2:");  						Debug.WriteLine (matrix2);  					}  					if (macLane == 0)  						break;  				}  				else {  					Debug.WriteLine ("Матрица не обратима");  				}  				int i = k;  				while (i-- > 0)  					if (indexes [indexOfIndex [i]]-- > 0)  						break;  					else  						indexes [indexOfIndex [i]] = n - 1;  				if (i < 0)  					break;  			}  			int count = k;  			while (count-- > 0)  				if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  					break;  				else  					indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  			if (count < 0)  				break;  		}  		if (WorkerLog != null)  			WorkerLog ("Смена начальной точки симплекс-метода");  		///////////////////////////////////////////////////  		// Cмена базиса симплекс-метода обычным методом  		Dictionary<int' int> dictionary2 = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  		booleanMatrix = new BooleanMatrix (dictionary2.Select (pair1 => dictionary2.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  		Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  	}  	if (macLane > 0) {  		if (WorkerLog != null)  			WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  		if (WorkerLog != null)  			WorkerLog ("Граф не планарен");  		bool result = false;  		if (WorkerComplite != null)  			WorkerComplite (result);  		return result;  	}  }  
Magic Number,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The following statement contains a magic number: if (Settings.EnableCudafy)  	lock (CudafyMatrix.Semaphore) {  		try {  			/////////////////////////////////////////////////////  			// Использование параллельных вычислений CUDA  			// для приведения матрицы к каноническому виду  			CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  			// Использование алгоритма Гаусса-Жордана  			// Для приведения матрицы к каноническому виду  			CudafyMatrix.ExecuteGaussJordan ();  			// Удаляем нулевые строки  			int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  			booleanMatrix = new BooleanMatrix (CudafyMatrix.GetIndexes ().Select ((first' row) => new KeyValuePair<int' int> (row' first)).Where (pair => pair.Value >= 0).Select (pair => arrayOfArray [pair.Key].Select (value => value != 0)));  			CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  		}  		catch (Exception ex) {  			if (WorkerLog != null)  				WorkerLog (ex.ToString ());  			/////////////////////////////////////////////////////  			// Приведение матрицы к каноническому виду обычным способом  			booleanMatrix.GaussJordan ();  			booleanMatrix.RemoveAll (BooleanVector.IsZero);  		}  		if (WorkerLog != null)  			WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  		// Матрица имеет канонический вид  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  		Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).Distinct ().Count () == booleanMatrix.Count);  		Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).SelectMany (index => booleanMatrix.Where (vector => vector.Count > index && vector [index])).Count () == booleanMatrix.Count);  		// Поскольку в колонках содержится по одной единице' то к строке можно прибавить только одну другую строку  		int n = booleanMatrix.Count;  		int macLane;  		try {  			/////////////////////////////////////////////////////  			// Использование параллельных вычислений CUDA  			// для расчёта целевой функции симплекс-метода  			Debug.Assert (CudafyMatrix.GetMatrix () != null);  			CudafyMatrix.SetIndexes (Enumerable.Range (0' n).ToArray ());  			CudafyMatrix.ExecuteMacLane ();  			macLane = CudafyMatrix.GetMacLane ();  			#if DEBUG  			int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  			Debug.WriteLine (string.Join (Environment.NewLine' arrayOfArray.Select (v => string.Join ("'"' v.Select (i => i.ToString ())))));  			#endif  		}  		catch (Exception ex) {  			if (WorkerLog != null)  				WorkerLog (ex.ToString ());  			///////////////////////////////////////////////////  			// Вычисление целевой функции обычным методом  			macLane = booleanMatrix.MacLane;  		}  		Debug.WriteLine ("macLane = " + macLane);  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  		int k = Math.Min (2' Math.Max (1' n));  		k = Math.Min (n' k);  		if (WorkerLog != null)  			WorkerLog ("Начало симплекс-метода");  		if (WorkerLog != null)  			WorkerLog ("Текущий macLane = " + macLane);  		for (bool updated = true; k <= n && updated && macLane > 0;) {  			Debug.Assert (booleanMatrix.Length == subGraph.Count ());  			List<int> values = Enumerable.Range (0' n).ToList ();  			updated = false;  			List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  			while (macLane > 0) {  				if (WorkerLog != null)  					WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  				CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  				List<int> indexes = values.ToList ();  				foreach (int index in indexOfIndex)  					indexes [index] = n - 1;  				while (macLane > 0) {  					Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  					// Проверяем' что матрица образованная indexes является обратимой  					var detMatrix = new BooleanMatrix (indexes);  					if (detMatrix.Det ()) {  						BooleanMatrix matrix2;  						int macLane2 = 0;  						try {  							/////////////////////////////////////////////////////  							// Использование параллельных вычислений CUDA  							// для расчёта целевой функции симплекс-метода  							Debug.Assert (CudafyMatrix.GetMatrix () != null);  							CudafyMatrix.SetIndexes (indexes.ToArray ());  							CudafyMatrix.ExecuteMacLane ();  							macLane2 = CudafyMatrix.GetMacLane ();  							#if DEBUG  							CudafyMatrix.ExecuteUpdate ();  							int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  							matrix2 = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  							CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (v => v.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  							#endif  						}  						catch (Exception ex) {  							if (WorkerLog != null)  								WorkerLog (ex.ToString ());  							///////////////////////////////////////////////////  							// Вычисление целевой функции обычным методом  							Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  							matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  							macLane2 = matrix2.MacLane;  						}  						finally {  							Debug.WriteLine ("macLane = " + macLane2);  						}  						if (macLane > macLane2) {  							if (WorkerLog != null)  								WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  							Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  							values = indexes.ToList ();  							macLane = macLane2;  							updated = true;  							Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  							Debug.WriteLine ("matrix2:");  							Debug.WriteLine (matrix2);  						}  						if (macLane == 0)  							break;  					}  					else {  						Debug.WriteLine ("Матрица не обратима");  					}  					int i = k;  					while (i-- > 0)  						if (indexes [indexOfIndex [i]]-- > 0)  							break;  						else  							indexes [indexOfIndex [i]] = n - 1;  					if (i < 0)  						break;  				}  				int count = k;  				while (count-- > 0)  					if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  						break;  					else  						indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  				if (count < 0)  					break;  			}  			if (WorkerLog != null)  				WorkerLog ("Смена начальной точки симплекс-метода");  			try {  				/////////////////////////////////////////////////////  				// Использование параллельных вычислений CUDA  				// для смены базиса симплекс-метода  				Debug.Assert (CudafyMatrix.GetMatrix () != null);  				CudafyMatrix.SetIndexes (values.ToArray ());  				CudafyMatrix.ExecuteUpdate ();  				#if DEBUG  				int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  				booleanMatrix = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  				#endif  			}  			catch (Exception ex) {  				if (WorkerLog != null)  					WorkerLog (ex.ToString ());  				///////////////////////////////////////////////////  				// Cмена базиса симплекс-метода обычным методом  				Dictionary<int' int> dictionary = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  				booleanMatrix = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  			}  			Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  			Debug.WriteLine ("matrix:");  			Debug.WriteLine (booleanMatrix);  		}  		if (macLane > 0) {  			if (WorkerLog != null)  				WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  			if (WorkerLog != null)  				WorkerLog ("Граф не планарен");  			bool result = false;  			if (WorkerComplite != null)  				WorkerComplite (result);  			return result;  		}  	}  else {  	// Приведение матрицы к каноническому виду обычным способом  	booleanMatrix.GaussJordan ();  	booleanMatrix.RemoveAll (BooleanVector.IsZero);  	if (WorkerLog != null)  		WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  	int macLane = booleanMatrix.MacLane;  	Debug.WriteLine ("macLane = " + macLane);  	Debug.WriteLine ("matrix:");  	Debug.WriteLine (booleanMatrix);  	int n = booleanMatrix.Count;  	int k = Math.Min (2' Math.Max (1' n));  	k = Math.Min (n' k);  	if (WorkerLog != null)  		WorkerLog ("Начало симплекс-метода");  	if (WorkerLog != null)  		WorkerLog ("Текущий macLane = " + macLane);  	for (bool updated = true; k <= n && updated && macLane > 0;) {  		Debug.Assert (booleanMatrix.Length == subGraph.Count ());  		List<int> values = Enumerable.Range (0' n).ToList ();  		updated = false;  		List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  		while (macLane > 0) {  			if (WorkerLog != null)  				WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  			CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  			List<int> indexes = values.ToList ();  			foreach (int index in indexOfIndex)  				indexes [index] = n - 1;  			while (macLane > 0) {  				Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  				// Проверяем' что матрица образованная indexes является обратимой  				var detMatrix = new BooleanMatrix (indexes);  				if (detMatrix.Det ()) {  					int macLane2 = 0;  					///////////////////////////////////////////////////  					// Вычисление целевой функции обычным методом  					Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  					var matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  					macLane2 = matrix2.MacLane;  					Debug.WriteLine ("macLane = " + macLane2);  					if (macLane > macLane2) {  						if (WorkerLog != null)  							WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  						Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  						values = indexes.ToList ();  						macLane = macLane2;  						updated = true;  						Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  						Debug.WriteLine ("matrix2:");  						Debug.WriteLine (matrix2);  					}  					if (macLane == 0)  						break;  				}  				else {  					Debug.WriteLine ("Матрица не обратима");  				}  				int i = k;  				while (i-- > 0)  					if (indexes [indexOfIndex [i]]-- > 0)  						break;  					else  						indexes [indexOfIndex [i]] = n - 1;  				if (i < 0)  					break;  			}  			int count = k;  			while (count-- > 0)  				if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  					break;  				else  					indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  			if (count < 0)  				break;  		}  		if (WorkerLog != null)  			WorkerLog ("Смена начальной точки симплекс-метода");  		///////////////////////////////////////////////////  		// Cмена базиса симплекс-метода обычным методом  		Dictionary<int' int> dictionary2 = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  		booleanMatrix = new BooleanMatrix (dictionary2.Select (pair1 => dictionary2.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  		Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  	}  	if (macLane > 0) {  		if (WorkerLog != null)  			WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  		if (WorkerLog != null)  			WorkerLog ("Граф не планарен");  		bool result = false;  		if (WorkerComplite != null)  			WorkerComplite (result);  		return result;  	}  }  
Magic Number,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The following statement contains a magic number: lock (CudafyMatrix.Semaphore) {  	try {  		/////////////////////////////////////////////////////  		// Использование параллельных вычислений CUDA  		// для приведения матрицы к каноническому виду  		CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  		// Использование алгоритма Гаусса-Жордана  		// Для приведения матрицы к каноническому виду  		CudafyMatrix.ExecuteGaussJordan ();  		// Удаляем нулевые строки  		int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  		booleanMatrix = new BooleanMatrix (CudafyMatrix.GetIndexes ().Select ((first' row) => new KeyValuePair<int' int> (row' first)).Where (pair => pair.Value >= 0).Select (pair => arrayOfArray [pair.Key].Select (value => value != 0)));  		CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  	}  	catch (Exception ex) {  		if (WorkerLog != null)  			WorkerLog (ex.ToString ());  		/////////////////////////////////////////////////////  		// Приведение матрицы к каноническому виду обычным способом  		booleanMatrix.GaussJordan ();  		booleanMatrix.RemoveAll (BooleanVector.IsZero);  	}  	if (WorkerLog != null)  		WorkerLog (string.Format ("Размер матрицы {0}х{1}"' booleanMatrix.Count ()' booleanMatrix.Length));  	// Матрица имеет канонический вид  	Debug.WriteLine ("matrix:");  	Debug.WriteLine (booleanMatrix);  	Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).Distinct ().Count () == booleanMatrix.Count);  	Debug.Assert (booleanMatrix.Select (vector => vector.IndexOf (true)).SelectMany (index => booleanMatrix.Where (vector => vector.Count > index && vector [index])).Count () == booleanMatrix.Count);  	// Поскольку в колонках содержится по одной единице' то к строке можно прибавить только одну другую строку  	int n = booleanMatrix.Count;  	int macLane;  	try {  		/////////////////////////////////////////////////////  		// Использование параллельных вычислений CUDA  		// для расчёта целевой функции симплекс-метода  		Debug.Assert (CudafyMatrix.GetMatrix () != null);  		CudafyMatrix.SetIndexes (Enumerable.Range (0' n).ToArray ());  		CudafyMatrix.ExecuteMacLane ();  		macLane = CudafyMatrix.GetMacLane ();  		#if DEBUG  		int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  		Debug.WriteLine (string.Join (Environment.NewLine' arrayOfArray.Select (v => string.Join ("'"' v.Select (i => i.ToString ())))));  		#endif  	}  	catch (Exception ex) {  		if (WorkerLog != null)  			WorkerLog (ex.ToString ());  		///////////////////////////////////////////////////  		// Вычисление целевой функции обычным методом  		macLane = booleanMatrix.MacLane;  	}  	Debug.WriteLine ("macLane = " + macLane);  	Debug.WriteLine ("matrix:");  	Debug.WriteLine (booleanMatrix);  	int k = Math.Min (2' Math.Max (1' n));  	k = Math.Min (n' k);  	if (WorkerLog != null)  		WorkerLog ("Начало симплекс-метода");  	if (WorkerLog != null)  		WorkerLog ("Текущий macLane = " + macLane);  	for (bool updated = true; k <= n && updated && macLane > 0;) {  		Debug.Assert (booleanMatrix.Length == subGraph.Count ());  		List<int> values = Enumerable.Range (0' n).ToList ();  		updated = false;  		List<int> indexOfIndex = Enumerable.Range (n - k' k).ToList ();  		while (macLane > 0) {  			if (WorkerLog != null)  				WorkerLog (string.Format ("Перебираем индексы в позициях {0}"' string.Join ("'"' indexOfIndex.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  			CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (vector => vector.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  			List<int> indexes = values.ToList ();  			foreach (int index in indexOfIndex)  				indexes [index] = n - 1;  			while (macLane > 0) {  				Debug.Write (string.Format ("Проверяем индексы {0} ... "' string.Join ("'"' indexes.Select (index => index.ToString (CultureInfo.InvariantCulture)))));  				// Проверяем' что матрица образованная indexes является обратимой  				var detMatrix = new BooleanMatrix (indexes);  				if (detMatrix.Det ()) {  					BooleanMatrix matrix2;  					int macLane2 = 0;  					try {  						/////////////////////////////////////////////////////  						// Использование параллельных вычислений CUDA  						// для расчёта целевой функции симплекс-метода  						Debug.Assert (CudafyMatrix.GetMatrix () != null);  						CudafyMatrix.SetIndexes (indexes.ToArray ());  						CudafyMatrix.ExecuteMacLane ();  						macLane2 = CudafyMatrix.GetMacLane ();  						#if DEBUG  						CudafyMatrix.ExecuteUpdate ();  						int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  						matrix2 = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  						CudafyMatrix.SetMatrix (new ArrayOfArray<int> (booleanMatrix.Select (v => v.Select (b => b ? 1 : 0).ToArray ()).ToArray ()).ToTwoDimensional ());  						#endif  					}  					catch (Exception ex) {  						if (WorkerLog != null)  							WorkerLog (ex.ToString ());  						///////////////////////////////////////////////////  						// Вычисление целевой функции обычным методом  						Dictionary<int' int> dictionary = indexes.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  						matrix2 = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  						macLane2 = matrix2.MacLane;  					}  					finally {  						Debug.WriteLine ("macLane = " + macLane2);  					}  					if (macLane > macLane2) {  						if (WorkerLog != null)  							WorkerLog ("Найденое решение улучшилось ( " + macLane + " -> " + macLane2 + " )");  						Debug.WriteLine ("macLane: " + macLane + "->" + macLane2);  						values = indexes.ToList ();  						macLane = macLane2;  						updated = true;  						Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  						Debug.WriteLine ("matrix2:");  						Debug.WriteLine (matrix2);  					}  					if (macLane == 0)  						break;  				}  				else {  					Debug.WriteLine ("Матрица не обратима");  				}  				int i = k;  				while (i-- > 0)  					if (indexes [indexOfIndex [i]]-- > 0)  						break;  					else  						indexes [indexOfIndex [i]] = n - 1;  				if (i < 0)  					break;  			}  			int count = k;  			while (count-- > 0)  				if (indexOfIndex [count]-- > (count == 0 ? 0 : (indexOfIndex [count - 1] + 1)))  					break;  				else  					indexOfIndex [count] = (count == (k - 1) ? n - 1 : (indexOfIndex [count + 1] - 1));  			if (count < 0)  				break;  		}  		if (WorkerLog != null)  			WorkerLog ("Смена начальной точки симплекс-метода");  		try {  			/////////////////////////////////////////////////////  			// Использование параллельных вычислений CUDA  			// для смены базиса симплекс-метода  			Debug.Assert (CudafyMatrix.GetMatrix () != null);  			CudafyMatrix.SetIndexes (values.ToArray ());  			CudafyMatrix.ExecuteUpdate ();  			#if DEBUG  			int[][] arrayOfArray = new TwoDimensionalArray<int> (CudafyMatrix.GetMatrix ()).ToArrayOfArray ();  			booleanMatrix = new BooleanMatrix (arrayOfArray.Select (r => new BooleanVector (r.Select (c => c != 0))));  			#endif  		}  		catch (Exception ex) {  			if (WorkerLog != null)  				WorkerLog (ex.ToString ());  			///////////////////////////////////////////////////  			// Cмена базиса симплекс-метода обычным методом  			Dictionary<int' int> dictionary = values.Select ((item' value) => new KeyValuePair<int' int> (value' item)).ToDictionary (pair => pair.Key' pair => pair.Value);  			booleanMatrix = new BooleanMatrix (dictionary.Select (pair1 => dictionary.Where (pair2 => pair2.Value == pair1.Key && pair2.Key != pair1.Key).Select (pair => booleanMatrix [pair.Key]).Aggregate (booleanMatrix [pair1.Key]' BooleanVector.Xor)));  		}  		Debug.WriteLine (string.Join ("'"' values.Select (item => item.ToString ())));  		Debug.WriteLine ("matrix:");  		Debug.WriteLine (booleanMatrix);  	}  	if (macLane > 0) {  		if (WorkerLog != null)  			WorkerLog ("Не найдено нулевое значение фунции Мак-Лейна");  		if (WorkerLog != null)  			WorkerLog ("Граф не планарен");  		bool result = false;  		if (WorkerComplite != null)  			WorkerComplite (result);  		return result;  	}  }  
Magic Number,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,IsNonIntersected,The following statement contains a magic number: Debug.Assert (new StackListQueue<Vertex> {  	path1.First ()'  	path1.Last ()'  	path2.First ()'  	path2.Last ()'  }.Distinct ().Count () == 2);  
Magic Number,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,SplitBy,The following statement contains a magic number: try {  	int['] matrix;  	lock (CudafySequencies.Semaphore) {  		CudafySequencies.SetSequencies (segment.Select (GetInts).Select (item => item.ToArray ()).ToArray ()' GetRange (1' Count - 2).Select (GetInts).Select (item => item.ToArray ()).ToArray ());  		CudafySequencies.Execute ("Compare");  		matrix = CudafySequencies.GetMatrix ();  	}  	lock (CudafyMatrix.Semaphore) {  		CudafyMatrix.SetMatrix (matrix);  		CudafyMatrix.ExecuteRepeatZeroIndexOfZero ();  		indexes = new StackListQueue<int> (CudafyMatrix.GetIndexes ().Where (index => index >= 0).Select (index => index + 1));  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.ToString ());  	indexes = new StackListQueue<int> (GetRange (1' Count - 2).Intersect (segment).Select (v => IndexOf (v)));  }  
Magic Number,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,SplitBy,The following statement contains a magic number: try {  	int['] matrix;  	lock (CudafySequencies.Semaphore) {  		CudafySequencies.SetSequencies (segment.Select (GetInts).Select (item => item.ToArray ()).ToArray ()' GetRange (1' Count - 2).Select (GetInts).Select (item => item.ToArray ()).ToArray ());  		CudafySequencies.Execute ("Compare");  		matrix = CudafySequencies.GetMatrix ();  	}  	lock (CudafyMatrix.Semaphore) {  		CudafyMatrix.SetMatrix (matrix);  		CudafyMatrix.ExecuteRepeatZeroIndexOfZero ();  		indexes = new StackListQueue<int> (CudafyMatrix.GetIndexes ().Where (index => index >= 0).Select (index => index + 1));  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.ToString ());  	indexes = new StackListQueue<int> (GetRange (1' Count - 2).Intersect (segment).Select (v => IndexOf (v)));  }  
Magic Number,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,SplitBy,The following statement contains a magic number: lock (CudafySequencies.Semaphore) {  	CudafySequencies.SetSequencies (segment.Select (GetInts).Select (item => item.ToArray ()).ToArray ()' GetRange (1' Count - 2).Select (GetInts).Select (item => item.ToArray ()).ToArray ());  	CudafySequencies.Execute ("Compare");  	matrix = CudafySequencies.GetMatrix ();  }  
Magic Number,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,SplitBy,The following statement contains a magic number: CudafySequencies.SetSequencies (segment.Select (GetInts).Select (item => item.ToArray ()).ToArray ()' GetRange (1' Count - 2).Select (GetInts).Select (item => item.ToArray ()).ToArray ());  
Magic Number,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,SplitBy,The following statement contains a magic number: indexes = new StackListQueue<int> (GetRange (1' Count - 2).Intersect (segment).Select (v => IndexOf (v)));  
Magic Number,PlanarGraph.Data,Path,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Path.cs,IsLong,The following statement contains a magic number: return arg.Count > 2;  
Magic Number,PlanarGraph.Data,Edge,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Edge.cs,Split,The following statement contains a magic number: if (path.Count () < 2)  	return list;  
Magic Number,PlanarGraph.Data,Edge,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Edge.cs,Split,The following statement contains a magic number: if (index1 == index2) {  	// Вырожденый случай когда путь представляет собой цикл                  	// и пересечение с грань происходит только в одной точке                  	if (path.Count > 3)  		list.Add (new Edge (path.GetRange (0' path.Count - 1)));  	list.Add (this);  }  else {  	if (index1 > index2) {  		int t = index1;  		index1 = index2;  		index2 = t;  		vertexs.Reverse ();  	}  	List<Vertex> list1 = GetRange (0' index1);  	list1.AddRange (vertexs.GetRange (0' vertexs.Count - 1));  	list1.AddRange (GetRange (index2' this.Count () - index2));  	list.Add (new Edge (list1));  	vertexs.Reverse ();  	List<Vertex> list2 = GetRange (index1' index2 - index1);  	list2.AddRange (vertexs.GetRange (0' path.Count () - 1));  	list.Add (new Edge (list2));  }  
Magic Number,PlanarGraph.Data,Edge,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Edge.cs,Split,The following statement contains a magic number: if (path.Count > 3)  	list.Add (new Edge (path.GetRange (0' path.Count - 1)));  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,GetAllGraphPaths,The following statement contains a magic number: Parallel.ForEach (from i in Enumerable.Range (0' vertices.Count)  from j in Enumerable.Range (0' vertices.Count)  select new[] {  	i'  	j  }' pair =>  {  	int i = pair [0];  	int j = pair [1];  	KeyValuePair<Vertex' Vertex> key;  	PathCollection collection;  	lock (read)  		key = new KeyValuePair<Vertex' Vertex> (vertices.ElementAt (i)' vertices.ElementAt (j));  	lock (read)  		collection = prev [i' j];  	Dictionary<int' PathDictionary> dictionary1 = Enumerable.Range (2' vertices.Count).ToDictionary (len => len' len => new PathDictionary (key' new PathCollection (collection.Where (p => p.Count == len))));  	lock (write)  		dictionaries [i' j] = dictionary1;  });  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Random,The following statement contains a magic number: while (graph.Count < Math.Min (m' n * (n - 1) / 2)) {  	int i = random.Next () % n;  	int j = random.Next () % n;  	while (j == i)  		j = random.Next () % n;  	graph.Add (new Vertex (i)' new Vertex (j));  }  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,RemoveIntermedians,The following statement contains a magic number: for (Vertex v = Vertices.FirstOrDefault (vertex => this.Count (vertex.BelongsTo) == 2); v != null; v = Vertices.FirstOrDefault (vertex => this.Count (vertex.BelongsTo) == 2)) {  	var vv = new StackListQueue<Vertex> (this.Where (v.BelongsTo).SelectMany (s => s));  	vv.RemoveAll (v.Equals);  	RemoveAll (v.BelongsTo);  	Add (new Segment (vv));  }  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,RemoveIntermedians,The following statement contains a magic number: for (Vertex v = Vertices.FirstOrDefault (vertex => this.Count (vertex.BelongsTo) == 2); v != null; v = Vertices.FirstOrDefault (vertex => this.Count (vertex.BelongsTo) == 2)) {  	var vv = new StackListQueue<Vertex> (this.Where (v.BelongsTo).SelectMany (s => s));  	vv.RemoveAll (v.Equals);  	RemoveAll (v.BelongsTo);  	Add (new Segment (vv));  }  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,RemoveIntermedians,The following statement contains a magic number: v = Vertices.FirstOrDefault (vertex => this.Count (vertex.BelongsTo) == 2)
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The following statement contains a magic number: Debug.Assert (Count >= 2);  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The following statement contains a magic number: if (Settings.EnableCudafy)  	try {  		int['] matrix;  		lock (CudafySequencies.Semaphore) {  			CudafySequencies.SetSequencies (Vertices.Select (path.GetInts).Select (item => item.ToArray ()).ToArray ()' path.GetRange (1' Count - 2).Select (path.GetInts).Select (item => item.ToArray ()).ToArray ());  			CudafySequencies.Execute ("Compare");  			matrix = CudafySequencies.GetMatrix ();  		}  		lock (CudafyMatrix.Semaphore) {  			CudafyMatrix.SetMatrix (matrix);  			CudafyMatrix.ExecuteRepeatZeroIndexOfZero ();  			indexes = new StackListQueue<int> (CudafyMatrix.GetIndexes ().Where (index => index >= 0).Select (index => index + 1));  		}  	}  	catch (Exception ex) {  		Debug.WriteLine (ex.ToString ());  		indexes = new StackListQueue<int> (path.GetRange (1' Count - 2).Intersect (Vertices).Select (v => path.IndexOf (v)));  	}  else  	indexes = new StackListQueue<int> (path.GetRange (1' Count - 2).Intersect (Vertices).Select (v => path.IndexOf (v)));  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The following statement contains a magic number: if (Settings.EnableCudafy)  	try {  		int['] matrix;  		lock (CudafySequencies.Semaphore) {  			CudafySequencies.SetSequencies (Vertices.Select (path.GetInts).Select (item => item.ToArray ()).ToArray ()' path.GetRange (1' Count - 2).Select (path.GetInts).Select (item => item.ToArray ()).ToArray ());  			CudafySequencies.Execute ("Compare");  			matrix = CudafySequencies.GetMatrix ();  		}  		lock (CudafyMatrix.Semaphore) {  			CudafyMatrix.SetMatrix (matrix);  			CudafyMatrix.ExecuteRepeatZeroIndexOfZero ();  			indexes = new StackListQueue<int> (CudafyMatrix.GetIndexes ().Where (index => index >= 0).Select (index => index + 1));  		}  	}  	catch (Exception ex) {  		Debug.WriteLine (ex.ToString ());  		indexes = new StackListQueue<int> (path.GetRange (1' Count - 2).Intersect (Vertices).Select (v => path.IndexOf (v)));  	}  else  	indexes = new StackListQueue<int> (path.GetRange (1' Count - 2).Intersect (Vertices).Select (v => path.IndexOf (v)));  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The following statement contains a magic number: if (Settings.EnableCudafy)  	try {  		int['] matrix;  		lock (CudafySequencies.Semaphore) {  			CudafySequencies.SetSequencies (Vertices.Select (path.GetInts).Select (item => item.ToArray ()).ToArray ()' path.GetRange (1' Count - 2).Select (path.GetInts).Select (item => item.ToArray ()).ToArray ());  			CudafySequencies.Execute ("Compare");  			matrix = CudafySequencies.GetMatrix ();  		}  		lock (CudafyMatrix.Semaphore) {  			CudafyMatrix.SetMatrix (matrix);  			CudafyMatrix.ExecuteRepeatZeroIndexOfZero ();  			indexes = new StackListQueue<int> (CudafyMatrix.GetIndexes ().Where (index => index >= 0).Select (index => index + 1));  		}  	}  	catch (Exception ex) {  		Debug.WriteLine (ex.ToString ());  		indexes = new StackListQueue<int> (path.GetRange (1' Count - 2).Intersect (Vertices).Select (v => path.IndexOf (v)));  	}  else  	indexes = new StackListQueue<int> (path.GetRange (1' Count - 2).Intersect (Vertices).Select (v => path.IndexOf (v)));  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The following statement contains a magic number: try {  	int['] matrix;  	lock (CudafySequencies.Semaphore) {  		CudafySequencies.SetSequencies (Vertices.Select (path.GetInts).Select (item => item.ToArray ()).ToArray ()' path.GetRange (1' Count - 2).Select (path.GetInts).Select (item => item.ToArray ()).ToArray ());  		CudafySequencies.Execute ("Compare");  		matrix = CudafySequencies.GetMatrix ();  	}  	lock (CudafyMatrix.Semaphore) {  		CudafyMatrix.SetMatrix (matrix);  		CudafyMatrix.ExecuteRepeatZeroIndexOfZero ();  		indexes = new StackListQueue<int> (CudafyMatrix.GetIndexes ().Where (index => index >= 0).Select (index => index + 1));  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.ToString ());  	indexes = new StackListQueue<int> (path.GetRange (1' Count - 2).Intersect (Vertices).Select (v => path.IndexOf (v)));  }  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The following statement contains a magic number: try {  	int['] matrix;  	lock (CudafySequencies.Semaphore) {  		CudafySequencies.SetSequencies (Vertices.Select (path.GetInts).Select (item => item.ToArray ()).ToArray ()' path.GetRange (1' Count - 2).Select (path.GetInts).Select (item => item.ToArray ()).ToArray ());  		CudafySequencies.Execute ("Compare");  		matrix = CudafySequencies.GetMatrix ();  	}  	lock (CudafyMatrix.Semaphore) {  		CudafyMatrix.SetMatrix (matrix);  		CudafyMatrix.ExecuteRepeatZeroIndexOfZero ();  		indexes = new StackListQueue<int> (CudafyMatrix.GetIndexes ().Where (index => index >= 0).Select (index => index + 1));  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.ToString ());  	indexes = new StackListQueue<int> (path.GetRange (1' Count - 2).Intersect (Vertices).Select (v => path.IndexOf (v)));  }  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The following statement contains a magic number: lock (CudafySequencies.Semaphore) {  	CudafySequencies.SetSequencies (Vertices.Select (path.GetInts).Select (item => item.ToArray ()).ToArray ()' path.GetRange (1' Count - 2).Select (path.GetInts).Select (item => item.ToArray ()).ToArray ());  	CudafySequencies.Execute ("Compare");  	matrix = CudafySequencies.GetMatrix ();  }  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The following statement contains a magic number: CudafySequencies.SetSequencies (Vertices.Select (path.GetInts).Select (item => item.ToArray ()).ToArray ()' path.GetRange (1' Count - 2).Select (path.GetInts).Select (item => item.ToArray ()).ToArray ());  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The following statement contains a magic number: indexes = new StackListQueue<int> (path.GetRange (1' Count - 2).Intersect (Vertices).Select (v => path.IndexOf (v)));  
Magic Number,PlanarGraph.Data,Graph,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Data\Graph.cs,Split,The following statement contains a magic number: indexes = new StackListQueue<int> (path.GetRange (1' Count - 2).Intersect (Vertices).Select (v => path.IndexOf (v)));  
Duplicate Code,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The method contains a code clone-set at the following line numbers (starting from the method definition): ((139' 161)' (274' 296))
Duplicate Code,PlanarGraph.Algorithm,MacLaneAlgorithm,C:\repos\dprotopopov_PlanarGraph\PlanarGraph\Algorithm\MacLaneAlgorithm.cs,IsPlanar,The method contains a code clone-set at the following line numbers (starting from the method definition): ((191' 227)' (304' 340))
