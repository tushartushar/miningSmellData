Implementation smell,Namespace,Class,File,Method,Description
Long Method,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The method has 125 lines of code.
Complex Method,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,Cyclomatic complexity of the method is 12
Complex Method,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,Cyclomatic complexity of the method is 18
Complex Method,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseELFHeader,Cyclomatic complexity of the method is 9
Complex Method,TI.UtilLib.IO,FileIO,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\FileIO.cs,SetFileData,Cyclomatic complexity of the method is 8
Complex Method,TI.UtilLib.IO,FileIO,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\FileIO.cs,SetFileText,Cyclomatic complexity of the method is 8
Complex Method,out2rprc,Out2Rprc,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Out2Rprc.cs,Convert,Cyclomatic complexity of the method is 8
Long Statement,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSymbolTable,The length of the statement  "			throw new Exception ("Invalid auxNum (" + ((UInt32)symRef [symNum] ["auxNum"]) + ") detected for symbol " + symbols [symNum].name + "."); " is 137.
Long Statement,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,GetCOFFEndianness,The length of the statement  "				if ((val != (UInt16)COFF_Machine.CM_TI_C6000) && (val != (UInt16)COFF_Machine.CM_TI_ARM) && (val != (UInt16)COFF_Machine.CM_TI_MSP430)) { " is 137.
Long Statement,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The length of the statement  "	Debug.DebugMSG ("Section Header Table Index for Section Header String Table: " + (UInt32)headerRef ["stringHeaderTableIndex"]); " is 127.
Long Statement,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The length of the statement  "		if ((((UInt64)sectionRef [secNum] ["phyAddr"]) != 0) && (((UInt32)sectionRef [secNum] ["byteSize"]) != 0) && (ELF_SectionType.SHT_NULL != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_NOBITS != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_SYMTAB != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_DYNSYM != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_STRTAB != (ELF_SectionType)sectionRef [secNum] ["type"])) { " is 511.
Long Statement,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The length of the statement  "			if ((ELF_SectionType.SHT_PROGBITS == (ELF_SectionType)sectionRef [secNum] ["type"]) && ((flags | ((UInt64)ELF_SectionFlag.SHF_ALLOC)) != 0x0)) { " is 144.
Long Statement,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The length of the statement  "					if ((segmentHdr.p_filesz != 0) && (segmentHdr.p_vaddr <= (UInt64)secHdr.sh_addr) && ((segmentHdr.p_vaddr + segmentHdr.p_filesz) > (UInt64)secHdr.sh_addr) && (segmentHdr.p_offset <= (UInt64)secHdr.sh_offset) && ((segmentHdr.p_offset + segmentHdr.p_filesz) > (UInt64)secHdr.sh_offset)) { " is 285.
Long Statement,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSymbolTable,The length of the statement  "		ebr.BaseStream.Seek ((Int64)((UInt64)headerRef ["symbolTableAddr"]) + ((UInt32)headerRef ["symbolTableEntrySize"] * symNum)' SeekOrigin.Begin); " is 143.
Long Statement,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseELFHeader,The length of the statement  "		if ((0x7F != hdr.e_ident.magic [0]) || ('E' != hdr.e_ident.magic [1]) || ('L' != hdr.e_ident.magic [2]) || ('F' != hdr.e_ident.magic [3])) { " is 140.
Long Statement,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseELFHeader,The length of the statement  "		if ((ELF_DataEncoding.ELFDATA_2LSB != hdr.e_ident.dataEncoding) && (ELF_DataEncoding.ELFDATA_2MSB != hdr.e_ident.dataEncoding)) { " is 129.
Long Statement,TI.UtilLib.ObjectFile,ObjectFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ObjectFile.cs,ToString,The length of the statement  "			strBuilder.Append ("Sections[" + i + "]." + myFieldInfo [j].Name + " = " + myFieldInfo [j].GetValue (sections [i]) + "\n"); " is 123.
Long Statement,TI.UtilLib.ObjectFile,ObjectFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ObjectFile.cs,ToString,The length of the statement  "			strBuilder.Append ("Symbols[" + i + "]." + myFieldInfo [j].Name + " = " + myFieldInfo [j].GetValue (symbols [i]) + "\n"); " is 121.
Long Statement,out2rprc,Out2Rprc,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Out2Rprc.cs,Convert,The length of the statement  "				Console.WriteLine ("Warning: section in file " + input_file_name_2 + " starting at 0x" + section.loadAddr.ToString ("x8") + " overlaps with one or more sections in file " + input_file_name_1 + "."); " is 198.
Complex Conditional,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The conditional expression  "(((UInt64)sectionRef [secNum] ["phyAddr"]) != 0) && (((UInt32)sectionRef [secNum] ["byteSize"]) != 0) && (ELF_SectionType.SHT_NULL != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_NOBITS != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_SYMTAB != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_DYNSYM != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_STRTAB != (ELF_SectionType)sectionRef [secNum] ["type"])"  is complex.
Complex Conditional,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The conditional expression  "(segmentHdr.p_filesz != 0) && (segmentHdr.p_vaddr <= (UInt64)secHdr.sh_addr) && ((segmentHdr.p_vaddr + segmentHdr.p_filesz) > (UInt64)secHdr.sh_addr) && (segmentHdr.p_offset <= (UInt64)secHdr.sh_offset) && ((segmentHdr.p_offset + segmentHdr.p_filesz) > (UInt64)secHdr.sh_offset)"  is complex.
Complex Conditional,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseELFHeader,The conditional expression  "(0x7F != hdr.e_ident.magic [0]) || ('E' != hdr.e_ident.magic [1]) || ('L' != hdr.e_ident.magic [2]) || ('F' != hdr.e_ident.magic [3])"  is complex.
Complex Conditional,out2rprc,Out2Rprc,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Out2Rprc.cs,sectionOverlap,The conditional expression  "(s1 >= x1 && s1 <= x2) || (s2 >= x1 && s2 <= x2) || (s1 < x1 && s2 > x2)"  is complex.
Magic Number,TI.UtilLib.ObjectFile,BinaryFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\BinaryFile.cs,ParseBinaryFile,The following statement contains a magic number: sections [0].size = ((sections [0].size + 3) >> 2) << 2;  
Magic Number,TI.UtilLib.ObjectFile,BinaryFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\BinaryFile.cs,ParseBinaryFile,The following statement contains a magic number: sections [0].size = ((sections [0].size + 3) >> 2) << 2;  
Magic Number,TI.UtilLib.ObjectFile,BinaryFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\BinaryFile.cs,ParseBinaryFile,The following statement contains a magic number: sections [0].size = ((sections [0].size + 3) >> 2) << 2;  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: if (hdr.c_version == COFF_Version.COFF2) {  	numBytesInSectionHdr = 48;  }  else if (hdr.c_version == COFF_Version.COFF1) {  	numBytesInSectionHdr = 40;  }  else {  	numBytesInSectionHdr = 0;  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: if (hdr.c_version == COFF_Version.COFF2) {  	numBytesInSectionHdr = 48;  }  else if (hdr.c_version == COFF_Version.COFF1) {  	numBytesInSectionHdr = 40;  }  else {  	numBytesInSectionHdr = 0;  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: numBytesInSectionHdr = 48;  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: if (hdr.c_version == COFF_Version.COFF1) {  	numBytesInSectionHdr = 40;  }  else {  	numBytesInSectionHdr = 0;  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: numBytesInSectionHdr = 40;  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: for (UInt16 secNum = 0; secNum < sectionCount; secNum++) {  	sectionRef [secNum] = new Hashtable ();  	sections [secNum] = new ObjectSection ();  	ebr.BaseStream.Seek (numBytesInSectionHdr * secNum + COFFHeaderSize + hdr.c_ehsize' SeekOrigin.Begin);  	sections [secNum].name = COFF_getName ();  	ebr.BaseStream.Seek (numBytesInSectionHdr * secNum + COFFHeaderSize + hdr.c_ehsize + 8' SeekOrigin.Begin);  	sections [secNum].runAddr = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].loadAddr = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].size = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].size = ((sections [secNum].size + 3) >> 2) << 2;  	sections [secNum].binFileAddr = (UInt64)ebr.ReadUInt32 ();  	sectionRef [secNum] ["reloPtr"] = ebr.ReadUInt32 ();  	sectionRef [secNum] ["linePtr"] = ebr.ReadUInt32 ();  	if (hdr.c_version == COFF_Version.COFF2) {  		sectionRef [secNum].Add ("numRelos"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("numLines"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("flags"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("reserved"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("memPage"' (UInt32)ebr.ReadUInt16 ());  	}  	else {  		sectionRef [secNum].Add ("numRelos"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("numLines"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("flags"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("reserved"' (UInt32)ebr.ReadByte ());  		sectionRef [secNum].Add ("memPage"' (UInt32)ebr.ReadByte ());  	}  	//Check to see if section is bootable  	UInt32 flags = (UInt32)sectionRef [secNum] ["flags"];  	sectionRef [secNum] ["bootable"] = false;  	if ((flags & ((UInt32)(COFF_SectionType.TEXT | COFF_SectionType.DATA))) != 0) {  		if ((flags & ((UInt32)COFF_SectionType.COPY)) == 0) {  			if (sections [secNum].size != 0) {  				headerRef ["numBootSections"] = ((UInt32)headerRef ["numBootSections"]) + 1;  				sectionRef [secNum] ["bootable"] = true;  			}  		}  	}  	// Check to see if section is loadable  	sections [secNum].isLoadable = false;  	if ((sections [secNum].binFileAddr != 0) && (sections [secNum].size != 0)) {  		if ((flags & ((UInt32)(COFF_SectionType.BSS | // No BSS sections  		COFF_SectionType.COPY | // No COPY sections  		COFF_SectionType.NOLOAD | // No NOLOAD sections  		COFF_SectionType.DUMMY))// No DUMMY sections  		) == 0) {  			sections [secNum].isLoadable = true;  			loadableSectionCount++;  		}  	}  	Debug.DebugMSG ("ObjectSection sections[" + secNum + "] = \n{");  	Debug.DebugMSG ("\tname = " + sections [secNum].name + "'");  	Debug.DebugMSG ("\tsize = " + sections [secNum].size.ToString ("X8") + "'");  	Debug.DebugMSG ("\trunAddr = " + sections [secNum].runAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tloadAddr = " + sections [secNum].loadAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tisLoadable = " + sections [secNum].isLoadable + "'");  	Debug.DebugMSG ("\tbinFileAddr = " + sections [secNum].binFileAddr.ToString ("X8"));  	Debug.DebugMSG ("}");  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: for (UInt16 secNum = 0; secNum < sectionCount; secNum++) {  	sectionRef [secNum] = new Hashtable ();  	sections [secNum] = new ObjectSection ();  	ebr.BaseStream.Seek (numBytesInSectionHdr * secNum + COFFHeaderSize + hdr.c_ehsize' SeekOrigin.Begin);  	sections [secNum].name = COFF_getName ();  	ebr.BaseStream.Seek (numBytesInSectionHdr * secNum + COFFHeaderSize + hdr.c_ehsize + 8' SeekOrigin.Begin);  	sections [secNum].runAddr = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].loadAddr = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].size = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].size = ((sections [secNum].size + 3) >> 2) << 2;  	sections [secNum].binFileAddr = (UInt64)ebr.ReadUInt32 ();  	sectionRef [secNum] ["reloPtr"] = ebr.ReadUInt32 ();  	sectionRef [secNum] ["linePtr"] = ebr.ReadUInt32 ();  	if (hdr.c_version == COFF_Version.COFF2) {  		sectionRef [secNum].Add ("numRelos"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("numLines"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("flags"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("reserved"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("memPage"' (UInt32)ebr.ReadUInt16 ());  	}  	else {  		sectionRef [secNum].Add ("numRelos"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("numLines"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("flags"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("reserved"' (UInt32)ebr.ReadByte ());  		sectionRef [secNum].Add ("memPage"' (UInt32)ebr.ReadByte ());  	}  	//Check to see if section is bootable  	UInt32 flags = (UInt32)sectionRef [secNum] ["flags"];  	sectionRef [secNum] ["bootable"] = false;  	if ((flags & ((UInt32)(COFF_SectionType.TEXT | COFF_SectionType.DATA))) != 0) {  		if ((flags & ((UInt32)COFF_SectionType.COPY)) == 0) {  			if (sections [secNum].size != 0) {  				headerRef ["numBootSections"] = ((UInt32)headerRef ["numBootSections"]) + 1;  				sectionRef [secNum] ["bootable"] = true;  			}  		}  	}  	// Check to see if section is loadable  	sections [secNum].isLoadable = false;  	if ((sections [secNum].binFileAddr != 0) && (sections [secNum].size != 0)) {  		if ((flags & ((UInt32)(COFF_SectionType.BSS | // No BSS sections  		COFF_SectionType.COPY | // No COPY sections  		COFF_SectionType.NOLOAD | // No NOLOAD sections  		COFF_SectionType.DUMMY))// No DUMMY sections  		) == 0) {  			sections [secNum].isLoadable = true;  			loadableSectionCount++;  		}  	}  	Debug.DebugMSG ("ObjectSection sections[" + secNum + "] = \n{");  	Debug.DebugMSG ("\tname = " + sections [secNum].name + "'");  	Debug.DebugMSG ("\tsize = " + sections [secNum].size.ToString ("X8") + "'");  	Debug.DebugMSG ("\trunAddr = " + sections [secNum].runAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tloadAddr = " + sections [secNum].loadAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tisLoadable = " + sections [secNum].isLoadable + "'");  	Debug.DebugMSG ("\tbinFileAddr = " + sections [secNum].binFileAddr.ToString ("X8"));  	Debug.DebugMSG ("}");  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: for (UInt16 secNum = 0; secNum < sectionCount; secNum++) {  	sectionRef [secNum] = new Hashtable ();  	sections [secNum] = new ObjectSection ();  	ebr.BaseStream.Seek (numBytesInSectionHdr * secNum + COFFHeaderSize + hdr.c_ehsize' SeekOrigin.Begin);  	sections [secNum].name = COFF_getName ();  	ebr.BaseStream.Seek (numBytesInSectionHdr * secNum + COFFHeaderSize + hdr.c_ehsize + 8' SeekOrigin.Begin);  	sections [secNum].runAddr = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].loadAddr = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].size = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].size = ((sections [secNum].size + 3) >> 2) << 2;  	sections [secNum].binFileAddr = (UInt64)ebr.ReadUInt32 ();  	sectionRef [secNum] ["reloPtr"] = ebr.ReadUInt32 ();  	sectionRef [secNum] ["linePtr"] = ebr.ReadUInt32 ();  	if (hdr.c_version == COFF_Version.COFF2) {  		sectionRef [secNum].Add ("numRelos"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("numLines"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("flags"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("reserved"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("memPage"' (UInt32)ebr.ReadUInt16 ());  	}  	else {  		sectionRef [secNum].Add ("numRelos"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("numLines"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("flags"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("reserved"' (UInt32)ebr.ReadByte ());  		sectionRef [secNum].Add ("memPage"' (UInt32)ebr.ReadByte ());  	}  	//Check to see if section is bootable  	UInt32 flags = (UInt32)sectionRef [secNum] ["flags"];  	sectionRef [secNum] ["bootable"] = false;  	if ((flags & ((UInt32)(COFF_SectionType.TEXT | COFF_SectionType.DATA))) != 0) {  		if ((flags & ((UInt32)COFF_SectionType.COPY)) == 0) {  			if (sections [secNum].size != 0) {  				headerRef ["numBootSections"] = ((UInt32)headerRef ["numBootSections"]) + 1;  				sectionRef [secNum] ["bootable"] = true;  			}  		}  	}  	// Check to see if section is loadable  	sections [secNum].isLoadable = false;  	if ((sections [secNum].binFileAddr != 0) && (sections [secNum].size != 0)) {  		if ((flags & ((UInt32)(COFF_SectionType.BSS | // No BSS sections  		COFF_SectionType.COPY | // No COPY sections  		COFF_SectionType.NOLOAD | // No NOLOAD sections  		COFF_SectionType.DUMMY))// No DUMMY sections  		) == 0) {  			sections [secNum].isLoadable = true;  			loadableSectionCount++;  		}  	}  	Debug.DebugMSG ("ObjectSection sections[" + secNum + "] = \n{");  	Debug.DebugMSG ("\tname = " + sections [secNum].name + "'");  	Debug.DebugMSG ("\tsize = " + sections [secNum].size.ToString ("X8") + "'");  	Debug.DebugMSG ("\trunAddr = " + sections [secNum].runAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tloadAddr = " + sections [secNum].loadAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tisLoadable = " + sections [secNum].isLoadable + "'");  	Debug.DebugMSG ("\tbinFileAddr = " + sections [secNum].binFileAddr.ToString ("X8"));  	Debug.DebugMSG ("}");  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: for (UInt16 secNum = 0; secNum < sectionCount; secNum++) {  	sectionRef [secNum] = new Hashtable ();  	sections [secNum] = new ObjectSection ();  	ebr.BaseStream.Seek (numBytesInSectionHdr * secNum + COFFHeaderSize + hdr.c_ehsize' SeekOrigin.Begin);  	sections [secNum].name = COFF_getName ();  	ebr.BaseStream.Seek (numBytesInSectionHdr * secNum + COFFHeaderSize + hdr.c_ehsize + 8' SeekOrigin.Begin);  	sections [secNum].runAddr = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].loadAddr = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].size = (UInt64)ebr.ReadUInt32 ();  	sections [secNum].size = ((sections [secNum].size + 3) >> 2) << 2;  	sections [secNum].binFileAddr = (UInt64)ebr.ReadUInt32 ();  	sectionRef [secNum] ["reloPtr"] = ebr.ReadUInt32 ();  	sectionRef [secNum] ["linePtr"] = ebr.ReadUInt32 ();  	if (hdr.c_version == COFF_Version.COFF2) {  		sectionRef [secNum].Add ("numRelos"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("numLines"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("flags"' ebr.ReadUInt32 ());  		sectionRef [secNum].Add ("reserved"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("memPage"' (UInt32)ebr.ReadUInt16 ());  	}  	else {  		sectionRef [secNum].Add ("numRelos"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("numLines"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("flags"' (UInt32)ebr.ReadUInt16 ());  		sectionRef [secNum].Add ("reserved"' (UInt32)ebr.ReadByte ());  		sectionRef [secNum].Add ("memPage"' (UInt32)ebr.ReadByte ());  	}  	//Check to see if section is bootable  	UInt32 flags = (UInt32)sectionRef [secNum] ["flags"];  	sectionRef [secNum] ["bootable"] = false;  	if ((flags & ((UInt32)(COFF_SectionType.TEXT | COFF_SectionType.DATA))) != 0) {  		if ((flags & ((UInt32)COFF_SectionType.COPY)) == 0) {  			if (sections [secNum].size != 0) {  				headerRef ["numBootSections"] = ((UInt32)headerRef ["numBootSections"]) + 1;  				sectionRef [secNum] ["bootable"] = true;  			}  		}  	}  	// Check to see if section is loadable  	sections [secNum].isLoadable = false;  	if ((sections [secNum].binFileAddr != 0) && (sections [secNum].size != 0)) {  		if ((flags & ((UInt32)(COFF_SectionType.BSS | // No BSS sections  		COFF_SectionType.COPY | // No COPY sections  		COFF_SectionType.NOLOAD | // No NOLOAD sections  		COFF_SectionType.DUMMY))// No DUMMY sections  		) == 0) {  			sections [secNum].isLoadable = true;  			loadableSectionCount++;  		}  	}  	Debug.DebugMSG ("ObjectSection sections[" + secNum + "] = \n{");  	Debug.DebugMSG ("\tname = " + sections [secNum].name + "'");  	Debug.DebugMSG ("\tsize = " + sections [secNum].size.ToString ("X8") + "'");  	Debug.DebugMSG ("\trunAddr = " + sections [secNum].runAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tloadAddr = " + sections [secNum].loadAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tisLoadable = " + sections [secNum].isLoadable + "'");  	Debug.DebugMSG ("\tbinFileAddr = " + sections [secNum].binFileAddr.ToString ("X8"));  	Debug.DebugMSG ("}");  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: ebr.BaseStream.Seek (numBytesInSectionHdr * secNum + COFFHeaderSize + hdr.c_ehsize + 8' SeekOrigin.Begin);  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: sections [secNum].size = ((sections [secNum].size + 3) >> 2) << 2;  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: sections [secNum].size = ((sections [secNum].size + 3) >> 2) << 2;  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSectionHdrs,The following statement contains a magic number: sections [secNum].size = ((sections [secNum].size + 3) >> 2) << 2;  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSymbolTable,The following statement contains a magic number: for (UInt32 symNum = 0; symNum < symbolCount; symNum++) {  	symRef [symNum] = new Hashtable ();  	symbols [symNum] = new ObjectSymbol ();  	Debug.DebugMSG ("symbols[" + symNum + "] = \n{");  	ebr.BaseStream.Seek ((UInt32)currSymbolTableEntryFileAddr' SeekOrigin.Begin);  	symbols [symNum].name = COFF_getName ();  	Debug.DebugMSG ("\tname = " + symbols [symNum].name);  	ebr.BaseStream.Seek ((UInt32)currSymbolTableEntryFileAddr + 8' SeekOrigin.Begin);  	symbols [symNum].value = (UInt64)ebr.ReadUInt32 ();  	Debug.DebugMSG ("\tvalue = " + symbols [symNum].value.ToString ("X8") + "'");  	symRef [symNum] ["secNum"] = (Int32)ebr.ReadInt16 ();  	symRef [symNum] ["type"] = (UInt32)ebr.ReadUInt16 ();  	symRef [symNum] ["class"] = (UInt32)ebr.ReadByte ();  	symRef [symNum] ["auxNum"] = (UInt32)ebr.ReadByte ();  	Debug.DebugMSG ("\tsecNum = " + ((Int32)symRef [symNum] ["secNum"]).ToString ());  	Debug.DebugMSG ("\ttype   = " + ((UInt32)symRef [symNum] ["type"]).ToString ("X4"));  	Debug.DebugMSG ("\tclass  = " + ((UInt32)symRef [symNum] ["class"]).ToString ());  	Debug.DebugMSG ("\tauxNum = " + ((UInt32)symRef [symNum] ["auxNum"]).ToString ("X2"));  	// Check to make sure auxNum is either 0 or 1  	if ((((UInt32)symRef [symNum] ["auxNum"]) != 0) && (((UInt32)symRef [symNum] ["auxNum"]) != 1)) {  		throw new Exception ("Invalid auxNum (" + ((UInt32)symRef [symNum] ["auxNum"]) + ") detected for symbol " + symbols [symNum].name + ".");  	}  	if (((UInt32)symRef [symNum] ["auxNum"]) != 0) {  		currSymbolTableEntryFileAddr += 2 * symbolTableEntrySize;  		symNum++;  		symRef [symNum] = null;  		symbols [symNum] = new ObjectSymbol ();  		symbols [symNum].name = "";  		symbols [symNum].value = symbols [symNum - 1].value;  		Debug.DebugMSG ("\tsectionLength       = " + (UInt32)ebr.ReadInt32 ());  		Debug.DebugMSG ("\tnumRelocEntries     = " + (UInt32)ebr.ReadUInt16 ());  		Debug.DebugMSG ("\tnumLineNumberntries = " + (UInt32)ebr.ReadUInt16 ());  	}  	else {  		currSymbolTableEntryFileAddr += symbolTableEntrySize;  	}  	Debug.DebugMSG ("}");  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSymbolTable,The following statement contains a magic number: for (UInt32 symNum = 0; symNum < symbolCount; symNum++) {  	symRef [symNum] = new Hashtable ();  	symbols [symNum] = new ObjectSymbol ();  	Debug.DebugMSG ("symbols[" + symNum + "] = \n{");  	ebr.BaseStream.Seek ((UInt32)currSymbolTableEntryFileAddr' SeekOrigin.Begin);  	symbols [symNum].name = COFF_getName ();  	Debug.DebugMSG ("\tname = " + symbols [symNum].name);  	ebr.BaseStream.Seek ((UInt32)currSymbolTableEntryFileAddr + 8' SeekOrigin.Begin);  	symbols [symNum].value = (UInt64)ebr.ReadUInt32 ();  	Debug.DebugMSG ("\tvalue = " + symbols [symNum].value.ToString ("X8") + "'");  	symRef [symNum] ["secNum"] = (Int32)ebr.ReadInt16 ();  	symRef [symNum] ["type"] = (UInt32)ebr.ReadUInt16 ();  	symRef [symNum] ["class"] = (UInt32)ebr.ReadByte ();  	symRef [symNum] ["auxNum"] = (UInt32)ebr.ReadByte ();  	Debug.DebugMSG ("\tsecNum = " + ((Int32)symRef [symNum] ["secNum"]).ToString ());  	Debug.DebugMSG ("\ttype   = " + ((UInt32)symRef [symNum] ["type"]).ToString ("X4"));  	Debug.DebugMSG ("\tclass  = " + ((UInt32)symRef [symNum] ["class"]).ToString ());  	Debug.DebugMSG ("\tauxNum = " + ((UInt32)symRef [symNum] ["auxNum"]).ToString ("X2"));  	// Check to make sure auxNum is either 0 or 1  	if ((((UInt32)symRef [symNum] ["auxNum"]) != 0) && (((UInt32)symRef [symNum] ["auxNum"]) != 1)) {  		throw new Exception ("Invalid auxNum (" + ((UInt32)symRef [symNum] ["auxNum"]) + ") detected for symbol " + symbols [symNum].name + ".");  	}  	if (((UInt32)symRef [symNum] ["auxNum"]) != 0) {  		currSymbolTableEntryFileAddr += 2 * symbolTableEntrySize;  		symNum++;  		symRef [symNum] = null;  		symbols [symNum] = new ObjectSymbol ();  		symbols [symNum].name = "";  		symbols [symNum].value = symbols [symNum - 1].value;  		Debug.DebugMSG ("\tsectionLength       = " + (UInt32)ebr.ReadInt32 ());  		Debug.DebugMSG ("\tnumRelocEntries     = " + (UInt32)ebr.ReadUInt16 ());  		Debug.DebugMSG ("\tnumLineNumberntries = " + (UInt32)ebr.ReadUInt16 ());  	}  	else {  		currSymbolTableEntryFileAddr += symbolTableEntrySize;  	}  	Debug.DebugMSG ("}");  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSymbolTable,The following statement contains a magic number: ebr.BaseStream.Seek ((UInt32)currSymbolTableEntryFileAddr + 8' SeekOrigin.Begin);  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSymbolTable,The following statement contains a magic number: if (((UInt32)symRef [symNum] ["auxNum"]) != 0) {  	currSymbolTableEntryFileAddr += 2 * symbolTableEntrySize;  	symNum++;  	symRef [symNum] = null;  	symbols [symNum] = new ObjectSymbol ();  	symbols [symNum].name = "";  	symbols [symNum].value = symbols [symNum - 1].value;  	Debug.DebugMSG ("\tsectionLength       = " + (UInt32)ebr.ReadInt32 ());  	Debug.DebugMSG ("\tnumRelocEntries     = " + (UInt32)ebr.ReadUInt16 ());  	Debug.DebugMSG ("\tnumLineNumberntries = " + (UInt32)ebr.ReadUInt16 ());  }  else {  	currSymbolTableEntryFileAddr += symbolTableEntrySize;  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,ParseSymbolTable,The following statement contains a magic number: currSymbolTableEntryFileAddr += 2 * symbolTableEntrySize;  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,COFF_getName,The following statement contains a magic number: if (int0 == 0x00000000) {  	if ((int1 + stringTableFileAddr) > binFile.Length) {  		Console.WriteLine ("WARNING: Symbol name's offset in string table is beyond EOF! Returning NULL.\n");  	}  	else {  		ebr.BaseStream.Seek ((int1 + (UInt32)stringTableFileAddr)' SeekOrigin.Begin);  		// Read characters and build string until terminating null  		currByte = ebr.ReadByte ();  		while (currByte != 0) {  			name.Add (currByte);  			currByte = ebr.ReadByte ();  		}  	}  }  else {  	// Read characters straight from string table and build string until terminating null  	currByte = ebr.ReadByte ();  	while ((currByte != 0) && (name.Count < 8)) {  		name.Add (currByte);  		currByte = ebr.ReadByte ();  	}  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,COFF_getName,The following statement contains a magic number: while ((currByte != 0) && (name.Count < 8)) {  	name.Add (currByte);  	currByte = ebr.ReadByte ();  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,COFF_getName,The following statement contains a magic number: if (name.Count > 128) {  	Debug.DebugMSG (ASCIIEncoding.ASCII.GetString ((Byte[])name.ToArray (typeof(Byte))' 0' name.Count));  }  
Magic Number,TI.UtilLib.ObjectFile,CoffFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\CoffFile.cs,GetCOFFEndianness,The following statement contains a magic number: fs.Seek (20' SeekOrigin.Begin);  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The following statement contains a magic number: for (UInt32 secNum = 0; secNum < sectionCount; secNum++) {  	sectionRef [secNum] = new Hashtable ();  	sections [secNum] = new ObjectSection ();  	secHdr = ReadSectionHeader ((UInt32)secNum);  	ebr.BaseStream.Seek ((Int64)(secHdr.sh_name + (UInt64)headerRef ["stringTableAddr"])' SeekOrigin.Begin);  	sectionRef [secNum] ["name"] = ELF_getStringFromStringTable ();  	sectionRef [secNum] ["type"] = (ELF_SectionType)secHdr.sh_type;  	sectionRef [secNum] ["phyAddr"] = (UInt64)secHdr.sh_addr;  	sectionRef [secNum] ["virAddr"] = (UInt64)secHdr.sh_addr;  	sectionRef [secNum] ["fileAddr"] = (UInt64)secHdr.sh_offset;  	byteSize = (UInt32)secHdr.sh_size;  	wordSize = (byteSize + 3) >> 2;  	byteSize = wordSize << 2;  	sectionRef [secNum] ["byteSize"] = byteSize;  	sectionRef [secNum] ["wordSize"] = wordSize;  	sectionRef [secNum] ["flags"] = (UInt64)secHdr.sh_flags;  	flags = (UInt64)sectionRef [secNum] ["flags"];  	// FIXME: Check to see if section should be copied to target  	sectionRef [secNum] ["copyToTarget"] = false;  	if ((((UInt64)sectionRef [secNum] ["phyAddr"]) != 0) && (((UInt32)sectionRef [secNum] ["byteSize"]) != 0) && (ELF_SectionType.SHT_NULL != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_NOBITS != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_SYMTAB != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_DYNSYM != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_STRTAB != (ELF_SectionType)sectionRef [secNum] ["type"])) {  		if ((ELF_SectionType.SHT_PROGBITS == (ELF_SectionType)sectionRef [secNum] ["type"]) && ((flags | ((UInt64)ELF_SectionFlag.SHF_ALLOC)) != 0x0)) {  			headerRef ["numTargetSections"] = ((UInt32)headerRef ["numTargetSections"]) + 1;  			sectionRef [secNum] ["copyToTarget"] = true;  		}  	}  	// If we think this section should be copied to target' make sure it is   	// in a loadable ELF program segment.  If it is' then update physical   	// and virtual addresses. If not' then mark it as such.  	if ((Boolean)sectionRef [secNum] ["copyToTarget"]) {  		Boolean segmentFoundForSection = false;  		for (UInt32 segmentNum = 0; segmentNum < (UInt32)hdr.e_phnum; segmentNum++) {  			ELF_SegmentHeader segmentHdr = ReadSegmentHeader ((UInt32)segmentNum);  			// If the segment is of load type' check to see if the current section resides in it  			if (segmentHdr.p_type == ELF_SegmentType.PT_LOAD) {  				// Check if data is in the file' and if so then check if the section  				// is within this current segment  				if ((segmentHdr.p_filesz != 0) && (segmentHdr.p_vaddr <= (UInt64)secHdr.sh_addr) && ((segmentHdr.p_vaddr + segmentHdr.p_filesz) > (UInt64)secHdr.sh_addr) && (segmentHdr.p_offset <= (UInt64)secHdr.sh_offset) && ((segmentHdr.p_offset + segmentHdr.p_filesz) > (UInt64)secHdr.sh_offset)) {  					sectionRef [secNum] ["phyAddr"] = (UInt64)segmentHdr.p_paddr + (secHdr.sh_addr - segmentHdr.p_vaddr);  					segmentFoundForSection = true;  				}  			}  		}  		if (!segmentFoundForSection) {  			// This section is not actually in a loadable ELF program segment' indicate that  			sectionRef [secNum] ["copyToTarget"] = false;  		}  	}  	sections [secNum].name = (String)sectionRef [secNum] ["name"];  	sections [secNum].size = (UInt32)sectionRef [secNum] ["byteSize"];  	sections [secNum].runAddr = (UInt64)sectionRef [secNum] ["virAddr"];  	sections [secNum].loadAddr = (UInt64)sectionRef [secNum] ["phyAddr"];  	sections [secNum].isLoadable = (Boolean)sectionRef [secNum] ["copyToTarget"];  	if (sections [secNum].isLoadable) {  		loadableSectionCount++;  	}  	sections [secNum].binFileAddr = (UInt64)sectionRef [secNum] ["fileAddr"];  	Debug.DebugMSG ("ObjectSection sections[" + secNum + "] = \n{");  	Debug.DebugMSG ("\tname = " + sections [secNum].name + "'");  	Debug.DebugMSG ("\tsize = " + sections [secNum].size.ToString ("X8") + "'");  	Debug.DebugMSG ("\trunAddr = " + sections [secNum].runAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tloadAddr = " + sections [secNum].loadAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tisLoadable = " + sections [secNum].isLoadable + "'");  	Debug.DebugMSG ("\tbinFileAddr = " + sections [secNum].binFileAddr.ToString ("X8"));  	Debug.DebugMSG ("}");  }  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The following statement contains a magic number: for (UInt32 secNum = 0; secNum < sectionCount; secNum++) {  	sectionRef [secNum] = new Hashtable ();  	sections [secNum] = new ObjectSection ();  	secHdr = ReadSectionHeader ((UInt32)secNum);  	ebr.BaseStream.Seek ((Int64)(secHdr.sh_name + (UInt64)headerRef ["stringTableAddr"])' SeekOrigin.Begin);  	sectionRef [secNum] ["name"] = ELF_getStringFromStringTable ();  	sectionRef [secNum] ["type"] = (ELF_SectionType)secHdr.sh_type;  	sectionRef [secNum] ["phyAddr"] = (UInt64)secHdr.sh_addr;  	sectionRef [secNum] ["virAddr"] = (UInt64)secHdr.sh_addr;  	sectionRef [secNum] ["fileAddr"] = (UInt64)secHdr.sh_offset;  	byteSize = (UInt32)secHdr.sh_size;  	wordSize = (byteSize + 3) >> 2;  	byteSize = wordSize << 2;  	sectionRef [secNum] ["byteSize"] = byteSize;  	sectionRef [secNum] ["wordSize"] = wordSize;  	sectionRef [secNum] ["flags"] = (UInt64)secHdr.sh_flags;  	flags = (UInt64)sectionRef [secNum] ["flags"];  	// FIXME: Check to see if section should be copied to target  	sectionRef [secNum] ["copyToTarget"] = false;  	if ((((UInt64)sectionRef [secNum] ["phyAddr"]) != 0) && (((UInt32)sectionRef [secNum] ["byteSize"]) != 0) && (ELF_SectionType.SHT_NULL != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_NOBITS != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_SYMTAB != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_DYNSYM != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_STRTAB != (ELF_SectionType)sectionRef [secNum] ["type"])) {  		if ((ELF_SectionType.SHT_PROGBITS == (ELF_SectionType)sectionRef [secNum] ["type"]) && ((flags | ((UInt64)ELF_SectionFlag.SHF_ALLOC)) != 0x0)) {  			headerRef ["numTargetSections"] = ((UInt32)headerRef ["numTargetSections"]) + 1;  			sectionRef [secNum] ["copyToTarget"] = true;  		}  	}  	// If we think this section should be copied to target' make sure it is   	// in a loadable ELF program segment.  If it is' then update physical   	// and virtual addresses. If not' then mark it as such.  	if ((Boolean)sectionRef [secNum] ["copyToTarget"]) {  		Boolean segmentFoundForSection = false;  		for (UInt32 segmentNum = 0; segmentNum < (UInt32)hdr.e_phnum; segmentNum++) {  			ELF_SegmentHeader segmentHdr = ReadSegmentHeader ((UInt32)segmentNum);  			// If the segment is of load type' check to see if the current section resides in it  			if (segmentHdr.p_type == ELF_SegmentType.PT_LOAD) {  				// Check if data is in the file' and if so then check if the section  				// is within this current segment  				if ((segmentHdr.p_filesz != 0) && (segmentHdr.p_vaddr <= (UInt64)secHdr.sh_addr) && ((segmentHdr.p_vaddr + segmentHdr.p_filesz) > (UInt64)secHdr.sh_addr) && (segmentHdr.p_offset <= (UInt64)secHdr.sh_offset) && ((segmentHdr.p_offset + segmentHdr.p_filesz) > (UInt64)secHdr.sh_offset)) {  					sectionRef [secNum] ["phyAddr"] = (UInt64)segmentHdr.p_paddr + (secHdr.sh_addr - segmentHdr.p_vaddr);  					segmentFoundForSection = true;  				}  			}  		}  		if (!segmentFoundForSection) {  			// This section is not actually in a loadable ELF program segment' indicate that  			sectionRef [secNum] ["copyToTarget"] = false;  		}  	}  	sections [secNum].name = (String)sectionRef [secNum] ["name"];  	sections [secNum].size = (UInt32)sectionRef [secNum] ["byteSize"];  	sections [secNum].runAddr = (UInt64)sectionRef [secNum] ["virAddr"];  	sections [secNum].loadAddr = (UInt64)sectionRef [secNum] ["phyAddr"];  	sections [secNum].isLoadable = (Boolean)sectionRef [secNum] ["copyToTarget"];  	if (sections [secNum].isLoadable) {  		loadableSectionCount++;  	}  	sections [secNum].binFileAddr = (UInt64)sectionRef [secNum] ["fileAddr"];  	Debug.DebugMSG ("ObjectSection sections[" + secNum + "] = \n{");  	Debug.DebugMSG ("\tname = " + sections [secNum].name + "'");  	Debug.DebugMSG ("\tsize = " + sections [secNum].size.ToString ("X8") + "'");  	Debug.DebugMSG ("\trunAddr = " + sections [secNum].runAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tloadAddr = " + sections [secNum].loadAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tisLoadable = " + sections [secNum].isLoadable + "'");  	Debug.DebugMSG ("\tbinFileAddr = " + sections [secNum].binFileAddr.ToString ("X8"));  	Debug.DebugMSG ("}");  }  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The following statement contains a magic number: for (UInt32 secNum = 0; secNum < sectionCount; secNum++) {  	sectionRef [secNum] = new Hashtable ();  	sections [secNum] = new ObjectSection ();  	secHdr = ReadSectionHeader ((UInt32)secNum);  	ebr.BaseStream.Seek ((Int64)(secHdr.sh_name + (UInt64)headerRef ["stringTableAddr"])' SeekOrigin.Begin);  	sectionRef [secNum] ["name"] = ELF_getStringFromStringTable ();  	sectionRef [secNum] ["type"] = (ELF_SectionType)secHdr.sh_type;  	sectionRef [secNum] ["phyAddr"] = (UInt64)secHdr.sh_addr;  	sectionRef [secNum] ["virAddr"] = (UInt64)secHdr.sh_addr;  	sectionRef [secNum] ["fileAddr"] = (UInt64)secHdr.sh_offset;  	byteSize = (UInt32)secHdr.sh_size;  	wordSize = (byteSize + 3) >> 2;  	byteSize = wordSize << 2;  	sectionRef [secNum] ["byteSize"] = byteSize;  	sectionRef [secNum] ["wordSize"] = wordSize;  	sectionRef [secNum] ["flags"] = (UInt64)secHdr.sh_flags;  	flags = (UInt64)sectionRef [secNum] ["flags"];  	// FIXME: Check to see if section should be copied to target  	sectionRef [secNum] ["copyToTarget"] = false;  	if ((((UInt64)sectionRef [secNum] ["phyAddr"]) != 0) && (((UInt32)sectionRef [secNum] ["byteSize"]) != 0) && (ELF_SectionType.SHT_NULL != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_NOBITS != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_SYMTAB != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_DYNSYM != (ELF_SectionType)sectionRef [secNum] ["type"]) && (ELF_SectionType.SHT_STRTAB != (ELF_SectionType)sectionRef [secNum] ["type"])) {  		if ((ELF_SectionType.SHT_PROGBITS == (ELF_SectionType)sectionRef [secNum] ["type"]) && ((flags | ((UInt64)ELF_SectionFlag.SHF_ALLOC)) != 0x0)) {  			headerRef ["numTargetSections"] = ((UInt32)headerRef ["numTargetSections"]) + 1;  			sectionRef [secNum] ["copyToTarget"] = true;  		}  	}  	// If we think this section should be copied to target' make sure it is   	// in a loadable ELF program segment.  If it is' then update physical   	// and virtual addresses. If not' then mark it as such.  	if ((Boolean)sectionRef [secNum] ["copyToTarget"]) {  		Boolean segmentFoundForSection = false;  		for (UInt32 segmentNum = 0; segmentNum < (UInt32)hdr.e_phnum; segmentNum++) {  			ELF_SegmentHeader segmentHdr = ReadSegmentHeader ((UInt32)segmentNum);  			// If the segment is of load type' check to see if the current section resides in it  			if (segmentHdr.p_type == ELF_SegmentType.PT_LOAD) {  				// Check if data is in the file' and if so then check if the section  				// is within this current segment  				if ((segmentHdr.p_filesz != 0) && (segmentHdr.p_vaddr <= (UInt64)secHdr.sh_addr) && ((segmentHdr.p_vaddr + segmentHdr.p_filesz) > (UInt64)secHdr.sh_addr) && (segmentHdr.p_offset <= (UInt64)secHdr.sh_offset) && ((segmentHdr.p_offset + segmentHdr.p_filesz) > (UInt64)secHdr.sh_offset)) {  					sectionRef [secNum] ["phyAddr"] = (UInt64)segmentHdr.p_paddr + (secHdr.sh_addr - segmentHdr.p_vaddr);  					segmentFoundForSection = true;  				}  			}  		}  		if (!segmentFoundForSection) {  			// This section is not actually in a loadable ELF program segment' indicate that  			sectionRef [secNum] ["copyToTarget"] = false;  		}  	}  	sections [secNum].name = (String)sectionRef [secNum] ["name"];  	sections [secNum].size = (UInt32)sectionRef [secNum] ["byteSize"];  	sections [secNum].runAddr = (UInt64)sectionRef [secNum] ["virAddr"];  	sections [secNum].loadAddr = (UInt64)sectionRef [secNum] ["phyAddr"];  	sections [secNum].isLoadable = (Boolean)sectionRef [secNum] ["copyToTarget"];  	if (sections [secNum].isLoadable) {  		loadableSectionCount++;  	}  	sections [secNum].binFileAddr = (UInt64)sectionRef [secNum] ["fileAddr"];  	Debug.DebugMSG ("ObjectSection sections[" + secNum + "] = \n{");  	Debug.DebugMSG ("\tname = " + sections [secNum].name + "'");  	Debug.DebugMSG ("\tsize = " + sections [secNum].size.ToString ("X8") + "'");  	Debug.DebugMSG ("\trunAddr = " + sections [secNum].runAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tloadAddr = " + sections [secNum].loadAddr.ToString ("X8") + "'");  	Debug.DebugMSG ("\tisLoadable = " + sections [secNum].isLoadable + "'");  	Debug.DebugMSG ("\tbinFileAddr = " + sections [secNum].binFileAddr.ToString ("X8"));  	Debug.DebugMSG ("}");  }  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The following statement contains a magic number: wordSize = (byteSize + 3) >> 2;  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The following statement contains a magic number: wordSize = (byteSize + 3) >> 2;  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSectionHdrs,The following statement contains a magic number: byteSize = wordSize << 2;  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSymbolTable,The following statement contains a magic number: for (UInt32 symNum = 0; symNum < symbolCount; symNum++) {  	symRef [symNum] = new Hashtable ();  	symbols [symNum] = new ObjectSymbol ();  	// Go to current symbol  	ebr.BaseStream.Seek ((Int64)((UInt64)headerRef ["symbolTableAddr"]) + ((UInt32)headerRef ["symbolTableEntrySize"] * symNum)' SeekOrigin.Begin);  	sym.st_name = (UInt32)ebr.ReadUInt32 ();  	if (ELF_FileClass.ELFCLASS_32 == hdr.e_ident.fileClass) {  		sym.st_value = (UInt64)ebr.ReadUInt32 ();  		sym.st_size = (UInt64)ebr.ReadUInt32 ();  		info = ebr.ReadByte ();  		other = ebr.ReadByte ();  		sym.st_shndx = ebr.ReadUInt16 ();  	}  	else {  		info = ebr.ReadByte ();  		other = ebr.ReadByte ();  		sym.st_shndx = ebr.ReadUInt16 ();  		sym.st_value = ebr.ReadUInt64 ();  		sym.st_size = ebr.ReadUInt64 ();  	}  	sym.st_type = (ELF_SymbolType)(info & 0xF);  	sym.st_binding = (ELF_SymbolBinding)((info >> 4) & 0xF);  	sym.st_visibility = (ELF_SymbolVisibility)(other & 0x3);  	/*         Debug.DebugMSG( "Symbol[" + symNum + "] = \n{" );         Debug.DebugMSG( "  Symbol Name Offset        : 0x" + sym.st_name.ToString("X8"));                 Debug.DebugMSG( "  Symbol Value              : 0x" + sym.st_value.ToString("X16"));         Debug.DebugMSG( "  Symbol Size               : 0x" + sym.st_size.ToString("X16"));         Debug.DebugMSG( "  Symbol Type               : "   + sym.st_type);         Debug.DebugMSG( "  Symbol Binding            : "   + sym.st_binding);         Debug.DebugMSG( "  Symbol Visibility         : "   + sym.st_visibility);         Debug.DebugMSG( "  Symbol's Relevant Section : 0x" + sym.st_shndx.ToString("X4"));         Debug.DebugMSG( "}\n");         */// Move to name in String Table  	ebr.BaseStream.Seek ((Int64)((UInt64)headerRef ["stringTableAddr"]) + (sym.st_name)' SeekOrigin.Begin);  	symRef [symNum] ["name"] = ELF_getStringFromStringTable ();  	symRef [symNum] ["value"] = sym.st_value;  	symRef [symNum] ["secNum"] = sym.st_shndx;  	symRef [symNum] ["type"] = sym.st_type;  	symRef [symNum] ["binding"] = sym.st_binding;  	symRef [symNum] ["visibility"] = sym.st_visibility;  	symbols [symNum].name = (String)symRef [symNum] ["name"];  	symbols [symNum].value = (UInt64)symRef [symNum] ["value"];  	Debug.DebugMSG ("symbols[" + symNum + "] = {");  	Debug.DebugMSG ("\tname = " + symbols [symNum].name + "'");  	Debug.DebugMSG ("\tvalue = " + symbols [symNum].value.ToString ("X8") + " }");  	/*         Debug.DebugMSG("symRef[" + symNum.ToString() + "][\"name\"]: " + ((String)symRef[symNum]["name"]).ToString());         Debug.DebugMSG("symRef[" + symNum.ToString() + "][\"value\"]: " + ((UInt64)symRef[symNum]["value"]).ToString("X8"));         Debug.DebugMSG("symRef[" + symNum.ToString() + "][\"secNum\"]: " + ((UInt16)symRef[symNum]["secNum"]).ToString("X4"));         Debug.DebugMSG("symRef[" + symNum.ToString() + "][\"type\"]: " + sym.st_type);         Debug.DebugMSG("symRef[" + symNum.ToString() + "][\"binding\"]: " + sym.st_binding);         Debug.DebugMSG("symRef[" + symNum.ToString() + "][\"visibility\"]: " + sym.st_visibility);         */}  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseSymbolTable,The following statement contains a magic number: sym.st_binding = (ELF_SymbolBinding)((info >> 4) & 0xF);  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ELF_getStringFromStringTable,The following statement contains a magic number: if (name.Count > 128)  	Debug.DebugMSG (ASCIIEncoding.ASCII.GetString ((Byte[])name.ToArray (typeof(Byte))' 0' name.Count));  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseELFHeader,The following statement contains a magic number: hdr.e_ident.magic = br.ReadBytes (4);  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseELFHeader,The following statement contains a magic number: hdr.e_ident.pad = br.ReadBytes (7);  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseELFHeader,The following statement contains a magic number: if ((0x7F != hdr.e_ident.magic [0]) || ('E' != hdr.e_ident.magic [1]) || ('L' != hdr.e_ident.magic [2]) || ('F' != hdr.e_ident.magic [3])) {  	throw new Exception ("ELF magic number not found. Not an ELF object file.");  }  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseELFHeader,The following statement contains a magic number: if ((0x7F != hdr.e_ident.magic [0]) || ('E' != hdr.e_ident.magic [1]) || ('L' != hdr.e_ident.magic [2]) || ('F' != hdr.e_ident.magic [3])) {  	throw new Exception ("ELF magic number not found. Not an ELF object file.");  }  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseELFHeader,The following statement contains a magic number: Debug.DebugMSG ("  magic[2]        : 0x" + hdr.e_ident.magic [2].ToString ("X2"));  
Magic Number,TI.UtilLib.ObjectFile,ElfFile,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\..\..\UtilLib\ElfFile.cs,ParseELFHeader,The following statement contains a magic number: Debug.DebugMSG ("  magic[3]        : 0x" + hdr.e_ident.magic [3].ToString ("X2"));  
Magic Number,out2rprc,Out2Rprc,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Out2Rprc.cs,newResourceName,The following statement contains a magic number: if (text.Length > 47)  	text = text.Substring (0' 47);  
Magic Number,out2rprc,Out2Rprc,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Out2Rprc.cs,newResourceName,The following statement contains a magic number: if (text.Length > 47)  	text = text.Substring (0' 47);  
Magic Number,out2rprc,Out2Rprc,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Out2Rprc.cs,newResourceName,The following statement contains a magic number: text = text.Substring (0' 47);  
Magic Number,out2rprc,Out2Rprc,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Out2Rprc.cs,newResourceName,The following statement contains a magic number: for (int j = 0; j < 48 - text.Length; j++)  	name [text.Length + j] = (char)0;  
Magic Number,out2rprc,Program,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Program.cs,Main,The following statement contains a magic number: if (args.Length == 2) {  	// 2 args: 1 input file and 1 output file  	input_file_name_1 = args [0];  	input_file_name_2 = "";  	output_file_name = args [1];  }  else if (args.Length == 3) {  	// 3 args: 2 input files and 1 output file  	input_file_name_1 = args [0];  	input_file_name_2 = args [1];  	output_file_name = args [2];  }  else {  	// print usage instructions and quit  	Console.WriteLine ("Usage:");  	Console.WriteLine ("out2rprc.exe <input file 1 (COFF or ELF)> [<input file 2 (COFF or ELF)] <output file (RPRC)>");  	return;  }  
Magic Number,out2rprc,Program,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Program.cs,Main,The following statement contains a magic number: if (args.Length == 2) {  	// 2 args: 1 input file and 1 output file  	input_file_name_1 = args [0];  	input_file_name_2 = "";  	output_file_name = args [1];  }  else if (args.Length == 3) {  	// 3 args: 2 input files and 1 output file  	input_file_name_1 = args [0];  	input_file_name_2 = args [1];  	output_file_name = args [2];  }  else {  	// print usage instructions and quit  	Console.WriteLine ("Usage:");  	Console.WriteLine ("out2rprc.exe <input file 1 (COFF or ELF)> [<input file 2 (COFF or ELF)] <output file (RPRC)>");  	return;  }  
Magic Number,out2rprc,Program,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Program.cs,Main,The following statement contains a magic number: if (args.Length == 2) {  	// 2 args: 1 input file and 1 output file  	input_file_name_1 = args [0];  	input_file_name_2 = "";  	output_file_name = args [1];  }  else if (args.Length == 3) {  	// 3 args: 2 input files and 1 output file  	input_file_name_1 = args [0];  	input_file_name_2 = args [1];  	output_file_name = args [2];  }  else {  	// print usage instructions and quit  	Console.WriteLine ("Usage:");  	Console.WriteLine ("out2rprc.exe <input file 1 (COFF or ELF)> [<input file 2 (COFF or ELF)] <output file (RPRC)>");  	return;  }  
Magic Number,out2rprc,Program,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Program.cs,Main,The following statement contains a magic number: if (args.Length == 3) {  	// 3 args: 2 input files and 1 output file  	input_file_name_1 = args [0];  	input_file_name_2 = args [1];  	output_file_name = args [2];  }  else {  	// print usage instructions and quit  	Console.WriteLine ("Usage:");  	Console.WriteLine ("out2rprc.exe <input file 1 (COFF or ELF)> [<input file 2 (COFF or ELF)] <output file (RPRC)>");  	return;  }  
Magic Number,out2rprc,Program,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Program.cs,Main,The following statement contains a magic number: if (args.Length == 3) {  	// 3 args: 2 input files and 1 output file  	input_file_name_1 = args [0];  	input_file_name_2 = args [1];  	output_file_name = args [2];  }  else {  	// print usage instructions and quit  	Console.WriteLine ("Usage:");  	Console.WriteLine ("out2rprc.exe <input file 1 (COFF or ELF)> [<input file 2 (COFF or ELF)] <output file (RPRC)>");  	return;  }  
Magic Number,out2rprc,Program,C:\repos\hummingbird2012_flashUtils\Common\out2rprc\out2rprc\Program.cs,Main,The following statement contains a magic number: output_file_name = args [2];  
