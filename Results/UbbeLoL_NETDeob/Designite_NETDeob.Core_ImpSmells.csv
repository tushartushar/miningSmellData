Implementation smell,Namespace,Class,File,Method,Description
Long Method,NETDeob.Core.Deobfuscators.Generic,Renamer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Renamer.cs,RenameMembers,The method has 141 lines of code.
Long Method,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The method has 638 lines of code.
Long Method,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The method has 114 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The method has 453 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 160 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The method has 103 lines of code.
Long Method,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The method has 125 lines of code.
Long Method,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The method has 130 lines of code.
Long Method,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,EmulateInstruction,The method has 172 lines of code.
Complex Method,NETDeob.Core.Deobfuscators.Generic,AssemblyStripper,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\AssemblyStripper.cs,RemoveMembers,Cyclomatic complexity of the method is 9
Complex Method,NETDeob.Core.Deobfuscators.Generic,Renamer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Renamer.cs,RenameMembers,Cyclomatic complexity of the method is 31
Complex Method,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,Cyclomatic complexity of the method is 244
Complex Method,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,Code,Cyclomatic complexity of the method is 15
Complex Method,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 64
Complex Method,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 25
Complex Method,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,Cyclomatic complexity of the method is 26
Complex Method,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 22
Complex Method,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,Cyclomatic complexity of the method is 21
Complex Method,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,Cyclomatic complexity of the method is 12
Complex Method,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,Cyclomatic complexity of the method is 10
Complex Method,NETDeob.Core.Deobfuscators.Obsolete.CodeWall.Tasks,StubDumper2,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StubDumper2.cs,Phase1,Cyclomatic complexity of the method is 8
Complex Method,NETDeob.Core.Deobfuscators.Confuser.Obsolete.Utils,ExpressionScheme,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\Utils\DynamicEvaluator.cs,ParseInstructions,Cyclomatic complexity of the method is 9
Complex Method,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,Phase2,Cyclomatic complexity of the method is 8
Complex Method,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,Phase4,Cyclomatic complexity of the method is 14
Complex Method,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,DoAntiProxy,Cyclomatic complexity of the method is 12
Complex Method,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,EmulateInstruction,Cyclomatic complexity of the method is 35
Complex Method,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformComparison,Cyclomatic complexity of the method is 8
Complex Method,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,Cyclomatic complexity of the method is 23
Complex Method,NETDeob.Core.Deobfuscators.Generic.Obsolete,MethodCleaner,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\MethodCleaner.cs,Phase2,Cyclomatic complexity of the method is 9
Complex Method,NETDeob.Core.Engine.Utils.Extensions,TypeDefinitionExt,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\TypeDefinition.cs,GetAllReferences,Cyclomatic complexity of the method is 18
Complex Method,NETDeob.Misc.Structs__Enums___Interfaces.Tasks.Base,Task,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Misc\Structs, Enums & Interfaces\Tasks\Base\Task.cs,MarkMember,Cyclomatic complexity of the method is 12
Long Parameter List,NETDeob.Core.Engine.Utils,Snapshot,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,Snapshot,The method has 5 parameters. Parameters: clonedStack' clonedLocals' currentInstruction' body' previous
Long Parameter List,SevenZip,ICoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The method has 6 parameters. Parameters: outBuf' outIndex' outLen' inBuf' inIndex' inLen
Long Parameter List,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,EmulateInstruction,The method has 6 parameters. Parameters: instr' instrList' stack' locals' markings' idx
Long Identifier,NETDeob.Core,DeobfuscatorOptions,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscator.cs,,The length of the parameter PreferPluginsOverBuiltinIdentifiers is 35.
Long Identifier,SevenZip.Compression.LZMA,Base,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,NETDeob.Core.Engine.Utils,Logger,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Logger.cs,VSLog,The length of the statement  "            if (Globals.DeobContext.Output == DeobfuscatorContext.OutputType.Subtle || Globals.DeobContext.Output == DeobfuscatorContext.OutputType.Verbose) " is 144.
Long Statement,NETDeob.Core.Engine.Utils,SignatureFinder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\SignatureFinder.cs,IsMatch,The length of the statement  "            if (mDef.Body.Instructions.Count <= (signature.StartIndex > 0 ? signature.StartIndex : -signature.StartIndex) + signature.Instructions.Count) " is 141.
Long Statement,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "					_posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 125.
Long Statement,NETDeob.Core.Deobfuscators.Manco.Tasks,CFlowCleaner,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\CFlowCleaner.cs,YieldBadBranches,The length of the statement  "                foreach (var fLoad in mDef.Body.Instructions.Where(i => i.OpCode == OpCodes.Ldsfld && (i.Operand as FieldReference).Resolve().DeclaringType == targetType)) " is 155.
Long Statement,NETDeob.Core.Deobfuscators.Manco.Tasks,CFlowCleaner,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\CFlowCleaner.cs,RemoveBranch,The length of the statement  "            mDef.Body.GetILProcessor().RemoveBlock(instr' instr.Next.Operand as Instruction); // load bool (ldsfld) -> branch target " is 120.
Long Statement,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,ConstructEntries,The length of the statement  "            foreach (var mDef in from modDef in AsmDef.Modules from typeDef in modDef.Types from mDef in typeDef.Methods where mDef.HasBody select mDef) " is 140.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,AntiDump,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\AntiDump.cs,Phase1,The length of the statement  "                ctor.Body.Instructions.FirstOrDefault(i => i.OpCode == OpCodes.Call && IsBadMethod((i.Operand as MethodReference).Resolve())); " is 126.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,AntiDump,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\AntiDump.cs,IsBadMethod,The length of the statement  "            if (mDef.Body.Instructions[0].OpCode != OpCodes.Ldtoken && (mDef.Body.Instructions[0].Operand as TypeReference).Resolve() == mDef.DeclaringType) " is 144.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,Phase3,The length of the statement  "                PT.InitProxyType(Params.ResolveFieldMD.MetadataToken.ToInt32()' Params.ResolveMethodMD.MetadataToken.ToInt32()' Params.asmReflection); " is 134.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,Phase4,The length of the statement  "                    AsmDef.MainModule.Types[i].Methods[j].Name = String.Format("M_{0}_{1}"' j' AsmDef.MainModule.Types[i].Methods[j].ReturnType.Name); " is 130.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,Phase4,The length of the statement  "                        AsmDef.MainModule.Types[i].Methods[j].Parameters[x].Name = String.Format("Arg_{0}_{1}"' x' AsmDef.MainModule.Types[i].Methods[j].Parameters[x].ParameterType.Name); " is 163.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,DoAntiProxy,The length of the statement  "                            MethodReference MR2 = AsmDef.MainModule.Import(Params.asmReflection.GetModules()[0].ResolveMethod(TokenOfOriginalCall2)); " is 121.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyType,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,InitProxyType,The length of the statement  "                    Int32 TokenOfCurrentInstruction = ((MethodDefinition)this.CCTor.Body.Instructions[(i * 2) + 1].Operand).MetadataToken.ToInt32(); " is 128.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyType,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,InitProxyType,The length of the statement  "                    this.arProxyTypeDelegate[i] = (TokenOfCurrentInstruction == TokenResolveField) ? ProxyTypeDelegate.NewObjectCall : ProxyTypeDelegate.DirectMethodCall; " is 150.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The length of the statement  "            using (var stream2 = new CryptoStream(new MemoryStream(buf)' new RijndaelManaged().CreateDecryptor(buf2' buf1)' CryptoStreamMode.Read)){ " is 136.
Long Statement,NETDeob.Deobfuscators.Confuser.Tasks.Common,WatermarkRemover,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\Common\WatermarkRemover.cs,Phase1,The length of the statement  "            MarkMember(AsmDef.MainModule.CustomAttributes.FirstOrDefault(attrib => attrib.AttributeType.Name == "ConfusedByAttribute")' AsmDef.MainModule); " is 143.
Long Statement,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The length of the statement  "                    markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null }); return; " is 120.
Long Statement,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The length of the statement  "                    markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null }); return; " is 120.
Long Statement,NETDeob.Core.Deobfuscators.Obfusasm,ObfusasmDeobfuscator,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\ObfusasmDeobfuscator.cs,CreateTaskQueue,The length of the statement  "            TaskQueue.Add(new Renamer(AsmDef' new RenamingScheme(false) { Methods = true' Fields = true' Properties = true' Parameters = true' Events = true' Delegates = true})); " is 166.
Long Statement,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,Phase1,The length of the statement  "            _staticKey = (cctor.Body.Instructions.FirstOrDefault(op => op.OpCode == OpCodes.Ldtoken).Operand as FieldReference).Resolve().InitialValue; " is 139.
Long Statement,NETDeob.Core.Engine.Utils.Extensions,AssemblyDefinitionExt,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\AssemblyDefinition.cs,FindResource,The length of the statement  "            return (from modDef in asmDef.Modules from res in modDef.Resources where pred(res) select res as EmbeddedResource).FirstOrDefault(); " is 132.
Long Statement,NETDeob.Core.Engine.Utils.Extensions,AssemblyDefinitionExt,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\AssemblyDefinition.cs,FindMethod,The length of the statement  "            return (from modDef in asmDef.Modules from typeDef in modDef.Types from mDef in typeDef.Methods where mDef.HasBody select mDef).FirstOrDefault(mDef => pred(mDef)); " is 163.
Long Statement,NETDeob.Core.Engine.Utils.Extensions,MethodDefinitionExt,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\MethodDefinition.cs,HasDelegateReference,The length of the statement  "            return mDef.Body.Instructions.Where(instr => instr.OpCode == OpCodes.Newobj).FirstOrDefault(instr => instr.Operand == Delegate); " is 128.
Long Statement,NETDeob.Core.Engine.Utils.Extensions,MiscExt,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\Misc.cs,IsNumeric,The length of the statement  "            return val is int || val is long || val is sbyte || val is short || val is ushort || val is ulong || val is uint || val is byte || val is double || val is decimal || val is float; " is 179.
Long Statement,NETDeob.Core.Misc,AssemblyUtils,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Misc\AssemblyUtils.cs,FindMethodReferences,The length of the statement  "                foreach (var instr in mDef.Body.Instructions.Where(i => i.IsCall()).Where(instr => (instr.Operand as MethodReference).Resolve() == target)) " is 139.
Long Statement,NETDeob.Core.Unpackers.Mpress.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Mpress\Tasks\Unpacker.cs,Phase1,The length of the statement  "            _offset = (int)Convert.ChangeType(target.Body.Instructions.First(instr => instr.IsLdcI4WOperand()).Operand' typeof(Int32)); " is 123.
Long Statement,NETDeob.Core.Unpackers.Rpx.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Rpx\Tasks\Unpacker.cs,Phase2,The length of the statement  "                //                                                    Globals.DeobContext.InPath.LastIndexOf("\\"' StringComparison.Ordinal) + 1)))); " is 133.
Long Statement,NETDeob.Core.Unpackers.Rpx.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Rpx\Tasks\Unpacker.cs,GetResourceData,The length of the statement  "                    Logger.VSLog(string.Concat("Found compressed assembly; "' res.Name' " ("' (res as EmbeddedResource).GetResourceData().Length'") bytes...")); " is 140.
Long Statement,NETDeob.Misc.Structs__Enums___Interfaces,AssemblyWorker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Misc\Structs, Enums & Interfaces\Deobfuscation\AssemblyWorker.cs,Deobfuscate,The length of the statement  "            Logger.VSLog(string.Format("\n----------------------------\nSuccessfully deobfuscated assembly: {0} in {1} milliseconds"' AsmDef.Name.ToString().Split(''')[0]' (DateTime.Now - _startTime).Milliseconds)); " is 203.
Complex Conditional,NETDeob.Core.Engine.Utils,Identifier,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The conditional expression  "mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7"  is complex.
Complex Conditional,NETDeob.Core.Engine.Utils,Identifier,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The conditional expression  "mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2"  is complex.
Virtual Method Call from Constructor,NETDeob.Misc.Structs__Enums___Interfaces,AssemblyWorker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Misc\Structs, Enums & Interfaces\Deobfuscation\AssemblyWorker.cs,AssemblyWorker,The constructor "AssemblyWorker" calls a virtual method "CreateTaskQueue".
Empty Catch Block,NETDeob.Core.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver2,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ProxyResolver2.cs,ResolveMethod,The method has an empty catch block.
Empty Catch Block,NETDeob.Core.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver2,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ProxyResolver2.cs,ResolveMethod,The method has an empty catch block.
Empty Catch Block,NETDeob.Core.Deobfuscators.Generic,MetadataFixer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\MetadataFixer.cs,AnalyzeTypeDefs,The method has an empty catch block.
Magic Number,NETDeob.Core.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver2,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ProxyResolver2.cs,Phase1,The following statement contains a magic number: Logger.VSLog("Located proxy resolver method at " + resolver.Name.Truncate(10));
Magic Number,NETDeob.Core.Deobfuscators.Generic,MetadataFixer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\MetadataFixer.cs,AnalyzeResources,The following statement contains a magic number: resStream.Length != 0 && res.Name.Length <= 1000
Magic Number,NETDeob.Core.Deobfuscators.Generic,MetadataFixer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\MetadataFixer.cs,AnalyzeTypeDefs,The following statement contains a magic number: typeDef.Name.Length >= 1000
Magic Number,NETDeob.Core.Deobfuscators.Generic,GenericDecryptionContext,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\GenericStringDecryptor.cs,FetchParameters,The following statement contains a magic number: var st = new StackTracer(Source.Body' 1000);
Magic Number,NETDeob.Core.Deobfuscators.Generic,AssemblyStripper,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\AssemblyStripper.cs,RemoveMembers,The following statement contains a magic number: switch (member.Type)                      {                          case DeobfuscatorContext.MemberType.Type:                              Logger.VLog("[Remove(Type)] " + (member.Member as TypeDefinition).Name.Truncate(10));                              AsmDef.MainModule.Types.Remove(member.Member as TypeDefinition);                              break;                            case DeobfuscatorContext.MemberType.Method:                              Logger.VLog("[Remove(Method)] " + (member.Member as MethodDefinition).Name);                              (member.Member as MethodDefinition).DeclaringType.Methods.Remove(                                  member.Member as MethodDefinition);                              break;                            case DeobfuscatorContext.MemberType.Field:                              Logger.VLog("[Remove(Field)] " + (member.Member as FieldDefinition).Name);                              (member.Member as FieldDefinition).DeclaringType.Fields.Remove(                                  member.Member as FieldDefinition);                              break;                            case DeobfuscatorContext.MemberType.Property:                              Logger.VLog("[Remove(Property)] " + (member.Member as PropertyDefinition).Name);                              (member.Member as PropertyDefinition).DeclaringType.Properties.Remove(                                  member.Member as PropertyDefinition);                              break;                            case DeobfuscatorContext.MemberType.Resource:                              Logger.VLog("[Remove(Resource)] " +                                          ((member.Member as EmbeddedResource).Name.Truncate(10)));                              AsmDef.MainModule.Resources.Remove(member.Member as EmbeddedResource);                              break;                            case DeobfuscatorContext.MemberType.Attribute:                              Logger.VLog("[Remove(Attribute)] " + (member.Member as CustomAttribute).AttributeType.Name);                              (member.ParentMember as ModuleDefinition).CustomAttributes.Remove(                                  member.Member as CustomAttribute);                              break;                            case DeobfuscatorContext.MemberType.Instruction:                              Logger.VLog("[Remove(Instruction)] " + (member.Member as Instruction).OpCode);                              (member.ParentMember as MethodDefinition).Body.Instructions.Remove(                                  member.Member as Instruction);                              break;                            case DeobfuscatorContext.MemberType.AssemblyReference:                              Logger.VLog("[Remove(AssemblyReference)] " + (member.Member as AssemblyNameReference).MetadataToken.ToInt32());                              AsmDef.MainModule.AssemblyReferences.Remove(member.Member as AssemblyNameReference);                              break;                      }
Magic Number,NETDeob.Core.Deobfuscators.Generic,AssemblyStripper,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\AssemblyStripper.cs,RemoveMembers,The following statement contains a magic number: switch (member.Type)                      {                          case DeobfuscatorContext.MemberType.Type:                              Logger.VLog("[Remove(Type)] " + (member.Member as TypeDefinition).Name.Truncate(10));                              AsmDef.MainModule.Types.Remove(member.Member as TypeDefinition);                              break;                            case DeobfuscatorContext.MemberType.Method:                              Logger.VLog("[Remove(Method)] " + (member.Member as MethodDefinition).Name);                              (member.Member as MethodDefinition).DeclaringType.Methods.Remove(                                  member.Member as MethodDefinition);                              break;                            case DeobfuscatorContext.MemberType.Field:                              Logger.VLog("[Remove(Field)] " + (member.Member as FieldDefinition).Name);                              (member.Member as FieldDefinition).DeclaringType.Fields.Remove(                                  member.Member as FieldDefinition);                              break;                            case DeobfuscatorContext.MemberType.Property:                              Logger.VLog("[Remove(Property)] " + (member.Member as PropertyDefinition).Name);                              (member.Member as PropertyDefinition).DeclaringType.Properties.Remove(                                  member.Member as PropertyDefinition);                              break;                            case DeobfuscatorContext.MemberType.Resource:                              Logger.VLog("[Remove(Resource)] " +                                          ((member.Member as EmbeddedResource).Name.Truncate(10)));                              AsmDef.MainModule.Resources.Remove(member.Member as EmbeddedResource);                              break;                            case DeobfuscatorContext.MemberType.Attribute:                              Logger.VLog("[Remove(Attribute)] " + (member.Member as CustomAttribute).AttributeType.Name);                              (member.ParentMember as ModuleDefinition).CustomAttributes.Remove(                                  member.Member as CustomAttribute);                              break;                            case DeobfuscatorContext.MemberType.Instruction:                              Logger.VLog("[Remove(Instruction)] " + (member.Member as Instruction).OpCode);                              (member.ParentMember as MethodDefinition).Body.Instructions.Remove(                                  member.Member as Instruction);                              break;                            case DeobfuscatorContext.MemberType.AssemblyReference:                              Logger.VLog("[Remove(AssemblyReference)] " + (member.Member as AssemblyNameReference).MetadataToken.ToInt32());                              AsmDef.MainModule.AssemblyReferences.Remove(member.Member as AssemblyNameReference);                              break;                      }
Magic Number,NETDeob.Core.Engine.Utils,BugReporter,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Bugster.cs,DoRequest,The following statement contains a magic number: request.Timeout = 10 * 1000;
Magic Number,NETDeob.Core.Engine.Utils,BugReporter,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Bugster.cs,DoRequest,The following statement contains a magic number: request.Timeout = 10 * 1000;
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                       break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      var mr = (instruction.Operand as MethodReference);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodReference).ReturnType != mr.Module.Import(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                              break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic) Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.VerifyTop<int>())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if(Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic) Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long) Convert.ChangeType(Stack.Pop().Value' typeof (long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                              break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                              break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if(ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Ldelem_Any:                      break;                  case Code.Stelem_Any:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tail:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.No:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,NETDeob.Core.Engine.Utils,Identifier,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7
Magic Number,NETDeob.Core.Engine.Utils,Identifier,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7
Magic Number,NETDeob.Core.Engine.Utils,Identifier,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7
Magic Number,NETDeob.Core.Engine.Utils,Identifier,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2
Magic Number,NETDeob.Core.Engine.Utils,Identifier,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2
Magic Number,NETDeob.Core.Engine.Utils,Identifier,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Identifier.cs,IdentifyHurpFuscator,The following statement contains a magic number: mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2
Magic Number,SevenZip,CRC,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,SevenZip,CRC,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Common\CRC.cs,CRC,The following statement contains a magic number: j < 8
Magic Number,SevenZip,CRC,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Common\CRC.cs,CRC,The following statement contains a magic number: i < 256
Magic Number,SevenZip,CRC,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,SevenZip,CRC,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Common\CRC.cs,Update,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: Index < 4
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaBase.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: lp > 8
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: lc > 8
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: properties.Length < 5
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: i < 4
Magic Number,SevenZip.Compression.LZMA,LiteralDecoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,SevenZip.Compression.LZMA,Decoder2,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: uint matchBit = (uint)(matchByte >> 7) & 1;
Magic Number,SevenZip.Compression.LZMA,Decoder2,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: int c = 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: pos < (1 << 11)
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: pos < (1 << 21)
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: pos < (1 << 17)
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: pos < (1 << 27)
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: int numHashBytes = 4;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: numHashBytes = 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: lenRes = _matchDistances[numDistancePairs - 2];
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numAvailableBytes < 2
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenEnd < 2
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: repLen < 2
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[cur].Backs2 = reps[2];
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[cur].Backs3 = reps[3];
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numAvailableBytes < 2
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: UInt32 startLen = 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest < 2
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numDistancePairs += 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: _matchPriceCount >= (1 << 7)
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: nowPos64 - progressPosValuePrev >= (1 << 12)
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: i < 4
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}
Magic Number,SevenZip.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}
Magic Number,SevenZip.Compression.LZMA,LiteralEncoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,SevenZip.Compression.LZMA,Encoder2,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: state += ((1 + matchBit) << 8);
Magic Number,SevenZip.Compression.LZMA,Encoder2,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,SevenZip.Compression.LZMA,Encoder2,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: kMinMatchCheck = 4;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: historySize > kMaxValForNormalize - 256
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  					matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  					matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 2);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 4);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 8);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs > (1 << 24)
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances[offset++] = maxLen = 2;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances[offset++] = maxLen = 3;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: i < 5
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Stream.WriteByte((byte)(temp + (Low >> 32)));
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: _cache = (byte)(((uint)Low) >> 24);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: (uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +  				Stream.Position - StartPosition + 4;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: i < 5
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: uint t = (code - range) >> 31;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: encoder.Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,LZMAT_GET_U4,The following statement contains a magic number: return (_n_ ^= 1) != 0 ? (uint)(_p_[_i_] & 0xF) : (uint)(_p_[_i_++] >> 4);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,LZMAT_GET_U8,The following statement contains a magic number: return (byte)(((_n_) != 0 ? ((_p_[_i_] >> 4) | (_p_[_i_ + 1] << 4)) : _p_[_i_]));
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,LZMAT_GET_U8,The following statement contains a magic number: return (byte)(((_n_) != 0 ? ((_p_[_i_] >> 4) | (_p_[_i_ + 1] << 4)) : _p_[_i_]));
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,LZMAT_GET_LE16,The following statement contains a magic number: return (ushort)((_n_) != 0 ? ((_p_[_i_] >> 4) | ((ushort)(GET_LE16(_p_' _i_ + 1)) << 4)) : GET_LE16(_p_' _i_));
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,LZMAT_GET_LE16,The following statement contains a magic number: return (ushort)((_n_) != 0 ? ((_p_[_i_] >> 4) | ((ushort)(GET_LE16(_p_' _i_ + 1)) << 4)) : GET_LE16(_p_' _i_));
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: dist = r_cnt >> 2;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: r_cnt += 3;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: return LzmatStatus.INTEGRITY_FAILURE + 4;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following statement contains a magic number: bc < 8 && inPos < (cbIn - cur_nib) && outPos < cbOutBuf
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: int srcIndex = 3;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: int partLen = compressed[srcIndex++] + (compressed[srcIndex++] << 8) + (compressed[srcIndex++] << 16);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress_old,The following statement contains a magic number: int partLen = compressed[srcIndex++] + (compressed[srcIndex++] << 8) + (compressed[srcIndex++] << 16);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: r_cnt = inBuf[inIndex + inPos++] + 18;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: r_cnt == 18
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: inPos + 2 > inLen
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: inPos += 2;
Magic Number,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,lzmat_old,The following statement contains a magic number: bc < 8 && inPos < inLen && outPos < outLen
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_1,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_1\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_1,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_1\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_1,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_1\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 1 &&                      mDef.Body.Variables.Count == 7 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldstr) == 2);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_1,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_1\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: var managed2 = new RijndaelManaged              {                  BlockSize = 256'                  Padding = PaddingMode.PKCS7              };
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,IsDecryptor,The following statement contains a magic number: return (mDef.Parameters.Count == 2 &&                      mDef.Body.Variables.Count == 9 &&                      mDef.ReturnType.ToString().ToLower().Contains("string") &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Callvirt) == 7);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: var destinationArray = new byte[8];
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: Array.Copy(provider2.ComputeHash(Encoding.ASCII.GetBytes((entry as HurpFuscatorEntry).Arg2))' 0'                         destinationArray' 0' 8);
Magic Number,NETDeob.Core.Deobfuscators.HurpFuscator.Tasks._1_0,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\HurpFuscator\Tasks\1_0\StringDecryptor.cs,ProcessEntry,The following statement contains a magic number: MarkMember(_entry.BadInstructions[2]' _entry.Source);
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,CFlowCleaner,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\CFlowCleaner.cs,IsBoolInitializer,The following statement contains a magic number: cctor.Body.Instructions.Count >= 4
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,MancoContext,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,ToString,The following statement contains a magic number: return string.Format(@"[Decrypt] ""{0}"" -> ""{1}"""' OrigString.Truncate(10)' PlainText);
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,Phase1,The following statement contains a magic number: Logger.VSLog("Found decryptor method at " + _decryptor.Name.Truncate(5));
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: int length = (paramStr.Length/2) + (paramStr.Length%2);
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: int length = (paramStr.Length/2) + (paramStr.Length%2);
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: bool flag = (str.Length%2) == 0;
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: chArray[num2/2] = str[num2];
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: chArray[(str.Length - (num2/2)) - 1] = str[num2 + 1];
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: flag = (str2.Length%2) == 0;
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: chArray2[num2/2] = str2[num2];
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: chArray2[(str2.Length - (num2/2)) - 1] = str2[num2 + 1];
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,CreateAlgo,The following statement contains a magic number: algorithm.IV = encoding.GetBytes(paramStr.Substring(0' (strAlgo == Algorithm.Rijndael ? 0x10 : 8)));
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,CreateAlgo,The following statement contains a magic number: algorithm.Key = encoding.GetBytes(paramStr.Substring((strAlgo == Algorithm.Rijndael ? 0x10 : 8)));
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,ExtractDecryptor,The following statement contains a magic number: var decryptor =                  mTarget.DeclaringType.Methods.FirstOrDefault(                      m => m.Parameters.Count == 4 && m.ReturnType.ToString().Contains("String"));
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,ExtractDecryptor,The following statement contains a magic number: decryptor.Body.Variables.Count != 10
Magic Number,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,BaseIsDecryptor,The following statement contains a magic number: var decryptor =                  mTarget.DeclaringType.Methods.FirstOrDefault(                      m => m.Parameters.Count == 4 && m.ReturnType.ToString().Contains("String"));
Magic Number,NETDeob.Deobfuscators.CodeWall,CodeWallDeobfuscator,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\CodeWallDeobfuscator.cs,IsAssemblyEncrypted,The following statement contains a magic number: return target.Body.Instructions.GetOpCodeCount(OpCodes.Ldc_I4) == 5 &&                     target.Body.Instructions.GetOpCodeCount(OpCodes.Call) == 7;
Magic Number,NETDeob.Deobfuscators.CodeWall,CodeWallDeobfuscator,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\CodeWallDeobfuscator.cs,IsAssemblyEncrypted,The following statement contains a magic number: return target.Body.Instructions.GetOpCodeCount(OpCodes.Ldc_I4) == 5 &&                     target.Body.Instructions.GetOpCodeCount(OpCodes.Call) == 7;
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: tmpEntry.Modifier3 = decModifiers[2];
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: i -= 4;
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: i += 4;
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindDecryptors,The following statement contains a magic number: return                  AsmDef.FindMethods(                      mDef =>                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Xor) == 6 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldc_I4) == 3).ToList();
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindDecryptors,The following statement contains a magic number: return                  AsmDef.FindMethods(                      mDef =>                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Xor) == 6 &&                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Ldc_I4) == 3).ToList();
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindDecryptionModifiers,The following statement contains a magic number: var decModifiers = new int[3];
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,FindDecryptionModifiers,The following statement contains a magic number: t.OpCode == OpCodes.Xor && tmp == 4
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: var key3 = decKey[2] ^ decModifiers[2];
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: var key3 = decKey[2] ^ decModifiers[2];
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: key2 ^= BitConverter.ToInt32(publicKeyToken' 0) ^ BitConverter.ToInt32(publicKeyToken' 4);
Magic Number,NETDeob.Deobfuscators.CodeWall.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obsolete\CodeWall\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: publicKeyToken.Length == 8
Magic Number,NETDeob.Core.Deobfuscators.Confuser,ConfuserDeobfuscator,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\ConfuserDeobfuscator.cs,CreateTaskQueue,The following statement contains a magic number: switch((Globals.DeobContext.ActiveSignature).Ver.Minor)              {                  case 7:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      //TaskQueue.Add(new MethodCleaner2(AsmDef));                      //TaskQueue.Add(new ProxyResolver(AsmDef));                      TaskQueue.Add(new MethodCleaner(AsmDef));                      TaskQueue.Add(new ResourceDecryptor(AsmDef));                      //TaskQueue.Add(new ProxyResolver2(AsmDef));                      TaskQueue.Add(new ConstantsDecryptor(AsmDef));                      TaskQueue.Add(new StackUnderflowCleaner(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      TaskQueue.Add(new AntiDump(AsmDef));                      TaskQueue.Add(new AntiDebug(AsmDef));                      TaskQueue.Add(new AntiILDasm(AsmDef));                      TaskQueue.Add(new Renamer(AsmDef' new RenamingScheme(true) {Resources = false}));                      break;                    case 8:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      break;                    case 9:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new ProxyResolver2(AsmDef));                      break;              }
Magic Number,NETDeob.Core.Deobfuscators.Confuser,ConfuserDeobfuscator,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\ConfuserDeobfuscator.cs,CreateTaskQueue,The following statement contains a magic number: switch((Globals.DeobContext.ActiveSignature).Ver.Minor)              {                  case 7:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      //TaskQueue.Add(new MethodCleaner2(AsmDef));                      //TaskQueue.Add(new ProxyResolver(AsmDef));                      TaskQueue.Add(new MethodCleaner(AsmDef));                      TaskQueue.Add(new ResourceDecryptor(AsmDef));                      //TaskQueue.Add(new ProxyResolver2(AsmDef));                      TaskQueue.Add(new ConstantsDecryptor(AsmDef));                      TaskQueue.Add(new StackUnderflowCleaner(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      TaskQueue.Add(new AntiDump(AsmDef));                      TaskQueue.Add(new AntiDebug(AsmDef));                      TaskQueue.Add(new AntiILDasm(AsmDef));                      TaskQueue.Add(new Renamer(AsmDef' new RenamingScheme(true) {Resources = false}));                      break;                    case 8:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      break;                    case 9:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new ProxyResolver2(AsmDef));                      break;              }
Magic Number,NETDeob.Core.Deobfuscators.Confuser,ConfuserDeobfuscator,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\ConfuserDeobfuscator.cs,CreateTaskQueue,The following statement contains a magic number: switch((Globals.DeobContext.ActiveSignature).Ver.Minor)              {                  case 7:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      //TaskQueue.Add(new MethodCleaner2(AsmDef));                      //TaskQueue.Add(new ProxyResolver(AsmDef));                      TaskQueue.Add(new MethodCleaner(AsmDef));                      TaskQueue.Add(new ResourceDecryptor(AsmDef));                      //TaskQueue.Add(new ProxyResolver2(AsmDef));                      TaskQueue.Add(new ConstantsDecryptor(AsmDef));                      TaskQueue.Add(new StackUnderflowCleaner(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      TaskQueue.Add(new AntiDump(AsmDef));                      TaskQueue.Add(new AntiDebug(AsmDef));                      TaskQueue.Add(new AntiILDasm(AsmDef));                      TaskQueue.Add(new Renamer(AsmDef' new RenamingScheme(true) {Resources = false}));                      break;                    case 8:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      break;                    case 9:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new ProxyResolver2(AsmDef));                      break;              }
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,AntiDebug,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\AntiDebug.cs,Phase1,The following statement contains a magic number: ctorBody.Body.Instructions.Count == 2
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,AntiDump,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\AntiDump.cs,IsBadMethod,The following statement contains a magic number: mDef.Body.Variables.Count != 44
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,BaseIsDecryptor,The following statement contains a magic number: mDef.Body.Variables.Count != 20
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers = new int[4];
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[0] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 3);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[1] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 4);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[2] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 5);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[2] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 5);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[3] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 12);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Modifiers[3] = mDef.Body.Instructions.GetOperandAt<int>(OpCodes.Ldc_I4' 12);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: uint num5 = (uint)Modifiers[2];
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num3 = (uint)(((num3 & 16777215) << 8) | ((num3 & -16777216) >> 24));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: uint num7 = (num3 & 255) % 64;
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: uint num7 = (num3 & 255) % 64;
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num4 |= (((num3 & 65280) >> 8) & ((num3 & 16711680) >> 16)) ^ (~num3 & 255);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num5 ^= ((num3 * i) + 1) % 16;
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: num3 += (num4 | num5) ^ (uint)Modifiers[3];
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: (num7 >= 0) && (num7 < 16)
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: i <= 64
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,DecryptEntry,The following statement contains a magic number: var random = new Random(Modifiers[3] ^ ((int)key));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,ProcessEntry,The following statement contains a magic number: ilProc.InsertAfter(badInstructions[2]' ilProc.Create(OpCodes.Ldstr' entry.PlainText));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ConstantsDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ConstantsDecryptor.cs,ConstructEntries,The following statement contains a magic number: var entry = new Confuser1_7Entry                      {                          Id = (int)instr.Previous.Operand'                          Caller = mDef'                          MDToken = mDef.MetadataToken.ToUInt32()'                          BadInstructions = mDef.Body.Instructions.GetInstructionBlock(i - 1' 3)'                      };
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyResolver,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,GetTokenForMethodDecode,The following statement contains a magic number: CT = (array2[0] == 13) ? FunctionCallType.Callvirt : FunctionCallType.Call;
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyType,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,ProxyType,The following statement contains a magic number: iNumberOfMembers = (CCTor.Body.Instructions.Count - 1) / 2;
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyType,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,InitProxyType,The following statement contains a magic number: this.arFields[i] = (FieldDefinition)this.CCTor.Body.Instructions[i * 2].Operand;
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ProxyType,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\ProxyResolver.cs,InitProxyType,The following statement contains a magic number: Int32 TokenOfCurrentInstruction = ((MethodDefinition)this.CCTor.Body.Instructions[(i * 2) + 1].Operand).MetadataToken.ToInt32();
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ResourceDecryptor.cs,Phase2,The following statement contains a magic number: var modifier = resolver.Body.Instructions.GetOperandAt<dynamic>(instr => instr.IsLdcI4()' 6);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ResourceDecryptor.cs,Phase2,The following statement contains a magic number: byte[] buffer2 = new byte[buffer.Length / 2];
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\ResourceDecryptor.cs,Phase2,The following statement contains a magic number: buffer2[i / 2] = (byte)(((buffer[i + 1] ^ modifier) * modifier) + (buffer[i] ^ modifier));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,StackUnderflowCleaner,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\StackUnderflowRemover.cs,Phase1,The following statement contains a magic number: (mDef.Body.Instructions[0].Operand as Instruction) == mDef.Body.Instructions[3]
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i] = (byte)(buf2[i] ^ (36 & 255));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i] = (byte)(buf2[i] ^ (36 & 255));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 1] = (byte)(buf2[i + 1] ^ ((36 & 65280) >> 8));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 2] = (byte)(buf2[i + 2] ^ (((36 & 16711680) >> 16)));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: buf2[i + 3] = (byte)(buf2[i + 3] ^ ((36 & 4278190080L) >> 24));
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: var buffer4 = new byte[4];
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: stream2.Read(buffer4' 0' 4);
Magic Number,NETDeob.Deobfuscators.Confuser.Tasks._1_7,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Tasks\1_7\Unpacker.cs,Phase3,The following statement contains a magic number: var buffer6 = new byte[4096];
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,FoldAndReplace,The following statement contains a magic number: instrList.RemoveAt(marking.Key.Key -2);
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,FoldAndReplace,The following statement contains a magic number: switch(marking.Value.OpCode.Code)                          {                              case Code.Ldc_I4:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I4' (int)marking.Value.Value));                                  break;                                case Code.Ldc_I8:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I8' (long)marking.Value.Value));                                  break;                          }
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,FoldAndReplace,The following statement contains a magic number: switch(marking.Value.OpCode.Code)                          {                              case Code.Ldc_I4:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I4' (int)marking.Value.Value));                                  break;                                case Code.Ldc_I8:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I8' (long)marking.Value.Value));                                  break;                          }
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,EmulateInstruction,The following statement contains a magic number: switch(instr.OpCode.Code)              {                  case Code.Ldc_I4:                      stack.Push((int) Convert.ChangeType(instr.Operand' typeof (int)));                      break;                    case Code.Ldc_I4_S:                      stack.Push((sbyte)Convert.ChangeType(instr.Operand' typeof(sbyte)));                      break;                    case Code.Ldc_I4_0:                  case Code.Ldc_I4_1:                  case Code.Ldc_I4_2:                  case Code.Ldc_I4_3:                  case Code.Ldc_I4_4:                  case Code.Ldc_I4_5:                  case Code.Ldc_I4_6:                  case Code.Ldc_I4_7:                  case Code.Ldc_I4_8:                      stack.Push(Int32.Parse(instr.OpCode.Code.ToString().Split('_')[2]));                      break;                    case Code.Ldc_I4_M1:                      stack.Push(-1);                      break;                    case Code.Ldc_I8:                      stack.Push((long) Convert.ChangeType(instr.Operand' typeof (long)));                      break;                    case Code.Ldc_R4:                      stack.Push((float) Convert.ChangeType(instr.Operand' typeof(float)));                      break;                    case Code.Ldc_R8:                      stack.Push((double)Convert.ChangeType(instr.Operand' typeof(float)));                      break;                    case Code.Stloc:                  case Code.Stloc_S:                      PopToLocal(ref locals' ref stack' instr);                      break;                    case Code.Stloc_0:                  case Code.Stloc_1:                  case Code.Stloc_2:                  case Code.Stloc_3:                      PopToLocal(ref locals' ref stack' instr' Int32.Parse(instr.OpCode.Code.ToString().Split('_')[1]));                      break;                    case Code.Ldloc:                  case Code.Ldloc_S:                      PushFromLocal(ref locals' ref stack' instr);                      break;                    case Code.Ldloc_0:                  case Code.Ldloc_1:                  case Code.Ldloc_2:                  case Code.Ldloc_3:                      PushFromLocal(ref locals' ref stack' instr' Int32.Parse(instr.OpCode.Code.ToString().Split('_')[1]));                      break;                    case Code.Add:                  case Code.Add_Ovf:                  case Code.Add_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Addition' ref markings' ref idx);                      break;                    case Code.Sub:                  case Code.Sub_Ovf:                  case Code.Sub_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Subtraction' ref markings' ref idx);                      break;                    case Code.Mul:                  case Code.Mul_Ovf:                  case Code.Mul_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Multiplication' ref markings' ref idx);                      break;                    case Code.Div:                  case Code.Div_Un:                      PerformArithmetic(ref stack' Operator.Divide' ref markings' ref idx);                      break;                    case Code.Shl:                      PerformArithmetic(ref stack' Operator.ShiftLeft' ref markings' ref idx);                      break;                    case Code.Shr:                  case Code.Shr_Un:                      PerformArithmetic(ref stack' Operator.ShiftRight' ref markings' ref idx);                      break;                    case Code.Rem:                  case Code.Rem_Un:                      PerformArithmetic(ref stack' Operator.Mod' ref markings' ref idx);                      break;                      // We still need to follow control flow to not fuck up stack                  case Code.Br:                  case Code.Br_S:                  case Code.Leave:                  case Code.Leave_S:                      idx = (instr.Operand as Instruction).GetInstructionIndex(instrList);                      break;                    case Code.Conv_I1:                      //stack.Push((sbyte) stack.Pop());                      break;                    case Code.Conv_I2:                      //stack.Push((short) stack.Pop());                      break;                    case Code.Conv_I4:                      //stack.Push((int) stack.Pop());                      break;                    case Code.Conv_I8:                      //stack.Push((long) (stack.Pop() is UnknownValue ? 0 : );                      break;                    case Code.Call:                  case Code.Calli:                  case Code.Callvirt:                      EmulateCall(ref stack' instr);                      break;                    case Code.Ldtoken:                      stack.Push(new UnknownValue());                      break;                    case Code.Ldsfld:                      stack.Push(new UnknownValue());                      break;                    case Code.Stsfld:                      stack.Pop();                      break;                    case Code.Dup:                      stack.Push(stack.Peek());                      break;                    case Code.Clt:                  case Code.Clt_Un:                  case Code.Bgt:                  case Code.Bgt_S:                  case Code.Bgt_Un:                  case Code.Bgt_Un_S:                  case Code.Bge:                  case Code.Bge_S:                  case Code.Bge_Un:                  case Code.Bge_Un_S:                  case Code.Blt:                  case Code.Blt_S:                  case Code.Blt_Un:                  case Code.Blt_Un_S:                  case Code.Bne_Un:                  case Code.Bne_Un_S:                  case Code.Beq:                  case Code.Beq_S:                      PerformComparison(ref stack' instr' ref idx' instrList);                      break;                    case Code.Box:                      stack.Push((object) stack.Pop());                      break;                    case Code.Stobj:                      stack.Pop();                      stack.Pop();                      break;                    case Code.Ldelem_Any:                  case Code.Ldelem_I:                  case Code.Ldelem_I1:                  case Code.Ldelem_I2:                  case Code.Ldelem_I4:                  case Code.Ldelem_I8:                  case Code.Ldelem_R4:                  case Code.Ldelem_R8:                  case Code.Ldelem_Ref:                  case Code.Ldelem_U1:                  case Code.Ldelem_U2:                  case Code.Ldelem_U4:                      stack.Pop();                      stack.Pop();                      stack.Push(new UnknownValue());                      break;                    case Code.Ldlen:                      stack.Push(new UnknownValue());                      break;                    case Code.Ldnull:                      stack.Push(null);                      break;                    case Code.Newobj:                      stack.Push(new UnknownValue());                      break;              }
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_0' Value = null});
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_1' Value = null});
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_2' Value = null });
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: val == 2
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_3' Value = null});
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: val == 3
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_4' Value = null});
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: val == 4
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_5' Value = null});
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: val == 5
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_6' Value = null});
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: val == 6
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_I4_7' Value = null});
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: val == 7
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_8' Value = null });
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: val == 8
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction {OpCode = OpCodes.Ldc_R4' Value = val});
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_R8' Value = val });
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following statement contains a magic number: markings.Add(new KeyValuePair<int' int>(idx' 2)' new ExInstruction { OpCode = OpCodes.Ldc_I4_S' Value = val });
Magic Number,NETDeob.Core.Deobfuscators.Generic.Obsolete,MethodCleaner,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\MethodCleaner.cs,Phase2,The following statement contains a magic number: cleanBody.Count >= 10000
Magic Number,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,IsBadType,The following statement contains a magic number: cctor.Body.Instructions.GetOpCodeCount(OpCodes.Newarr) != 2
Magic Number,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,IsBadType,The following statement contains a magic number: !typeDef.IsSealed || typeDef.Fields.Count != 3
Magic Number,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: var decEntry = new ObfusasmEntry                          {                              Key =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 2).GetLdcI4()'                              Key1 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 3).GetLdcI4()'                              Key2 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 4).GetLdcI4()'                             // TargetProxy = tmpTarget                          };
Magic Number,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: var decEntry = new ObfusasmEntry                          {                              Key =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 2).GetLdcI4()'                              Key1 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 3).GetLdcI4()'                              Key2 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 4).GetLdcI4()'                             // TargetProxy = tmpTarget                          };
Magic Number,NETDeob.Core.Deobfuscators.Obfusasm.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Obfusasm\Tasks\StringDecryptor.cs,ConstructEntries,The following statement contains a magic number: var decEntry = new ObfusasmEntry                          {                              Key =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 2).GetLdcI4()'                              Key1 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 3).GetLdcI4()'                              Key2 =                                  tmpTarget.Body.Instructions.FindInstruction(                                      iinstr => iinstr.IsLdcI4()' 4).GetLdcI4()'                             // TargetProxy = tmpTarget                          };
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,Phase1,The following statement contains a magic number: var target =                  AsmDef.FindMethod(                      mDef =>                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Xor) == 4 &&                       mDef.Body.Variables.Count == 10 &&                      mDef.Parameters.Count == 1 &&                      mDef.Parameters[0].ParameterType.ToString().Contains("Int32"));
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,Phase1,The following statement contains a magic number: var target =                  AsmDef.FindMethod(                      mDef =>                      mDef.Body.Instructions.GetOpCodeCount(OpCodes.Xor) == 4 &&                       mDef.Body.Variables.Count == 10 &&                      mDef.Parameters.Count == 1 &&                      mDef.Parameters[0].ParameterType.ToString().Contains("Int32"));
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: fs.Seek(-48L' SeekOrigin.End);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: byte[] buf1 = new byte[16]' buf2 = null;
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: i += fs.Read(buf1' i' 16 - i);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: i < 16
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Buffer.BlockCopy(buf2' 0' _decMod = new uint[4]' 0' 16);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,InitializeDecryption,The following statement contains a magic number: Buffer.BlockCopy(buf2' 0' _decMod = new uint[4]' 0' 16);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: rEntry.Key = 62;
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: rEntry.Key == 61 + 1
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: fs.Seek((rEntry.Key*4) - _offset' SeekOrigin.End);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: var num3 = 3337565984;
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: num2 -= (((num << 4) ^ (num >> 5)) + num) ^                                      (num3 + _decMod[(int) ((IntPtr) ((num3 >> 11) & 3))]);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: num3 -= 2654435769;
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: num -= (((num2 << 4) ^ (num2 >> 5)) + num2) ^ (num3 + _decMod[(int) ((IntPtr) (num3 & 3))]);
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: numArray4 = numArray = new uint[num + 11/8*2 - 1];
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: numArray4 = numArray = new uint[num + 11/8*2 - 1];
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: numArray4 = numArray = new uint[num + 11/8*2 - 1];
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: x += 2;
Magic Number,NETDeob.Core.Deobfuscators.Rummage.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Rummage\Tasks\StringDecryptor.cs,DecryptEntry,The following statement contains a magic number: x < (numArray ?? new uint[1337]).Length
Magic Number,NETDeob.Core.Engine.Utils.Extensions,InstructionExt,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\Instruction.cs,GetLdcI4,The following statement contains a magic number: switch (instr.OpCode.Code)              {                  case Code.Ldc_I4_0:                  case Code.Ldc_I4_1:                  case Code.Ldc_I4_2:                  case Code.Ldc_I4_3:                  case Code.Ldc_I4_4:                  case Code.Ldc_I4_5:                  case Code.Ldc_I4_6:                  case Code.Ldc_I4_7:                  case Code.Ldc_I4_8:                      return Int32.Parse(instr.OpCode.Code.ToString().Split('_')[2]); // Lazy :)                    case Code.Ldc_I4_M1:                      return -1;                    case Code.Ldc_I4:                  case Code.Ldc_I4_S:                      return (int)Convert.ChangeType(instr.Operand' typeof(int)); // No idea why I have to cast it this way                    default:                      throw new Exception("Internal invalid instruction!");              }
Magic Number,NETDeob.Core.Unpackers.Mpress.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Mpress\Tasks\Unpacker.cs,lf,The following statement contains a magic number: num2 -= 12;
Magic Number,NETDeob.Core.Unpackers.Mpress.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Mpress\Tasks\Unpacker.cs,lf,The following statement contains a magic number: (num2 >= 2) && (num2 <= (length - 0x200))
Magic Number,NETDeob.Core.Unpackers.Netz.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Netz\Tasks\Unpacker.cs,Phase1,The following statement contains a magic number: target = target.Body.Instructions.FirstOfOpCode((op => op == OpCodes.Call)' 3).Operand as MethodDefinition;
Magic Number,NETDeob.Deobfuscators.Phoenix_Protector,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Phoenix Protector\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: chrArr[i] =                      char.ConvertFromUtf32((((byte) ((c >> 8) ^ i) << 8) | (byte) (c ^ (chrArr.Length - i++))))[0];
Magic Number,NETDeob.Deobfuscators.Phoenix_Protector,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Phoenix Protector\Tasks\StringDecryptor.cs,DecryptString,The following statement contains a magic number: chrArr[i] =                      char.ConvertFromUtf32((((byte) ((c >> 8) ^ i) << 8) | (byte) (c ^ (chrArr.Length - i++))))[0];
Magic Number,NETDeob.Core.Unpackers.Sixxpack.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Sixxpack\Tasks\Unpacker.cs,Decompress,The following statement contains a magic number: byte[] buffer = new byte[5];
Magic Number,NETDeob.Core.Unpackers.Sixxpack.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Sixxpack\Tasks\Unpacker.cs,Decompress,The following statement contains a magic number: inStream.Read(buffer' 0' 5) != 5
Magic Number,NETDeob.Core.Unpackers.Sixxpack.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Sixxpack\Tasks\Unpacker.cs,Decompress,The following statement contains a magic number: inStream.Read(buffer' 0' 5) != 5
Magic Number,NETDeob.Core.Unpackers.Sixxpack.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Sixxpack\Tasks\Unpacker.cs,Decompress,The following statement contains a magic number: outSize |= ((byte)num3) << (8 * i);
Magic Number,NETDeob.Core.Unpackers.Sixxpack.Tasks,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Unpackers\Sixxpack\Tasks\Unpacker.cs,Decompress,The following statement contains a magic number: i < 8
Missing Default,NETDeob.Core.Deobfuscators.Generic,AssemblyStripper,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\AssemblyStripper.cs,RemoveMembers,The following switch statement is missing a default case: switch (member.Type)                      {                          case DeobfuscatorContext.MemberType.Type:                              Logger.VLog("[Remove(Type)] " + (member.Member as TypeDefinition).Name.Truncate(10));                              AsmDef.MainModule.Types.Remove(member.Member as TypeDefinition);                              break;                            case DeobfuscatorContext.MemberType.Method:                              Logger.VLog("[Remove(Method)] " + (member.Member as MethodDefinition).Name);                              (member.Member as MethodDefinition).DeclaringType.Methods.Remove(                                  member.Member as MethodDefinition);                              break;                            case DeobfuscatorContext.MemberType.Field:                              Logger.VLog("[Remove(Field)] " + (member.Member as FieldDefinition).Name);                              (member.Member as FieldDefinition).DeclaringType.Fields.Remove(                                  member.Member as FieldDefinition);                              break;                            case DeobfuscatorContext.MemberType.Property:                              Logger.VLog("[Remove(Property)] " + (member.Member as PropertyDefinition).Name);                              (member.Member as PropertyDefinition).DeclaringType.Properties.Remove(                                  member.Member as PropertyDefinition);                              break;                            case DeobfuscatorContext.MemberType.Resource:                              Logger.VLog("[Remove(Resource)] " +                                          ((member.Member as EmbeddedResource).Name.Truncate(10)));                              AsmDef.MainModule.Resources.Remove(member.Member as EmbeddedResource);                              break;                            case DeobfuscatorContext.MemberType.Attribute:                              Logger.VLog("[Remove(Attribute)] " + (member.Member as CustomAttribute).AttributeType.Name);                              (member.ParentMember as ModuleDefinition).CustomAttributes.Remove(                                  member.Member as CustomAttribute);                              break;                            case DeobfuscatorContext.MemberType.Instruction:                              Logger.VLog("[Remove(Instruction)] " + (member.Member as Instruction).OpCode);                              (member.ParentMember as MethodDefinition).Body.Instructions.Remove(                                  member.Member as Instruction);                              break;                            case DeobfuscatorContext.MemberType.AssemblyReference:                              Logger.VLog("[Remove(AssemblyReference)] " + (member.Member as AssemblyNameReference).MetadataToken.ToInt32());                              AsmDef.MainModule.AssemblyReferences.Remove(member.Member as AssemblyNameReference);                              break;                      }
Missing Default,NETDeob.Core.Engine.Utils,StackTracer,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\StackTracer.cs,ExecuteInstruction,The following switch statement is missing a default case: switch (instruction.OpCode.StackBehaviourPush)                  {                      case StackBehaviour.Push0:                      case StackBehaviour.Push1:                      case StackBehaviour.Pushi:                      case StackBehaviour.Pushi8:                      case StackBehaviour.Pushr4:                      case StackBehaviour.Pushr8:                      case StackBehaviour.Pushref:                          _stack.Push(new StackEntry(instruction' true' instruction.Operand));                          break;                      case StackBehaviour.Push1_push1:                          _stack.Push(new StackEntry(instruction' false));                          _stack.Push(new StackEntry(instruction' false));                          break;                  }
Missing Default,NETDeob.Core.Engine.Utils.Decompression,Lzmat,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Decompression\Lzmat.cs,decompress,The following switch statement is missing a default case: switch (r_cnt & 3)                              {                                  case 0:                                      dist = (dist & LZMAT_DIST_MSK0) + 1;                                      break;                                  case 1:                                      inPos += cur_nib;                                      dist = (dist & LZMAT_DIST_MSK1) + 0x41;                                      cur_nib ^= 1;                                      break;                                  case 2:                                      inPos++;                                      dist += 0x441;                                      break;                                  case 3:                                      if ((inPos + 2 + cur_nib) > cbIn)                                          return LzmatStatus.INTEGRITY_FAILURE + 1;                                      inPos++;                                      dist = (dist +                                      ((uint)LZMAT_GET_U4(pbIn' ref inPos' ref cur_nib) << 14))                                      + 0x4441;                                      break;                              }
Missing Default,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,GetAlgo,The following switch statement is missing a default case: switch (strAlgo)              {                  case Algorithm.DES:                      return new DESCryptoServiceProvider();                    case Algorithm.RC2:                      return new RC2CryptoServiceProvider();                    case Algorithm.Rijndael:                      return new RijndaelManaged();                    case Algorithm.TripleDES:                      return new TripleDESCryptoServiceProvider();              }
Missing Default,NETDeob.Core.Deobfuscators.Manco.Tasks,StringDecryptor,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Manco\Tasks\StringDecryptor.cs,DecryptStrings,The following switch statement is missing a default case: switch (strAlgo)                      {                          case Algorithm.Plain:                              decryptedStr = DecryptString(curInstr.Operand as string' ""' strAlgo);                              outDict.Add(curInstr.Next.Next.Operand as FieldDefinition' decryptedStr);                              break;                            case Algorithm.RC2:                          case Algorithm.DES:                          case Algorithm.Rijndael:                          case Algorithm.TripleDES:                                decryptedStr = DecryptString(curInstr.Operand as string' key' strAlgo);                              outDict.Add(curInstr.Next.Next.Operand as FieldDefinition' decryptedStr);                                break;                      }
Missing Default,NETDeob.Core.Deobfuscators.Confuser,ConfuserDeobfuscator,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\ConfuserDeobfuscator.cs,CreateTaskQueue,The following switch statement is missing a default case: switch((Globals.DeobContext.ActiveSignature).Ver.Minor)              {                  case 7:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      //TaskQueue.Add(new MethodCleaner2(AsmDef));                      //TaskQueue.Add(new ProxyResolver(AsmDef));                      TaskQueue.Add(new MethodCleaner(AsmDef));                      TaskQueue.Add(new ResourceDecryptor(AsmDef));                      //TaskQueue.Add(new ProxyResolver2(AsmDef));                      TaskQueue.Add(new ConstantsDecryptor(AsmDef));                      TaskQueue.Add(new StackUnderflowCleaner(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      TaskQueue.Add(new AntiDump(AsmDef));                      TaskQueue.Add(new AntiDebug(AsmDef));                      TaskQueue.Add(new AntiILDasm(AsmDef));                      TaskQueue.Add(new Renamer(AsmDef' new RenamingScheme(true) {Resources = false}));                      break;                    case 8:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new WatermarkRemover(AsmDef));                      break;                    case 9:                      TaskQueue.Add(new MetadataFixer(AsmDef));                      TaskQueue.Add(new ProxyResolver2(AsmDef));                      break;              }
Missing Default,NETDeob.Core.Deobfuscators.Confuser.Obsolete.Utils,ExpressionScheme,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\Utils\DynamicEvaluator.cs,ExpressionScheme,The following switch statement is missing a default case: switch(instr.OpCode.Code)                      {                          case Code.Add:                              _parts.Add(new ExpOperator {Operator = Operator.Addition});                              break;                          case Code.Sub:                              _parts.Add(new ExpOperator { Operator = Operator.Subtraction });                              break;                          case Code.Mul:                              _parts.Add(new ExpOperator { Operator = Operator.Multiplication });                              break;                          case Code.Xor:                              _parts.Add(new ExpOperator { Operator = Operator.Xor });                              break;                      }
Missing Default,NETDeob.Core.Deobfuscators.Confuser.Obsolete.Utils,ExpressionScheme,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Confuser\Obsolete\Utils\DynamicEvaluator.cs,ParseInstructions,The following switch statement is missing a default case: switch (((ExpOperator)part).Operator)                      {                          case Operator.Addition:                              yield return new ExInstruction                                              {                                                  Code = System.Reflection.Emit.OpCodes.Add'                                                  Value = null                                              };                              break;                            case Operator.Multiplication:                              yield return new ExInstruction                              {                                  Code = System.Reflection.Emit.OpCodes.Mul'                                  Value = null                              };                              break;                            case Operator.Subtraction:                              yield return new ExInstruction                              {                                  Code = System.Reflection.Emit.OpCodes.Sub'                                  Value = null                              };                              break;                            case Operator.Xor:                              yield return new ExInstruction                              {                                  Code = System.Reflection.Emit.OpCodes.Xor'                                  Value = null                              };                              continue;                      }
Missing Default,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,FoldAndReplace,The following switch statement is missing a default case: switch(marking.Value.OpCode.Code)                          {                              case Code.Ldc_I4:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I4' (int)marking.Value.Value));                                  break;                                case Code.Ldc_I8:                                  instrList.Insert(marking.Key.Key -3'                                                   body.GetILProcessor().Create(OpCodes.Ldc_I8' (long)marking.Value.Value));                                  break;                          }
Missing Default,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,EmulateInstruction,The following switch statement is missing a default case: switch(instr.OpCode.Code)              {                  case Code.Ldc_I4:                      stack.Push((int) Convert.ChangeType(instr.Operand' typeof (int)));                      break;                    case Code.Ldc_I4_S:                      stack.Push((sbyte)Convert.ChangeType(instr.Operand' typeof(sbyte)));                      break;                    case Code.Ldc_I4_0:                  case Code.Ldc_I4_1:                  case Code.Ldc_I4_2:                  case Code.Ldc_I4_3:                  case Code.Ldc_I4_4:                  case Code.Ldc_I4_5:                  case Code.Ldc_I4_6:                  case Code.Ldc_I4_7:                  case Code.Ldc_I4_8:                      stack.Push(Int32.Parse(instr.OpCode.Code.ToString().Split('_')[2]));                      break;                    case Code.Ldc_I4_M1:                      stack.Push(-1);                      break;                    case Code.Ldc_I8:                      stack.Push((long) Convert.ChangeType(instr.Operand' typeof (long)));                      break;                    case Code.Ldc_R4:                      stack.Push((float) Convert.ChangeType(instr.Operand' typeof(float)));                      break;                    case Code.Ldc_R8:                      stack.Push((double)Convert.ChangeType(instr.Operand' typeof(float)));                      break;                    case Code.Stloc:                  case Code.Stloc_S:                      PopToLocal(ref locals' ref stack' instr);                      break;                    case Code.Stloc_0:                  case Code.Stloc_1:                  case Code.Stloc_2:                  case Code.Stloc_3:                      PopToLocal(ref locals' ref stack' instr' Int32.Parse(instr.OpCode.Code.ToString().Split('_')[1]));                      break;                    case Code.Ldloc:                  case Code.Ldloc_S:                      PushFromLocal(ref locals' ref stack' instr);                      break;                    case Code.Ldloc_0:                  case Code.Ldloc_1:                  case Code.Ldloc_2:                  case Code.Ldloc_3:                      PushFromLocal(ref locals' ref stack' instr' Int32.Parse(instr.OpCode.Code.ToString().Split('_')[1]));                      break;                    case Code.Add:                  case Code.Add_Ovf:                  case Code.Add_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Addition' ref markings' ref idx);                      break;                    case Code.Sub:                  case Code.Sub_Ovf:                  case Code.Sub_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Subtraction' ref markings' ref idx);                      break;                    case Code.Mul:                  case Code.Mul_Ovf:                  case Code.Mul_Ovf_Un:                      PerformArithmetic(ref stack' Operator.Multiplication' ref markings' ref idx);                      break;                    case Code.Div:                  case Code.Div_Un:                      PerformArithmetic(ref stack' Operator.Divide' ref markings' ref idx);                      break;                    case Code.Shl:                      PerformArithmetic(ref stack' Operator.ShiftLeft' ref markings' ref idx);                      break;                    case Code.Shr:                  case Code.Shr_Un:                      PerformArithmetic(ref stack' Operator.ShiftRight' ref markings' ref idx);                      break;                    case Code.Rem:                  case Code.Rem_Un:                      PerformArithmetic(ref stack' Operator.Mod' ref markings' ref idx);                      break;                      // We still need to follow control flow to not fuck up stack                  case Code.Br:                  case Code.Br_S:                  case Code.Leave:                  case Code.Leave_S:                      idx = (instr.Operand as Instruction).GetInstructionIndex(instrList);                      break;                    case Code.Conv_I1:                      //stack.Push((sbyte) stack.Pop());                      break;                    case Code.Conv_I2:                      //stack.Push((short) stack.Pop());                      break;                    case Code.Conv_I4:                      //stack.Push((int) stack.Pop());                      break;                    case Code.Conv_I8:                      //stack.Push((long) (stack.Pop() is UnknownValue ? 0 : );                      break;                    case Code.Call:                  case Code.Calli:                  case Code.Callvirt:                      EmulateCall(ref stack' instr);                      break;                    case Code.Ldtoken:                      stack.Push(new UnknownValue());                      break;                    case Code.Ldsfld:                      stack.Push(new UnknownValue());                      break;                    case Code.Stsfld:                      stack.Pop();                      break;                    case Code.Dup:                      stack.Push(stack.Peek());                      break;                    case Code.Clt:                  case Code.Clt_Un:                  case Code.Bgt:                  case Code.Bgt_S:                  case Code.Bgt_Un:                  case Code.Bgt_Un_S:                  case Code.Bge:                  case Code.Bge_S:                  case Code.Bge_Un:                  case Code.Bge_Un_S:                  case Code.Blt:                  case Code.Blt_S:                  case Code.Blt_Un:                  case Code.Blt_Un_S:                  case Code.Bne_Un:                  case Code.Bne_Un_S:                  case Code.Beq:                  case Code.Beq_S:                      PerformComparison(ref stack' instr' ref idx' instrList);                      break;                    case Code.Box:                      stack.Push((object) stack.Pop());                      break;                    case Code.Stobj:                      stack.Pop();                      stack.Pop();                      break;                    case Code.Ldelem_Any:                  case Code.Ldelem_I:                  case Code.Ldelem_I1:                  case Code.Ldelem_I2:                  case Code.Ldelem_I4:                  case Code.Ldelem_I8:                  case Code.Ldelem_R4:                  case Code.Ldelem_R8:                  case Code.Ldelem_Ref:                  case Code.Ldelem_U1:                  case Code.Ldelem_U2:                  case Code.Ldelem_U4:                      stack.Pop();                      stack.Pop();                      stack.Push(new UnknownValue());                      break;                    case Code.Ldlen:                      stack.Push(new UnknownValue());                      break;                    case Code.Ldnull:                      stack.Push(null);                      break;                    case Code.Newobj:                      stack.Push(new UnknownValue());                      break;              }
Missing Default,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformComparison,The following switch statement is missing a default case: switch(instr.OpCode.Code)              {                  case Code.Clt:                  case Code.Clt_Un:                      stack.Push(val1 < val2 ? 1 : 0);                      break;                    case Code.Blt:                  case Code.Blt_S:                  case Code.Blt_Un:                  case Code.Blt_Un_S:                      idx = (val1 < val2 ? (instr.Operand as Instruction).GetInstructionIndex(instrList) : idx);                      break;                    case Code.Bgt:                  case Code.Bgt_S:                  case Code.Bgt_Un:                  case Code.Bgt_Un_S:                      idx = (val1 > val2 ? (instr.Operand as Instruction).GetInstructionIndex(instrList) : idx);                      break;                    case Code.Bge:                  case Code.Bge_S:                  case Code.Bge_Un:                  case Code.Bge_Un_S:                      idx = (val1 >= val2 ? (instr.Operand as Instruction).GetInstructionIndex(instrList) : idx);                      break;                    case Code.Beq:                  case Code.Beq_S:                      idx = (val1 == val2 ? (instr.Operand as Instruction).GetInstructionIndex(instrList) : idx);                      break;                    case Code.Bne_Un:                  case Code.Bne_Un_S:                      idx = (val1 != val2 ? (instr.Operand as Instruction).GetInstructionIndex(instrList) : idx);                      break;              }
Missing Default,NETDeob.Core.Deobfuscators.Generic.Obsolete.Emulation,ConstantFolder,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Deobfuscators\Generic\Obsolete\Emulation\ConstantFolder.cs,PerformArithmetic,The following switch statement is missing a default case: switch (@operator)                  {                      case Operator.Addition:                          stack.Push(val1 + val2);                          break;                        case Operator.Subtraction:                          stack.Push(val1 - val2);                          break;                        case Operator.Multiplication:                          stack.Push(val1*val2);                          break;                        case Operator.Xor:                          stack.Push(val1 ^ val2);                          break;                        case Operator.Divide:                          stack.Push(val1/val2);                          break;                        case Operator.ShiftLeft:                          stack.Push(val1 << val2);                          break;                        case Operator.ShiftRight:                          stack.Push(val1 >> val2);                          break;                        case Operator.Mod:                          stack.Push(val1%val2);                          break;                  }
Missing Default,NETDeob.Core.Engine.Utils.Extensions,TypeDefinitionExt,D:\research\architectureSmells\repos\UbbeLoL_NETDeob\NETDeob\Engine\Utils\Extensions\TypeDefinition.cs,GetAllReferences,The following switch statement is missing a default case: switch (instr.OpCode.Code)                      {                          case Code.Ldsfld:                          case Code.Ldsflda:                              if ((instr.Operand as FieldReference).Resolve().DeclaringType == typeDef)                                  if ((TopParentType<MethodDefinition>(mDef) != typeDef))                                      yield return new Tuple<Instruction' MethodDefinition>(instr' mDef);                                break;                            case Code.Stobj:                          case Code.Ldobj:                          case Code.Castclass:                          case Code.Isinst:                          case Code.Unbox:                          case Code.Box:                          case Code.Newarr:                          case Code.Ldelem_I1:                          case Code.Ldelem_Any:                          case Code.Stelem_Any:                          case Code.Unbox_Any:                          case Code.Refanyval:                          case Code.Mkrefany:                          case Code.Initobj:                          case Code.Constrained:                          case Code.Sizeof:                              if ((instr.Operand as TypeReference).Resolve() == typeDef)                                  if ((TopParentType(mDef) != typeDef))                                      yield return new Tuple<Instruction' MethodDefinition>(instr' mDef);                                break;                            case Code.Ldtoken:                              if ((instr.Operand is TypeReference))                              {                                  if ((instr.Operand as TypeReference).Resolve() == typeDef)                                      if ((TopParentType(mDef) != typeDef))                                          yield return new Tuple<Instruction' MethodDefinition>(instr' mDef);                              }                              else if ((instr.Operand is FieldReference) || (instr.Operand is MethodReference))                                  if ((instr.Operand as dynamic).Resolve().DeclaringType == typeDef)                                      if ((TopParentType(mDef) != typeDef))                                          yield return new Tuple<Instruction' MethodDefinition>(instr' mDef);                                break;                            case Code.Call:                          case Code.Callvirt:                          case Code.Jmp:                          case Code.Newobj:                          case Code.Ldftn:                          case Code.Ldvirtftn:                              if (((instr.Operand as MethodReference).Resolve()).DeclaringType == typeDef)                                  if ((TopParentType(mDef) != typeDef))                                      yield return new Tuple<Instruction' MethodDefinition>(instr' mDef);                                break;                        }
